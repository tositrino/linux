diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/Makefile linux-2.6.21.1-ps3/arch/powerpc/boot/Makefile
--- linux-2.6.21.1-org/arch/powerpc/boot/Makefile	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/Makefile	2007-05-21 13:50:25.919512087 +0200
@@ -25,13 +25,17 @@
 HOSTCC		:= gcc
 BOOTCFLAGS	:= $(HOSTCFLAGS) -fno-builtin -nostdinc -isystem \
 		   $(shell $(CROSS32CC) -print-file-name=include) -fPIC
-BOOTAFLAGS	:= -D__ASSEMBLY__ $(BOOTCFLAGS) -traditional -nostdinc
+BOOTAFLAGS	:= -D__ASSEMBLY__ $(BOOTCFLAGS) -nostdinc
 
 ifeq ($(call cc-option-yn, -fstack-protector),y)
 BOOTCFLAGS	+= -fno-stack-protector
 endif
 
 BOOTCFLAGS	+= -I$(obj) -I$(srctree)/$(obj)
+BOOTAFLAGS	+= -I$(obj) -I$(srctree)/$(obj)
+
+src-plat-$(CONFIG_PPC_PS3) += ps3-head.S smp.S ps3.c ps3-hvcall.S
+inc-plat-$(CONFIG_PPC_PS3) += lv1call.h
 
 zlib       := inffast.c inflate.c inftrees.c
 zlibheader := inffast.h inffixed.h inflate.h inftrees.h infutil.h
@@ -40,15 +44,17 @@
 $(addprefix $(obj)/,$(zlib) main.o): $(addprefix $(obj)/,$(zliblinuxheader)) \
 		$(addprefix $(obj)/,$(zlibheader))
 
-src-wlib := string.S stdio.c main.c flatdevtree.c flatdevtree_misc.c \
-		ns16550.c serial.c simple_alloc.c div64.S util.S $(zlib)
-src-plat := of.c
-src-boot := crt0.S $(src-wlib) $(src-plat) empty.c
+src-wlib := string.S crt0.S stdio.c main.c flatdevtree.c flatdevtree_misc.c \
+		ns16550.c serial.c simple_alloc.c div64.S util.S \
+		gunzip_util.c elf_util.c $(zlib) devtree.c
+src-plat := of.c $(src-plat-y)
+src-boot := $(src-wlib) $(src-plat) empty.c
 
 src-boot := $(addprefix $(obj)/, $(src-boot))
 obj-boot := $(addsuffix .o, $(basename $(src-boot)))
 obj-wlib := $(addsuffix .o, $(basename $(addprefix $(obj)/, $(src-wlib))))
 obj-plat := $(addsuffix .o, $(basename $(addprefix $(obj)/, $(src-plat))))
+inc-plat := $(addprefix $(obj)/,$(inc-plat-y))
 
 quiet_cmd_copy_zlib = COPY    $@
       cmd_copy_zlib = sed "s@__attribute_used__@@;s@<linux/\([^>]\+\).*@\"\1\"@" $< > $@
@@ -68,14 +74,17 @@
 $(addprefix $(obj)/,$(zliblinuxheader)): $(obj)/%: $(srctree)/include/linux/%
 	$(call cmd,copy_zliblinuxheader)
 
+$(addprefix $(obj)/,$(inc-plat-y)): $(obj)/%: $(srctree)/include/asm-powerpc/%
+	$(call cmd,copy_zliblinuxheader)
+
 $(obj)/empty.c:
 	@touch $@
 
-$(obj)/zImage.lds $(obj)/zImage.coff.lds: $(obj)/%: $(srctree)/$(src)/%.S
+$(obj)/zImage.lds $(obj)/zImage.coff.lds $(obj)/zImage.ps3.lds: $(obj)/%: $(srctree)/$(src)/%.S
 	@cp $< $@
 
 clean-files := $(zlib) $(zlibheader) $(zliblinuxheader) \
-		empty.c zImage zImage.coff.lds zImage.lds zImage.sandpoint
+		empty.c zImage zImage.coff.lds zImage.ps3.lds zImage.lds zImage.sandpoint
 
 quiet_cmd_bootcc = BOOTCC  $@
       cmd_bootcc = $(CROSS32CC) -Wp,-MD,$(depfile) $(BOOTCFLAGS) -c -o $@ $<
@@ -84,23 +93,25 @@
       cmd_bootas = $(CROSS32CC) -Wp,-MD,$(depfile) $(BOOTAFLAGS) -c -o $@ $<
 
 quiet_cmd_bootar = BOOTAR  $@
-      cmd_bootar = $(CROSS32AR) -cr $@.$$$$ $^; mv $@.$$$$ $@
+      cmd_bootar = $(CROSS32AR) -cr $@.$$$$ $(filter-out FORCE,$^); mv $@.$$$$ $@
 
-$(patsubst %.c,%.o, $(filter %.c, $(src-boot))): %.o: %.c
+$(patsubst %.c,%.o, $(filter %.c, $(src-boot))): %.o: %.c FORCE
 	$(call if_changed_dep,bootcc)
-$(patsubst %.S,%.o, $(filter %.S, $(src-boot))): %.o: %.S
+$(patsubst %.S,%.o, $(filter %.S, $(src-boot))): %.o: %.S FORCE
 	$(call if_changed_dep,bootas)
 
-$(obj)/wrapper.a: $(obj-wlib)
-	$(call cmd,bootar)
+$(obj)/wrapper.a: $(obj-wlib) FORCE
+	$(call if_changed,bootar)
 
 hostprogs-y	:= addnote addRamDisk hack-coff mktree
 
-extra-y		:= $(obj)/crt0.o $(obj)/wrapper.a $(obj-plat) $(obj)/empty.o \
-		   $(obj)/zImage.lds $(obj)/zImage.coff.lds
+targets		+= $(patsubst $(obj)/%,%,$(obj-boot) wrapper.a)
+extra-y		:= $(obj)/wrapper.a  $(inc-plat) $(obj-plat) $(obj)/empty.o \
+		   $(obj)/zImage.lds $(obj)/zImage.coff.lds $(obj)/zImage.ps3.lds
 
 wrapper		:=$(srctree)/$(src)/wrapper
-wrapperbits	:= $(extra-y) $(addprefix $(obj)/,addnote hack-coff mktree)
+wrapperbits	:= $(extra-y) $(addprefix $(obj)/,addnote hack-coff mktree) \
+			$(wrapper) FORCE
 
 #############
 # Bits for building various flavours of zImage
@@ -113,50 +124,10 @@
 endif
 endif
 
+# args (to if_changed): 1 = (this rule), 2 = platform, 3 = dts 4=dtb 5=initrd
 quiet_cmd_wrap	= WRAP    $@
-      cmd_wrap	=$(CONFIG_SHELL) $(wrapper) -c -o $@ -p $2 $(CROSSWRAP) vmlinux
-quiet_cmd_wrap_initrd = WRAP    $@
-      cmd_wrap_initrd =$(CONFIG_SHELL) $(wrapper) -c -o $@ -p $2 $(CROSSWRAP) \
-				-i $(obj)/ramdisk.image.gz vmlinux
-
-$(obj)/zImage.chrp: vmlinux $(wrapperbits)
-	$(call cmd,wrap,chrp)
-
-$(obj)/zImage.initrd.chrp: vmlinux $(wrapperbits)
-	$(call cmd,wrap_initrd,chrp)
-
-$(obj)/zImage.pseries:	vmlinux $(wrapperbits)
-	$(call cmd,wrap,pseries)
-
-$(obj)/zImage.initrd.pseries: vmlinux $(wrapperbits)
-	$(call cmd,wrap_initrd,pseries)
-
-$(obj)/zImage.pmac: vmlinux $(wrapperbits)
-	$(call cmd,wrap,pmac)
-
-$(obj)/zImage.initrd.pmac: vmlinux $(wrapperbits)
-	$(call cmd,wrap_initrd,pmac)
-
-$(obj)/zImage.coff: vmlinux $(wrapperbits)
-	$(call cmd,wrap,pmaccoff)
-
-$(obj)/zImage.initrd.coff: vmlinux $(wrapperbits)
-	$(call cmd,wrap_initrd,pmaccoff)
-
-$(obj)/zImage.miboot: vmlinux $(wrapperbits)
-	$(call cmd,wrap,miboot)
-
-$(obj)/zImage.initrd.miboot: vmlinux $(wrapperbits)
-	$(call cmd,wrap_initrd,miboot)
-
-$(obj)/zImage.ps3: vmlinux
-	$(STRIP) -s -R .comment $< -o $@
-
-$(obj)/zImage.initrd.ps3: vmlinux
-	@echo "  WARNING zImage.initrd.ps3 not supported (yet)"
-
-$(obj)/uImage: vmlinux $(wrapperbits)
-	$(call cmd,wrap,uboot)
+      cmd_wrap	=$(CONFIG_SHELL) $(wrapper) -c -o $@ -p $2 $(CROSSWRAP) \
+		$(if $3, -s $3)$(if $4, -d $4)$(if $5, -i $5) vmlinux
 
 image-$(CONFIG_PPC_PSERIES)		+= zImage.pseries
 image-$(CONFIG_PPC_MAPLE)		+= zImage.pseries
@@ -174,7 +145,31 @@
 image-$(CONFIG_PPC_PMAC)	+= zImage.coff zImage.miboot
 endif
 
+initrd-  := $(patsubst zImage%, zImage.initrd%, $(image-n) $(image-))
 initrd-y := $(patsubst zImage%, zImage.initrd%, $(image-y))
+initrd-y := $(filter-out $(image-y), $(initrd-y))
+targets	+= $(image-y) $(initrd-y)
+
+$(addprefix $(obj)/, $(initrd-y)): $(obj)/ramdisk.image.gz
+
+# Don't put the ramdisk on the pattern rule; when its missing make will try
+# the pattern rule with less dependencies that also matches (even with the
+# hard dependency listed).
+$(obj)/zImage.initrd.%: vmlinux $(wrapperbits)
+	$(call if_changed,wrap,$*,,,$(obj)/ramdisk.image.gz)
+
+$(obj)/zImage.%: vmlinux $(wrapperbits)
+	$(call if_changed,wrap,$*)
+
+$(obj)/zImage.ps3: vmlinux $(wrapper) $(wrapperbits)
+	$(STRIP) -s -R .comment vmlinux -o vmlinux.strip
+	$(call cmd,wrap,ps3 -s $(srctree)/$(src)/dts/ps3.dts)
+
+$(obj)/zImage.initrd.ps3: vmlinux  $(wrapper) $(wrapperbits)
+	$(call cmd,wrap_initrd,ps3 -s $(srctree)/$(src)/dts/ps3.dts)
+
+$(obj)/uImage: vmlinux $(wrapperbits)
+	$(call if_changed,wrap,uboot)
 
 $(obj)/zImage:		$(addprefix $(obj)/, $(image-y))
 	@rm -f $@; ln $< $@
@@ -184,6 +179,11 @@
 install: $(CONFIGURE) $(image-y)
 	sh -x $(srctree)/$(src)/install.sh "$(KERNELRELEASE)" vmlinux System.map "$(INSTALL_PATH)" $<
 
-clean-files += $(addprefix $(objtree)/, $(obj-boot) vmlinux.strip.gz)
-clean-files += $(addprefix $(objtree)/, $(obj-boot) vmlinux.bin.gz)
-clean-files += $(image-)
+# anything not in $(targets)
+clean-files += $(image-) $(initrd-) zImage zImage.initrd
+
+# clean up files cached by wrapper
+clean-kernel := vmlinux.strip vmlinux.bin
+clean-kernel += $(addsuffix .gz,$(clean-kernel))
+# If not absolute clean-files are relative to $(obj).
+clean-files += $(addprefix $(objtree)/, $(clean-kernel))
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/crt0.S linux-2.6.21.1-ps3/arch/powerpc/boot/crt0.S
--- linux-2.6.21.1-org/arch/powerpc/boot/crt0.S	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/crt0.S	2007-05-21 13:50:25.935511235 +0200
@@ -16,8 +16,11 @@
 _zimage_start_opd:
 	.long	_zimage_start, 0, 0, 0
 
+	.weak	_zimage_start
 	.globl	_zimage_start
 _zimage_start:
+	.globl	_zimage_start_lib
+_zimage_start_lib:
 	/* Work out the offset between the address we were linked at
 	   and the address where we're running. */
 	bl	1f
@@ -44,7 +47,7 @@
 	addi	r9,r9,4
 	bdnz	2b
 
-	/* Do a cache flush for our text, in case OF didn't */
+	/* Do a cache flush for our text, in case the loader didn't */
 3:	lis	r9,_start@ha
 	addi	r9,r9,_start@l
 	add	r9,r0,r9
@@ -59,6 +62,34 @@
 	sync
 	isync
 
-	mr	r6,r1
-	b	start
+	/* Clear the BSS */
+	lis	r9,__bss_start@ha
+	addi	r9,r9,__bss_start@l
+	add	r9,r0,r9
+	lis	r8,_end@ha
+	addi	r8,r8,_end@l
+	add	r8,r0,r8
+	li	r10,0
+5:	stw	r10,0(r9)
+	addi	r9,r9,4
+	cmplw	cr0,r9,r8
+	blt	5b
 
+	/* Possibly set up a custom stack */
+.weak	_platform_stack_top
+	lis	r8,_platform_stack_top@ha
+	addi	r8,r8,_platform_stack_top@l
+	cmpwi	r8,0
+	beq	6f
+	add	r8,r0,r8
+	lwz	r1,0(r8)
+	add	r1,r0,r1
+	li	r0,0
+	stwu	r0,-16(r1)	/* establish a stack frame */
+6:
+
+	/* Call platform_init() */
+	bl	platform_init
+
+	/* Call start */
+	b	start
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/devtree.c linux-2.6.21.1-ps3/arch/powerpc/boot/devtree.c
--- linux-2.6.21.1-org/arch/powerpc/boot/devtree.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/devtree.c	2007-05-21 13:50:25.998507881 +0200
@@ -0,0 +1,289 @@
+/*
+ * devtree.c - convenience functions for device tree manipulation
+ * Copyright 2007 David Gibson, IBM Corporation.
+ * Copyright (c) 2007 Freescale Semiconductor, Inc.
+ *
+ * Authors: David Gibson <david@gibson.dropbear.id.au>
+ *	    Scott Wood <scottwood@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+#include <stdarg.h>
+#include <stddef.h>
+#include "types.h"
+#include "string.h"
+#include "stdio.h"
+#include "ops.h"
+
+void dt_fixup_memory(u64 start, u64 size)
+{
+	void *root, *memory;
+	int naddr, nsize, i;
+	u32 memreg[4];
+
+	root = finddevice("/");
+	if (getprop(root, "#address-cells", &naddr, sizeof(naddr)) < 0)
+		naddr = 2;
+	if (naddr < 1 || naddr > 2)
+		fatal("Can't cope with #address-cells == %d in /\n\r", naddr);
+
+	if (getprop(root, "#size-cells", &nsize, sizeof(nsize)) < 0)
+		nsize = 1;
+	if (nsize < 1 || nsize > 2)
+		fatal("Can't cope with #size-cells == %d in /\n\r", nsize);
+
+	i = 0;
+	if (naddr == 2)
+		memreg[i++] = start >> 32;
+	memreg[i++] = start & 0xffffffff;
+	if (nsize == 2)
+		memreg[i++] = size >> 32;
+	memreg[i++] = size & 0xffffffff;
+
+	memory = finddevice("/memory");
+	if (! memory) {
+		memory = create_node(NULL, "memory");
+		setprop_str(memory, "device_type", "memory");
+	}
+
+	printf("Memory <- <0x%x", memreg[0]);
+	for (i = 1; i < (naddr + nsize); i++)
+		printf(" 0x%x", memreg[i]);
+	printf("> (%ldMB)\n\r", (unsigned long)(size >> 20));
+
+	setprop(memory, "reg", memreg, (naddr + nsize)*sizeof(u32));
+}
+
+#define MHZ(x)	((x + 500000) / 1000000)
+
+void dt_fixup_cpu_clocks(u32 cpu, u32 tb, u32 bus)
+{
+	void *devp = NULL;
+
+	printf("CPU clock-frequency <- 0x%x (%dMHz)\n\r", cpu, MHZ(cpu));
+	printf("CPU timebase-frequency <- 0x%x (%dMHz)\n\r", tb, MHZ(tb));
+	if (bus > 0)
+		printf("CPU bus-frequency <- 0x%x (%dMHz)\n\r", bus, MHZ(bus));
+
+	while ((devp = find_node_by_devtype(devp, "cpu"))) {
+		setprop_val(devp, "clock-frequency", cpu);
+		setprop_val(devp, "timebase-frequency", tb);
+		if (bus > 0)
+			setprop_val(devp, "bus-frequency", bus);
+	}
+}
+
+void dt_fixup_clock(const char *path, u32 freq)
+{
+	void *devp = finddevice(path);
+
+	if (devp) {
+		printf("%s: clock-frequency <- %x (%dMHz)\n\r", path, freq, MHZ(freq));
+		setprop_val(devp, "clock-frequency", freq);
+	}
+}
+
+void __dt_fixup_mac_addresses(u32 startindex, ...)
+{
+	va_list ap;
+	u32 index = startindex;
+	void *devp;
+	const u8 *addr;
+
+	va_start(ap, startindex);
+	while ((addr = va_arg(ap, const u8 *))) {
+		devp = find_node_by_prop_value(NULL, "linux,network-index",
+					       (void*)&index, sizeof(index));
+
+		printf("ENET%d: local-mac-address <-"
+		       " %02x:%02x:%02x:%02x:%02x:%02x\n\r", index,
+		       addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+
+		if (devp)
+			setprop(devp, "local-mac-address", addr, 6);
+
+		index++;
+	}
+	va_end(ap);
+}
+
+#define MAX_ADDR_CELLS 4
+#define MAX_RANGES 8
+
+static void get_reg_format(void *node, u32 *naddr, u32 *nsize)
+{
+	if (getprop(node, "#address-cells", naddr, 4) != 4)
+		*naddr = 2;
+	if (getprop(node, "#size-cells", nsize, 4) != 4)
+		*nsize = 1;
+}
+
+static void copy_val(u32 *dest, u32 *src, int naddr)
+{
+	memset(dest, 0, (MAX_ADDR_CELLS - naddr) * 4);
+	memcpy(dest, src, naddr * 4);
+}
+
+static int sub_reg(u32 *reg, u32 *sub)
+{
+	int i, borrow = 0;
+
+	for (i = 0; i < MAX_ADDR_CELLS; i++) {
+		int prev_borrow = borrow;
+		borrow = reg[i] < sub[i] + prev_borrow;
+		reg[i] -= sub[i] + prev_borrow;
+	}
+
+	return !borrow;
+}
+
+static int add_reg(u32 *reg, u32 *add)
+{
+	int i, carry = 0;
+
+	for (i = 0; i < MAX_ADDR_CELLS; i++) {
+		u64 tmp = (u64)reg[i] + add[i] + carry;
+		carry = tmp >> 32;
+		reg[i] = (u32)tmp;
+	}
+
+	return !carry;
+}
+
+/* It is assumed that if the first byte of reg fits in a
+ * range, then the whole reg block fits.
+ */
+static int compare_reg(u32 *reg, u32 *range, u32 *rangesize)
+{
+	int i;
+	u32 end;
+
+	for (i = 0; i < MAX_ADDR_CELLS; i++) {
+		if (reg[i] < range[i])
+			return 0;
+		if (reg[i] > range[i])
+			break;
+	}
+
+	for (i = 0; i < MAX_ADDR_CELLS; i++) {
+		end = range[i] + rangesize[i];
+
+		if (reg[i] < end)
+			break;
+		if (reg[i] > end)
+			return 0;
+	}
+
+	return reg[i] != end;
+}
+
+/* reg must be MAX_ADDR_CELLS */
+static int find_range(u32 *reg, u32 *ranges, int nregaddr,
+                      int naddr, int nsize, int buflen)
+{
+	int nrange = nregaddr + naddr + nsize;
+	int i;
+
+	for (i = 0; i + nrange <= buflen; i += nrange) {
+		u32 range_addr[MAX_ADDR_CELLS];
+		u32 range_size[MAX_ADDR_CELLS];
+
+		copy_val(range_addr, ranges + i, naddr);
+		copy_val(range_size, ranges + i + nregaddr + naddr, nsize);
+
+		if (compare_reg(reg, range_addr, range_size))
+			return i;
+	}
+
+	return -1;
+}
+
+/* Currently only generic buses without special encodings are supported.
+ * In particular, PCI is not supported.  Also, only the beginning of the
+ * reg block is tracked; size is ignored except in ranges.
+ */
+int dt_xlate_reg(void *node, int res, unsigned long *addr,
+                 unsigned long *size)
+{
+	u32 last_addr[MAX_ADDR_CELLS];
+	u32 this_addr[MAX_ADDR_CELLS];
+	u32 buf[MAX_ADDR_CELLS * MAX_RANGES * 3];
+	void *parent;
+	u64 ret_addr, ret_size;
+	u32 naddr, nsize, prev_naddr;
+	int buflen, offset;
+
+	parent = get_parent(node);
+	if (!parent)
+		return 0;
+
+	get_reg_format(parent, &naddr, &nsize);
+
+	if (nsize > 2)
+		return 0;
+
+	buflen = getprop(node, "reg", buf, sizeof(buf)) / 4;
+	offset = (naddr + nsize) * res;
+
+	if (buflen < offset + naddr + nsize)
+		return 0;
+
+	copy_val(last_addr, buf + offset, naddr);
+
+	ret_size = buf[offset + naddr];
+	if (nsize == 2) {
+		ret_size <<= 32;
+		ret_size |= buf[offset + naddr + 1];
+	}
+
+	while ((node = get_parent(node))) {
+		prev_naddr = naddr;
+
+		get_reg_format(node, &naddr, &nsize);
+
+		buflen = getprop(node, "ranges", buf, sizeof(buf));
+		if (buflen < 0)
+			continue;
+		if (buflen > sizeof(buf))
+			return 0;
+
+		offset = find_range(last_addr, buf, prev_naddr,
+		                    naddr, nsize, buflen / 4);
+
+		if (offset < 0)
+			return 0;
+
+		copy_val(this_addr, buf + offset, prev_naddr);
+
+		if (!sub_reg(last_addr, this_addr))
+			return 0;
+
+		copy_val(this_addr, buf + offset + prev_naddr, naddr);
+
+		if (!add_reg(last_addr, this_addr))
+			return 0;
+	}
+
+	if (naddr > 2)
+		return 0;
+
+	ret_addr = last_addr[0];
+	if (naddr == 2) {
+		ret_addr <<= 32;
+		ret_addr |= last_addr[1];
+	}
+
+	if (sizeof(void *) == 4 &&
+	    (ret_addr >= 0x100000000ULL || ret_size > 0x100000000ULL ||
+	     ret_addr + ret_size > 0x100000000ULL))
+		return 0;
+
+	*addr = ret_addr;
+	if (size)
+		*size = ret_size;
+
+	return 1;
+}
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/kuroboxHD.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/kuroboxHD.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/kuroboxHD.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/kuroboxHD.dts	2007-05-21 13:50:26.050505112 +0200
@@ -29,7 +29,6 @@
 
 	cpus {
 		linux,phandle = <2000>;
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/kuroboxHG.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/kuroboxHG.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/kuroboxHG.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/kuroboxHG.dts	2007-05-21 13:50:26.092502876 +0200
@@ -29,7 +29,6 @@
 
 	cpus {
 		linux,phandle = <2000>;
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/lite5200.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/lite5200.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/lite5200.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/lite5200.dts	2007-05-21 13:50:26.106502130 +0200
@@ -24,7 +24,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/lite5200b.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/lite5200b.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/lite5200b.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/lite5200b.dts	2007-05-21 13:50:26.139500373 +0200
@@ -24,7 +24,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc7448hpc2.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc7448hpc2.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc7448hpc2.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc7448hpc2.dts	2007-05-21 13:50:26.173498563 +0200
@@ -19,7 +19,6 @@
 	linux,phandle = <100>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells =<0>;
 		linux,phandle = <200>;
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8272ads.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8272ads.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8272ads.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8272ads.dts	2007-05-21 13:50:26.205496859 +0200
@@ -17,7 +17,6 @@
        linux,phandle = <100>;
 
        cpus {
-               #cpus = <1>;
                #address-cells = <1>;
                #size-cells = <0>;
                linux,phandle = <200>;
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8313erdb.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8313erdb.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8313erdb.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8313erdb.dts	2007-05-21 13:50:26.239495049 +0200
@@ -16,7 +16,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc832x_mds.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc832x_mds.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc832x_mds.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc832x_mds.dts	2007-05-21 13:50:26.280492866 +0200
@@ -16,7 +16,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc832x_rdb.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc832x_rdb.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc832x_rdb.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc832x_rdb.dts	2007-05-21 13:50:26.297491961 +0200
@@ -0,0 +1,291 @@
+/*
+ * MPC832x RDB Device Tree Source
+ *
+ * Copyright 2007 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+/ {
+	model = "MPC8323ERDB";
+	compatible = "MPC8323ERDB", "MPC832xRDB", "MPC83xxRDB";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		PowerPC,8323@0 {
+			device_type = "cpu";
+			reg = <0>;
+			d-cache-line-size = <20>;	// 32 bytes
+			i-cache-line-size = <20>;	// 32 bytes
+			d-cache-size = <4000>;		// L1, 16K
+			i-cache-size = <4000>;		// L1, 16K
+			timebase-frequency = <0>;
+			bus-frequency = <0>;
+			clock-frequency = <0>;
+			32-bit;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <00000000 04000000>;
+	};
+
+	soc8323@e0000000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		#interrupt-cells = <2>;
+		device_type = "soc";
+		ranges = <0 e0000000 00100000>;
+		reg = <e0000000 00000200>;
+		bus-frequency = <0>;
+
+		wdt@200 {
+			device_type = "watchdog";
+			compatible = "mpc83xx_wdt";
+			reg = <200 100>;
+		};
+
+		i2c@3000 {
+			device_type = "i2c";
+			compatible = "fsl-i2c";
+			reg = <3000 100>;
+			interrupts = <e 8>;
+			interrupt-parent = <&pic>;
+			dfsrr;
+		};
+
+		serial@4500 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <4500 100>;
+			clock-frequency = <0>;
+			interrupts = <9 8>;
+			interrupt-parent = <&pic>;
+		};
+
+		serial@4600 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <4600 100>;
+			clock-frequency = <0>;
+			interrupts = <a 8>;
+			interrupt-parent = <&pic>;
+		};
+
+		crypto@30000 {
+			device_type = "crypto";
+			model = "SEC2";
+			compatible = "talitos";
+			reg = <30000 7000>;
+			interrupts = <b 8>;
+			interrupt-parent = <&pic>;
+			/* Rev. 2.2 */
+			num-channels = <1>;
+			channel-fifo-len = <18>;
+			exec-units-mask = <0000004c>;
+			descriptor-types-mask = <0122003f>;
+		};
+
+		pci@8500 {
+			interrupt-map-mask = <f800 0 0 7>;
+			interrupt-map = <
+					/* IDSEL 0x10 AD16 (USB) */
+					 8000 0 0 1 &pic 11 8
+
+					/* IDSEL 0x11 AD17 (Mini1)*/
+					 8800 0 0 1 &pic 12 8
+					 8800 0 0 2 &pic 13 8
+					 8800 0 0 3 &pic 14 8
+					 8800 0 0 4 &pic 30 8
+
+					/* IDSEL 0x12 AD18 (PCI/Mini2) */
+					 9000 0 0 1 &pic 13 8
+					 9000 0 0 2 &pic 14 8
+					 9000 0 0 3 &pic 30 8
+					 9000 0 0 4 &pic 11 8>;
+
+			interrupt-parent = <&pic>;
+			interrupts = <42 8>;
+			bus-range = <0 0>;
+			ranges = <42000000 0 80000000 80000000 0 10000000
+			          02000000 0 90000000 90000000 0 10000000
+			          01000000 0 d0000000 d0000000 0 04000000>;
+			clock-frequency = <0>;
+			#interrupt-cells = <1>;
+			#size-cells = <2>;
+			#address-cells = <3>;
+			reg = <8500 100>;
+			compatible = "83xx";
+			device_type = "pci";
+		};
+
+		pic:pic@700 {
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <2>;
+			reg = <700 100>;
+			built-in;
+			device_type = "ipic";
+		};
+
+		par_io@1400 {
+			reg = <1400 100>;
+			device_type = "par_io";
+			num-ports = <7>;
+
+			ucc2pio:ucc_pin@02 {
+				pio-map = <
+			/* port  pin  dir  open_drain  assignment  has_irq */
+					3  4  3  0  2  0 	/* MDIO */
+					3  5  1  0  2  0 	/* MDC */
+					3 15  2  0  1  0 	/* RX_CLK (CLK16) */
+					3 17  2  0  1  0 	/* TX_CLK (CLK3) */
+					0 12  1  0  1  0 	/* TxD0 */
+					0 13  1  0  1  0 	/* TxD1 */
+					0 14  1  0  1  0 	/* TxD2 */
+					0 15  1  0  1  0 	/* TxD3 */
+					0 16  2  0  1  0 	/* RxD0 */
+					0 17  2  0  1  0 	/* RxD1 */
+					0 18  2  0  1  0 	/* RxD2 */
+					0 19  2  0  1  0 	/* RxD3 */
+					0 1a  2  0  1  0 	/* RX_ER */
+					0 1b  1  0  1  0 	/* TX_ER */
+					0 1c  2  0  1  0 	/* RX_DV */
+					0 1d  2  0  1  0 	/* COL */
+					0 1e  1  0  1  0 	/* TX_EN */
+					0 1f  2  0  1  0>;      /* CRS */
+			};
+			ucc3pio:ucc_pin@03 {
+				pio-map = <
+			/* port  pin  dir  open_drain  assignment  has_irq */
+					0  d  2  0  1  0 	/* RX_CLK (CLK9) */
+					3 18  2  0  1  0 	/* TX_CLK (CLK10) */
+					1  0  1  0  1  0 	/* TxD0 */
+					1  1  1  0  1  0 	/* TxD1 */
+					1  2  1  0  1  0 	/* TxD2 */
+					1  3  1  0  1  0 	/* TxD3 */
+					1  4  2  0  1  0 	/* RxD0 */
+					1  5  2  0  1  0 	/* RxD1 */
+					1  6  2  0  1  0 	/* RxD2 */
+					1  7  2  0  1  0 	/* RxD3 */
+					1  8  2  0  1  0 	/* RX_ER */
+					1  9  1  0  1  0 	/* TX_ER */
+					1  a  2  0  1  0 	/* RX_DV */
+					1  b  2  0  1  0 	/* COL */
+					1  c  1  0  1  0 	/* TX_EN */
+					1  d  2  0  1  0>;      /* CRS */
+			};
+		};
+	};
+
+	qe@e0100000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		device_type = "qe";
+		model = "QE";
+		ranges = <0 e0100000 00100000>;
+		reg = <e0100000 480>;
+		brg-frequency = <0>;
+		bus-frequency = <BCD3D80>;
+
+		muram@10000 {
+			device_type = "muram";
+			ranges = <0 00010000 00004000>;
+
+			data-only@0 {
+				reg = <0 4000>;
+			};
+		};
+
+		spi@4c0 {
+			device_type = "spi";
+			compatible = "fsl_spi";
+			reg = <4c0 40>;
+			interrupts = <2>;
+			interrupt-parent = <&qeic>;
+			mode = "cpu";
+		};
+
+		spi@500 {
+			device_type = "spi";
+			compatible = "fsl_spi";
+			reg = <500 40>;
+			interrupts = <1>;
+			interrupt-parent = <&qeic>;
+			mode = "cpu";
+		};
+
+		ucc@3000 {
+			device_type = "network";
+			compatible = "ucc_geth";
+			model = "UCC";
+			device-id = <2>;
+			reg = <3000 200>;
+			interrupts = <21>;
+			interrupt-parent = <&qeic>;
+			mac-address = [ 00 04 9f ef 03 02 ];
+			rx-clock = <20>;
+			tx-clock = <13>;
+			phy-handle = <&phy00>;
+			pio-handle = <&ucc2pio>;
+		};
+
+		ucc@2200 {
+			device_type = "network";
+			compatible = "ucc_geth";
+			model = "UCC";
+			device-id = <3>;
+			reg = <2200 200>;
+			interrupts = <22>;
+			interrupt-parent = <&qeic>;
+			mac-address = [ 00 04 9f ef 03 01 ];
+			rx-clock = <19>;
+			tx-clock = <1a>;
+			phy-handle = <&phy04>;
+			pio-handle = <&ucc3pio>;
+		};
+
+		mdio@3120 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <3120 18>;
+			device_type = "mdio";
+			compatible = "ucc_geth_phy";
+
+			phy00:ethernet-phy@00 {
+				interrupt-parent = <&pic>;
+				interrupts = <0>;
+				reg = <0>;
+				device_type = "ethernet-phy";
+				interface = <3>; //ENET_100_MII
+			};
+			phy04:ethernet-phy@04 {
+				interrupt-parent = <&pic>;
+				interrupts = <0>;
+				reg = <4>;
+				device_type = "ethernet-phy";
+				interface = <3>;
+			};
+		};
+
+		qeic:qeic@80 {
+			interrupt-controller;
+			device_type = "qeic";
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			reg = <80 80>;
+			built-in;
+			big-endian;
+			interrupts = <20 8 21 8>; //high:32 low:33
+			interrupt-parent = <&pic>;
+		};
+	};
+};
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8349emitx.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8349emitx.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8349emitx.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8349emitx.dts	2007-05-21 13:50:26.323490577 +0200
@@ -15,7 +15,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8349emitxgp.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8349emitxgp.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8349emitxgp.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8349emitxgp.dts	2007-05-21 13:50:26.383487382 +0200
@@ -15,7 +15,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc834x_mds.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc834x_mds.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc834x_mds.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc834x_mds.dts	2007-05-21 13:50:26.438484454 +0200
@@ -16,7 +16,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc836x_mds.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc836x_mds.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc836x_mds.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc836x_mds.dts	2007-05-21 13:50:26.472482643 +0200
@@ -21,7 +21,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8540ads.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8540ads.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8540ads.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8540ads.dts	2007-05-21 13:50:26.489481738 +0200
@@ -17,7 +17,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8541cds.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8541cds.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8541cds.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8541cds.dts	2007-05-21 13:50:26.522479981 +0200
@@ -17,7 +17,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8544ds.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8544ds.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8544ds.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8544ds.dts	2007-05-21 13:50:26.556478171 +0200
@@ -0,0 +1,136 @@
+/*
+ * MPC8544 DS Device Tree Source
+ *
+ * Copyright 2007 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+/ {
+	model = "MPC8544DS";
+	compatible = "MPC8544DS", "MPC85xxDS";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	cpus {
+		#cpus = <1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		PowerPC,8544@0 {
+			device_type = "cpu";
+			reg = <0>;
+			d-cache-line-size = <20>;	// 32 bytes
+			i-cache-line-size = <20>;	// 32 bytes
+			d-cache-size = <8000>;		// L1, 32K
+			i-cache-size = <8000>;		// L1, 32K
+			timebase-frequency = <0>;
+			bus-frequency = <0>;
+			clock-frequency = <0>;
+			32-bit;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <00000000 00000000>;	// Filled by U-Boot
+	};
+
+	soc8544@e0000000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		#interrupt-cells = <2>;
+		device_type = "soc";
+		ranges = <0 e0000000 00100000>;
+		reg = <e0000000 00100000>;	// CCSRBAR 1M
+		bus-frequency = <0>;		// Filled out by uboot.
+
+		i2c@3000 {
+			device_type = "i2c";
+			compatible = "fsl-i2c";
+			reg = <3000 100>;
+			interrupts = <1b 2>;
+			interrupt-parent = <&mpic>;
+			dfsrr;
+		};
+
+		mdio@24520 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			device_type = "mdio";
+			compatible = "gianfar";
+			reg = <24520 20>;
+			phy0: ethernet-phy@0 {
+				interrupt-parent = <&mpic>;
+				interrupts = <3a 1>;
+				reg = <0>;
+				device_type = "ethernet-phy";
+			};
+			phy1: ethernet-phy@1 {
+				interrupt-parent = <&mpic>;
+				interrupts = <3a 1>;
+				reg = <1>;
+				device_type = "ethernet-phy";
+			};
+		};
+
+		ethernet@24000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			device_type = "network";
+			model = "TSEC";
+			compatible = "gianfar";
+			reg = <24000 1000>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			interrupts = <d 2 e 2 12 2>;
+			interrupt-parent = <&mpic>;
+			phy-handle = <&phy0>;
+		};
+
+		ethernet@26000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			device_type = "network";
+			model = "TSEC";
+			compatible = "gianfar";
+			reg = <26000 1000>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			interrupts = <f 2 10 2 11 2>;
+			interrupt-parent = <&mpic>;
+			phy-handle = <&phy1>;
+		};
+
+		serial@4500 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <4500 100>;
+			clock-frequency = <0>;
+			interrupts = <1a 2>;
+			interrupt-parent = <&mpic>;
+		};
+
+		serial@4600 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <4600 100>;
+			clock-frequency = <0>;
+			interrupts = <1a 2>;
+			interrupt-parent = <&mpic>;
+		};
+
+		mpic: pic@40000 {
+			clock-frequency = <0>;
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <2>;
+			reg = <40000 40000>;
+			built-in;
+			compatible = "chrp,open-pic";
+			device_type = "open-pic";
+			big-endian;
+		};
+	};
+};
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8548cds.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8548cds.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8548cds.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8548cds.dts	2007-05-21 13:50:26.604475615 +0200
@@ -17,7 +17,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8555cds.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8555cds.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8555cds.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8555cds.dts	2007-05-21 13:50:26.655472900 +0200
@@ -17,7 +17,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8560ads.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8560ads.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8560ads.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8560ads.dts	2007-05-21 13:50:26.689471089 +0200
@@ -17,7 +17,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8568mds.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8568mds.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8568mds.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8568mds.dts	2007-05-21 13:50:26.720469439 +0200
@@ -21,7 +21,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8641_hpcn.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8641_hpcn.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc8641_hpcn.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc8641_hpcn.dts	2007-05-21 13:50:26.754467628 +0200
@@ -17,7 +17,6 @@
 	#size-cells = <1>;
 
 	cpus {
-		#cpus = <2>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 
@@ -300,6 +299,30 @@
 			};
 
 		};
+
+		pci@9000 {
+			compatible = "86xx";
+			device_type = "pci";
+			#interrupt-cells = <1>;
+			#size-cells = <2>;
+			#address-cells = <3>;
+			reg = <9000 1000>;
+			bus-range = <0 ff>;
+			ranges = <02000000 0 a0000000 a0000000 0 20000000
+				  01000000 0 00000000 e3000000 0 00100000>;
+			clock-frequency = <1fca055>;
+			interrupt-parent = <&mpic>;
+			interrupts = <19 2>;
+			interrupt-map-mask = <f800 0 0 7>;
+			interrupt-map = <
+				/* IDSEL 0x0 */
+				0000 0 0 1 &mpic 44 1
+				0000 0 0 2 &mpic 45 1
+				0000 0 0 3 &mpic 46 1
+				0000 0 0 4 &mpic 47 1
+				>;
+		};
+
 		mpic: pic@40000 {
 			clock-frequency = <0>;
 			interrupt-controller;
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc866ads.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc866ads.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc866ads.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc866ads.dts	2007-05-21 13:50:26.773466617 +0200
@@ -18,7 +18,6 @@
 	linux,phandle = <100>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 		linux,phandle = <200>;
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc885ads.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc885ads.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/mpc885ads.dts	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/mpc885ads.dts	2007-05-21 13:50:26.824463901 +0200
@@ -18,7 +18,6 @@
 	linux,phandle = <100>;
 
 	cpus {
-		#cpus = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
 		linux,phandle = <200>;
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/dts/ps3.dts linux-2.6.21.1-ps3/arch/powerpc/boot/dts/ps3.dts
--- linux-2.6.21.1-org/arch/powerpc/boot/dts/ps3.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/dts/ps3.dts	2007-05-21 13:50:26.839463103 +0200
@@ -0,0 +1,74 @@
+/*
+ *  PS3 Game Console device tree.
+ *
+ *  Copyright (C) 2006 Sony Computer Entertainment Inc.
+ *  Copyright 2006 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+/ {
+	model = "PS3 Game Console";
+	compatible = "PS3";
+	#size-cells = <2>;
+	#address-cells = <2>;
+
+	/*
+	 * Need to keep linux,platform for a while, not used by kernel.
+	 */
+
+	chosen {
+		linux,platform = <0>;
+	};
+
+	/*
+	 * dtc expects a memory entry, so we'll put a null entry here.
+	 * We'll get the size of the bootmem block from lv1 after startup.
+	 */
+
+	memory {
+		device_type = "memory";
+		reg = <0 0 0 0>;
+	};
+
+	/*
+	 * dtc expects a clock-frequency and timebase-frequency entries, so
+	 * we'll put a null entries here.  These will be initialized after
+	 * startup with data from lv1.
+	 *
+	 * The boot cpu is always zero for PS3.
+	 *
+	 * Seems the only way currently to indicate a processor has multiple
+	 * threads is with an ibm,ppc-interrupt-server#s entry.  We'll put one
+	 * here so we can bring up both of ours.  See smp_setup_cpu_maps().
+	 */
+
+	cpus {
+		#size-cells = <0>;
+		#address-cells = <1>;
+
+		CBE,PPE {
+			device_type = "cpu";
+			reg = <0>;
+			ibm,ppc-interrupt-server#s = <0 1>;
+			clock-frequency = <0>;
+			timebase-frequency = <0>;
+			i-cache-size = <8000>;
+			d-cache-size = <8000>;
+			i-cache-line-size = <80>;
+			d-cache-line-size = <80>;
+		};
+	};
+};
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/elf.h linux-2.6.21.1-ps3/arch/powerpc/boot/elf.h
--- linux-2.6.21.1-org/arch/powerpc/boot/elf.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/elf.h	2007-05-21 13:50:26.883460760 +0200
@@ -146,4 +146,12 @@
 #define ELFOSABI_NONE	0
 #define ELFOSABI_LINUX	3
 
+struct elf_info {
+	unsigned long loadsize;
+	unsigned long memsize;
+	unsigned long elfoffset;
+};
+int parse_elf64(void *hdr, struct elf_info *info);
+int parse_elf32(void *hdr, struct elf_info *info);
+
 #endif				/* _PPC_BOOT_ELF_H_ */
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/elf_util.c linux-2.6.21.1-ps3/arch/powerpc/boot/elf_util.c
--- linux-2.6.21.1-org/arch/powerpc/boot/elf_util.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/elf_util.c	2007-05-21 13:50:26.930458258 +0200
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) Paul Mackerras 1997.
+ *
+ * Updates for PPC64 by Todd Inglett, Dave Engebretsen & Peter Bergner.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+#include <stdarg.h>
+#include <stddef.h>
+#include "elf.h"
+#include "page.h"
+#include "string.h"
+#include "stdio.h"
+
+int parse_elf64(void *hdr, struct elf_info *info)
+{
+	Elf64_Ehdr *elf64 = hdr;
+	Elf64_Phdr *elf64ph;
+	unsigned int i;
+
+	if (!(elf64->e_ident[EI_MAG0]  == ELFMAG0	&&
+	      elf64->e_ident[EI_MAG1]  == ELFMAG1	&&
+	      elf64->e_ident[EI_MAG2]  == ELFMAG2	&&
+	      elf64->e_ident[EI_MAG3]  == ELFMAG3	&&
+	      elf64->e_ident[EI_CLASS] == ELFCLASS64	&&
+	      elf64->e_ident[EI_DATA]  == ELFDATA2MSB	&&
+	      elf64->e_type            == ET_EXEC	&&
+	      elf64->e_machine         == EM_PPC64))
+		return 0;
+
+	elf64ph = (Elf64_Phdr *)((unsigned long)elf64 +
+				 (unsigned long)elf64->e_phoff);
+	for (i = 0; i < (unsigned int)elf64->e_phnum; i++, elf64ph++)
+		if (elf64ph->p_type == PT_LOAD)
+			break;
+	if (i >= (unsigned int)elf64->e_phnum)
+		return 0;
+
+	info->loadsize = (unsigned long)elf64ph->p_filesz;
+	info->memsize = (unsigned long)elf64ph->p_memsz;
+	info->elfoffset = (unsigned long)elf64ph->p_offset;
+
+	return 1;
+}
+
+int parse_elf32(void *hdr, struct elf_info *info)
+{
+	Elf32_Ehdr *elf32 = hdr;
+	Elf32_Phdr *elf32ph;
+	unsigned int i;
+
+	if (!(elf32->e_ident[EI_MAG0]  == ELFMAG0	&&
+	      elf32->e_ident[EI_MAG1]  == ELFMAG1	&&
+	      elf32->e_ident[EI_MAG2]  == ELFMAG2	&&
+	      elf32->e_ident[EI_MAG3]  == ELFMAG3	&&
+	      elf32->e_ident[EI_CLASS] == ELFCLASS32	&&
+	      elf32->e_ident[EI_DATA]  == ELFDATA2MSB	&&
+	      elf32->e_type            == ET_EXEC	&&
+	      elf32->e_machine         == EM_PPC))
+		return 0;
+
+	elf32ph = (Elf32_Phdr *) ((unsigned long)elf32 + elf32->e_phoff);
+	for (i = 0; i < elf32->e_phnum; i++, elf32ph++)
+		if (elf32ph->p_type == PT_LOAD)
+			break;
+	if (i >= elf32->e_phnum)
+		return 0;
+
+	info->loadsize = elf32ph->p_filesz;
+	info->memsize = elf32ph->p_memsz;
+	info->elfoffset = elf32ph->p_offset;
+	return 1;
+}
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/flatdevtree.c linux-2.6.21.1-ps3/arch/powerpc/boot/flatdevtree.c
--- linux-2.6.21.1-org/arch/powerpc/boot/flatdevtree.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/flatdevtree.c	2007-05-21 13:50:26.946457406 +0200
@@ -29,12 +29,20 @@
 
 #define _ALIGN(x, al)	(((x) + (al) - 1) & ~((al) - 1))
 
+static char *ft_root_node(struct ft_cxt *cxt)
+{
+	return cxt->rgn[FT_STRUCT].start;
+}
+
 /* Routines for keeping node ptrs returned by ft_find_device current */
 /* First entry not used b/c it would return 0 and be taken as NULL/error */
-static void *ft_node_add(struct ft_cxt *cxt, char *node)
+static void *ft_get_phandle(struct ft_cxt *cxt, char *node)
 {
 	unsigned int i;
 
+	if (!node)
+		return NULL;
+
 	for (i = 1; i < cxt->nodes_used; i++)	/* already there? */
 		if (cxt->node_tbl[i] == node)
 			return (void *)i;
@@ -238,7 +246,7 @@
 			if (rgn == FT_STRUCT)
 				ft_node_update_before(cxt, p, -nextra);
 		}
-		*p -= nextra;
+		*pp -= nextra;
 		cxt->rgn[rgn].start -= nextra;
 		cxt->rgn[rgn].size += nextra;
 		return 1;
@@ -253,8 +261,14 @@
 	char *str, *next;
 	enum ft_rgn_id r;
 
-	if (!cxt->isordered && !ft_reorder(cxt, nextra))
-		return 0;
+	if (!cxt->isordered) {
+		unsigned long rgn_off = *pp - cxt->rgn[rgn].start;
+
+		if (!ft_reorder(cxt, nextra))
+			return 0;
+
+		*pp = cxt->rgn[rgn].start + rgn_off;
+	}
 	if (ft_shuffle(cxt, pp, rgn, nextra))
 		return 1;
 
@@ -415,7 +429,7 @@
 {
 	int off, len;
 
-	off = lookup_string(cxt, name);
+	off = map_string(cxt, name);
 	if (off == NO_STRING)
 		return -1;
 
@@ -590,7 +604,7 @@
 
 void ft_begin_tree(struct ft_cxt *cxt)
 {
-	cxt->p = cxt->rgn[FT_STRUCT].start;
+	cxt->p = ft_root_node(cxt);
 }
 
 void ft_end_tree(struct ft_cxt *cxt)
@@ -636,8 +650,21 @@
 	/* require absolute path */
 	if (srch_path[0] != '/')
 		return NULL;
-	node = ft_find_descendent(cxt, cxt->rgn[FT_STRUCT].start, srch_path);
-	return ft_node_add(cxt, node);
+	node = ft_find_descendent(cxt, ft_root_node(cxt), srch_path);
+	return ft_get_phandle(cxt, node);
+}
+
+void *ft_find_device_rel(struct ft_cxt *cxt, const void *top,
+                         const char *srch_path)
+{
+	char *node;
+
+	node = ft_node_ph2node(cxt, top);
+	if (node == NULL)
+		return NULL;
+
+	node = ft_find_descendent(cxt, node, srch_path);
+	return ft_get_phandle(cxt, node);
 }
 
 void *ft_find_descendent(struct ft_cxt *cxt, void *top, const char *srch_path)
@@ -701,23 +728,18 @@
 	return NULL;
 }
 
-void *ft_get_parent(struct ft_cxt *cxt, const void *phandle)
+void *__ft_get_parent(struct ft_cxt *cxt, void *node)
 {
-	void *node;
 	int d;
 	struct ft_atom atom;
 	char *p;
 
-	node = ft_node_ph2node(cxt, phandle);
-	if (node == NULL)
-		return NULL;
-
 	for (d = 0; cxt->genealogy[d] != NULL; ++d)
 		if (cxt->genealogy[d] == node)
-			return cxt->genealogy[d > 0 ? d - 1 : 0];
+			return d > 0 ? cxt->genealogy[d - 1] : NULL;
 
 	/* have to do it the hard way... */
-	p = cxt->rgn[FT_STRUCT].start;
+	p = ft_root_node(cxt);
 	d = 0;
 	while ((p = ft_next(cxt, p, &atom)) != NULL) {
 		switch (atom.tag) {
@@ -726,7 +748,7 @@
 			if (node == atom.data) {
 				/* found it */
 				cxt->genealogy[d + 1] = NULL;
-				return d > 0 ? cxt->genealogy[d - 1] : node;
+				return d > 0 ? cxt->genealogy[d - 1] : NULL;
 			}
 			++d;
 			break;
@@ -738,41 +760,131 @@
 	return NULL;
 }
 
-int ft_get_prop(struct ft_cxt *cxt, const void *phandle, const char *propname,
-		void *buf, const unsigned int buflen)
+void *ft_get_parent(struct ft_cxt *cxt, const void *phandle)
 {
-	struct ft_atom atom;
-	void *node;
-	char *p;
-	int depth;
-	unsigned int size;
-
-	node = ft_node_ph2node(cxt, phandle);
+	void *node = ft_node_ph2node(cxt, phandle);
 	if (node == NULL)
-		return -1;
+		return NULL;
 
-	depth = 0;
-	p = (char *)node;
+	node = __ft_get_parent(cxt, node);
+	return ft_get_phandle(cxt, node);
+}
 
-	while ((p = ft_next(cxt, p, &atom)) != NULL) {
+static const void *__ft_get_prop(struct ft_cxt *cxt, void *node,
+                                 const char *propname, unsigned int *len)
+{
+	struct ft_atom atom;
+	int depth = 0;
+
+	while ((node = ft_next(cxt, node, &atom)) != NULL) {
 		switch (atom.tag) {
 		case OF_DT_BEGIN_NODE:
 			++depth;
 			break;
+
 		case OF_DT_PROP:
-			if ((depth != 1) || strcmp(atom.name, propname))
+			if (depth != 1 || strcmp(atom.name, propname))
 				break;
-			size = min(atom.size, buflen);
-			memcpy(buf, atom.data, size);
-			return atom.size;
+
+			if (len)
+				*len = atom.size;
+
+			return atom.data;
+
 		case OF_DT_END_NODE:
 			if (--depth <= 0)
-				return -1;
+				return NULL;
 		}
 	}
+
+	return NULL;
+}
+
+int ft_get_prop(struct ft_cxt *cxt, const void *phandle, const char *propname,
+		void *buf, const unsigned int buflen)
+{
+	const void *data;
+	unsigned int size;
+
+	void *node = ft_node_ph2node(cxt, phandle);
+	if (!node)
+		return -1;
+
+	data = __ft_get_prop(cxt, node, propname, &size);
+	if (data) {
+		unsigned int clipped_size = min(size, buflen);
+		memcpy(buf, data, clipped_size);
+		return size;
+	}
+
 	return -1;
 }
 
+void *__ft_find_node_by_prop_value(struct ft_cxt *cxt, void *prev,
+                                   const char *propname, const char *propval,
+                                   unsigned int proplen)
+{
+	struct ft_atom atom;
+	char *p = ft_root_node(cxt);
+	char *next;
+	int past_prev = prev ? 0 : 1;
+	int depth = -1;
+
+	while ((next = ft_next(cxt, p, &atom)) != NULL) {
+		const void *data;
+		unsigned int size;
+
+		switch (atom.tag) {
+		case OF_DT_BEGIN_NODE:
+			depth++;
+
+			if (prev == p) {
+				past_prev = 1;
+				break;
+			}
+
+			if (!past_prev || depth < 1)
+				break;
+
+			data = __ft_get_prop(cxt, p, propname, &size);
+			if (!data || size != proplen)
+				break;
+			if (memcmp(data, propval, size))
+				break;
+
+			return p;
+
+		case OF_DT_END_NODE:
+			if (depth-- == 0)
+				return NULL;
+
+			break;
+		}
+
+		p = next;
+	}
+
+	return NULL;
+}
+
+void *ft_find_node_by_prop_value(struct ft_cxt *cxt, const void *prev,
+                                 const char *propname, const char *propval,
+                                 int proplen)
+{
+	void *node = NULL;
+
+	if (prev) {
+		node = ft_node_ph2node(cxt, prev);
+
+		if (!node)
+			return NULL;
+	}
+
+	node = __ft_find_node_by_prop_value(cxt, node, propname,
+	                                    propval, proplen);
+	return ft_get_phandle(cxt, node);
+}
+
 int ft_set_prop(struct ft_cxt *cxt, const void *phandle, const char *propname,
 		const void *buf, const unsigned int buflen)
 {
@@ -849,19 +961,26 @@
 	return -1;
 }
 
-void *ft_create_node(struct ft_cxt *cxt, const void *parent, const char *path)
+void *ft_create_node(struct ft_cxt *cxt, const void *parent, const char *name)
 {
 	struct ft_atom atom;
 	char *p, *next;
 	int depth = 0;
 
-	p = cxt->rgn[FT_STRUCT].start;
+	if (parent) {
+		p = ft_node_ph2node(cxt, parent);
+		if (!p)
+			return NULL;
+	} else {
+		p = ft_root_node(cxt);
+	}
+
 	while ((next = ft_next(cxt, p, &atom)) != NULL) {
 		switch (atom.tag) {
 		case OF_DT_BEGIN_NODE:
 			++depth;
-			if (depth == 1 && strcmp(atom.name, path) == 0)
-				/* duplicate node path, return error */
+			if (depth == 1 && strcmp(atom.name, name) == 0)
+				/* duplicate node name, return error */
 				return NULL;
 			break;
 		case OF_DT_END_NODE:
@@ -870,7 +989,7 @@
 				break;
 			/* end of node, insert here */
 			cxt->p = p;
-			ft_begin_node(cxt, path);
+			ft_begin_node(cxt, name);
 			ft_end_node(cxt);
 			return p;
 		}
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/flatdevtree.h linux-2.6.21.1-ps3/arch/powerpc/boot/flatdevtree.h
--- linux-2.6.21.1-org/arch/powerpc/boot/flatdevtree.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/flatdevtree.h	2007-05-21 13:50:26.985455329 +0200
@@ -97,10 +97,17 @@
 void ft_dump_blob(const void *bphp);
 void ft_merge_blob(struct ft_cxt *cxt, void *blob);
 void *ft_find_device(struct ft_cxt *cxt, const char *srch_path);
+void *ft_find_device_rel(struct ft_cxt *cxt, const void *top,
+                         const char *srch_path);
 void *ft_find_descendent(struct ft_cxt *cxt, void *top, const char *srch_path);
 int ft_get_prop(struct ft_cxt *cxt, const void *phandle, const char *propname,
 		void *buf, const unsigned int buflen);
 int ft_set_prop(struct ft_cxt *cxt, const void *phandle, const char *propname,
 		const void *buf, const unsigned int buflen);
+void *ft_get_parent(struct ft_cxt *cxt, const void *phandle);
+void *ft_find_node_by_prop_value(struct ft_cxt *cxt, const void *prev,
+                                 const char *propname, const char *propval,
+                                 int proplen);
+void *ft_create_node(struct ft_cxt *cxt, const void *parent, const char *name);
 
 #endif /* FLATDEVTREE_H */
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/flatdevtree_misc.c linux-2.6.21.1-ps3/arch/powerpc/boot/flatdevtree_misc.c
--- linux-2.6.21.1-org/arch/powerpc/boot/flatdevtree_misc.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/flatdevtree_misc.c	2007-05-21 13:50:27.031452880 +0200
@@ -16,24 +16,43 @@
 
 static struct ft_cxt cxt;
 
-static void *ft_finddevice(const char *name)
+static void *fdtm_finddevice(const char *name)
 {
 	return ft_find_device(&cxt, name);
 }
 
-static int ft_getprop(const void *phandle, const char *propname, void *buf,
-		const int buflen)
+static int fdtm_getprop(const void *phandle, const char *propname,
+                        void *buf, const int buflen)
 {
 	return ft_get_prop(&cxt, phandle, propname, buf, buflen);
 }
 
-static int ft_setprop(const void *phandle, const char *propname,
-		const void *buf, const int buflen)
+static int fdtm_setprop(const void *phandle, const char *propname,
+                        const void *buf, const int buflen)
 {
 	return ft_set_prop(&cxt, phandle, propname, buf, buflen);
 }
 
-static unsigned long ft_finalize(void)
+static void *fdtm_get_parent(const void *phandle)
+{
+	return ft_get_parent(&cxt, phandle);
+}
+
+static void *fdtm_create_node(const void *phandle, const char *name)
+{
+	return ft_create_node(&cxt, phandle, name);
+}
+
+static void *fdtm_find_node_by_prop_value(const void *prev,
+                                          const char *propname,
+                                          const char *propval,
+                                          int proplen)
+{
+	return ft_find_node_by_prop_value(&cxt, prev, propname,
+	                                  propval, proplen);
+}
+
+static unsigned long fdtm_finalize(void)
 {
 	ft_end_tree(&cxt);
 	return (unsigned long)cxt.bph;
@@ -41,10 +60,13 @@
 
 int ft_init(void *dt_blob, unsigned int max_size, unsigned int max_find_device)
 {
-	dt_ops.finddevice = ft_finddevice;
-	dt_ops.getprop = ft_getprop;
-	dt_ops.setprop = ft_setprop;
-	dt_ops.finalize = ft_finalize;
+	dt_ops.finddevice = fdtm_finddevice;
+	dt_ops.getprop = fdtm_getprop;
+	dt_ops.setprop = fdtm_setprop;
+	dt_ops.get_parent = fdtm_get_parent;
+	dt_ops.create_node = fdtm_create_node;
+	dt_ops.find_node_by_prop_value = fdtm_find_node_by_prop_value;
+	dt_ops.finalize = fdtm_finalize;
 
 	return ft_open(&cxt, dt_blob, max_size, max_find_device,
 			platform_ops.realloc);
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/gunzip_util.c linux-2.6.21.1-ps3/arch/powerpc/boot/gunzip_util.c
--- linux-2.6.21.1-org/arch/powerpc/boot/gunzip_util.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/gunzip_util.c	2007-05-21 13:50:27.077450431 +0200
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2007 David Gibson, IBM Corporation.
+ * Based on earlier work, Copyright (C) Paul Mackerras 1997.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <stddef.h>
+#include "string.h"
+#include "stdio.h"
+#include "ops.h"
+#include "gunzip_util.h"
+
+#define HEAD_CRC	2
+#define EXTRA_FIELD	4
+#define ORIG_NAME	8
+#define COMMENT		0x10
+#define RESERVED	0xe0
+
+/**
+ * gunzip_start - prepare to decompress gzip data
+ * @state:     decompressor state structure to be initialized
+ * @src:       buffer containing gzip compressed or uncompressed data
+ * @srclen:    size in bytes of the buffer at src
+ *
+ * If the buffer at @src contains a gzip header, this function
+ * initializes zlib to decompress the data, storing the decompression
+ * state in @state.  The other functions in this file can then be used
+ * to decompress data from the gzipped stream.
+ *
+ * If the buffer at @src does not contain a gzip header, it is assumed
+ * to contain uncompressed data.  The buffer information is recorded
+ * in @state and the other functions in this file will simply copy
+ * data from the uncompressed data stream at @src.
+ *
+ * Any errors, such as bad compressed data, cause an error to be
+ * printed an the platform's exit() function to be called.
+ */
+void gunzip_start(struct gunzip_state *state, void *src, int srclen)
+{
+	char *hdr = src;
+	int hdrlen = 0;
+
+	memset(state, 0, sizeof(*state));
+
+	/* Check for gzip magic number */
+	if ((hdr[0] == 0x1f) && (hdr[1] == 0x8b)) {
+		/* gzip data, initialize zlib parameters */
+		int r, flags;
+
+		state->s.workspace = state->scratch;
+		if (zlib_inflate_workspacesize() > sizeof(state->scratch))
+			fatal("insufficient scratch space for gunzip\n\r");
+
+		/* skip header */
+		hdrlen = 10;
+		flags = hdr[3];
+		if (hdr[2] != Z_DEFLATED || (flags & RESERVED) != 0)
+			fatal("bad gzipped data\n\r");
+		if ((flags & EXTRA_FIELD) != 0)
+			hdrlen = 12 + hdr[10] + (hdr[11] << 8);
+		if ((flags & ORIG_NAME) != 0)
+			while (hdr[hdrlen++] != 0)
+				;
+		if ((flags & COMMENT) != 0)
+			while (hdr[hdrlen++] != 0)
+				;
+		if ((flags & HEAD_CRC) != 0)
+			hdrlen += 2;
+		if (hdrlen >= srclen)
+			fatal("gunzip_start: ran out of data in header\n\r");
+
+		r = zlib_inflateInit2(&state->s, -MAX_WBITS);
+		if (r != Z_OK)
+			fatal("inflateInit2 returned %d\n\r", r);
+	}
+
+	state->s.next_in = src + hdrlen;
+	state->s.avail_in = srclen - hdrlen;
+}
+
+/**
+ * gunzip_partial - extract bytes from a gzip data stream
+ * @state:     gzip state structure previously initialized by gunzip_start()
+ * @dst:       buffer to store extracted data
+ * @dstlen:    maximum number of bytes to extract
+ *
+ * This function extracts at most @dstlen bytes from the data stream
+ * previously associated with @state by gunzip_start(), decompressing
+ * if necessary.  Exactly @dstlen bytes are extracted unless the data
+ * stream doesn't contain enough bytes, in which case the entire
+ * remainder of the stream is decompressed.
+ *
+ * Returns the actual number of bytes extracted.  If any errors occur,
+ * such as a corrupted compressed stream, an error is printed an the
+ * platform's exit() function is called.
+ */
+int gunzip_partial(struct gunzip_state *state, void *dst, int dstlen)
+{
+	int len;
+
+	if (state->s.workspace) {
+		/* gunzipping */
+		int r;
+
+		state->s.next_out = dst;
+		state->s.avail_out = dstlen;
+		r = zlib_inflate(&state->s, Z_FULL_FLUSH);
+		if (r != Z_OK && r != Z_STREAM_END)
+			fatal("inflate returned %d msg: %s\n\r", r, state->s.msg);
+		len = state->s.next_out - (unsigned char *)dst;
+	} else {
+		/* uncompressed image */
+		len = min(state->s.avail_in, (unsigned)dstlen);
+		memcpy(dst, state->s.next_in, len);
+		state->s.next_in += len;
+		state->s.avail_in -= len;
+	}
+	return len;
+}
+
+/**
+ * gunzip_exactly - extract a fixed number of bytes from a gzip data stream
+ * @state:     gzip state structure previously initialized by gunzip_start()
+ * @dst:       buffer to store extracted data
+ * @dstlen:    number of bytes to extract
+ *
+ * This function extracts exactly @dstlen bytes from the data stream
+ * previously associated with @state by gunzip_start(), decompressing
+ * if necessary.
+ *
+ * If there are less @dstlen bytes available in the data stream, or if
+ * any other errors occur, such as a corrupted compressed stream, an
+ * error is printed an the platform's exit() function is called.
+ */
+void gunzip_exactly(struct gunzip_state *state, void *dst, int dstlen)
+{
+	int len;
+
+	len  = gunzip_partial(state, dst, dstlen);
+	if (len < dstlen)
+		fatal("gunzip_block: ran out of data\n\r");
+}
+
+/**
+ * gunzip_discard - discard bytes from a gzip data stream
+ * @state:     gzip state structure previously initialized by gunzip_start()
+ * @len:       number of bytes to discard
+ *
+ * This function extracts, then discards exactly @len bytes from the
+ * data stream previously associated with @state by gunzip_start().
+ * Subsequent gunzip_partial(), gunzip_exactly() or gunzip_finish()
+ * calls will extract the data following the discarded bytes in the
+ * data stream.
+ *
+ * If there are less @len bytes available in the data stream, or if
+ * any other errors occur, such as a corrupted compressed stream, an
+ * error is printed an the platform's exit() function is called.
+ */
+void gunzip_discard(struct gunzip_state *state, int len)
+{
+	static char discard_buf[128];
+
+	while (len > sizeof(discard_buf)) {
+		gunzip_exactly(state, discard_buf, sizeof(discard_buf));
+		len -= sizeof(discard_buf);
+	}
+
+	if (len > 0)
+		gunzip_exactly(state, discard_buf, len);
+}
+
+/**
+ * gunzip_finish - extract all remaining bytes from a gzip data stream
+ * @state:     gzip state structure previously initialized by gunzip_start()
+ * @dst:       buffer to store extracted data
+ * @dstlen:    maximum number of bytes to extract
+ *
+ * This function extracts all remaining data, or at most @dstlen
+ * bytes, from the stream previously associated with @state by
+ * gunzip_start().  zlib is then shut down, so it is an error to use
+ * any of the functions in this file on @state until it is
+ * re-initialized with another call to gunzip_start().
+ *
+ * If any errors occur, such as a corrupted compressed stream, an
+ * error is printed an the platform's exit() function is called.
+ */
+int gunzip_finish(struct gunzip_state *state, void *dst, int dstlen)
+{
+	int len;
+
+	if (state->s.workspace) {
+		len = gunzip_partial(state, dst, dstlen);
+		zlib_inflateEnd(&state->s);
+	} else {
+		/* uncompressed image */
+		len = min(state->s.avail_in, (unsigned)dstlen);
+		memcpy(dst, state->s.next_in, len);
+	}
+
+	return len;
+}
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/gunzip_util.h linux-2.6.21.1-ps3/arch/powerpc/boot/gunzip_util.h
--- linux-2.6.21.1-org/arch/powerpc/boot/gunzip_util.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/gunzip_util.h	2007-05-21 13:50:27.113448514 +0200
@@ -0,0 +1,45 @@
+/*
+ * Decompression convenience functions
+ *
+ * Copyright 2007 David Gibson, IBM Corporation.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef _PPC_BOOT_GUNZIP_UTIL_H_
+#define _PPC_BOOT_GUNZIP_UTIL_H_
+
+#include "zlib.h"
+
+/*
+ * These functions are designed to make life easy for decompressing
+ * kernel images, initrd images or any other gzip compressed image,
+ * particularly if its useful to decompress part of the image (e.g. to
+ * examine headers) before decompressing the remainder.
+ *
+ * To use:
+ *     - declare a gunzip_state structure
+ *     - use gunzip_start() to initialize the state, associating it
+ *       with a stream of compressed data
+ *     - use gunzip_partial(), gunzip_exactly() and gunzip_discard()
+ *       in any combination to extract pieces of data from the stream
+ *     - Finally use gunzip_finish() to extract the tail of the
+ *       compressed stream and wind up zlib
+ */
+
+/* scratch space for gunzip; 46912 is from zlib_inflate_workspacesize() */
+#define GUNZIP_SCRATCH_SIZE	46912
+
+struct gunzip_state {
+	z_stream s;
+	char scratch[46912];
+};
+
+void gunzip_start(struct gunzip_state *state, void *src, int srclen);
+int gunzip_partial(struct gunzip_state *state, void *dst, int dstlen);
+void gunzip_exactly(struct gunzip_state *state, void *dst, int len);
+void gunzip_discard(struct gunzip_state *state, int len);
+int gunzip_finish(struct gunzip_state *state, void *dst, int len);
+
+#endif /* _PPC_BOOT_GUNZIP_UTIL_H_ */
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/main.c linux-2.6.21.1-ps3/arch/powerpc/boot/main.c
--- linux-2.6.21.1-org/arch/powerpc/boot/main.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/main.c	2007-05-21 13:50:27.127447769 +0200
@@ -14,11 +14,10 @@
 #include "page.h"
 #include "string.h"
 #include "stdio.h"
-#include "zlib.h"
 #include "ops.h"
+#include "gunzip_util.h"
 #include "flatdevtree.h"
-
-extern void flush_cache(void *, unsigned long);
+#include "reg.h"
 
 extern char _start[];
 extern char __bss_start[];
@@ -30,304 +29,171 @@
 extern char _dtb_start[];
 extern char _dtb_end[];
 
+static struct gunzip_state gzstate;
+
 struct addr_range {
-	unsigned long addr;
+	void *addr;
 	unsigned long size;
-	unsigned long memsize;
 };
-static struct addr_range vmlinux;
-static struct addr_range vmlinuz;
-static struct addr_range initrd;
-
-static unsigned long elfoffset;
-static int is_64bit;
-
-/* scratch space for gunzip; 46912 is from zlib_inflate_workspacesize() */
-static char scratch[46912];
-static char elfheader[256];
-
-typedef void (*kernel_entry_t)(unsigned long, unsigned long, void *);
 
 #undef DEBUG
 
-#define HEAD_CRC	2
-#define EXTRA_FIELD	4
-#define ORIG_NAME	8
-#define COMMENT		0x10
-#define RESERVED	0xe0
-
-static void gunzip(void *dst, int dstlen, unsigned char *src, int *lenp)
-{
-	z_stream s;
-	int r, i, flags;
-
-	/* skip header */
-	i = 10;
-	flags = src[3];
-	if (src[2] != Z_DEFLATED || (flags & RESERVED) != 0) {
-		printf("bad gzipped data\n\r");
-		exit();
-	}
-	if ((flags & EXTRA_FIELD) != 0)
-		i = 12 + src[10] + (src[11] << 8);
-	if ((flags & ORIG_NAME) != 0)
-		while (src[i++] != 0)
-			;
-	if ((flags & COMMENT) != 0)
-		while (src[i++] != 0)
-			;
-	if ((flags & HEAD_CRC) != 0)
-		i += 2;
-	if (i >= *lenp) {
-		printf("gunzip: ran out of data in header\n\r");
-		exit();
-	}
-
-	if (zlib_inflate_workspacesize() > sizeof(scratch)) {
-		printf("gunzip needs more mem\n");
-		exit();
-	}
-	memset(&s, 0, sizeof(s));
-	s.workspace = scratch;
-	r = zlib_inflateInit2(&s, -MAX_WBITS);
-	if (r != Z_OK) {
-		printf("inflateInit2 returned %d\n\r", r);
-		exit();
-	}
-	s.next_in = src + i;
-	s.avail_in = *lenp - i;
-	s.next_out = dst;
-	s.avail_out = dstlen;
-	r = zlib_inflate(&s, Z_FULL_FLUSH);
-	if (r != Z_OK && r != Z_STREAM_END) {
-		printf("inflate returned %d msg: %s\n\r", r, s.msg);
-		exit();
-	}
-	*lenp = s.next_out - (unsigned char *) dst;
-	zlib_inflateEnd(&s);
-}
-
-static int is_elf64(void *hdr)
-{
-	Elf64_Ehdr *elf64 = hdr;
-	Elf64_Phdr *elf64ph;
-	unsigned int i;
-
-	if (!(elf64->e_ident[EI_MAG0]  == ELFMAG0	&&
-	      elf64->e_ident[EI_MAG1]  == ELFMAG1	&&
-	      elf64->e_ident[EI_MAG2]  == ELFMAG2	&&
-	      elf64->e_ident[EI_MAG3]  == ELFMAG3	&&
-	      elf64->e_ident[EI_CLASS] == ELFCLASS64	&&
-	      elf64->e_ident[EI_DATA]  == ELFDATA2MSB	&&
-	      elf64->e_type            == ET_EXEC	&&
-	      elf64->e_machine         == EM_PPC64))
-		return 0;
-
-	elf64ph = (Elf64_Phdr *)((unsigned long)elf64 +
-				 (unsigned long)elf64->e_phoff);
-	for (i = 0; i < (unsigned int)elf64->e_phnum; i++, elf64ph++)
-		if (elf64ph->p_type == PT_LOAD)
-			break;
-	if (i >= (unsigned int)elf64->e_phnum)
-		return 0;
-
-	elfoffset = (unsigned long)elf64ph->p_offset;
-	vmlinux.size = (unsigned long)elf64ph->p_filesz + elfoffset;
-	vmlinux.memsize = (unsigned long)elf64ph->p_memsz + elfoffset;
-
-	is_64bit = 1;
-	return 1;
-}
-
-static int is_elf32(void *hdr)
-{
-	Elf32_Ehdr *elf32 = hdr;
-	Elf32_Phdr *elf32ph;
-	unsigned int i;
-
-	if (!(elf32->e_ident[EI_MAG0]  == ELFMAG0	&&
-	      elf32->e_ident[EI_MAG1]  == ELFMAG1	&&
-	      elf32->e_ident[EI_MAG2]  == ELFMAG2	&&
-	      elf32->e_ident[EI_MAG3]  == ELFMAG3	&&
-	      elf32->e_ident[EI_CLASS] == ELFCLASS32	&&
-	      elf32->e_ident[EI_DATA]  == ELFDATA2MSB	&&
-	      elf32->e_type            == ET_EXEC	&&
-	      elf32->e_machine         == EM_PPC))
-		return 0;
-
-	elf32 = (Elf32_Ehdr *)elfheader;
-	elf32ph = (Elf32_Phdr *) ((unsigned long)elf32 + elf32->e_phoff);
-	for (i = 0; i < elf32->e_phnum; i++, elf32ph++)
-		if (elf32ph->p_type == PT_LOAD)
-			break;
-	if (i >= elf32->e_phnum)
-		return 0;
-
-	elfoffset = elf32ph->p_offset;
-	vmlinux.size = elf32ph->p_filesz + elf32ph->p_offset;
-	vmlinux.memsize = elf32ph->p_memsz + elf32ph->p_offset;
-	return 1;
-}
-
-static void prep_kernel(unsigned long a1, unsigned long a2)
+static struct addr_range prep_kernel(void)
 {
+	char elfheader[256];
+	void *vmlinuz_addr = _vmlinux_start;
+	unsigned long vmlinuz_size = _vmlinux_end - _vmlinux_start;
+	void *addr = 0;
+	struct elf_info ei;
 	int len;
 
-	vmlinuz.addr = (unsigned long)_vmlinux_start;
-	vmlinuz.size = (unsigned long)(_vmlinux_end - _vmlinux_start);
-
 	/* gunzip the ELF header of the kernel */
-	if (*(unsigned short *)vmlinuz.addr == 0x1f8b) {
-		len = vmlinuz.size;
-		gunzip(elfheader, sizeof(elfheader),
-				(unsigned char *)vmlinuz.addr, &len);
-	} else
-		memcpy(elfheader, (const void *)vmlinuz.addr,
-		       sizeof(elfheader));
+	gunzip_start(&gzstate, vmlinuz_addr, vmlinuz_size);
+	gunzip_exactly(&gzstate, elfheader, sizeof(elfheader));
+
+	if (!parse_elf64(elfheader, &ei) && !parse_elf32(elfheader, &ei))
+		fatal("Error: not a valid PPC32 or PPC64 ELF file!\n\r");
 
-	if (!is_elf64(elfheader) && !is_elf32(elfheader)) {
-		printf("Error: not a valid PPC32 or PPC64 ELF file!\n\r");
-		exit();
-	}
 	if (platform_ops.image_hdr)
 		platform_ops.image_hdr(elfheader);
 
-	/* We need to alloc the memsize plus the file offset since gzip
-	 * will expand the header (file offset), then the kernel, then
-	 * possible rubbish we don't care about. But the kernel bss must
-	 * be claimed (it will be zero'd by the kernel itself)
+	/* We need to alloc the memsize: gzip will expand the kernel
+	 * text/data, then possible rubbish we don't care about. But
+	 * the kernel bss must be claimed (it will be zero'd by the
+	 * kernel itself)
 	 */
-	printf("Allocating 0x%lx bytes for kernel ...\n\r", vmlinux.memsize);
-	vmlinux.addr = (unsigned long)malloc(vmlinux.memsize);
-	if (vmlinux.addr == 0) {
-		printf("Can't allocate memory for kernel image !\n\r");
-		exit();
-	}
+	printf("Allocating 0x%lx bytes for kernel ...\n\r", ei.memsize);
+
+	if (platform_ops.vmlinux_alloc) {
+		addr = platform_ops.vmlinux_alloc(ei.memsize);
+	} else {
+		if ((unsigned long)_start < ei.memsize)
+			fatal("Insufficient memory for kernel at address 0!"
+			       " (_start=%p)\n\r", _start);
+	}
+
+	/* Finally, gunzip the kernel */
+	printf("gunzipping (0x%p <- 0x%p:0x%p)...", addr,
+	       vmlinuz_addr, vmlinuz_addr+vmlinuz_size);
+	/* discard up to the actual load data */
+	gunzip_discard(&gzstate, ei.elfoffset - sizeof(elfheader));
+	len = gunzip_finish(&gzstate, addr, ei.loadsize);
+	if (len != ei.loadsize)
+		fatal("ran out of data!  only got 0x%x of 0x%lx bytes.\n\r",
+				len, ei.loadsize);
+	printf("done 0x%x bytes\n\r", len);
+
+	flush_cache(addr, ei.loadsize);
+
+	return (struct addr_range){addr, ei.memsize};
+}
+
+static struct addr_range prep_initrd(struct addr_range vmlinux, void *chosen,
+				     unsigned long initrd_addr,
+				     unsigned long initrd_size)
+{
+	/* If we have an image attached to us, it overrides anything
+	 * supplied by the loader. */
+	if (_initrd_end > _initrd_start) {
+		printf("Attached initrd image at 0x%p-0x%p\n\r",
+		       _initrd_start, _initrd_end);
+		initrd_addr = (unsigned long)_initrd_start;
+		initrd_size = _initrd_end - _initrd_start;
+	} else if (initrd_size > 0) {
+		printf("Using loader supplied ramdisk at 0x%lx-0x%lx\n\r",
+		       initrd_addr, initrd_addr + initrd_size);
+	}
+
+	/* If there's no initrd at all, we're done */
+	if (! initrd_size)
+		return (struct addr_range){0, 0};
 
 	/*
-	 * Now find the initrd
-	 *
-	 * First see if we have an image attached to us.  If so
-	 * allocate memory for it and copy it there.
+	 * If the initrd is too low it will be clobbered when the
+	 * kernel relocates to its final location.  In this case,
+	 * allocate a safer place and move it.
 	 */
-	initrd.size = (unsigned long)(_initrd_end - _initrd_start);
-	initrd.memsize = initrd.size;
-	if (initrd.size > 0) {
-		printf("Allocating 0x%lx bytes for initrd ...\n\r",
-		       initrd.size);
-		initrd.addr = (unsigned long)malloc((u32)initrd.size);
-		if (initrd.addr == 0) {
-			printf("Can't allocate memory for initial "
-					"ramdisk !\n\r");
-			exit();
-		}
-		printf("initial ramdisk moving 0x%lx <- 0x%lx "
-			"(0x%lx bytes)\n\r", initrd.addr,
-			(unsigned long)_initrd_start, initrd.size);
-		memmove((void *)initrd.addr, (void *)_initrd_start,
-			initrd.size);
-		printf("initrd head: 0x%lx\n\r",
-				*((unsigned long *)initrd.addr));
-	} else if (a2 != 0) {
-		/* Otherwise, see if yaboot or another loader gave us an initrd */
-		initrd.addr = a1;
-		initrd.memsize = initrd.size = a2;
-		printf("Using loader supplied initrd at 0x%lx (0x%lx bytes)\n\r",
-		       initrd.addr, initrd.size);
-	}
-
-	/* Eventually gunzip the kernel */
-	if (*(unsigned short *)vmlinuz.addr == 0x1f8b) {
-		printf("gunzipping (0x%lx <- 0x%lx:0x%0lx)...",
-		       vmlinux.addr, vmlinuz.addr, vmlinuz.addr+vmlinuz.size);
-		len = vmlinuz.size;
-		gunzip((void *)vmlinux.addr, vmlinux.memsize,
-			(unsigned char *)vmlinuz.addr, &len);
-		printf("done 0x%lx bytes\n\r", len);
-	} else {
-		memmove((void *)vmlinux.addr,(void *)vmlinuz.addr,
-			vmlinuz.size);
-	}
+	if (initrd_addr < vmlinux.size) {
+		void *old_addr = (void *)initrd_addr;
 
-	/* Skip over the ELF header */
-#ifdef DEBUG
-	printf("... skipping 0x%lx bytes of ELF header\n\r",
-			elfoffset);
-#endif
-	vmlinux.addr += elfoffset;
+		printf("Allocating 0x%lx bytes for initrd ...\n\r",
+		       initrd_size);
+		initrd_addr = (unsigned long)malloc(initrd_size);
+		if (! initrd_addr)
+			fatal("Can't allocate memory for initial "
+			       "ramdisk !\n\r");
+		printf("Relocating initrd 0x%lx <- 0x%p (0x%lx bytes)\n\r",
+		       initrd_addr, old_addr, initrd_size);
+		memmove((void *)initrd_addr, old_addr, initrd_size);
+	}
+
+	printf("initrd head: 0x%lx\n\r", *((unsigned long *)initrd_addr));
+
+	/* Tell the kernel initrd address via device tree */
+	setprop_val(chosen, "linux,initrd-start", (u32)(initrd_addr));
+	setprop_val(chosen, "linux,initrd-end", (u32)(initrd_addr+initrd_size));
 
-	flush_cache((void *)vmlinux.addr, vmlinux.size);
+	return (struct addr_range){(void *)initrd_addr, initrd_size};
 }
 
 /* A buffer that may be edited by tools operating on a zImage binary so as to
  * edit the command line passed to vmlinux (by setting /chosen/bootargs).
  * The buffer is put in it's own section so that tools may locate it easier.
  */
-static char builtin_cmdline[COMMAND_LINE_SIZE]
+static char cmdline[COMMAND_LINE_SIZE]
 	__attribute__((__section__("__builtin_cmdline")));
 
-static void get_cmdline(char *buf, int size)
+static void prep_cmdline(void *chosen)
 {
-	void *devp;
-	int len = strlen(builtin_cmdline);
-
-	buf[0] = '\0';
-
-	if (len > 0) { /* builtin_cmdline overrides dt's /chosen/bootargs */
-		len = min(len, size-1);
-		strncpy(buf, builtin_cmdline, len);
-		buf[len] = '\0';
-	}
-	else if ((devp = finddevice("/chosen")))
-		getprop(devp, "bootargs", buf, size);
-}
+	if (cmdline[0] == '\0')
+		getprop(chosen, "bootargs", cmdline, COMMAND_LINE_SIZE-1);
 
-static void set_cmdline(char *buf)
-{
-	void *devp;
+	printf("\n\rLinux/PowerPC load: %s", cmdline);
+	/* If possible, edit the command line */
+	if (console_ops.edit_cmdline)
+		console_ops.edit_cmdline(cmdline, COMMAND_LINE_SIZE);
+	printf("\n\r");
 
-	if ((devp = finddevice("/chosen")))
-		setprop(devp, "bootargs", buf, strlen(buf) + 1);
+	/* Put the command line back into the devtree for the kernel */
+	setprop_str(chosen, "bootargs", cmdline);
 }
 
 struct platform_ops platform_ops;
 struct dt_ops dt_ops;
 struct console_ops console_ops;
+struct loader_info loader_info;
 
-void start(unsigned long a1, unsigned long a2, void *promptr, void *sp)
+void start(void)
 {
+	struct addr_range vmlinux, initrd;
 	kernel_entry_t kentry;
-	char cmdline[COMMAND_LINE_SIZE];
 	unsigned long ft_addr = 0;
+	void *chosen;
 
-	memset(__bss_start, 0, _end - __bss_start);
-	memset(&platform_ops, 0, sizeof(platform_ops));
-	memset(&dt_ops, 0, sizeof(dt_ops));
-	memset(&console_ops, 0, sizeof(console_ops));
+	/* Do this first, because malloc() could clobber the loader's
+	 * command line.  Only use the loader command line if a
+	 * built-in command line wasn't set by an external tool */
+	if ((loader_info.cmdline_len > 0) && (cmdline[0] == '\0'))
+		memmove(cmdline, loader_info.cmdline,
+			min(loader_info.cmdline_len, COMMAND_LINE_SIZE-1));
 
-	if (platform_init(promptr, _dtb_start, _dtb_end))
-		exit();
 	if (console_ops.open && (console_ops.open() < 0))
 		exit();
 	if (platform_ops.fixups)
 		platform_ops.fixups();
 
 	printf("\n\rzImage starting: loaded at 0x%p (sp: 0x%p)\n\r",
-	       _start, sp);
-
-	prep_kernel(a1, a2);
+	       _start, get_sp());
 
-	/* If cmdline came from zimage wrapper or if we can edit the one
-	 * in the dt, print it out and edit it, if possible.
-	 */
-	if ((strlen(builtin_cmdline) > 0) || console_ops.edit_cmdline) {
-		get_cmdline(cmdline, COMMAND_LINE_SIZE);
-		printf("\n\rLinux/PowerPC load: %s", cmdline);
-		if (console_ops.edit_cmdline)
-			console_ops.edit_cmdline(cmdline, COMMAND_LINE_SIZE);
-		printf("\n\r");
-		set_cmdline(cmdline);
-	}
+	/* Ensure that the device tree has a /chosen node */
+	chosen = finddevice("/chosen");
+	if (!chosen)
+		chosen = create_node(NULL, "chosen");
+
+	vmlinux = prep_kernel();
+	initrd = prep_initrd(vmlinux, chosen,
+			     loader_info.initrd_addr, loader_info.initrd_size);
+	prep_cmdline(chosen);
 
 	printf("Finalizing device tree...");
 	if (dt_ops.finalize)
@@ -335,19 +201,22 @@
 	if (ft_addr)
 		printf(" flat tree at 0x%lx\n\r", ft_addr);
 	else
-		printf(" using OF tree (promptr=%p)\n\r", promptr);
+		printf(" using OF tree (promptr=%p)\n\r", loader_info.promptr);
 
 	if (console_ops.close)
 		console_ops.close();
 
 	kentry = (kernel_entry_t) vmlinux.addr;
+
+	if (platform_ops.secondary_release)
+		platform_ops.secondary_release(kentry);
+
 	if (ft_addr)
 		kentry(ft_addr, 0, NULL);
 	else
-		/* XXX initrd addr/size should be passed in properties */
-		kentry(initrd.addr, initrd.size, promptr);
+		kentry((unsigned long)initrd.addr, initrd.size,
+		       loader_info.promptr);
 
-	/* console closed so printf below may not work */
-	printf("Error: Linux kernel returned to zImage boot wrapper!\n\r");
-	exit();
+	/* console closed so printf in fatal below may not work */
+	fatal("Error: Linux kernel returned to zImage boot wrapper!\n\r");
 }
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/ns16550.c linux-2.6.21.1-ps3/arch/powerpc/boot/ns16550.c
--- linux-2.6.21.1-org/arch/powerpc/boot/ns16550.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/ns16550.c	2007-05-21 13:50:27.172445373 +0200
@@ -55,10 +55,15 @@
 int ns16550_console_init(void *devp, struct serial_console_data *scdp)
 {
 	int n;
+	unsigned long reg_phys;
 
 	n = getprop(devp, "virtual-reg", &reg_base, sizeof(reg_base));
-	if (n != sizeof(reg_base))
-		return -1;
+	if (n != sizeof(reg_base)) {
+		if (!dt_xlate_reg(devp, 0, &reg_phys, NULL))
+			return -1;
+
+		reg_base = (void *)reg_phys;
+	}
 
 	n = getprop(devp, "reg-shift", &reg_shift, sizeof(reg_shift));
 	if (n != sizeof(reg_shift))
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/of.c linux-2.6.21.1-ps3/arch/powerpc/boot/of.c
--- linux-2.6.21.1-org/arch/powerpc/boot/of.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/of.c	2007-05-21 13:50:27.211443296 +0200
@@ -208,6 +208,16 @@
 	}
 }
 
+static void *of_vmlinux_alloc(unsigned long size)
+{
+	void *p = malloc(size);
+
+	if (!p)
+		fatal("Can't allocate memory for kernel image!\n\r");
+
+	return p;
+}
+
 static void of_exit(void)
 {
 	call_prom("exit", 0, 0);
@@ -251,16 +261,17 @@
 	return -1;
 }
 
-static void of_console_write(char *buf, int len)
+static void of_console_write(const char *buf, int len)
 {
 	call_prom("write", 3, 1, of_stdout_handle, buf, len);
 }
 
-int platform_init(void *promptr, char *dt_blob_start, char *dt_blob_end)
+void platform_init(unsigned long a1, unsigned long a2, void *promptr)
 {
 	platform_ops.image_hdr = of_image_hdr;
 	platform_ops.malloc = of_try_claim;
 	platform_ops.exit = of_exit;
+	platform_ops.vmlinux_alloc = of_vmlinux_alloc;
 
 	dt_ops.finddevice = of_finddevice;
 	dt_ops.getprop = of_getprop;
@@ -270,5 +281,9 @@
 	console_ops.write = of_console_write;
 
 	prom = (int (*)(void *))promptr;
-	return 0;
+	loader_info.promptr = promptr;
+	if (a1 && a2 && a2 != 0xdeadbeef) {
+		loader_info.initrd_addr = a1;
+		loader_info.initrd_size = a2;
+	}
 }
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/ops.h linux-2.6.21.1-ps3/arch/powerpc/boot/ops.h
--- linux-2.6.21.1-org/arch/powerpc/boot/ops.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/ops.h	2007-05-21 13:50:27.228442391 +0200
@@ -11,12 +11,17 @@
 #ifndef _PPC_BOOT_OPS_H_
 #define _PPC_BOOT_OPS_H_
 
+#include <stddef.h>
 #include "types.h"
+#include "string.h"
 
 #define	COMMAND_LINE_SIZE	512
 #define	MAX_PATH_LEN		256
 #define	MAX_PROP_LEN		256 /* What should this be? */
 
+typedef void (*kernel_entry_t)(unsigned long, unsigned long, void *);
+void smp_secondary_release(kernel_entry_t kentry);
+
 /* Platform specific operations */
 struct platform_ops {
 	void	(*fixups)(void);
@@ -25,6 +30,8 @@
 	void	(*free)(void *ptr);
 	void *	(*realloc)(void *ptr, unsigned long size);
 	void	(*exit)(void);
+	void *	(*vmlinux_alloc)(unsigned long size);
+	void	(*secondary_release)(kernel_entry_t kentry);
 };
 extern struct platform_ops platform_ops;
 
@@ -35,6 +42,12 @@
 			const int buflen);
 	int	(*setprop)(const void *phandle, const char *name,
 			const void *buf, const int buflen);
+	void *(*get_parent)(const void *phandle);
+	/* The node must not already exist. */
+	void *(*create_node)(const void *parent, const char *name);
+	void *(*find_node_by_prop_value)(const void *prev,
+	                                 const char *propname,
+	                                 const char *propval, int proplen);
 	unsigned long (*finalize)(void);
 };
 extern struct dt_ops dt_ops;
@@ -42,7 +55,7 @@
 /* Console operations */
 struct console_ops {
 	int	(*open)(void);
-	void	(*write)(char *buf, int len);
+	void	(*write)(const char *buf, int len);
 	void	(*edit_cmdline)(char *buf, int len);
 	void	(*close)(void);
 	void	*data;
@@ -58,13 +71,23 @@
 	void		(*close)(void);
 };
 
-int platform_init(void *promptr, char *dt_blob_start, char *dt_blob_end);
+struct loader_info {
+	void *promptr;
+	unsigned long initrd_addr, initrd_size;
+	char *cmdline;
+	int cmdline_len;
+};
+extern struct loader_info loader_info;
+
+void start(void);
 int ft_init(void *dt_blob, unsigned int max_size, unsigned int max_find_device);
 int serial_console_init(void);
 int ns16550_console_init(void *devp, struct serial_console_data *scdp);
 void *simple_alloc_init(char *base, u32 heap_size, u32 granularity,
 		u32 max_allocs);
-
+extern void flush_cache(void *, unsigned long);
+int dt_xlate_reg(void *node, int res, unsigned long *addr,
+                 unsigned long *size);
 
 static inline void *finddevice(const char *name)
 {
@@ -76,10 +99,74 @@
 	return (dt_ops.getprop) ? dt_ops.getprop(devp, name, buf, buflen) : -1;
 }
 
-static inline int setprop(void *devp, const char *name, void *buf, int buflen)
+static inline int setprop(void *devp, const char *name,
+                          const void *buf, int buflen)
 {
 	return (dt_ops.setprop) ? dt_ops.setprop(devp, name, buf, buflen) : -1;
 }
+#define setprop_val(devp, name, val) \
+	do { \
+		typeof(val) x = (val); \
+		setprop((devp), (name), &x, sizeof(x)); \
+	} while (0)
+
+static inline int setprop_str(void *devp, const char *name, const char *buf)
+{
+	if (dt_ops.setprop)
+		return dt_ops.setprop(devp, name, buf, strlen(buf) + 1);
+
+	return -1;
+}
+
+static inline void *get_parent(const char *devp)
+{
+	return dt_ops.get_parent ? dt_ops.get_parent(devp) : NULL;
+}
+
+static inline void *create_node(const void *parent, const char *name)
+{
+	return dt_ops.create_node ? dt_ops.create_node(parent, name) : NULL;
+}
+
+
+static inline void *find_node_by_prop_value(const void *prev,
+                                            const char *propname,
+                                            const char *propval, int proplen)
+{
+	if (dt_ops.find_node_by_prop_value)
+		return dt_ops.find_node_by_prop_value(prev, propname,
+		                                      propval, proplen);
+
+	return NULL;
+}
+
+static inline void *find_node_by_prop_value_str(const void *prev,
+                                                const char *propname,
+                                                const char *propval)
+{
+	return find_node_by_prop_value(prev, propname, propval,
+	                               strlen(propval) + 1);
+}
+
+static inline void *find_node_by_devtype(const void *prev,
+                                         const char *type)
+{
+	return find_node_by_prop_value_str(prev, "device_type", type);
+}
+
+void dt_fixup_memory(u64 start, u64 size);
+void dt_fixup_cpu_clocks(u32 cpufreq, u32 tbfreq, u32 busfreq);
+void dt_fixup_clock(const char *path, u32 freq);
+void __dt_fixup_mac_addresses(u32 startindex, ...);
+#define dt_fixup_mac_addresses(...) \
+	__dt_fixup_mac_addresses(0, __VA_ARGS__, NULL)
+
+
+static inline void *find_node_by_linuxphandle(const u32 linuxphandle)
+{
+	return find_node_by_prop_value(NULL, "linux,phandle",
+			(char *)&linuxphandle, sizeof(u32));
+}
 
 static inline void *malloc(u32 size)
 {
@@ -98,5 +185,11 @@
 		platform_ops.exit();
 	for(;;);
 }
+#define fatal(args...) { printf(args); exit(); }
+
+
+#define PLATFORM_STACK(size) \
+	char _platform_stack[size]; \
+	void *_platform_stack_top = _platform_stack + sizeof(_platform_stack);
 
 #endif /* _PPC_BOOT_OPS_H_ */
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/ps3-head.S linux-2.6.21.1-ps3/arch/powerpc/boot/ps3-head.S
--- linux-2.6.21.1-org/arch/powerpc/boot/ps3-head.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/ps3-head.S	2007-05-21 13:50:27.272440048 +0200
@@ -0,0 +1,47 @@
+/*
+ *  PS3 zImage exception vector entry.
+ *
+ *  Copyright (C) 2007 Sony Computer Entertainment Inc.
+ *  Copyright 2007 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ppc_asm.h"
+
+/*
+ * __system_reset_entry - PS3 first stage entry.
+ */
+
+	.section .vectors,"ax"
+	. = 0x100
+	.globl __system_reset_entry
+__system_reset_entry:
+
+	/* Switch to 32-bit mode. */
+	mfmsr	r9
+	clrldi	r9,r9,1
+	mtmsrd	r9
+	nop
+
+	/* Get thread number in r3 and branch. */
+
+	mfspr	r3, 0x88
+	cntlzw.	r3, r3
+	li	r4, 0
+	li	r5, 0
+	beq	1f
+	b	smp_secondary_hold
+1:
+	b	_zimage_start
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/ps3-hvcall.S linux-2.6.21.1-ps3/arch/powerpc/boot/ps3-hvcall.S
--- linux-2.6.21.1-org/arch/powerpc/boot/ps3-hvcall.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/ps3-hvcall.S	2007-05-21 13:50:27.351435842 +0200
@@ -0,0 +1,297 @@
+/*
+ *  PS3 hvcall interface.
+ *
+ *  Copyright (C) 2006 Sony Computer Entertainment Inc.
+ *  Copyright 2006 Sony Corp.
+ *  Copyright 2003, 2004 (c) MontaVista Software, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ppc_asm.h"
+
+/*
+ *  wrapper           lv1
+ *  32-bit (h,l)      64-bit
+ *
+ *  1: r3,r4          <-> r3
+ *  2: r5,r6          <-> r4
+ *  3: r7,r8          <-> r5
+ *  4: r9,r10         <-> r6
+ *  5: 8(r1),12(r1)   <-> r7
+ *  6: 16(r1),20(r1)  <-> r8
+ *  7: 24(r1),28(r1)  <-> r9
+ *  8: 32(r1),36(r1)  <-> r10
+ *
+ */
+
+.macro global name
+	.section ".text"
+	.balign 4
+	.globl \name
+\name:
+.endm
+
+.macro no_support name
+	GLOBAL \name
+	b ps3_no_support
+.endm
+
+.macro hvcall
+	.long 0x44000022
+	extsw r3, r3
+.endm
+
+.macro save_lr offset=4
+	mflr r0
+	stw r0, \offset(r1)
+.endm
+
+.macro load_lr offset=4
+	lwz r0, \offset(r1)
+	mtlr r0
+.endm
+
+.macro load_64_reg target,high,low
+	sldi r11, \high, 32
+	or \target, r11, \low
+.endm
+
+.macro load_64_stack target,offset
+	ld \target, \offset(r1)
+.endm
+
+.macro load_r3
+	LOAD_64_REG r3,r3,r4
+.endm
+
+.macro load_r4
+	LOAD_64_REG r4,r5,r6
+.endm
+
+.macro load_r5
+	LOAD_64_REG r5,r7,r8
+.endm
+
+.macro load_r6
+	LOAD_64_REG r6,r9,r10
+.endm
+
+.macro load_r7
+	LOAD_64_STACK r7,8
+.endm
+
+.macro load_r8
+	LOAD_64_STACK r8,16
+.endm
+
+.macro load_r9
+	LOAD_64_STACK r9,24
+.endm
+
+.macro load_r10
+	LOAD_64_STACK r10,32
+.endm
+
+.macro load_regs_5
+	LOAD_R3
+	LOAD_R4
+	LOAD_R5
+	LOAD_R6
+	LOAD_R7
+.endm
+
+.macro load_regs_6
+	LOAD_REGS_5
+	LOAD_R8
+.endm
+
+.macro load_regs_8
+	LOAD_REGS_6
+	LOAD_R9
+	LOAD_R10
+.endm
+
+.macro store_regs_0_1
+	lwz r11, 8(r1)
+	std r4, 0(r11)
+.endm
+
+.macro store_regs_5_2
+	lwz r11, 16(r1)
+	std r4, 0(r11)
+	lwz r11, 24(r1)
+	std r5, 0(r11)
+.endm
+
+.macro store_regs_6_1
+	lwz r11, 24(r1)
+	std r4, 0(r11)
+.endm
+
+#define LV1_N_IN_0_OUT(API_NAME, API_NUMBER)	\
+GLOBAL _##API_NAME;				\
+	SAVE_LR;				\
+	LOAD_REGS_8;				\
+	li      r11, API_NUMBER;		\
+	HVCALL;					\
+	LOAD_LR;				\
+	blr
+
+#define LV1_0_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_1_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_2_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_3_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_4_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_5_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_6_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_7_IN_0_OUT LV1_N_IN_0_OUT
+
+.macro save_r5
+	stw r5, 8(r1)
+.endm
+
+.macro save_r6
+	stw r6, 12(r1)
+.endm
+
+.macro save_1
+	SAVE_R5
+	SAVE_R6
+.endm
+
+#define LV1_0_IN_1_OUT(API_NAME, API_NUMBER)	\
+GLOBAL _##API_NAME;				\
+	SAVE_LR;				\
+	stwu r1,-16(r1);			\
+	stw r3, 8(r1);				\
+	li      r11, API_NUMBER;		\
+	HVCALL;					\
+	lwz r11, 8(r1);				\
+	std r4, 0(r11);				\
+	mr r4, r3;				\
+	li r3, 0;				\
+	addi r1,r1,16;				\
+	LOAD_LR;				\
+	blr
+
+#define LV1_0_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_0_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_0_IN_7_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_4_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_5_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_6_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT
+
+#define LV1_1_IN_7_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_2_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_2_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_2_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_2_IN_4_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_2_IN_5_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_3_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_3_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_3_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_4_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_4_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_4_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_5_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_5_IN_2_OUT(API_NAME, API_NUMBER)	\
+GLOBAL _##API_NAME;				\
+	SAVE_LR;				\
+	LOAD_REGS_5;				\
+	li      r11, API_NUMBER;		\
+	HVCALL;					\
+	STORE_REGS_5_2;				\
+	LOAD_LR;				\
+	blr
+
+#define LV1_5_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_6_IN_1_OUT(API_NAME, API_NUMBER)	\
+GLOBAL _##API_NAME;				\
+	SAVE_LR;				\
+	LOAD_REGS_6;				\
+	li      r11, API_NUMBER;		\
+	HVCALL;					\
+	STORE_REGS_6_1;				\
+	LOAD_LR;				\
+	blr
+
+#define LV1_6_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_6_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_7_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_7_IN_6_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_8_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+/* the lv1 underscored call definitions expand here */
+
+#define LV1_CALL(name, in, out, num) LV1_##in##_IN_##out##_OUT(lv1_##name, num)
+#include "lv1call.h"
+
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/ps3.c linux-2.6.21.1-ps3/arch/powerpc/boot/ps3.c
--- linux-2.6.21.1-org/arch/powerpc/boot/ps3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/ps3.c	2007-05-21 13:50:27.404433020 +0200
@@ -0,0 +1,123 @@
+/*
+ *  PS3 bootwrapper support.
+ *
+ *  Copyright (C) 2007 Sony Computer Entertainment Inc.
+ *  Copyright 2007 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdarg.h>
+#include <stddef.h>
+#include "types.h"
+#include "elf.h"
+#include "string.h"
+#include "stdio.h"
+#include "page.h"
+#include "ops.h"
+#include "lv1call.h"
+
+#if defined(DEBUG)
+#define DBG(fmt...) printf(fmt)
+#else
+static inline int __attribute__ ((format (printf, 1, 2))) DBG(
+	const char *fmt, ...) {return 0;}
+#endif
+
+extern char _start[];
+extern char _end[];
+extern char _dtb_start[];
+extern char _dtb_end[];
+
+PLATFORM_STACK(4096);
+
+static void ps3_console_write(const char *buf, int len)
+{
+}
+
+static void ps3_exit(void)
+{
+	printf("ps3_exit\n");
+	lv1_panic(0); /* zero = no reboot */
+	while(1);
+}
+
+static int ps3_repository_read_rm_size(u64 *rm_size)
+{
+	int result;
+	u64 lpar_id;
+	u64 ppe_id;
+	u64 v2;
+
+	result = lv1_get_logical_partition_id(&lpar_id);
+
+	if (result)
+		return -1;
+
+	result = lv1_get_logical_ppe_id(&ppe_id);
+
+	if (result)
+		return -1;
+
+	/*
+	 * n1: 0000000062690000 : ....bi..
+	 * n2: 7075000000000000 : pu......
+	 * n3: 0000000000000001 : ........
+	 * n4: 726d5f73697a6500 : rm_size.
+	*/
+
+	result = lv1_get_repository_node_value(lpar_id, 0x0000000062690000ULL,
+		0x7075000000000000ULL, ppe_id, 0x726d5f73697a6500ULL, rm_size,
+		&v2);
+
+	printf("%s:%d: ppe_id  %lu \n", __func__, __LINE__,
+		(unsigned long)ppe_id);
+	printf("%s:%d: lpar_id %lu \n", __func__, __LINE__,
+		(unsigned long)lpar_id);
+	printf("%s:%d: rm_size %llxh \n", __func__, __LINE__, *rm_size);
+
+	return result;
+}
+
+static void ps3_fixups(void)
+{
+	u64 rm_size;
+
+	ps3_repository_read_rm_size(&rm_size);
+	dt_fixup_memory(0, rm_size);
+}
+
+int platform_init(void)
+{
+	const u32 heapsize = 0x4000000 - (u32)_end; /* 64M */
+
+	console_ops.write = ps3_console_write;
+	platform_ops.secondary_release = smp_secondary_release;
+	platform_ops.exit = ps3_exit;
+
+	printf("\n-- PS3 bootwrapper --\n");
+
+	simple_alloc_init(_end, heapsize, 32, 64);
+	platform_ops.vmlinux_alloc = platform_ops.malloc;
+	platform_ops.fixups = ps3_fixups;
+	ft_init(_dtb_start, 0, 4);
+
+	return 0;
+}
+
+void ps3_no_support(void)
+{
+	printf("\n*** bootwrapper BUG: ps3_no_support() called!\n");
+	ps3_exit();
+}
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/reg.h linux-2.6.21.1-ps3/arch/powerpc/boot/reg.h
--- linux-2.6.21.1-org/arch/powerpc/boot/reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/reg.h	2007-05-21 13:50:27.420432168 +0200
@@ -0,0 +1,22 @@
+#ifndef _PPC_BOOT_REG_H
+#define _PPC_BOOT_REG_H
+/*
+ * Copyright 2007 Davud Gibson, IBM Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+static inline u32 mfpvr(void)
+{
+	u32 pvr;
+	asm volatile ("mfpvr	%0" : "=r"(pvr));
+	return pvr;
+}
+
+register void *__stack_pointer asm("r1");
+#define get_sp()	(__stack_pointer)
+
+#endif	/* _PPC_BOOT_REG_H */
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/serial.c linux-2.6.21.1-ps3/arch/powerpc/boot/serial.c
--- linux-2.6.21.1-org/arch/powerpc/boot/serial.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/serial.c	2007-05-21 13:50:27.439431156 +0200
@@ -27,7 +27,7 @@
 	return scdp->open();
 }
 
-static void serial_write(char *buf, int len)
+static void serial_write(const char *buf, int len)
 {
 	struct serial_console_data *scdp = console_ops.data;
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/smp.S linux-2.6.21.1-ps3/arch/powerpc/boot/smp.S
--- linux-2.6.21.1-org/arch/powerpc/boot/smp.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/smp.S	2007-05-21 13:50:27.455430305 +0200
@@ -0,0 +1,64 @@
+/*
+ *  zImage SMP support.
+ *
+ *  Copyright (C) 2007 Sony Computer Entertainment Inc.
+ *  Copyright 2007 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ppc_asm.h"
+
+	.data
+	.balign 4
+smp_secondary_entry:
+	.long 0
+
+	.text
+
+/**
+ * smp_secondary_hold - Hold any secondary cpus until kernel is ready to enter.
+ * !!!Need to make this do a kexec entry!!!
+ */
+
+	.balign 4
+	.globl smp_secondary_hold
+smp_secondary_hold:
+
+	lis	r9, smp_secondary_entry@ha
+	addi	r9, r9, smp_secondary_entry@l
+	lwz	r9, 0(r9)
+	cmpwi	r9, 0
+	beq	smp_secondary_hold
+	li	r3, 0
+	li	r4, 0
+	li	r5, 0
+	mtctr	r9
+	bctr
+
+/**
+ * smp_secondary_release - Release any secondary cpus.
+ * @kentry: The kernel entry for secondary cpus.
+ *
+ * Typically called by the primary cpu after the kernel is ready for entry.
+ */
+
+	.balign 4
+	.globl smp_secondary_release
+smp_secondary_release:
+	lis	r9, smp_secondary_entry@ha
+	addi	r9, r9, smp_secondary_entry@l
+	stw	r3, 0(r9)
+	sync
+	blr
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/stdio.c linux-2.6.21.1-ps3/arch/powerpc/boot/stdio.c
--- linux-2.6.21.1-org/arch/powerpc/boot/stdio.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/stdio.c	2007-05-21 13:50:27.494428228 +0200
@@ -190,7 +190,11 @@
 
 		/* get the conversion qualifier */
 		qualifier = -1;
-		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt =='Z') {
+		if (*fmt == 'l' && *(fmt + 1) =='l') {
+			qualifier = 'q';
+			fmt += 2;
+		} else if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L'
+			|| *fmt =='Z') {
 			qualifier = *fmt;
 			++fmt;
 		}
@@ -281,6 +285,10 @@
 			num = va_arg(args, unsigned long);
 			if (flags & SIGN)
 				num = (signed long) num;
+		} else if (qualifier == 'q') {
+			num = va_arg(args, unsigned long long);
+			if (flags & SIGN)
+				num = (signed long long) num;
 		} else if (qualifier == 'Z') {
 			num = va_arg(args, size_t);
 		} else if (qualifier == 'h') {
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/stdio.h linux-2.6.21.1-ps3/arch/powerpc/boot/stdio.h
--- linux-2.6.21.1-org/arch/powerpc/boot/stdio.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/stdio.h	2007-05-21 13:50:27.548425353 +0200
@@ -7,11 +7,12 @@
 #define	EINVAL		22	/* Invalid argument */
 #define ENOSPC		28	/* No space left on device */
 
-extern int printf(const char *fmt, ...);
+extern int printf(const char *fmt, ...) __attribute__((format(printf, 1, 2)));
 
 #define fprintf(fmt, args...)	printf(args)
 
-extern int sprintf(char *buf, const char *fmt, ...);
+extern int sprintf(char *buf, const char *fmt, ...)
+	__attribute__((format(printf, 2, 3)));
 
 extern int vsprintf(char *buf, const char *fmt, va_list args);
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/types.h linux-2.6.21.1-ps3/arch/powerpc/boot/types.h
--- linux-2.6.21.1-org/arch/powerpc/boot/types.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/types.h	2007-05-21 13:50:27.613421892 +0200
@@ -7,6 +7,10 @@
 typedef unsigned short		u16;
 typedef unsigned int		u32;
 typedef unsigned long long	u64;
+typedef signed char		s8;
+typedef short			s16;
+typedef int			s32;
+typedef long long		s64;
 
 #define min(x,y) ({ \
 	typeof(x) _x = (x);	\
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/wrapper linux-2.6.21.1-ps3/arch/powerpc/boot/wrapper
--- linux-2.6.21.1-org/arch/powerpc/boot/wrapper	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/wrapper	2007-05-21 13:50:27.627421147 +0200
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/sh -x
 
 # Copyright (C) 2006 Paul Mackerras, IBM Corporation <paulus@samba.org>
 # This program may be used under the terms of version 2 of the GNU
@@ -29,6 +29,7 @@
 dtb=
 dts=
 cacheit=
+gzip=.gz
 
 # cross-compilation prefix
 CROSS=
@@ -42,7 +43,7 @@
 usage() {
     echo 'Usage: wrapper [-o output] [-p platform] [-i initrd]' >&2
     echo '       [-d devtree] [-s tree.dts] [-c] [-C cross-prefix]' >&2
-    echo '       [-D datadir] [-W workingdir] [vmlinux]' >&2
+    echo '       [-D datadir] [-W workingdir] [--no-gzip] [vmlinux]' >&2
     exit 1
 }
 
@@ -91,6 +92,9 @@
 	[ "$#" -gt 0 ] || usage
 	tmpdir="$1"
 	;;
+    --no-gzip)
+        gzip=
+        ;;
     -?)
 	usage
 	;;
@@ -137,19 +141,29 @@
     ksection=image
     isection=initrd
     ;;
+ps3)
+    platformo="$object/ps3-head.o $object/smp.o $object/ps3-hvcall.o $object/ps3.o"
+    lds=$object/zImage.ps3.lds
+    ;;
 esac
 
 vmz="$tmpdir/`basename \"$kernel\"`.$ext"
-if [ -z "$cacheit" -o ! -f "$vmz.gz" -o "$vmz.gz" -ot "$kernel" ]; then
+if [ -z "$cacheit" -o ! -f "$vmz$gzip" -o "$vmz$gzip" -ot "$kernel" ]; then
     ${CROSS}objcopy $objflags "$kernel" "$vmz.$$"
-    gzip -f -9 "$vmz.$$"
+
+    if [ -n "$gzip" ]; then
+        gzip -f -9 "$vmz.$$"
+    fi
+
     if [ -n "$cacheit" ]; then
-	mv -f "$vmz.$$.gz" "$vmz.gz"
+	mv -f "$vmz.$$$gzip" "$vmz$gzip"
     else
 	vmz="$vmz.$$"
     fi
 fi
 
+vmz="$vmz$gzip"
+
 case "$platform" in
 uboot)
     rm -f "$ofile"
@@ -159,9 +173,9 @@
 	version="-n Linux-$version"
     fi
     mkimage -A ppc -O linux -T kernel -C gzip -a 00000000 -e 00000000 \
-	$version -d "$vmz.gz" "$ofile"
+	$version -d "$vmz" "$ofile"
     if [ -z "$cacheit" ]; then
-	rm -f $vmz.gz
+	rm -f "$vmz"
     fi
     exit 0
     ;;
@@ -173,9 +187,9 @@
 	--set-section-flags=$3=contents,alloc,load,readonly,data
 }
 
-addsec $tmp "$vmz.gz" $ksection $object/empty.o
+addsec $tmp "$vmz" $ksection $object/empty.o
 if [ -z "$cacheit" ]; then
-    rm -f "$vmz.gz"
+    rm -f "$vmz"
 fi
 
 if [ -n "$initrd" ]; then
@@ -191,7 +205,8 @@
 
 if [ "$platform" != "miboot" ]; then
     ${CROSS}ld -m elf32ppc -T $lds -o "$ofile" \
-	$object/crt0.o $platformo $tmp $object/wrapper.a
+	-Map "$ofile.map" \
+	$platformo $tmp $object/wrapper.a
     rm $tmp
 fi
 
@@ -201,7 +216,14 @@
     $object/addnote "$ofile"
     ;;
 pmaccoff)
-    ${CROSS}objcopy -O aixcoff-rs6000 --set-start 0x500000 "$ofile"
+    entry=`objdump -f "$ofile" | grep '^start address ' | \
+	cut -d' ' -f3`
+    ${CROSS}objcopy -O aixcoff-rs6000 --set-start "$entry" "$ofile"
     $object/hack-coff "$ofile"
     ;;
+ps3)
+    # The ps3's loader supports gziped binary images.
+    ${CROSS}objcopy -O binary "$ofile" "$ofile.rom"
+    gzip -f -9 -c "$ofile.rom" > "otheros.bld"
+    ;;
 esac
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/zImage.coff.lds.S linux-2.6.21.1-ps3/arch/powerpc/boot/zImage.coff.lds.S
--- linux-2.6.21.1-org/arch/powerpc/boot/zImage.coff.lds.S	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/zImage.coff.lds.S	2007-05-21 13:50:27.664419177 +0200
@@ -1,5 +1,6 @@
 OUTPUT_ARCH(powerpc:common)
-ENTRY(_start)
+ENTRY(_zimage_start_opd)
+EXTERN(_zimage_start_opd)
 SECTIONS
 {
   . = (5*1024*1024);
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/zImage.lds.S linux-2.6.21.1-ps3/arch/powerpc/boot/zImage.lds.S
--- linux-2.6.21.1-org/arch/powerpc/boot/zImage.lds.S	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/zImage.lds.S	2007-05-21 13:50:27.680418325 +0200
@@ -1,7 +1,10 @@
 OUTPUT_ARCH(powerpc:common)
 ENTRY(_zimage_start)
+EXTERN(_zimage_start)
 SECTIONS
 {
+  .vectors 0 : { *(.vectors) }
+
   . = (4*1024*1024);
   _start = .;
   .text      :
diff -Naur linux-2.6.21.1-org/arch/powerpc/boot/zImage.ps3.lds.S linux-2.6.21.1-ps3/arch/powerpc/boot/zImage.ps3.lds.S
--- linux-2.6.21.1-org/arch/powerpc/boot/zImage.ps3.lds.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/boot/zImage.ps3.lds.S	2007-05-21 13:50:27.721416142 +0200
@@ -0,0 +1,55 @@
+OUTPUT_ARCH(powerpc:common)
+ENTRY(_zimage_start)
+EXTERN(_zimage_start)
+SECTIONS
+{
+  .vectors 0 : { *(.vectors) }
+
+  . = (8M);
+
+  _start = .;
+  .text      :
+  {
+    *(.text)
+    *(.fixup)
+  }
+  _etext = .;
+  . = ALIGN(4096);
+  .data    :
+  {
+    *(.rodata*)
+    *(.data*)
+    *(.sdata*)
+    __got2_start = .;
+    *(.got2)
+    __got2_end = .;
+  }
+
+  . = ALIGN(8);
+  _dtb_start = .;
+  .kernel:dtb : { *(.kernel:dtb) }
+  _dtb_end = .;
+
+  . = ALIGN(4096);
+  _vmlinux_start =  .;
+  .kernel:vmlinux.strip : { *(.kernel:vmlinux.strip) }
+  _vmlinux_end =  .;
+
+  . = ALIGN(4096);
+  _initrd_start =  .;
+  .kernel:initrd : { *(.kernel:initrd) }
+  _initrd_end =  .;
+
+  . = ALIGN(4096);
+  _edata  =  .;
+
+  . = ALIGN(4096);
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss)
+   *(.bss)
+  }
+  . = ALIGN(4096);
+  _end = . ;
+}
diff -Naur linux-2.6.21.1-org/arch/powerpc/configs/ps3_defconfig linux-2.6.21.1-ps3/arch/powerpc/configs/ps3_defconfig
--- linux-2.6.21.1-org/arch/powerpc/configs/ps3_defconfig	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/configs/ps3_defconfig	2007-05-21 13:50:27.767413692 +0200
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.20-rc6
-# Thu Jan 25 13:35:34 2007
+# Linux kernel version: 2.6.21-rc7
+# Sat Apr 21 11:22:07 2007
 #
 CONFIG_PPC64=y
 CONFIG_64BIT=y
@@ -60,6 +60,7 @@
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_TASKSTATS is not set
@@ -69,6 +70,7 @@
 # CONFIG_CPUSETS is not set
 CONFIG_SYSFS_DEPRECATED=y
 # CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
@@ -131,6 +133,7 @@
 # CONFIG_PPC_PSERIES is not set
 # CONFIG_PPC_ISERIES is not set
 # CONFIG_PPC_MPC52xx is not set
+# CONFIG_PPC_MPC5200 is not set
 # CONFIG_PPC_PMAC is not set
 # CONFIG_PPC_MAPLE is not set
 # CONFIG_PPC_PASEMI is not set
@@ -138,6 +141,7 @@
 # CONFIG_PPC_CELL_NATIVE is not set
 # CONFIG_PPC_IBM_CELL_BLADE is not set
 CONFIG_PPC_PS3=y
+# CONFIG_PPC_CELLEB is not set
 # CONFIG_U3_DART is not set
 # CONFIG_PPC_RTAS is not set
 # CONFIG_MMIO_NVRAM is not set
@@ -154,16 +158,17 @@
 #
 CONFIG_SPU_FS=y
 CONFIG_SPU_BASE=y
-# CONFIG_CBE_RAS is not set
 
 #
 # PS3 Platform Options
 #
+# CONFIG_PS3_ADVANCED is not set
 CONFIG_PS3_HTAB_SIZE=20
 # CONFIG_PS3_DYNAMIC_DMA is not set
 CONFIG_PS3_USE_LPAR_ADDR=y
 CONFIG_PS3_VUART=y
 CONFIG_PS3_PS3AV=y
+CONFIG_PS3_SYS_MANAGER=y
 
 #
 # Kernel options
@@ -179,10 +184,10 @@
 # CONFIG_PREEMPT_BKL is not set
 CONFIG_BINFMT_ELF=y
 CONFIG_BINFMT_MISC=y
-CONFIG_FORCE_MAX_ZONEORDER=9
+CONFIG_FORCE_MAX_ZONEORDER=13
 # CONFIG_IOMMU_VMERGE is not set
 CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
-# CONFIG_KEXEC is not set
+CONFIG_KEXEC=y
 # CONFIG_CRASH_DUMP is not set
 # CONFIG_IRQ_ALL_CPUS is not set
 # CONFIG_NUMA is not set
@@ -203,8 +208,9 @@
 CONFIG_MEMORY_HOTPLUG_SPARSE=y
 CONFIG_SPLIT_PTLOCK_CPUS=4
 CONFIG_RESOURCES_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
 CONFIG_ARCH_MEMORY_PROBE=y
-CONFIG_PPC_64K_PAGES=y
+# CONFIG_PPC_64K_PAGES is not set
 # CONFIG_SCHED_SMT is not set
 CONFIG_PROC_DEVICETREE=y
 CONFIG_CMDLINE_BOOL=y
@@ -216,6 +222,7 @@
 #
 # Bus options
 #
+CONFIG_ZONE_DMA=y
 CONFIG_GENERIC_ISA_DMA=y
 # CONFIG_MPIC_WEIRD is not set
 # CONFIG_PPC_I8259 is not set
@@ -244,6 +251,10 @@
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
 CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
 # CONFIG_IP_MULTICAST is not set
@@ -261,7 +272,7 @@
 # CONFIG_INET_ESP is not set
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
 # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
 # CONFIG_INET_XFRM_MODE_TUNNEL is not set
 # CONFIG_INET_XFRM_MODE_BEET is not set
@@ -270,9 +281,22 @@
 CONFIG_TCP_CONG_CUBIC=y
 CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
 # CONFIG_INET6_XFRM_TUNNEL is not set
 # CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
 # CONFIG_NETWORK_SECMARK is not set
 # CONFIG_NETFILTER is not set
 
@@ -313,8 +337,26 @@
 # CONFIG_NET_PKTGEN is not set
 # CONFIG_HAMRADIO is not set
 # CONFIG_IRDA is not set
-# CONFIG_BT is not set
+CONFIG_BT=m
+CONFIG_BT_L2CAP=m
+CONFIG_BT_SCO=m
+CONFIG_BT_RFCOMM=m
+# CONFIG_BT_RFCOMM_TTY is not set
+# CONFIG_BT_BNEP is not set
+CONFIG_BT_HIDP=m
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIUSB=m
+CONFIG_BT_HCIUSB_SCO=y
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
 # CONFIG_IEEE80211 is not set
+CONFIG_WIRELESS_EXT=y
 
 #
 # Device Drivers
@@ -327,6 +369,7 @@
 CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_FW_LOADER is not set
 # CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
 
 #
@@ -347,24 +390,30 @@
 #
 # Plug and Play support
 #
+# CONFIG_PNPACPI is not set
 
 #
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_UB is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65535
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
+CONFIG_PS3_STORAGE=y
+CONFIG_PS3_STORAGE_EXPECTED_NUM_DRIVES=3
+CONFIG_PS3_STORAGE_MAX_SPINUP_WAIT_TIME=10
 
 #
 # Misc devices
 #
-# CONFIG_TIFM_CORE is not set
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -388,7 +437,7 @@
 # CONFIG_CHR_DEV_OSST is not set
 CONFIG_BLK_DEV_SR=y
 # CONFIG_BLK_DEV_SR_VENDOR is not set
-# CONFIG_CHR_DEV_SG is not set
+CONFIG_CHR_DEV_SG=m
 # CONFIG_CHR_DEV_SCH is not set
 
 #
@@ -460,11 +509,12 @@
 # Ethernet (10 or 100Mbit)
 #
 # CONFIG_NET_ETHERNET is not set
-CONFIG_MII=y
+CONFIG_MII=m
 
 #
 # Ethernet (1000 Mbit)
 #
+CONFIG_GELIC_NET=y
 
 #
 # Ethernet (10000 Mbit)
@@ -477,7 +527,15 @@
 #
 # Wireless LAN (non-hamradio)
 #
-# CONFIG_NET_RADIO is not set
+CONFIG_NET_RADIO=y
+# CONFIG_NET_WIRELESS_RTNETLINK is not set
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
 
 #
 # Wan interfaces
@@ -551,7 +609,8 @@
 # Non-8250 serial port support
 #
 CONFIG_UNIX98_PTYS=y
-# CONFIG_LEGACY_PTYS is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
 
 #
 # IPMI
@@ -598,6 +657,11 @@
 # CONFIG_HWMON_VID is not set
 
 #
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -611,15 +675,22 @@
 #
 # Graphics support
 #
-# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
 CONFIG_FB_CFB_FILLRECT=y
 CONFIG_FB_CFB_COPYAREA=y
 CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
 # CONFIG_FB_BACKLIGHT is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frambuffer hardware drivers
+#
 # CONFIG_FB_OF is not set
 # CONFIG_FB_VGA16 is not set
 # CONFIG_FB_S1D13XXX is not set
@@ -634,7 +705,7 @@
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
-# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
 # CONFIG_FONTS is not set
 CONFIG_FONT_8x8=y
 CONFIG_FONT_8x16=y
@@ -646,17 +717,70 @@
 # CONFIG_LOGO_LINUX_MONO is not set
 # CONFIG_LOGO_LINUX_VGA16 is not set
 CONFIG_LOGO_LINUX_CLUT224=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
 #
-# CONFIG_SOUND is not set
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA PowerMac devices
+#
+
+#
+# ALSA PowerMac requires I2C
+#
+
+#
+# ALSA PowerPC devices
+#
+CONFIG_SND_PS3=y
+CONFIG_SND_PS3_DEFAULT_START_DELAY=2000
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_USX2Y is not set
+
+#
+# SoC audio support
+#
+# CONFIG_SND_SOC is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
 
 #
 # HID Devices
 #
 CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
 
 #
 # USB support
@@ -665,13 +789,12 @@
 CONFIG_USB_ARCH_HAS_OHCI=y
 CONFIG_USB_ARCH_HAS_EHCI=y
 CONFIG_USB=y
-CONFIG_USB_DEBUG=y
+# CONFIG_USB_DEBUG is not set
 
 #
 # Miscellaneous USB options
 #
-# CONFIG_USB_DEVICEFS is not set
-# CONFIG_USB_BANDWIDTH is not set
+CONFIG_USB_DEVICEFS=y
 # CONFIG_USB_DYNAMIC_MINORS is not set
 # CONFIG_USB_OTG is not set
 
@@ -704,7 +827,7 @@
 #
 # may also be needed; see USB_STORAGE Help for more information
 #
-CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE=m
 # CONFIG_USB_STORAGE_DEBUG is not set
 # CONFIG_USB_STORAGE_DATAFAB is not set
 # CONFIG_USB_STORAGE_FREECOM is not set
@@ -720,10 +843,16 @@
 #
 # USB Input Devices
 #
-CONFIG_USB_HID=y
+CONFIG_USB_HID=m
 # CONFIG_USB_HIDINPUT_POWERBOOK is not set
 # CONFIG_HID_FF is not set
 # CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
 # CONFIG_USB_AIPTEK is not set
 # CONFIG_USB_WACOM is not set
 # CONFIG_USB_ACECAD is not set
@@ -736,6 +865,7 @@
 # CONFIG_USB_ATI_REMOTE2 is not set
 # CONFIG_USB_KEYSPAN_REMOTE is not set
 # CONFIG_USB_APPLETOUCH is not set
+# CONFIG_USB_GTCO is not set
 
 #
 # USB Imaging devices
@@ -748,15 +878,16 @@
 #
 # CONFIG_USB_CATC is not set
 # CONFIG_USB_KAWETH is not set
-# CONFIG_USB_PEGASUS is not set
+CONFIG_USB_PEGASUS=m
 # CONFIG_USB_RTL8150 is not set
-CONFIG_USB_USBNET_MII=y
-CONFIG_USB_USBNET=y
-CONFIG_USB_NET_CDCETHER=y
+CONFIG_USB_USBNET_MII=m
+CONFIG_USB_USBNET=m
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_DM9601 is not set
 # CONFIG_USB_NET_GL620A is not set
 # CONFIG_USB_NET_NET1080 is not set
 # CONFIG_USB_NET_PLUSB is not set
-CONFIG_USB_NET_MCS7830=y
+CONFIG_USB_NET_MCS7830=m
 # CONFIG_USB_NET_RNDIS_HOST is not set
 # CONFIG_USB_NET_CDC_SUBSET is not set
 # CONFIG_USB_NET_ZAURUS is not set
@@ -781,6 +912,7 @@
 # CONFIG_USB_RIO500 is not set
 # CONFIG_USB_LEGOTOWER is not set
 # CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
 # CONFIG_USB_LED is not set
 # CONFIG_USB_CYPRESS_CY7C63 is not set
 # CONFIG_USB_CYTHERM is not set
@@ -791,6 +923,8 @@
 # CONFIG_USB_SISUSBVGA is not set
 # CONFIG_USB_LD is not set
 # CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
 
 #
 # USB DSL modem support
@@ -846,13 +980,19 @@
 #
 
 #
+# Auxiliary Display support
+#
+
+#
 # Virtualization
 #
 
 #
 # File systems
 #
-# CONFIG_EXT2_FS is not set
+CONFIG_EXT2_FS=m
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 # CONFIG_EXT3_FS_POSIX_ACL is not set
@@ -871,27 +1011,30 @@
 # CONFIG_ROMFS_FS is not set
 CONFIG_INOTIFY=y
 CONFIG_INOTIFY_USER=y
-# CONFIG_QUOTA is not set
+CONFIG_QUOTA=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
+CONFIG_AUTOFS4_FS=y
 # CONFIG_FUSE_FS is not set
 
 #
 # CD-ROM/DVD Filesystems
 #
-CONFIG_ISO9660_FS=y
+CONFIG_ISO9660_FS=m
 CONFIG_JOLIET=y
 # CONFIG_ZISOFS is not set
-CONFIG_UDF_FS=y
+CONFIG_UDF_FS=m
 CONFIG_UDF_NLS=y
 
 #
 # DOS/FAT/NT Filesystems
 #
-CONFIG_FAT_FS=y
+CONFIG_FAT_FS=m
 # CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
+CONFIG_VFAT_FS=m
 CONFIG_FAT_DEFAULT_CODEPAGE=437
 CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 # CONFIG_NTFS_FS is not set
@@ -933,7 +1076,7 @@
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_V3_ACL is not set
-# CONFIG_NFS_V4 is not set
+CONFIG_NFS_V4=y
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
@@ -941,10 +1084,16 @@
 CONFIG_LOCKD_V4=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
-# CONFIG_RPCSEC_GSS_KRB5 is not set
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
@@ -1014,7 +1163,8 @@
 CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_PLIST=y
-CONFIG_IOMAP_COPY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
 
 #
 # Instrumentation Support
@@ -1032,16 +1182,16 @@
 # CONFIG_DEBUG_FS is not set
 # CONFIG_HEADERS_CHECK is not set
 CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
 CONFIG_LOG_BUF_SHIFT=17
 CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
-CONFIG_DEBUG_SLAB=y
-# CONFIG_DEBUG_SLAB_LEAK is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_SLAB is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_RT_MUTEX_TESTER is not set
 CONFIG_DEBUG_SPINLOCK=y
 CONFIG_DEBUG_MUTEXES=y
-CONFIG_DEBUG_RWSEMS=y
 CONFIG_DEBUG_SPINLOCK_SLEEP=y
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
@@ -1051,6 +1201,7 @@
 CONFIG_DEBUG_LIST=y
 CONFIG_FORCED_INLINING=y
 # CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
 CONFIG_DEBUG_STACKOVERFLOW=y
 # CONFIG_DEBUG_STACK_USAGE is not set
 # CONFIG_DEBUGGER is not set
@@ -1063,6 +1214,8 @@
 # CONFIG_PPC_EARLY_DEBUG_RTAS_CONSOLE is not set
 # CONFIG_PPC_EARLY_DEBUG_MAPLE is not set
 # CONFIG_PPC_EARLY_DEBUG_ISERIES is not set
+# CONFIG_PPC_EARLY_DEBUG_PAS_REALMODE is not set
+# CONFIG_PPC_EARLY_DEBUG_BEAT is not set
 
 #
 # Security options
@@ -1073,4 +1226,43 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_ECB=m
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
diff -Naur linux-2.6.21.1-org/arch/powerpc/kernel/head_64.S linux-2.6.21.1-ps3/arch/powerpc/kernel/head_64.S
--- linux-2.6.21.1-org/arch/powerpc/kernel/head_64.S	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/kernel/head_64.S	2007-05-21 13:50:27.810411403 +0200
@@ -103,8 +103,8 @@
 
 	. = 0x60
 /*
- * The following code is used on pSeries to hold secondary processors
- * in a spin loop after they have been freed from OpenFirmware, but
+ * The following code is used to hold secondary processors
+ * in a spin loop after they have entered the kernel, but
  * before the bulk of the kernel has been relocated.  This code
  * is relocated to physical address 0x60 before prom_init is run.
  * All of it must fit below the first exception vector at 0x100.
@@ -1555,7 +1555,6 @@
 	
 	/* turn on 64-bit mode */
 	bl	.enable_64b_mode
-	isync
 
 	/* Set up a paca value for this processor. Since we have the
 	 * physical cpu id in r24, we need to search the pacas to find
@@ -1690,9 +1689,32 @@
 2:
 
 	/* Switch off MMU if not already */
-	LOAD_REG_IMMEDIATE(r4, .__after_prom_start - KERNELBASE)
+	LOAD_REG_IMMEDIATE(r4, __mmu_off_return - KERNELBASE)
 	add	r4,r4,r30
 	bl	.__mmu_off
+__mmu_off_return:
+
+	/* Test if this is a secondary cpu and if so send it off to
+	 * __secondary_hold with a thread number in r3.  Secondary processors
+	 * call _start with regs r3,r4,r5 zeroed.
+	 * Pass cpu number in r6???
+	 */
+	or.	r3, r31, r30
+	bne	1f
+	li	r3, 1
+	b	.__secondary_hold
+1:
+
+	/* The primary cpu waits here for all the expected secondary cpus to
+	 * enter the kernel, after which time it is safe to reclaim the
+	 * memory use by the bootwrapper.
+	 * How to know what to wait for???
+	 * !!! need to use the kexec entry mechanism here!!!!
+	*/
+1:	LOAD_REG_IMMEDIATE(r4, __secondary_hold_acknowledge)
+	cmpwi	r4, 0
+	beq	1b
+	mr	r3, r30
 	b	.__after_prom_start
 
 _STATIC(__boot_from_prom)
@@ -1851,7 +1873,6 @@
 _GLOBAL(pmac_secondary_start)
 	/* turn on 64-bit mode */
 	bl	.enable_64b_mode
-	isync
 
 	/* Copy some CPU settings from CPU 0 */
 	bl	.__restore_cpu_ppc970
diff -Naur linux-2.6.21.1-org/arch/powerpc/kernel/irq.c linux-2.6.21.1-ps3/arch/powerpc/kernel/irq.c
--- linux-2.6.21.1-org/arch/powerpc/kernel/irq.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/kernel/irq.c	2007-05-21 13:50:27.851409220 +0200
@@ -67,6 +67,7 @@
 #ifdef CONFIG_PPC64
 #include <asm/paca.h>
 #include <asm/firmware.h>
+#include <asm/lv1call.h>
 #endif
 
 int __irq_offset_value;
@@ -162,6 +163,16 @@
 	local_paca->hard_enabled = en;
 	if ((int)mfspr(SPRN_DEC) < 0)
 		mtspr(SPRN_DEC, 1);
+
+	/*
+	 * Force the delivery of pending soft-disabled interrupts on PS3.
+	 * Any HV call will have this side effect.
+	 */
+	if (firmware_has_feature(FW_FEATURE_PS3_LV1)) {
+		u64 tmp;
+		lv1_get_version_info(&tmp);
+	}
+
 	hard_irq_enable();
 }
 #endif /* CONFIG_PPC64 */
diff -Naur linux-2.6.21.1-org/arch/powerpc/kernel/prom.c linux-2.6.21.1-ps3/arch/powerpc/kernel/prom.c
--- linux-2.6.21.1-org/arch/powerpc/kernel/prom.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/kernel/prom.c	2007-05-21 13:50:27.869408262 +0200
@@ -719,6 +719,7 @@
 					    const char *uname, int depth, void *data)
 {
 	unsigned long *lprop;
+	u32 *prop;
 	unsigned long l;
 	char *p;
 
@@ -760,6 +761,22 @@
                crashk_res.end = crashk_res.start + *lprop - 1;
 #endif
 
+#ifdef CONFIG_BLK_DEV_INITRD
+	DBG("Looking for initrd properties... ");
+	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &l);
+	if (prop) {
+		initrd_start = (unsigned long)__va(of_read_ulong(prop, l/4));
+		prop = of_get_flat_dt_prop(node, "linux,initrd-end", &l);
+		if (prop) {
+			initrd_end = (unsigned long)__va(of_read_ulong(prop, l/4));
+			initrd_below_start_ok = 1;
+		} else {
+			initrd_start = 0;
+		}
+	}
+	DBG("initrd_start=0x%lx  initrd_end=0x%lx\n", initrd_start, initrd_end);
+#endif /* CONFIG_BLK_DEV_INITRD */
+
 	/* Retreive command line */
  	p = of_get_flat_dt_prop(node, "bootargs", &l);
 	if (p != NULL && l > 0)
@@ -906,6 +923,12 @@
 				size = 0x80000000ul - base;
 		}
 #endif
+#if defined(CONFIG_PPC_PS3)
+	/* temporary hack for the legacy bootloader */
+	if (of_flat_dt_is_compatible(of_get_flat_dt_root(), "PS3PF")) {
+		size = 0x8000000;
+	}
+#endif
 		lmb_add(base, size);
 	}
 	return 0;
@@ -926,6 +949,12 @@
 	self_size = initial_boot_params->totalsize;
 	lmb_reserve(self_base, self_size);
 
+#ifdef CONFIG_BLK_DEV_INITRD
+	/* then reserve the initrd, if any */
+	if (initrd_start && (initrd_end > initrd_start))
+		lmb_reserve(__pa(initrd_start), initrd_end - initrd_start);
+#endif /* CONFIG_BLK_DEV_INITRD */
+
 #ifdef CONFIG_PPC32
 	/* 
 	 * Handle the case where we might be booting from an old kexec
@@ -954,9 +983,6 @@
 		size = *(reserve_map++);
 		if (size == 0)
 			break;
-		/* skip if the reservation is for the blob */
-		if (base == self_base && size == self_size)
-			continue;
 		DBG("reserving: %llx -> %llx\n", base, size);
 		lmb_reserve(base, size);
 	}
@@ -969,7 +995,7 @@
 
 void __init early_init_devtree(void *params)
 {
-	DBG(" -> early_init_devtree()\n");
+	DBG(" -> early_init_devtree(%p)\n", params);
 
 	/* Setup flat device-tree pointer */
 	initial_boot_params = params;
diff -Naur linux-2.6.21.1-org/arch/powerpc/kernel/prom_init.c linux-2.6.21.1-ps3/arch/powerpc/kernel/prom_init.c
--- linux-2.6.21.1-org/arch/powerpc/kernel/prom_init.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/kernel/prom_init.c	2007-05-21 13:50:27.933404854 +0200
@@ -44,10 +44,7 @@
 #include <asm/sections.h>
 #include <asm/machdep.h>
 
-#ifdef CONFIG_LOGO_LINUX_CLUT224
 #include <linux/linux_logo.h>
-extern const struct linux_logo logo_linux_clut224;
-#endif
 
 /*
  * Properties whose value is longer than this get excluded from our
diff -Naur linux-2.6.21.1-org/arch/powerpc/kernel/setup-common.c linux-2.6.21.1-ps3/arch/powerpc/kernel/setup-common.c
--- linux-2.6.21.1-org/arch/powerpc/kernel/setup-common.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/kernel/setup-common.c	2007-05-21 13:50:27.952403842 +0200
@@ -304,26 +304,8 @@
 void __init check_for_initrd(void)
 {
 #ifdef CONFIG_BLK_DEV_INITRD
-	const unsigned int *prop;
-	int len;
-
-	DBG(" -> check_for_initrd()\n");
-
-	if (of_chosen) {
-		prop = get_property(of_chosen, "linux,initrd-start", &len);
-		if (prop != NULL) {
-			initrd_start = (unsigned long)
-				__va(of_read_ulong(prop, len / 4));
-			prop = get_property(of_chosen,
-					"linux,initrd-end", &len);
-			if (prop != NULL) {
-				initrd_end = (unsigned long)
-					__va(of_read_ulong(prop, len / 4));
-				initrd_below_start_ok = 1;
-			} else
-				initrd_start = 0;
-		}
-	}
+	DBG(" -> check_for_initrd()  initrd_start=0x%lx  initrd_end=0x%lx\n",
+	    initrd_start, initrd_end);
 
 	/* If we were passed an initrd, set the ROOT_DEV properly if the values
 	 * look sensible. If not, clear initrd reference.
diff -Naur linux-2.6.21.1-org/arch/powerpc/mm/lmb.c linux-2.6.21.1-ps3/arch/powerpc/mm/lmb.c
--- linux-2.6.21.1-org/arch/powerpc/mm/lmb.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/mm/lmb.c	2007-05-21 13:50:28.017400382 +0200
@@ -146,6 +146,10 @@
 		unsigned long rgnbase = rgn->region[i].base;
 		unsigned long rgnsize = rgn->region[i].size;
 
+		if ((rgnbase == base) && (rgnsize == size))
+			/* Already have this region, so we're done */
+			return 0;
+
 		adjacent = lmb_addrs_adjacent(base,size,rgnbase,rgnsize);
 		if ( adjacent > 0 ) {
 			rgn->region[i].base -= size;
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/cell/Kconfig linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/Kconfig
--- linux-2.6.21.1-org/arch/powerpc/platforms/cell/Kconfig	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/Kconfig	2007-05-21 13:50:28.038399263 +0200
@@ -18,6 +18,7 @@
 
 config CBE_RAS
 	bool "RAS features for bare metal Cell BE"
+	depends on PPC_CELL_NATIVE
 	default y
 
 config CBE_THERM
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/cell/spu_base.c linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spu_base.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/cell/spu_base.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spu_base.c	2007-05-21 13:50:28.076397240 +0200
@@ -31,6 +31,7 @@
 #include <linux/mm.h>
 #include <linux/io.h>
 #include <linux/mutex.h>
+#include <linux/linux_logo.h>
 #include <asm/spu.h>
 #include <asm/spu_priv1.h>
 #include <asm/xmon.h>
@@ -44,6 +45,7 @@
 static spinlock_t spu_list_lock = SPIN_LOCK_UNLOCKED;
 
 EXPORT_SYMBOL_GPL(spu_priv1_ops);
+EXPORT_SYMBOL_GPL(spu_management_ops);
 
 void spu_invalidate_slbs(struct spu *spu)
 {
@@ -216,27 +218,34 @@
 spu_irq_class_0(int irq, void *data)
 {
 	struct spu *spu;
+	unsigned long stat, mask;
 
 	spu = data;
-	spu->class_0_pending = 1;
+
+	mask = spu_int_mask_get(spu, 0);
+	stat = spu_int_stat_get(spu, 0);
+	stat &= mask;
+
+	spin_lock(&spu->register_lock);
+	spu->class_0_pending |= stat;
+	spin_unlock(&spu->register_lock);
+
 	spu->stop_callback(spu);
 
+	spu_int_stat_clear(spu, 0, stat);
+
 	return IRQ_HANDLED;
 }
 
 int
 spu_irq_class_0_bottom(struct spu *spu)
 {
-	unsigned long stat, mask;
 	unsigned long flags;
-
-	spu->class_0_pending = 0;
+	unsigned long stat;
 
 	spin_lock_irqsave(&spu->register_lock, flags);
-	mask = spu_int_mask_get(spu, 0);
-	stat = spu_int_stat_get(spu, 0);
-
-	stat &= mask;
+	stat = spu->class_0_pending;
+	spu->class_0_pending = 0;
 
 	if (stat & 1) /* invalid DMA alignment */
 		__spu_trap_dma_align(spu);
@@ -736,16 +745,18 @@
 
 	ret = spu_enumerate_spus(create_spu);
 
-	if (ret) {
+	if (ret < 0) {
 		printk(KERN_WARNING "%s: Error initializing spus\n",
 			__FUNCTION__);
 		cleanup_spu_base();
 		return ret;
 	}
+	if (ret > 0)
+		fb_append_extra_logo(&logo_spe_clut224, ret);
 
 	xmon_register_spus(&spu_full_list);
 
-	return ret;
+	return 0;
 }
 module_init(init_spu_base);
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/cell/spu_manage.c linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spu_manage.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/cell/spu_manage.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spu_manage.c	2007-05-21 13:50:28.117395057 +0200
@@ -35,6 +35,7 @@
 #include <asm/firmware.h>
 #include <asm/prom.h>
 
+#include "spufs/spufs.h"
 #include "interrupt.h"
 
 struct device_node *spu_devnode(struct spu *spu)
@@ -279,6 +280,7 @@
 {
 	int ret;
 	struct device_node *node;
+	unsigned int n = 0;
 
 	ret = -ENODEV;
 	for (node = of_find_node_by_type(NULL, "spe");
@@ -289,8 +291,9 @@
 				__FUNCTION__, node->name);
 			break;
 		}
+		n++;
 	}
-	return ret;
+	return ret ? ret : n;
 }
 
 static int __init of_create_spu(struct spu *spu, void *data)
@@ -359,8 +362,22 @@
 	return 0;
 }
 
+static int enable_spu_by_master_run(struct spu_context *ctx)
+{
+	ctx->ops->master_start(ctx);
+	return 0;
+}
+
+static int disable_spu_by_master_run(struct spu_context *ctx)
+{
+	ctx->ops->master_stop(ctx);
+	return 0;
+}
+
 const struct spu_management_ops spu_management_of_ops = {
 	.enumerate_spus = of_enumerate_spus,
 	.create_spu = of_create_spu,
 	.destroy_spu = of_destroy_spu,
+	.enable_spu = enable_spu_by_master_run,
+	.disable_spu = disable_spu_by_master_run,
 };
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/backing_ops.c linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/backing_ops.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/backing_ops.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/backing_ops.c	2007-05-21 13:50:28.134394152 +0200
@@ -285,6 +285,11 @@
 	spin_unlock(&ctx->csa.register_lock);
 }
 
+static void spu_backing_runcntl_stop(struct spu_context *ctx)
+{
+	spu_backing_runcntl_write(ctx, SPU_RUNCNTL_STOP);
+}
+
 static void spu_backing_master_start(struct spu_context *ctx)
 {
 	struct spu_state *csa = &ctx->csa;
@@ -370,6 +375,7 @@
 	.get_ls = spu_backing_get_ls,
 	.runcntl_read = spu_backing_runcntl_read,
 	.runcntl_write = spu_backing_runcntl_write,
+	.runcntl_stop = spu_backing_runcntl_stop,
 	.master_start = spu_backing_master_start,
 	.master_stop = spu_backing_master_stop,
 	.set_mfc_query = spu_backing_set_mfc_query,
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/context.c linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/context.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/context.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/context.c	2007-05-21 13:50:28.167392395 +0200
@@ -41,6 +41,7 @@
 		goto out_free;
 	}
 	spin_lock_init(&ctx->mmio_lock);
+	spin_lock_init(&ctx->mapping_lock);
 	kref_init(&ctx->kref);
 	mutex_init(&ctx->state_mutex);
 	init_MUTEX(&ctx->run_sema);
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/file.c linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/file.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/file.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/file.c	2007-05-21 13:50:28.185391437 +0200
@@ -44,8 +44,26 @@
 {
 	struct spufs_inode_info *i = SPUFS_I(inode);
 	struct spu_context *ctx = i->i_ctx;
+
+	spin_lock(&ctx->mapping_lock);
 	file->private_data = ctx;
-	ctx->local_store = inode->i_mapping;
+	if (!i->i_openers++)
+		ctx->local_store = inode->i_mapping;
+	spin_unlock(&ctx->mapping_lock);
+	smp_wmb();
+	return 0;
+}
+
+static int
+spufs_mem_release(struct inode *inode, struct file *file)
+{
+	struct spufs_inode_info *i = SPUFS_I(inode);
+	struct spu_context *ctx = i->i_ctx;
+
+	spin_lock(&ctx->mapping_lock);
+	if (!--i->i_openers)
+		ctx->local_store = NULL;
+	spin_unlock(&ctx->mapping_lock);
 	smp_wmb();
 	return 0;
 }
@@ -149,6 +167,7 @@
 
 static const struct file_operations spufs_mem_fops = {
 	.open	 = spufs_mem_open,
+	.release = spufs_mem_release,
 	.read    = spufs_mem_read,
 	.write   = spufs_mem_write,
 	.llseek  = generic_file_llseek,
@@ -238,16 +257,35 @@
 	struct spufs_inode_info *i = SPUFS_I(inode);
 	struct spu_context *ctx = i->i_ctx;
 
+	spin_lock(&ctx->mapping_lock);
 	file->private_data = ctx;
-	ctx->cntl = inode->i_mapping;
+	if (!i->i_openers++)
+		ctx->cntl = inode->i_mapping;
+	spin_unlock(&ctx->mapping_lock);
 	smp_wmb();
 	return simple_attr_open(inode, file, spufs_cntl_get,
 					spufs_cntl_set, "0x%08lx");
 }
 
+static int
+spufs_cntl_release(struct inode *inode, struct file *file)
+{
+	struct spufs_inode_info *i = SPUFS_I(inode);
+	struct spu_context *ctx = i->i_ctx;
+
+	simple_attr_close(inode, file);
+
+	spin_lock(&ctx->mapping_lock);
+	if (!--i->i_openers)
+		ctx->cntl = NULL;
+	spin_unlock(&ctx->mapping_lock);
+	smp_wmb();
+	return 0;
+}
+
 static const struct file_operations spufs_cntl_fops = {
 	.open = spufs_cntl_open,
-	.release = simple_attr_close,
+	.release = spufs_cntl_release,
 	.read = simple_attr_read,
 	.write = simple_attr_write,
 	.mmap = spufs_cntl_mmap,
@@ -723,12 +761,30 @@
 {
 	struct spufs_inode_info *i = SPUFS_I(inode);
 	struct spu_context *ctx = i->i_ctx;
+
+	spin_lock(&ctx->mapping_lock);
 	file->private_data = ctx;
-	ctx->signal1 = inode->i_mapping;
+	if (!i->i_openers++)
+		ctx->signal1 = inode->i_mapping;
+	spin_unlock(&ctx->mapping_lock);
 	smp_wmb();
 	return nonseekable_open(inode, file);
 }
 
+static int
+spufs_signal1_release(struct inode *inode, struct file *file)
+{
+	struct spufs_inode_info *i = SPUFS_I(inode);
+	struct spu_context *ctx = i->i_ctx;
+
+	spin_lock(&ctx->mapping_lock);
+	if (!--i->i_openers)
+		ctx->signal1 = NULL;
+	spin_unlock(&ctx->mapping_lock);
+	smp_wmb();
+	return 0;
+}
+
 static ssize_t __spufs_signal1_read(struct spu_context *ctx, char __user *buf,
 			size_t len, loff_t *pos)
 {
@@ -821,6 +877,7 @@
 
 static const struct file_operations spufs_signal1_fops = {
 	.open = spufs_signal1_open,
+	.release = spufs_signal1_release,
 	.read = spufs_signal1_read,
 	.write = spufs_signal1_write,
 	.mmap = spufs_signal1_mmap,
@@ -830,12 +887,30 @@
 {
 	struct spufs_inode_info *i = SPUFS_I(inode);
 	struct spu_context *ctx = i->i_ctx;
+
+	spin_lock(&ctx->mapping_lock);
 	file->private_data = ctx;
-	ctx->signal2 = inode->i_mapping;
+	if (!i->i_openers++)
+		ctx->signal2 = inode->i_mapping;
+	spin_unlock(&ctx->mapping_lock);
 	smp_wmb();
 	return nonseekable_open(inode, file);
 }
 
+static int
+spufs_signal2_release(struct inode *inode, struct file *file)
+{
+	struct spufs_inode_info *i = SPUFS_I(inode);
+	struct spu_context *ctx = i->i_ctx;
+
+	spin_lock(&ctx->mapping_lock);
+	if (!--i->i_openers)
+		ctx->signal2 = NULL;
+	spin_unlock(&ctx->mapping_lock);
+	smp_wmb();
+	return 0;
+}
+
 static ssize_t __spufs_signal2_read(struct spu_context *ctx, char __user *buf,
 			size_t len, loff_t *pos)
 {
@@ -932,6 +1007,7 @@
 
 static const struct file_operations spufs_signal2_fops = {
 	.open = spufs_signal2_open,
+	.release = spufs_signal2_release,
 	.read = spufs_signal2_read,
 	.write = spufs_signal2_write,
 	.mmap = spufs_signal2_mmap,
@@ -1031,13 +1107,32 @@
 	struct spu_context *ctx = i->i_ctx;
 
 	file->private_data = i->i_ctx;
-	ctx->mss = inode->i_mapping;
+
+	spin_lock(&ctx->mapping_lock);
+	if (!i->i_openers++)
+		ctx->mss = inode->i_mapping;
+	spin_unlock(&ctx->mapping_lock);
 	smp_wmb();
 	return nonseekable_open(inode, file);
 }
 
+static int
+spufs_mss_release(struct inode *inode, struct file *file)
+{
+	struct spufs_inode_info *i = SPUFS_I(inode);
+	struct spu_context *ctx = i->i_ctx;
+
+	spin_lock(&ctx->mapping_lock);
+	if (!--i->i_openers)
+		ctx->mss = NULL;
+	spin_unlock(&ctx->mapping_lock);
+	smp_wmb();
+	return 0;
+}
+
 static const struct file_operations spufs_mss_fops = {
 	.open	 = spufs_mss_open,
+	.release = spufs_mss_release,
 	.mmap	 = spufs_mss_mmap,
 };
 
@@ -1072,14 +1167,32 @@
 	struct spufs_inode_info *i = SPUFS_I(inode);
 	struct spu_context *ctx = i->i_ctx;
 
+	spin_lock(&ctx->mapping_lock);
 	file->private_data = i->i_ctx;
-	ctx->psmap = inode->i_mapping;
+	if (!i->i_openers++)
+		ctx->psmap = inode->i_mapping;
+	spin_unlock(&ctx->mapping_lock);
 	smp_wmb();
 	return nonseekable_open(inode, file);
 }
 
+static int
+spufs_psmap_release(struct inode *inode, struct file *file)
+{
+	struct spufs_inode_info *i = SPUFS_I(inode);
+	struct spu_context *ctx = i->i_ctx;
+
+	spin_lock(&ctx->mapping_lock);
+	if (!--i->i_openers)
+		ctx->psmap = NULL;
+	spin_unlock(&ctx->mapping_lock);
+	smp_wmb();
+	return 0;
+}
+
 static const struct file_operations spufs_psmap_fops = {
 	.open	 = spufs_psmap_open,
+	.release = spufs_psmap_release,
 	.mmap	 = spufs_psmap_mmap,
 };
 
@@ -1126,12 +1239,29 @@
 	if (atomic_read(&inode->i_count) != 1)
 		return -EBUSY;
 
+	spin_lock(&ctx->mapping_lock);
 	file->private_data = ctx;
-	ctx->mfc = inode->i_mapping;
+	if (!i->i_openers++)
+		ctx->mfc = inode->i_mapping;
+	spin_unlock(&ctx->mapping_lock);
 	smp_wmb();
 	return nonseekable_open(inode, file);
 }
 
+static int
+spufs_mfc_release(struct inode *inode, struct file *file)
+{
+	struct spufs_inode_info *i = SPUFS_I(inode);
+	struct spu_context *ctx = i->i_ctx;
+
+	spin_lock(&ctx->mapping_lock);
+	if (!--i->i_openers)
+		ctx->mfc = NULL;
+	spin_unlock(&ctx->mapping_lock);
+	smp_wmb();
+	return 0;
+}
+
 /* interrupt-level mfc callback function. */
 void spufs_mfc_callback(struct spu *spu)
 {
@@ -1399,6 +1529,7 @@
 
 static const struct file_operations spufs_mfc_fops = {
 	.open	 = spufs_mfc_open,
+	.release = spufs_mfc_release,
 	.read	 = spufs_mfc_read,
 	.write	 = spufs_mfc_write,
 	.poll	 = spufs_mfc_poll,
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/hw_ops.c linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/hw_ops.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/hw_ops.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/hw_ops.c	2007-05-21 13:50:28.226389254 +0200
@@ -221,6 +221,15 @@
 	spin_unlock_irq(&ctx->spu->register_lock);
 }
 
+static void spu_hw_runcntl_stop(struct spu_context *ctx)
+{
+	spin_lock_irq(&ctx->spu->register_lock);
+	out_be32(&ctx->spu->problem->spu_runcntl_RW, SPU_RUNCNTL_STOP);
+	while(in_be32(&ctx->spu->problem->spu_status_R) & SPU_STATUS_RUNNING)
+		cpu_relax();
+	spin_unlock_irq(&ctx->spu->register_lock);
+}
+
 static void spu_hw_master_start(struct spu_context *ctx)
 {
 	struct spu *spu = ctx->spu;
@@ -314,6 +323,7 @@
 	.get_ls = spu_hw_get_ls,
 	.runcntl_read = spu_hw_runcntl_read,
 	.runcntl_write = spu_hw_runcntl_write,
+	.runcntl_stop = spu_hw_runcntl_stop,
 	.master_start = spu_hw_master_start,
 	.master_stop = spu_hw_master_stop,
 	.set_mfc_query = spu_hw_set_mfc_query,
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/inode.c linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/inode.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/inode.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/inode.c	2007-05-21 13:50:28.241388455 +0200
@@ -54,6 +54,7 @@
 
 	ei->i_gang = NULL;
 	ei->i_ctx = NULL;
+	ei->i_openers = 0;
 
 	return &ei->vfs_inode;
 }
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/run.c linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/run.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/run.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/run.c	2007-05-21 13:50:28.260387443 +0200
@@ -313,7 +313,7 @@
 	if (down_interruptible(&ctx->run_sema))
 		return -ERESTARTSYS;
 
-	ctx->ops->master_start(ctx);
+	spu_enable_spu(ctx);
 	ctx->event_return = 0;
 	ret = spu_run_init(ctx, npc);
 	if (ret)
@@ -343,7 +343,7 @@
 	} while (!ret && !(status & (SPU_STATUS_STOPPED_BY_STOP |
 				      SPU_STATUS_STOPPED_BY_HALT)));
 
-	ctx->ops->master_stop(ctx);
+	spu_disable_spu(ctx);
 	ret = spu_run_fini(ctx, npc, &status);
 	spu_yield(ctx);
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/spufs.h linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/spufs.h
--- linux-2.6.21.1-org/arch/powerpc/platforms/cell/spufs/spufs.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/cell/spufs/spufs.h	2007-05-21 13:50:28.293385686 +0200
@@ -50,11 +50,12 @@
 	spinlock_t mmio_lock;		  /* protects mmio access */
 	struct address_space *local_store; /* local store mapping.  */
 	struct address_space *mfc;	   /* 'mfc' area mappings. */
-	struct address_space *cntl; 	   /* 'control' area mappings. */
-	struct address_space *signal1; 	   /* 'signal1' area mappings. */
-	struct address_space *signal2; 	   /* 'signal2' area mappings. */
-	struct address_space *mss; 	   /* 'mss' area mappings. */
-	struct address_space *psmap; 	   /* 'psmap' area mappings. */
+	struct address_space *cntl;	   /* 'control' area mappings. */
+	struct address_space *signal1;	   /* 'signal1' area mappings. */
+	struct address_space *signal2;	   /* 'signal2' area mappings. */
+	struct address_space *mss;	   /* 'mss' area mappings. */
+	struct address_space *psmap;	   /* 'psmap' area mappings. */
+	spinlock_t mapping_lock;
 	u64 object_id;		   /* user space pointer for oprofile */
 
 	enum { SPU_STATE_RUNNABLE, SPU_STATE_SAVED } state;
@@ -129,6 +130,7 @@
 	char*(*get_ls) (struct spu_context * ctx);
 	 u32 (*runcntl_read) (struct spu_context * ctx);
 	void (*runcntl_write) (struct spu_context * ctx, u32 data);
+	void (*runcntl_stop) (struct spu_context * ctx);
 	void (*master_start) (struct spu_context * ctx);
 	void (*master_stop) (struct spu_context * ctx);
 	int (*set_mfc_query)(struct spu_context * ctx, u32 mask, u32 mode);
@@ -149,6 +151,7 @@
 	struct spu_context *i_ctx;
 	struct spu_gang *i_gang;
 	struct inode vfs_inode;
+	int i_openers;
 };
 #define SPUFS_I(inode) \
 	container_of(inode, struct spufs_inode_info, vfs_inode)
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/ps3/Makefile linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/Makefile
--- linux-2.6.21.1-org/arch/powerpc/platforms/ps3/Makefile	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/Makefile	2007-05-21 13:50:28.352382545 +0200
@@ -1,6 +1,7 @@
 obj-y += setup.o mm.o time.o hvcall.o htab.o repository.o
 obj-y += interrupt.o exports.o os-area.o
 obj-y += system-bus.o
+obj-y += device-init.o
 
 obj-$(CONFIG_SMP) += smp.o
 obj-$(CONFIG_SPU_BASE) += spu.o
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/ps3/device-init.c linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/device-init.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/ps3/device-init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/device-init.c	2007-05-21 13:50:28.391380468 +0200
@@ -0,0 +1,463 @@
+/*
+ *  PS3 device init routines.
+ *
+ *  Copyright (C) 2006 Sony Computer Entertainment Inc.
+ *  Copyright 2006 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define DEBUG 1
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/firmware.h>
+
+#include "platform.h"
+
+static int __devinit
+ps3_register_gelic (void)
+{
+	int result;
+	struct ps3_system_bus_device *dev;
+	struct ps3_repository_device repo;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	dev = kzalloc(sizeof(struct ps3_system_bus_device)
+		+ sizeof(struct ps3_dma_region), GFP_KERNEL);
+
+	dev->match_id = PS3_MATCH_ID_GELIC;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_GELIC, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_first_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	dev->did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_EVENT_PORT, &dev->interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	BUG_ON(dev->interrupt_id != 0);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_get_interrupt_id failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	dev->d_region = (struct ps3_dma_region *)((char*)dev
+		+ sizeof(struct ps3_system_bus_device));
+
+	ps3_dma_region_init(dev->d_region, &dev->did, PS3_DMA_64K,
+		PS3_DMA_OTHER);
+
+	result = ps3_system_bus_device_register(dev);
+
+	if (result) {
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(dev, 0xad, sizeof(struct ps3_system_bus_device)
+		+ sizeof(struct ps3_dma_region));
+#endif
+	kfree(dev);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ohci_0 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ohci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ohci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_OHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_OHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_OHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 16);
+	BUG_ON(bus_addr != 0x3010000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ohci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ohci_1 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ohci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ohci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_OHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	result = ps3_repository_find_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_OHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_OHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 17);
+	BUG_ON(bus_addr != 0x3020000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ohci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ehci_0 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ehci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ehci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_EHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_EHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_EHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 10);
+	BUG_ON(bus_addr != 0x3810000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ehci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ehci_1 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ehci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ehci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_EHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	result = ps3_repository_find_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_EHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_EHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 11);
+	BUG_ON(bus_addr != 0x3820000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ehci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_sys_manager (void)
+{
+	int result;
+	static struct ps3_vuart_port_device dev = {
+		.match_id = PS3_MATCH_ID_SYSTEM_MANAGER,
+	};
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	result = ps3_vuart_port_device_register(&dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_vuart_port_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+int __init
+ps3_register_known_devices (void)
+{
+	int result;
+
+	if (!firmware_has_feature(FW_FEATURE_PS3_LV1))
+		return -ENODEV;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	//ps3_repository_dump_bus_info();
+
+	result = ps3_register_ohci_0();
+	result = ps3_register_ehci_0();
+	result = ps3_register_ohci_1();
+	result = ps3_register_ehci_1();
+#if defined(CONFIG_PS3_SYS_MANAGER)
+	result = ps3_register_sys_manager();
+#endif
+	result = ps3_register_gelic();
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+device_initcall(ps3_register_known_devices);
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/ps3/interrupt.c linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/interrupt.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/ps3/interrupt.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/interrupt.c	2007-05-21 13:50:28.441377806 +0200
@@ -89,7 +89,18 @@
 
 static DEFINE_PER_CPU(struct ps3_private, ps3_private);
 
-int ps3_alloc_irq(enum ps3_cpu_binding cpu, unsigned long outlet,
+/**
+ * ps3_virq_setup - virq related setup.
+ * @cpu: enum ps3_cpu_binding indicating the cpu the interrupt should be
+ * serviced on.
+ * @outlet: The HV outlet from the various create outlet routines.
+ * @virq: The assigned Linux virq.
+ *
+ * Calls irq_create_mapping() to get a virq and sets the chip data to
+ * ps3_private data.
+ */
+
+int ps3_virq_setup(enum ps3_cpu_binding cpu, unsigned long outlet,
 	unsigned int *virq)
 {
 	int result;
@@ -111,17 +122,6 @@
 		goto fail_create;
 	}
 
-	/* Binds outlet to cpu + virq. */
-
-	result = lv1_connect_irq_plug_ext(pd->node, pd->cpu, *virq, outlet, 0);
-
-	if (result) {
-		pr_info("%s:%d: lv1_connect_irq_plug_ext failed: %s\n",
-		__func__, __LINE__, ps3_result(result));
-		result = -EPERM;
-		goto fail_connect;
-	}
-
 	pr_debug("%s:%d: outlet %lu => cpu %u, virq %u\n", __func__, __LINE__,
 		outlet, cpu, *virq);
 
@@ -136,94 +136,118 @@
 	return result;
 
 fail_set:
-	lv1_disconnect_irq_plug_ext(pd->node, pd->cpu, *virq);
-fail_connect:
 	irq_dispose_mapping(*virq);
 fail_create:
 	return result;
 }
-EXPORT_SYMBOL_GPL(ps3_alloc_irq);
 
-int ps3_free_irq(unsigned int virq)
+/**
+ * ps3_virq_destroy - virq related teardown.
+ * @virq: The assigned Linux virq.
+ *
+ * Clears chip data and calls irq_dispose_mapping() for the virq.
+ */
+
+int ps3_virq_destroy(unsigned int virq)
 {
-	int result;
 	const struct ps3_private *pd = get_irq_chip_data(virq);
 
 	pr_debug("%s:%d: node %lu, cpu %d, virq %u\n", __func__, __LINE__,
 		pd->node, pd->cpu, virq);
 
-	result = lv1_disconnect_irq_plug_ext(pd->node, pd->cpu, virq);
-
-	if (result)
-		pr_info("%s:%d: lv1_disconnect_irq_plug_ext failed: %s\n",
-		__func__, __LINE__, ps3_result(result));
-
 	set_irq_chip_data(virq, NULL);
 	irq_dispose_mapping(virq);
-	return result;
+
+	pr_debug("%s:%d <-\n", __func__, __LINE__);
+	return 0;
 }
-EXPORT_SYMBOL_GPL(ps3_free_irq);
 
 /**
- * ps3_alloc_io_irq - Assign a virq to a system bus device.
+ * ps3_irq_plug_setup - Generic outlet and virq related setup.
  * @cpu: enum ps3_cpu_binding indicating the cpu the interrupt should be
  * serviced on.
- * @interrupt_id: The device interrupt id read from the system repository.
+ * @outlet: The HV outlet from the various create outlet routines.
  * @virq: The assigned Linux virq.
  *
- * An io irq represents a non-virtualized device interrupt.  interrupt_id
- * coresponds to the interrupt number of the interrupt controller.
+ * Sets up virq and connects the irq plug.
  */
 
-int ps3_alloc_io_irq(enum ps3_cpu_binding cpu, unsigned int interrupt_id,
+int ps3_irq_plug_setup(enum ps3_cpu_binding cpu, unsigned long outlet,
 	unsigned int *virq)
 {
 	int result;
-	unsigned long outlet;
+	struct ps3_private *pd;
 
-	result = lv1_construct_io_irq_outlet(interrupt_id, &outlet);
+	result = ps3_virq_setup(cpu, outlet, virq);
 
 	if (result) {
-		pr_debug("%s:%d: lv1_construct_io_irq_outlet failed: %s\n",
-			__func__, __LINE__, ps3_result(result));
-		return result;
+		pr_debug("%s:%d: ps3_virq_setup failed\n", __func__, __LINE__);
+		goto fail_setup;
 	}
 
-	result = ps3_alloc_irq(cpu, outlet, virq);
-	BUG_ON(result);
+	pd = get_irq_chip_data(*virq);
+
+	/* Binds outlet to cpu + virq. */
+
+	result = lv1_connect_irq_plug_ext(pd->node, pd->cpu, *virq, outlet, 0);
 
+	if (result) {
+		pr_info("%s:%d: lv1_connect_irq_plug_ext failed: %s\n",
+		__func__, __LINE__, ps3_result(result));
+		result = -EPERM;
+		goto fail_connect;
+	}
+
+	return result;
+
+fail_connect:
+	ps3_virq_destroy(*virq);
+fail_setup:
 	return result;
 }
-EXPORT_SYMBOL_GPL(ps3_alloc_io_irq);
+EXPORT_SYMBOL_GPL(ps3_irq_plug_setup);
+
+/**
+ * ps3_irq_plug_destroy - Generic outlet and virq related teardown.
+ * @virq: The assigned Linux virq.
+ *
+ * Disconnects the irq plug and tears down virq.
+ * Do not call for system bus event interrupts setup with
+ * ps3_sb_event_receive_port_setup().
+ */
 
-int ps3_free_io_irq(unsigned int virq)
+int ps3_irq_plug_destroy(unsigned int virq)
 {
 	int result;
+	const struct ps3_private *pd = get_irq_chip_data(virq);
 
-	result = lv1_destruct_io_irq_outlet(virq_to_hw(virq));
+	pr_debug("%s:%d: node %lu, cpu %d, virq %u\n", __func__, __LINE__,
+		pd->node, pd->cpu, virq);
+
+	result = lv1_disconnect_irq_plug_ext(pd->node, pd->cpu, virq);
 
 	if (result)
-		pr_debug("%s:%d: lv1_destruct_io_irq_outlet failed: %s\n",
-			__func__, __LINE__, ps3_result(result));
+		pr_info("%s:%d: lv1_disconnect_irq_plug_ext failed: %s\n",
+		__func__, __LINE__, ps3_result(result));
 
-	ps3_free_irq(virq);
+	ps3_virq_destroy(virq);
 
 	return result;
 }
-EXPORT_SYMBOL_GPL(ps3_free_io_irq);
+EXPORT_SYMBOL_GPL(ps3_irq_plug_destroy);
 
 /**
- * ps3_alloc_event_irq - Allocate a virq for use with a system event.
+ * ps3_event_receive_port_setup - Setup an event receive port.
  * @cpu: enum ps3_cpu_binding indicating the cpu the interrupt should be
  * serviced on.
  * @virq: The assigned Linux virq.
  *
  * The virq can be used with lv1_connect_interrupt_event_receive_port() to
- * arrange to receive events, or with ps3_send_event_locally() to signal
- * events.
+ * arrange to receive interrupts from system-bus devices, or with
+ * ps3_send_event_locally() to signal events.
  */
 
-int ps3_alloc_event_irq(enum ps3_cpu_binding cpu, unsigned int *virq)
+int ps3_event_receive_port_setup(enum ps3_cpu_binding cpu, unsigned int *virq)
 {
 	int result;
 	unsigned long outlet;
@@ -237,17 +261,27 @@
 		return result;
 	}
 
-	result = ps3_alloc_irq(cpu, outlet, virq);
+	result = ps3_irq_plug_setup(cpu, outlet, virq);
 	BUG_ON(result);
 
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_event_receive_port_setup);
+
+/**
+ * ps3_event_receive_port_destroy - Destroy an event receive port.
+ * @virq: The assigned Linux virq.
+ *
+ * Since ps3_event_receive_port_destroy destroys the receive port outlet,
+ * SB devices need to call disconnect_interrupt_event_receive_port() before
+ * this.
+ */
 
-int ps3_free_event_irq(unsigned int virq)
+int ps3_event_receive_port_destroy(unsigned int virq)
 {
 	int result;
 
-	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+	pr_debug(" -> %s:%d virq: %u\n", __func__, __LINE__, virq);
 
 	result = lv1_destruct_event_receive_port(virq_to_hw(virq));
 
@@ -255,11 +289,17 @@
 		pr_debug("%s:%d: lv1_destruct_event_receive_port failed: %s\n",
 			__func__, __LINE__, ps3_result(result));
 
-	ps3_free_irq(virq);
+	/* lv1_destruct_event_receive_port() destroys the IRQ plug,
+	 * so don't call ps3_irq_plug_destroy() here.
+	 */
+
+	result = ps3_virq_destroy(virq);
+	BUG_ON(result);
 
 	pr_debug(" <- %s:%d\n", __func__, __LINE__);
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_event_receive_port_destroy);
 
 int ps3_send_event_locally(unsigned int virq)
 {
@@ -267,7 +307,7 @@
 }
 
 /**
- * ps3_connect_event_irq - Assign a virq to a system bus device.
+ * ps3_sb_event_receive_port_setup - Setup a system bus event receive port.
  * @cpu: enum ps3_cpu_binding indicating the cpu the interrupt should be
  * serviced on.
  * @did: The HV device identifier read from the system repository.
@@ -278,13 +318,15 @@
  * coresponds to the software interrupt number.
  */
 
-int ps3_connect_event_irq(enum ps3_cpu_binding cpu,
+int ps3_sb_event_receive_port_setup(enum ps3_cpu_binding cpu,
 	const struct ps3_device_id *did, unsigned int interrupt_id,
 	unsigned int *virq)
 {
+	/* this should go in system-bus.c */
+
 	int result;
 
-	result = ps3_alloc_event_irq(cpu, virq);
+	result = ps3_event_receive_port_setup(cpu, virq);
 
 	if (result)
 		return result;
@@ -296,7 +338,7 @@
 		pr_debug("%s:%d: lv1_connect_interrupt_event_receive_port"
 			" failed: %s\n", __func__, __LINE__,
 			ps3_result(result));
-		ps3_free_event_irq(*virq);
+		ps3_event_receive_port_destroy(*virq);
 		*virq = NO_IRQ;
 		return result;
 	}
@@ -306,10 +348,13 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(ps3_sb_event_receive_port_setup);
 
-int ps3_disconnect_event_irq(const struct ps3_device_id *did,
+int ps3_sb_event_receive_port_destroy(const struct ps3_device_id *did,
 	unsigned int interrupt_id, unsigned int virq)
 {
+	/* this should go in system-bus.c */
+
 	int result;
 
 	pr_debug(" -> %s:%d: interrupt_id %u, virq %u\n", __func__, __LINE__,
@@ -323,14 +368,65 @@
 			" failed: %s\n", __func__, __LINE__,
 			ps3_result(result));
 
-	ps3_free_event_irq(virq);
+	result = ps3_event_receive_port_destroy(virq);
+	BUG_ON(result);
 
 	pr_debug(" <- %s:%d\n", __func__, __LINE__);
 	return result;
 }
+EXPORT_SYMBOL(ps3_sb_event_receive_port_destroy);
 
 /**
- * ps3_alloc_vuart_irq - Configure the system virtual uart virq.
+ * ps3_io_irq_setup - Setup a system bus io irq.
+ * @cpu: enum ps3_cpu_binding indicating the cpu the interrupt should be
+ * serviced on.
+ * @interrupt_id: The device interrupt id read from the system repository.
+ * @virq: The assigned Linux virq.
+ *
+ * An io irq represents a non-virtualized device interrupt.  interrupt_id
+ * coresponds to the interrupt number of the interrupt controller.
+ */
+
+int ps3_io_irq_setup(enum ps3_cpu_binding cpu, unsigned int interrupt_id,
+	unsigned int *virq)
+{
+	int result;
+	unsigned long outlet;
+
+	result = lv1_construct_io_irq_outlet(interrupt_id, &outlet);
+
+	if (result) {
+		pr_debug("%s:%d: lv1_construct_io_irq_outlet failed: %s\n",
+			__func__, __LINE__, ps3_result(result));
+		return result;
+	}
+
+	result = ps3_irq_plug_setup(cpu, outlet, virq);
+	BUG_ON(result);
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(ps3_io_irq_setup);
+
+int ps3_io_irq_destroy(unsigned int virq)
+{
+	int result;
+
+	result = lv1_destruct_io_irq_outlet(virq_to_hw(virq));
+
+	if (result)
+		pr_debug("%s:%d: lv1_destruct_io_irq_outlet failed: %s\n",
+			__func__, __LINE__, ps3_result(result));
+
+	result = ps3_irq_plug_destroy(virq);
+	BUG_ON(result);
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(ps3_io_irq_destroy);
+
+/**
+ * ps3_vuart_irq_setup - Setup the system virtual uart virq.
  * @cpu: enum ps3_cpu_binding indicating the cpu the interrupt should be
  * serviced on.
  * @virt_addr_bmp: The caller supplied virtual uart interrupt bitmap.
@@ -340,7 +436,7 @@
  * freeing the interrupt will return a wrong state error.
  */
 
-int ps3_alloc_vuart_irq(enum ps3_cpu_binding cpu, void* virt_addr_bmp,
+int ps3_vuart_irq_setup(enum ps3_cpu_binding cpu, void* virt_addr_bmp,
 	unsigned int *virq)
 {
 	int result;
@@ -359,13 +455,13 @@
 		return result;
 	}
 
-	result = ps3_alloc_irq(cpu, outlet, virq);
+	result = ps3_irq_plug_setup(cpu, outlet, virq);
 	BUG_ON(result);
 
 	return result;
 }
 
-int ps3_free_vuart_irq(unsigned int virq)
+int ps3_vuart_irq_destroy(unsigned int virq)
 {
 	int result;
 
@@ -377,13 +473,14 @@
 		return result;
 	}
 
-	ps3_free_irq(virq);
+	result = ps3_irq_plug_destroy(virq);
+	BUG_ON(result);
 
 	return result;
 }
 
 /**
- * ps3_alloc_spe_irq - Configure an spe virq.
+ * ps3_spe_irq_setup - Setup an spe virq.
  * @cpu: enum ps3_cpu_binding indicating the cpu the interrupt should be
  * serviced on.
  * @spe_id: The spe_id returned from lv1_construct_logical_spe().
@@ -392,7 +489,7 @@
  *
  */
 
-int ps3_alloc_spe_irq(enum ps3_cpu_binding cpu, unsigned long spe_id,
+int ps3_spe_irq_setup(enum ps3_cpu_binding cpu, unsigned long spe_id,
 	unsigned int class, unsigned int *virq)
 {
 	int result;
@@ -408,15 +505,16 @@
 		return result;
 	}
 
-	result = ps3_alloc_irq(cpu, outlet, virq);
+	result = ps3_irq_plug_setup(cpu, outlet, virq);
 	BUG_ON(result);
 
 	return result;
 }
 
-int ps3_free_spe_irq(unsigned int virq)
+int ps3_spe_irq_destroy(unsigned int virq)
 {
-	ps3_free_irq(virq);
+	int result = ps3_irq_plug_destroy(virq);
+	BUG_ON(result);
 	return 0;
 }
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/ps3/mm.c linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/mm.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/ps3/mm.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/mm.c	2007-05-21 13:50:28.458376901 +0200
@@ -128,6 +128,16 @@
 
 static struct map map;
 
+// FIXME Temporary solution for the storage and sound drivers
+unsigned long ps3_mem_total;
+EXPORT_SYMBOL_GPL(ps3_mem_total);
+unsigned long ps3_rm_limit;
+EXPORT_SYMBOL_GPL(ps3_rm_limit);
+unsigned long ps3_2nd_mem_base;
+EXPORT_SYMBOL_GPL(ps3_2nd_mem_base);
+unsigned long ps3_2nd_mem_size;
+EXPORT_SYMBOL_GPL(ps3_2nd_mem_size);
+
 /**
  * ps3_mm_phys_to_lpar - translate a linux physical address to lpar address
  * @phys_addr: linux physical address
@@ -810,12 +820,17 @@
 	BUG_ON(map.rm.base);
 	BUG_ON(!map.rm.size);
 
-	lmb_add(map.rm.base, map.rm.size);
-	lmb_analyze();
+#warning FIXME - need to check if map.rm.size is same as value in DT.
 
 	/* arrange to do this in ps3_mm_add_memory */
 	ps3_mm_region_create(&map.r1, map.total - map.rm.size);
 
+	// FIXME Temporary solution for the storage and sound drivers
+	ps3_mem_total = map.rm.size + map.r1.size;
+	ps3_rm_limit = map.rm.size;
+	ps3_2nd_mem_base = map.r1.base;
+	ps3_2nd_mem_size = map.r1.size;
+
 	DBG(" <- %s:%d\n", __func__, __LINE__);
 }
 
@@ -826,5 +841,4 @@
 void ps3_mm_shutdown(void)
 {
 	ps3_mm_region_destroy(&map.r1);
-	map.total = map.rm.size;
 }
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/ps3/platform.h linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/platform.h
--- linux-2.6.21.1-org/arch/powerpc/platforms/ps3/platform.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/platform.h	2007-05-21 13:50:28.498374771 +0200
@@ -134,6 +134,8 @@
 	struct ps3_device_id did;
 };
 
+int ps3_repository_find_bus(enum ps3_bus_type bus_type, unsigned int from,
+	unsigned int *bus_index);
 int ps3_repository_find_device(enum ps3_bus_type bus_type,
 	enum ps3_dev_type dev_type,
 	const struct ps3_repository_device *start_dev,
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/ps3/repository.c linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/repository.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/ps3/repository.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/repository.c	2007-05-21 13:50:28.541372482 +0200
@@ -182,6 +182,7 @@
 	*bus_id = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_bus_id);
 
 int ps3_repository_read_bus_type(unsigned int bus_index,
 	enum ps3_bus_type *bus_type)
@@ -197,6 +198,7 @@
 	*bus_type = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_bus_type);
 
 int ps3_repository_read_bus_num_dev(unsigned int bus_index,
 	unsigned int *num_dev)
@@ -212,6 +214,7 @@
 	*num_dev = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_bus_num_dev);
 
 int ps3_repository_read_dev_str(unsigned int bus_index,
 	unsigned int dev_index, const char *dev_str, u64 *value)
@@ -239,6 +242,7 @@
 	*dev_id = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_dev_id);
 
 int ps3_repository_read_dev_type(unsigned int bus_index,
 	unsigned int dev_index, enum ps3_dev_type *dev_type)
@@ -255,6 +259,7 @@
 	*dev_type = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_dev_type);
 
 int ps3_repository_read_dev_intr(unsigned int bus_index,
 	unsigned int dev_index, unsigned int intr_index,
@@ -274,6 +279,7 @@
 	*interrupt_id = v2;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_dev_intr);
 
 int ps3_repository_read_dev_reg_type(unsigned int bus_index,
 	unsigned int dev_index, unsigned int reg_index,
@@ -513,6 +519,31 @@
 }
 #endif /* defined(DEBUG) */
 
+int ps3_repository_find_bus(enum ps3_bus_type bus_type, unsigned int from,
+	unsigned int *bus_index)
+{
+	unsigned int i;
+	enum ps3_bus_type type;
+	int error;
+
+	for (i = from; i < 10; i++) {
+		error = ps3_repository_read_bus_type(i, &type);
+		if (error) {
+			pr_debug("%s:%d read_bus_type failed\n",
+				__func__, __LINE__);
+			*bus_index = UINT_MAX;
+			return error;
+		}
+		if (type == bus_type) {
+			*bus_index = i;
+			return 0;
+		}
+	}
+	*bus_index = UINT_MAX;
+	return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(ps3_repository_find_bus);
+
 static int find_device(unsigned int bus_index, unsigned int num_dev,
 	unsigned int start_dev_index, enum ps3_dev_type dev_type,
 	struct ps3_repository_device *dev)
@@ -541,7 +572,7 @@
 	}
 
 	if (dev_index == num_dev)
-		return -1;
+		return -ENODEV;
 
 	pr_debug("%s:%d: found dev_type %u at dev_index %u\n",
 		__func__, __LINE__, dev_type, dev_index);
@@ -577,25 +608,14 @@
 
 	BUG_ON(start_dev && start_dev->bus_index > 10);
 
-	for (bus_index = start_dev ? start_dev->bus_index : 0; bus_index < 10;
-		bus_index++) {
-		enum ps3_bus_type x;
-
-		result = ps3_repository_read_bus_type(bus_index, &x);
-
-		if (result) {
-			pr_debug("%s:%d read_bus_type failed\n",
-				__func__, __LINE__);
-			dev->bus_index = UINT_MAX;
-			return result;
-		}
-		if (x == bus_type)
-			break;
+	result = ps3_repository_find_bus(bus_type,
+					 start_dev ? start_dev->bus_index : 0,
+					 &bus_index);
+	if (result) {
+		dev->bus_index = UINT_MAX;
+		return result;
 	}
 
-	if (bus_index >= 10)
-		return -ENODEV;
-
 	pr_debug("%s:%d: found bus_type %u at bus_index %u\n",
 		__func__, __LINE__, bus_type, bus_index);
 
@@ -630,6 +650,7 @@
 
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_find_device);
 
 int ps3_repository_find_interrupt(const struct ps3_repository_device *dev,
 	enum ps3_interrupt_type intr_type, unsigned int *interrupt_id)
@@ -668,6 +689,7 @@
 
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_find_interrupt);
 
 int ps3_repository_find_reg(const struct ps3_repository_device *dev,
 	enum ps3_reg_type reg_type, u64 *bus_addr, u64 *len)
@@ -949,6 +971,7 @@
 		0,
 		address, 0);
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_stor_dev_info);
 
 int ps3_repository_read_boot_dat_size(unsigned int *size)
 {
@@ -1015,6 +1038,7 @@
 		0,
 		tb_freq, 0);
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_stor_dev_region);
 
 int ps3_repository_read_be_tb_freq(unsigned int be_index, u64 *tb_freq)
 {
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/ps3/setup.c linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/setup.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/ps3/setup.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/setup.c	2007-05-21 13:50:28.558371577 +0200
@@ -117,9 +117,9 @@
 
 #ifdef CONFIG_FB_PS3
 struct ps3_prealloc ps3fb_videomemory = {
-    .name = "ps3fb videomemory",
-    .size = CONFIG_FB_PS3_DEFAULT_SIZE_M*1024*1024,
-    .align = 1024*1024			/* the GPU requires 1 MiB alignment */
+	.name = "ps3fb videomemory",
+	.size = CONFIG_FB_PS3_DEFAULT_SIZE_M*1024*1024,
+	.align = 1024*1024		/* the GPU requires 1 MiB alignment */
 };
 #define prealloc_ps3fb_videomemory()	prealloc(&ps3fb_videomemory)
 
@@ -137,6 +137,24 @@
 #define prealloc_ps3fb_videomemory()	do { } while (0)
 #endif
 
+#if defined(CONFIG_PS3_STORAGE) || defined(CONFIG_PS3_STORAGE_MODULE)
+struct ps3_prealloc ps3_stor_bounce_buffer = {
+	.name = "ps3_stor bounce buffer",
+	.size = 256*1024,
+	.align = 256*1024
+};
+EXPORT_SYMBOL_GPL(ps3_stor_bounce_buffer);
+#define prealloc_ps3_stor_bounce_buffer()	prealloc(&ps3_stor_bounce_buffer)
+#else
+#define prealloc_ps3_stor_bounce_buffer()	do { } while (0)
+#endif
+
+static int ps3_set_dabr(u64 dabr)
+{
+	enum {DABR_USER = 1, DABR_KERNEL = 2,};
+
+	return lv1_set_dabr(dabr, DABR_KERNEL | DABR_USER) ? -1 : 0;
+}
 
 static void __init ps3_setup_arch(void)
 {
@@ -160,6 +178,8 @@
 #endif
 
 	prealloc_ps3fb_videomemory();
+	prealloc_ps3_stor_bounce_buffer();
+
 	ppc_md.power_save = ps3_power_save;
 
 	DBG(" <- %s:%d\n", __func__, __LINE__);
@@ -225,6 +245,11 @@
 }
 #endif
 
+static int ps3_check_legacy_ioport(unsigned int baseport)
+{
+        return -ENODEV;
+}
+
 define_machine(ps3) {
 	.name				= "PS3",
 	.probe				= ps3_probe,
@@ -234,7 +259,9 @@
 	.get_boot_time			= ps3_get_boot_time,
 	.set_rtc_time			= ps3_set_rtc_time,
 	.get_rtc_time			= ps3_get_rtc_time,
+	.set_dabr			= ps3_set_dabr,
 	.calibrate_decr			= ps3_calibrate_decr,
+	.check_legacy_ioport		= ps3_check_legacy_ioport,
 	.progress			= ps3_progress,
 	.restart			= ps3_restart,
 	.power_off			= ps3_power_off,
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/ps3/smp.c linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/smp.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/ps3/smp.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/smp.c	2007-05-21 13:50:28.603369181 +0200
@@ -110,7 +110,7 @@
 	BUILD_BUG_ON(PPC_MSG_DEBUGGER_BREAK != 3);
 
 	for (i = 0; i < MSG_COUNT; i++) {
-		result = ps3_alloc_event_irq(cpu, &virqs[i]);
+		result = ps3_event_receive_port_setup(cpu, &virqs[i]);
 
 		if (result)
 			continue;
@@ -134,11 +134,13 @@
 	int i;
 
 	DBG(" -> %s:%d: (%d)\n", __func__, __LINE__, cpu);
+
 	for (i = 0; i < MSG_COUNT; i++) {
-		ps3_free_event_irq(virqs[i]);
 		free_irq(virqs[i], (void*)(long)i);
+		ps3_event_receive_port_destroy(virqs[i]);
 		virqs[i] = NO_IRQ;
 	}
+
 	DBG(" <- %s:%d: (%d)\n", __func__, __LINE__, cpu);
 }
 
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/ps3/spu.c linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/spu.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/ps3/spu.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/spu.c	2007-05-21 13:50:28.616368489 +0200
@@ -28,6 +28,7 @@
 #include <asm/spu_priv1.h>
 #include <asm/lv1call.h>
 
+#include "../cell/spufs/spufs.h"
 #include "platform.h"
 
 /* spu_management_ops */
@@ -230,19 +231,19 @@
 {
 	int result;
 
-	result = ps3_alloc_spe_irq(PS3_BINDING_CPU_ANY, spu_pdata(spu)->spe_id,
+	result = ps3_spe_irq_setup(PS3_BINDING_CPU_ANY, spu_pdata(spu)->spe_id,
 		0, &spu->irqs[0]);
 
 	if (result)
 		goto fail_alloc_0;
 
-	result = ps3_alloc_spe_irq(PS3_BINDING_CPU_ANY, spu_pdata(spu)->spe_id,
+	result = ps3_spe_irq_setup(PS3_BINDING_CPU_ANY, spu_pdata(spu)->spe_id,
 		1, &spu->irqs[1]);
 
 	if (result)
 		goto fail_alloc_1;
 
-	result = ps3_alloc_spe_irq(PS3_BINDING_CPU_ANY, spu_pdata(spu)->spe_id,
+	result = ps3_spe_irq_setup(PS3_BINDING_CPU_ANY, spu_pdata(spu)->spe_id,
 		2, &spu->irqs[2]);
 
 	if (result)
@@ -251,9 +252,9 @@
 	return result;
 
 fail_alloc_2:
-	ps3_free_spe_irq(spu->irqs[1]);
+	ps3_spe_irq_destroy(spu->irqs[1]);
 fail_alloc_1:
-	ps3_free_spe_irq(spu->irqs[0]);
+	ps3_spe_irq_destroy(spu->irqs[0]);
 fail_alloc_0:
 	spu->irqs[0] = spu->irqs[1] = spu->irqs[2] = NO_IRQ;
 	return result;
@@ -301,9 +302,9 @@
 	result = lv1_disable_logical_spe(spu_pdata(spu)->spe_id, 0);
 	BUG_ON(result);
 
-	ps3_free_spe_irq(spu->irqs[2]);
-	ps3_free_spe_irq(spu->irqs[1]);
-	ps3_free_spe_irq(spu->irqs[0]);
+	ps3_spe_irq_destroy(spu->irqs[2]);
+	ps3_spe_irq_destroy(spu->irqs[1]);
+	ps3_spe_irq_destroy(spu->irqs[0]);
 
 	spu->irqs[0] = spu->irqs[1] = spu->irqs[2] = NO_IRQ;
 
@@ -400,17 +401,32 @@
 		}
 	}
 
-	if (result)
+	if (result) {
 		printk(KERN_WARNING "%s:%d: Error initializing spus\n",
 			__func__, __LINE__);
+		return result;
+	}
 
-	return result;
+	return num_resource_id;
+}
+
+static int ps3_enable_spu(struct spu_context *ctx)
+{
+	return -ENOSYS;
+}
+
+static int ps3_disable_spu(struct spu_context *ctx)
+{
+	ctx->ops->runcntl_stop(ctx);
+	return -ENOSYS;
 }
 
 const struct spu_management_ops spu_management_ps3_ops = {
 	.enumerate_spus = ps3_enumerate_spus,
 	.create_spu = ps3_create_spu,
 	.destroy_spu = ps3_destroy_spu,
+	.enable_spu = ps3_enable_spu,
+	.disable_spu = ps3_disable_spu,
 };
 
 /* spu_priv1_ops */
diff -Naur linux-2.6.21.1-org/arch/powerpc/platforms/ps3/system-bus.c linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/system-bus.c
--- linux-2.6.21.1-org/arch/powerpc/platforms/ps3/system-bus.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/arch/powerpc/platforms/ps3/system-bus.c	2007-05-21 13:50:28.658366252 +0200
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/module.h>
@@ -30,6 +32,10 @@
 
 #include "platform.h"
 
+static struct device ps3_system_bus = {
+        .bus_id         = "ps3_system",
+};
+
 #define dump_mmio_region(_a) _dump_mmio_region(_a, __func__, __LINE__)
 static void _dump_mmio_region(const struct ps3_mmio_region* r,
 	const char* func, int line)
@@ -99,9 +105,10 @@
 
 	result = lv1_open_device(dev->did.bus_id, dev->did.dev_id, 0);
 
-	if (result) {
-		pr_debug("%s:%d: lv1_open_device failed (%d)\n",
-			__func__, __LINE__, result);
+	if (result && (result != LV1_BUSY || (dev->match_id != PS3_MATCH_ID_EHCI
+		&& dev->match_id != PS3_MATCH_ID_OHCI))) {
+		pr_debug("%s:%d: lv1_open_device failed: %s\n",
+			__func__, __LINE__, ps3_result(result));
 		result = -EACCES;
 		goto clean_none;
 	}
@@ -160,11 +167,42 @@
 	return 0;
 }
 
+static int ps3_system_bus_uevent(struct device *_dev, char **envp,
+				 int num_envp, char *buffer, int buffer_size)
+{
+	struct ps3_system_bus_device *dev = to_ps3_system_bus_device(_dev);
+	int i=0, length = 0;
+
+	if (add_uevent_var(envp, num_envp, &i, buffer, buffer_size,
+			   &length, "MODALIAS=ps3:%d",
+			   dev->match_id))
+		return -ENOMEM;
+
+	envp[i] = NULL;
+	return 0;
+}
+
+static ssize_t modalias_show(struct device *_dev, struct device_attribute *a,
+			     char *buf)
+{
+	struct ps3_system_bus_device *dev = to_ps3_system_bus_device(_dev);
+        int len = snprintf(buf, PAGE_SIZE, "ps3:%d\n", dev->match_id);
+
+        return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+
+static struct device_attribute ps3_system_bus_dev_attrs[] = {
+        __ATTR_RO(modalias),
+        __ATTR_NULL,
+};
+
 struct bus_type ps3_system_bus_type = {
 	.name = "ps3_system_bus",
 	.match = ps3_system_bus_match,
 	.probe = ps3_system_bus_probe,
 	.remove = ps3_system_bus_remove,
+	.uevent = ps3_system_bus_uevent,
+	.dev_attrs = ps3_system_bus_dev_attrs,
 };
 
 int __init ps3_system_bus_init(void)
@@ -173,7 +211,8 @@
 
 	if (!firmware_has_feature(FW_FEATURE_PS3_LV1))
 		return -ENODEV;
-
+	result = device_register(&ps3_system_bus);
+	BUG_ON(result);
 	result = bus_register(&ps3_system_bus_type);
 	BUG_ON(result);
 	return result;
@@ -353,6 +392,9 @@
 	dev->core.archdata.dma_ops = &ps3_dma_ops;
 	dev->core.archdata.numa_node = 0;
 
+	if (!dev->core.parent)
+		dev->core.parent = &ps3_system_bus;
+
 	snprintf(dev->core.bus_id, sizeof(dev->core.bus_id), "sb_%02x",
 		dev_count++);
 
diff -Naur linux-2.6.21.1-org/drivers/block/Kconfig linux-2.6.21.1-ps3/drivers/block/Kconfig
--- linux-2.6.21.1-org/drivers/block/Kconfig	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/block/Kconfig	2007-05-21 13:50:28.820357627 +0200
@@ -453,6 +453,34 @@
 	This driver provides Support for ATA over Ethernet block
 	devices like the Coraid EtherDrive (R) Storage Blade.
 
+config PS3_STORAGE
+       tristate "Support PS3 internal HDD/CDROM drives"
+       depends on PPC_PS3 && BLK_DEV_SD && BLK_DEV_SR
+       help
+       This driver provides support for internal HDD/CD-ROM drives
+       controlled under PS3 hypervisor storage system.
+
+config PS3_STORAGE_EXPECTED_NUM_DRIVES
+       int "Number of expected storage drives"
+       depends on PS3_STORAGE
+       default "3"
+       help
+         This specifies number of expected numbers of internal
+         storage drives.  The PS3 storage driver waits for
+         this number of drives are reported ready by the
+         hypervisor.
+
+config PS3_STORAGE_MAX_SPINUP_WAIT_TIME
+       int "Maximum time of wait time"
+       depends on PS3_STORAGE
+       default "10"
+       help
+         This specifies maximum time to wait for storage
+         drive readiness.  If only less drives than
+         PS3_STORAGE_EXPECTED_NUM_DRIVES become ready
+         until this time expired,  the PS3 storage driver
+         stop to wait and continue to run with available
+         drives.
 endmenu
 
 endif
diff -Naur linux-2.6.21.1-org/drivers/block/Makefile linux-2.6.21.1-ps3/drivers/block/Makefile
--- linux-2.6.21.1-org/drivers/block/Makefile	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/block/Makefile	2007-05-21 13:50:28.835356828 +0200
@@ -28,4 +28,5 @@
 obj-$(CONFIG_VIODASD)		+= viodasd.o
 obj-$(CONFIG_BLK_DEV_SX8)	+= sx8.o
 obj-$(CONFIG_BLK_DEV_UB)	+= ub.o
+obj-$(CONFIG_PS3_STORAGE)	+= ps3_storage.o
 
diff -Naur linux-2.6.21.1-org/drivers/block/ps3_storage.c linux-2.6.21.1-ps3/drivers/block/ps3_storage.c
--- linux-2.6.21.1-org/drivers/block/ps3_storage.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/drivers/block/ps3_storage.c	2007-05-21 13:50:28.898353474 +0200
@@ -0,0 +1,2741 @@
+/*
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * Copyright 2006, 2007 Sony Corporation
+ * storage support for PS3
+ *
+ * based on scsi_debug.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/blkdev.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/rwsem.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <linux/cdrom.h>
+#include <asm/lv1call.h>
+#include <asm/abs_addr.h>
+#include <asm/ps3.h>
+#include "ps3_storage.h"
+
+#undef _DEBUG
+#if defined(_DEBUG)
+#define DPRINTK(x...) printk(x)
+#else
+#define DPRINTK(x...) do {} while(0)
+#endif
+
+#undef _DEBUG_CALLTREE
+#if defined(_DEBUG_CALLTREE)
+static int func_level;
+#define FUNC_START     printk(KERN_ERR "%s:%d start\n", __FUNCTION__, func_level++)
+#define FUNC_STEP_C(x) printk(KERN_ERR "%s:%d step %s\n", __FUNCTION__, func_level, x)
+#define FUNC_END       printk(KERN_ERR "%s:%d end\n", __FUNCTION__, --func_level)
+#define FUNC_END_C(x)  printk(KERN_ERR "%s:%d end %s\n", __FUNCTION__, --func_level, x)
+#else
+#define FUNC_START     do {} while(0)
+#define FUNC_END       FUNC_START
+#define FUNC_STEP_C(x) FUNC_START
+#define FUNC_END_C(x)  FUNC_START
+#endif
+
+#define FLASH_ALIGN    (0x00040000) /* flash safe write size (256KB); should be powers of 2 */
+
+static int ps3_stor_add_host = 2;
+static int ps3_stor_wait_time = CONFIG_PS3_STORAGE_MAX_SPINUP_WAIT_TIME;
+static int ps3_stor_wait_num_storages = CONFIG_PS3_STORAGE_EXPECTED_NUM_DRIVES + 1;
+
+#define CEIL_ALIGN_16M(mem)  ((((mem - 1) >> 24) + 1 ) << 24) /* 2^24=16M */
+#define CEIL_ALIGN_1M(mem)   ((((mem - 1) >> 20) + 1 ) << 20) /* 2^20=1M */
+#define CEIL_ALIGN_64K(mem)  ((((mem - 1) >> 16) + 1 ) << 16) /* 2^16=64K */
+#define CEIL_ALIGN_4K(mem)   ((((mem - 1) >> 12) + 1 ) << 12) /* 2^12=4K */
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PS3 storage driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(PS3_STOR_VERSION);
+
+module_param_named(wait_num_storages, ps3_stor_wait_num_storages, int, 0);
+module_param_named(wait_time, ps3_stor_wait_time, int, 0);
+MODULE_PARM_DESC(wait_num_storages, "Number of expected (wanted) drives to wait spin up (default=3 drives)");
+MODULE_PARM_DESC(wait_time, "Maximum time to wait spinup (default=10sec)");
+
+static struct ps3_stor_lv1_bus_info ps3_stor_lv1_bus_info_array[PS3_STORAGE_NUM_OF_BUS_TYPES];
+
+static struct ps3_stor_lv1_dev_info * ps3_stor_lv1_dev_info_array;
+static int ps3_stor_lv1_devnum ; /* number of configured(used) lv1 devices */
+
+static LIST_HEAD(ps3_stor_host_list);
+static DEFINE_SPINLOCK(ps3_stor_host_list_lock);
+
+static u64 ps3_stor_virtual_to_lpar(struct ps3_stor_dev_info *dev_info,
+				    void *va);
+
+/*
+ * fill buf with MODE SENSE page 8 (caching parameter)
+ * changable: 0 fills current value, otherwise fills 0
+ * returns length of this page
+ */
+const static unsigned char page_data_6[] =
+{
+	0x06,    2, /* page 6, length =2                         */
+	0x01,       /* 0: write cache disabled                   */
+	0x00        /* reserved                                  */
+};
+const static unsigned char page_data_8[] =
+{
+	0x08,   10, /* page 8, length =10                        */
+	0x04,       /* 0:read cache, 1:mult factor, 2:write cache*/
+	0x00,       /* 0..3:write retantion, 4..7:read retantion */
+	0xff, 0xff, /* disable prefech block length              */
+	0x00, 0x00, /* minimum prefech                           */
+	0xff, 0xff, /* maximum prefech                           */
+	0xff, 0xff  /* maximum prefech ceiling                   */
+};
+
+/*
+ * returns 0: decoded
+ *        -1: not sense info, issue REQUEST_SENSE needed
+ */
+static int decode_lv1_status(u64 status, unsigned char * sense_key,
+			     unsigned char * asc, unsigned char * ascq)
+{
+	if (((status >> 24) & 0xff) != 0x02)
+		return -1;
+
+	*sense_key = (status >> 16) & 0xff;
+	*asc       = (status >>  8) & 0xff;
+	*ascq      =  status        & 0xff;
+	return 0;
+}
+
+
+static void ps3_stor_srb_done(struct ps3_stor_dev_info * dev_info)
+{
+	struct scsi_cmnd * srb = dev_info->srb;
+	unsigned long flags;
+
+	spin_lock_irqsave(&(dev_info->srb_lock), flags);
+	{
+		dev_info->srb = NULL;
+		srb->scsi_done(srb);
+	}
+	spin_unlock_irqrestore(&(dev_info->srb_lock), flags);
+}
+
+static void ps3_stor_process_srb(struct scsi_cmnd * srb)
+{
+	struct ps3_stor_dev_info * dev_info;
+	int (*command_handler)(struct ps3_stor_dev_info *, struct scsi_cmnd *);
+
+	dev_info = (struct ps3_stor_dev_info*) srb->device->hostdata;
+	command_handler = dev_info->handler_info[srb->cmnd[0]].cmnd_handler;
+
+	if (command_handler) {
+		(*command_handler)(dev_info, srb);
+	} else {
+		srb->result = (DID_ERROR << 16);
+		memset(srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		srb->sense_buffer[0] = 0x70;
+		srb->sense_buffer[2] = ILLEGAL_REQUEST;
+		ps3_stor_srb_done(dev_info);
+	}
+}
+
+/*
+ * main thread to process srb.
+ * thread is created per device basis.
+ * srb are often passed in interrupt context (softirq), so
+ * we can't sleep at queuecommand().  just receive it
+ * at queucommand(), then passed it to other thread
+ * to process it under non-interrupt context.
+ */
+static int ps3_stor_main_thread(void * parm)
+{
+	struct ps3_stor_dev_info * dev_info = (struct ps3_stor_dev_info *)parm;
+	int reason = 0;
+
+	current->flags |= PF_NOFREEZE; /* jugemu jugemu */
+
+	while (!reason) {
+		down_interruptible(&(dev_info->thread_sema));
+		switch (dev_info->thread_wakeup_reason) {
+		case SRB_QUEUED:
+			ps3_stor_process_srb(dev_info->srb);
+			break;
+		case THREAD_TERMINATE:
+			reason =  THREAD_TERMINATE;
+			break;
+		default:
+			printk(KERN_ERR "%s: unknown wakeup reason %d\n", __FUNCTION__,
+			       dev_info->thread_wakeup_reason);
+			break;
+		}
+	}
+
+	complete_and_exit(&(dev_info->thread_terminated), reason);
+}
+
+/*
+ * copy data from device into scatter/gather buffer
+ */
+static int fill_from_dev_buffer(struct scsi_cmnd * srb,
+				const unsigned char * arr,
+				int arr_len)
+{
+	int k, req_len, act_len, len, active;
+	void * kaddr;
+	void * kaddr_off;
+	struct scatterlist * sgpnt;
+
+	if (0 == srb->request_bufflen)
+		return 0;
+	if (NULL == srb->request_buffer)
+		return (DID_ERROR << 16);
+	if (! ((srb->sc_data_direction == DMA_BIDIRECTIONAL) ||
+	      (srb->sc_data_direction == DMA_FROM_DEVICE)))
+		return (DID_ERROR << 16);
+	if (0 == srb->use_sg) {
+		req_len = srb->request_bufflen;
+		act_len = (req_len < arr_len) ? req_len : arr_len;
+		memcpy(srb->request_buffer, arr, act_len);
+		srb->resid = req_len - act_len;
+		return 0;
+	}
+	sgpnt = (struct scatterlist *)srb->request_buffer;
+	active = 1;
+	for (k = 0, req_len = 0, act_len = 0; k < srb->use_sg; ++k, ++sgpnt) {
+		if (active) {
+			kaddr = kmap_atomic(sgpnt->page, KM_USER0);
+			if (NULL == kaddr)
+				return (DID_ERROR << 16);
+			kaddr_off = kaddr + sgpnt->offset;
+			len = sgpnt->length;
+			if ((req_len + len) > arr_len) {
+				active = 0;
+				len = arr_len - req_len;
+			}
+			memcpy(kaddr_off, arr + req_len, len);
+			kunmap_atomic(kaddr, KM_USER0);
+			act_len += len;
+		}
+		req_len += sgpnt->length;
+	}
+	srb->resid = req_len - act_len;
+	return 0;
+}
+
+/*
+ * copy data from scatter/gather into device's buffer
+ */
+static int fetch_to_dev_buffer(struct scsi_cmnd * srb,
+			       unsigned char * arr,
+			       int max_arr_len)
+{
+	int k, req_len, len, fin;
+	void * kaddr;
+	void * kaddr_off;
+	struct scatterlist * sgpnt;
+
+	if (0 == srb->request_bufflen)
+		return 0;
+	if (NULL == srb->request_buffer)
+		return -1;
+	if (! ((srb->sc_data_direction == DMA_BIDIRECTIONAL) ||
+	      (srb->sc_data_direction == DMA_TO_DEVICE)))
+		return -1;
+	if (0 == srb->use_sg) {
+		req_len = srb->request_bufflen;
+		len = (req_len < max_arr_len) ? req_len : max_arr_len;
+		memcpy(arr, srb->request_buffer, len);
+		return len;
+	}
+
+	sgpnt = (struct scatterlist *)srb->request_buffer;
+	for (k = 0, req_len = 0, fin = 0; k < srb->use_sg; ++k, ++sgpnt) {
+		kaddr = kmap_atomic(sgpnt->page, KM_USER0);
+		if (NULL == kaddr)
+			return -1;
+		kaddr_off = kaddr + sgpnt->offset;
+		len = sgpnt->length;
+		if ((req_len + len) > max_arr_len) {
+			len = max_arr_len - req_len;
+			fin = 1;
+		}
+		memcpy(arr + req_len, kaddr_off, len);
+		kunmap_atomic(kaddr, KM_USER0);
+		if (fin)
+			return req_len + len;
+		req_len += sgpnt->length;
+	}
+	return req_len;
+}
+
+/*
+ * copy data into device buffer to write.
+ * byte offset 'from' until byte offset 'to'
+ * data always copied into 'arr'
+ */
+static off_t fetch_to_dev_buffer_abs(struct scsi_cmnd * srb,
+				     unsigned char * arr,
+				     off_t from,
+				     off_t to)
+{
+	int i, fin;
+	void * kaddr;
+	void * kaddr_off;
+	off_t cur_pos, end_pos, start_pos, len;
+	struct scatterlist * sg;
+
+	if (0 == srb->request_bufflen)
+		return 0;
+	if (NULL == srb->request_buffer)
+		return -1;
+	if (! ((srb->sc_data_direction == DMA_BIDIRECTIONAL) ||
+	      (srb->sc_data_direction == DMA_TO_DEVICE)))
+		return -1;
+	if (to < from)
+		return -1;
+
+	DPRINTK(KERN_ERR "%s: from=%#lx(%ld) to=%#lx(%ld) sg=%d\n", __FUNCTION__,
+		from, from , to, to, srb->use_sg);
+
+	if (0 == srb->use_sg) {
+		len = (srb->request_bufflen < to) ? (srb->request_bufflen - from) : (to - from);
+		memcpy(arr, srb->request_buffer + from, len);
+		return len;
+	}
+
+
+	len = 0;
+	sg = (struct scatterlist *)srb->request_buffer;
+	for (i = 0, cur_pos = 0, fin = 0;
+	     (i < srb->use_sg) && !fin;
+	     cur_pos += sg->length, i++, sg++) {
+		kaddr = kmap_atomic(sg->page, KM_USER0);
+		kaddr_off = kaddr + sg->offset;
+
+		//DPRINTK(KERN_ERR "%s: cur_pos=%ld, sglen=%d kadoff=%p\n", __FUNCTION__,
+		//cur_pos, sg->length, kaddr_off);
+		if (NULL == kaddr)
+			return -1;
+
+		if (from <= cur_pos) {
+			start_pos = cur_pos;
+		}  else {
+			if (from < (cur_pos + sg->length)) {
+				/* copy start with middle of this segment */
+				start_pos = from;
+				kaddr_off += from - start_pos;
+			} else {
+				/* this segment does not have any desired data */
+				kunmap_atomic(kaddr, KM_USER0);
+				continue;
+			}
+		}
+
+		if (to < (cur_pos + sg->length)) {
+			/* copy end with middle of this segment */
+			end_pos = to;
+			fin = 1;
+		} else {
+			end_pos = cur_pos + sg->length;
+		}
+
+		if (start_pos < end_pos) {
+			//DPRINTK(KERN_ERR "%s: COPY start=%ld end=%ld kaddoff=%p\n", __FUNCTION__,
+			//start_pos, end_pos, kaddr_off);
+			memcpy(arr + len, kaddr_off, end_pos - start_pos);
+			len += end_pos - start_pos;
+		}
+		kunmap_atomic(kaddr, KM_USER0);
+
+	}
+	DPRINTK(KERN_ERR "%s: return ren=%ld\n", __FUNCTION__, len);
+	return len;
+}
+
+
+/*
+ * issue PACKET command according to passed SRB
+ * caller will block until the command completed.
+ * returns 0 if command sucessfully done,
+ * otherwise error detected.
+ * if auto_sense is on, request_sense is automatically issued and
+ * return the sense data into srb->sensebuffer[SCSI_SENSE_BUFFERSIZE]
+ * srb->result will be set.
+ * caller should call done(srb) to inform mid layer the command completed.
+ */
+static int issue_atapi_by_srb(struct ps3_stor_dev_info * dev_info,
+			      int auto_sense)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	struct lv1_atapi_cmnd_block atapi_cmnd;
+	const struct scsi_command_handler_info * handler_info;
+	unsigned char * cmnd = dev_info->srb->cmnd;
+	int bounce_len = 0;
+	int error;
+	unsigned char keys[4];
+
+	handler_info = &(dev_info->handler_info[cmnd[0]]);
+
+	/* check buffer size */
+	switch (handler_info->buflen) {
+	case USE_SRB_6:
+		bounce_len = cmnd[4];
+		break;
+	case USE_SRB_10:
+ 		bounce_len = (cmnd[7] << 8) | cmnd[8];
+		break;
+	case USE_CDDA_FRAME_RAW:
+		bounce_len = ((cmnd[6] << 16) |
+		       (cmnd[7] <<  8) |
+		       (cmnd[8] <<  0)) * CD_FRAMESIZE_RAW;
+		break;
+	default:
+		bounce_len = handler_info->buflen;
+	}
+
+	if (dev_info->dedicated_bounce_size < bounce_len ) {
+		static int printed;
+		if (!printed++)
+			printk(KERN_ERR "%s: data size too large %#x<%#x\n",
+			       __FUNCTION__,
+			       dev_info->dedicated_bounce_size,
+			       bounce_len);
+		dev_info->srb->result = DID_ERROR << 16;
+		memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		dev_info->srb->sense_buffer[0] = 0x70;
+		dev_info->srb->sense_buffer[2] = ILLEGAL_REQUEST;
+		return -1;
+	}
+
+	memset(&atapi_cmnd, 0, sizeof(struct lv1_atapi_cmnd_block));
+	memcpy(&(atapi_cmnd.pkt), cmnd, 12);
+	atapi_cmnd.pktlen = 12;
+	atapi_cmnd.proto = handler_info->proto;
+	if (handler_info->in_out != DIR_NA)
+		atapi_cmnd.in_out = handler_info->in_out;
+
+	if (atapi_cmnd.in_out == DIR_WRITE)
+		fetch_to_dev_buffer(dev_info->srb, dev_info->bounce_buf, bounce_len);
+
+	atapi_cmnd.block_size = 1; /* transfer size is block_size * blocks */
+
+	atapi_cmnd.blocks = atapi_cmnd.arglen = bounce_len;
+	atapi_cmnd.buffer = ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf);
+
+	/* issue command */
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_send_device_command(lv1_dev_info->repo.did.dev_id,
+						LV1_STORAGE_SEND_ATAPI_COMMAND,
+						ps3_mm_phys_to_lpar(__pa(&atapi_cmnd)),
+						sizeof(struct lv1_atapi_cmnd_block),
+						atapi_cmnd.buffer,
+						atapi_cmnd.arglen,
+						&lv1_dev_info->current_tag);
+	if (error) {
+		printk(KERN_ERR "%s: send_device failed lv1dev=%u ret=%d\n",
+		       __FUNCTION__, lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: is better other error code ? */
+		return -1;
+	}
+
+	/* wait interrupt */
+	wait_for_completion(&(dev_info->irq_done));
+
+	/* check error */
+	if (!dev_info->lv1_status) {
+		/* OK, completed */
+		if (atapi_cmnd.in_out == DIR_READ)
+			fill_from_dev_buffer(dev_info->srb, dev_info->bounce_buf, bounce_len);
+		dev_info->srb->result = DID_OK << 16;
+		return 0;
+	}
+
+	/* error */
+	if (!auto_sense) {
+		dev_info->srb->result = (DID_ERROR << 16) | (CHECK_CONDITION << 1);
+		printk(KERN_ERR "%s: end error withtout autosense\n", __FUNCTION__);
+		return 1;
+	}
+
+	if (!decode_lv1_status(dev_info->lv1_status,
+			       &(keys[0]), &(keys[1]), &(keys[2]))) {
+		/* lv1 may have issued autosense ... */
+		dev_info->srb->sense_buffer[0]  = 0x70;
+		dev_info->srb->sense_buffer[2]  = keys[0];
+		dev_info->srb->sense_buffer[7]  = 16 - 6;
+		dev_info->srb->sense_buffer[12] = keys[1];
+		dev_info->srb->sense_buffer[13] = keys[2];
+		dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+	} else {
+		/* do auto sense by our selves*/
+		memset(&atapi_cmnd, 0, sizeof(struct lv1_atapi_cmnd_block));
+		atapi_cmnd.pkt[0] = REQUEST_SENSE;
+		atapi_cmnd.pkt[4] = 18;
+		atapi_cmnd.pktlen = 12;
+		atapi_cmnd.arglen = atapi_cmnd.blocks = atapi_cmnd.pkt[4];
+		atapi_cmnd.block_size = 1;
+		atapi_cmnd.proto = DMA_PROTO;
+		atapi_cmnd.in_out = DIR_READ;
+		atapi_cmnd.buffer = ps3_stor_virtual_to_lpar(dev_info,dev_info->bounce_buf);
+
+		/* issue REQUEST_SENSE command */
+		init_completion(&(dev_info->irq_done));
+		error = lv1_storage_send_device_command(lv1_dev_info->repo.did.dev_id,
+							LV1_STORAGE_SEND_ATAPI_COMMAND,
+							ps3_mm_phys_to_lpar(__pa(&atapi_cmnd)),
+							sizeof(struct lv1_atapi_cmnd_block),
+							atapi_cmnd.buffer,
+							atapi_cmnd.arglen,
+							&lv1_dev_info->current_tag);
+		if (error) {
+			printk(KERN_ERR "%s: send_device for request sense failed lv1dev=%u ret=%d\n", __FUNCTION__,
+			       lv1_dev_info->repo.did.dev_id, error);
+			dev_info->srb->result = DID_ERROR << 16; /* FIXME: is better other error code ? */
+			return -1;
+		}
+
+		/* wait interrupt */
+		wait_for_completion(&(dev_info->irq_done));
+
+		/* scsi spec says request sense should never get error */
+		if (dev_info->lv1_status) {
+			decode_lv1_status(dev_info->lv1_status,
+					  &(keys[0]), &(keys[1]), &(keys[2]));
+			printk(KERN_ERR "%s: auto REQUEST_SENSE error %#x %#x %#x\n", __FUNCTION__,
+			       keys[0], keys[1], keys[2]);
+		}
+
+		memcpy(dev_info->srb->sense_buffer, dev_info->bounce_buf,
+		       min((int)atapi_cmnd.pkt[4], SCSI_SENSE_BUFFERSIZE));
+		dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+	}
+
+	return 1;
+}
+
+/*
+ * just send command with auto REQUEST_SENSE
+ */
+static int ps3_stor_atapi_handle_simple(struct ps3_stor_dev_info * dev_info,
+				        struct scsi_cmnd * srb)
+{
+	int ret;
+
+	ret = issue_atapi_by_srb(dev_info, 1);
+	ps3_stor_srb_done(dev_info);
+	return ret;
+}
+
+/*
+ * just send command WITHOUT auto REQUEST_SENSE
+ */
+static int ps3_stor_atapi_handle_request_sense(struct ps3_stor_dev_info * dev_info, struct scsi_cmnd * srb)
+{
+	int ret;
+
+	ret = issue_atapi_by_srb(dev_info, 0);
+	ps3_stor_srb_done(dev_info);
+	return ret;
+}
+
+/******************************************************
+ * handlers for HDD
+ */
+
+static int ps3_stor_hdd_handle_inquiry(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	unsigned char inquiry_reply[PS3_STOR_MAX_INQUIRY_DATA_SIZE];
+	unsigned char *cmd = srb->cmnd;
+	const char * msg;
+	int alloc_len;
+	int ret;
+
+	FUNC_START;
+	alloc_len = (cmd[3] << 8) + cmd[4];
+	memset(inquiry_reply, 0, PS3_STOR_MAX_INQUIRY_DATA_SIZE);
+	inquiry_reply[0] = lv1_dev_info->device_type;
+	inquiry_reply[1] = 0;  /* Removable flag */
+	inquiry_reply[2] = 2;  /* ANSI version */
+	inquiry_reply[3] = 2;  /* response_data_format==2 */
+	inquiry_reply[4] = PS3_STOR_INQUIRY_DATA_SIZE - 5;
+
+	sprintf(&inquiry_reply[8], "%-8s", "SCEI");
+	if (lv1_dev_info->device_type == PS3_DEV_TYPE_STOR_DISK) {
+		switch (lv1_dev_info->attached_port) {
+		case 0:
+			msg = "Pri:Master";
+			break;
+		case 1:
+			msg = "Pri:Slave";
+			break;
+		case 2:
+			msg = "Sec:Master";
+			break;
+		case 3:
+			msg = "Sec:Slave";
+			break;
+		default:
+			msg = "Unknown";
+			break;
+
+		}
+	} else {
+		msg = "Flash";
+	}
+
+	/* SCSI spec requires model name left aligned, spece padded */
+	ret = sprintf(&inquiry_reply[16], "%s-%d", msg,
+		      lv1_dev_info->region_info_array[srb->cmnd[1]>>5].region_index);
+	if (ret < 16)
+		memset(&(inquiry_reply[16 + ret]), ' ', 16 - ret);
+
+	sprintf(&inquiry_reply[32], "%-4d", 4989);
+
+	inquiry_reply[58] = 0x0; inquiry_reply[59] = 0x40; /* SAM-2 */
+	inquiry_reply[60] = 0x3; inquiry_reply[61] = 0x0;  /* SPC-3 */
+	inquiry_reply[62] = 0x1; inquiry_reply[63] = 0x80; /* SBC */
+
+	ret = fill_from_dev_buffer(dev_info->srb, inquiry_reply, min(alloc_len, PS3_STOR_INQUIRY_DATA_SIZE));
+
+	srb->result = DID_OK << 16;
+	ps3_stor_srb_done(dev_info);
+	FUNC_END;
+	return ret;
+}
+
+
+static int ps3_stor_hdd_handle_request_sense(struct ps3_stor_dev_info * dev_info, struct scsi_cmnd * srb)
+{
+	unsigned char sense_data[PS3_STOR_SENSE_LEN];
+	int len = 18;
+
+	memset(sense_data, 0, PS3_STOR_SENSE_LEN);
+
+	if (dev_info->lv1_status) {
+		if (!decode_lv1_status(dev_info->lv1_status,
+				       &(sense_data[2]),
+				       &(sense_data[12]),
+				       &(sense_data[13]))) {
+		} else {
+			/* unknown error */
+			printk(KERN_ERR "%s: FIXME issue real RS %#lx %d\n",
+			       __FUNCTION__, dev_info->lv1_status,
+			       dev_info->lv1_retval);
+			sense_data[2] = HARDWARE_ERROR;
+			dev_info->srb->result = DID_OK << 16;
+		}
+		sense_data[0] = 0x70;
+	} else {
+		/* no sense */
+		sense_data[0] = 0x70;
+		dev_info->srb->result = DID_OK << 16;
+	}
+
+	fill_from_dev_buffer(dev_info->srb, sense_data, len);
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+static int ps3_stor_hdd_handle_just_ok(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	dev_info->srb->result = DID_OK << 16;
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+static int ps3_stor_hdd_handle_sync_cache(struct ps3_stor_dev_info * dev_info,
+					  struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	unsigned char keys[4];
+	int error;
+
+	/* issue command */
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_send_device_command(lv1_dev_info->repo.did.dev_id,
+						LV1_STORAGE_ATA_HDDOUT,
+						0,
+						0,
+						0,
+						0,
+						&lv1_dev_info->current_tag);
+	if (error) {
+		/* error */
+		printk(KERN_ERR "%s: send_device failed. lv1dev=%u ret=%d\n",
+		       __FUNCTION__, lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: is better other error code? */
+	} else {
+		/* wait interrupt */
+		wait_for_completion(&(dev_info->irq_done));
+
+		/* check error */
+		if (!dev_info->lv1_status) {
+			dev_info->srb->result = DID_OK << 16;
+		} else {
+			decode_lv1_status(dev_info->lv1_status,
+					  &(keys[0]), &(keys[1]), &(keys[2]));
+			dev_info->srb->sense_buffer[0]  = 0x70;
+			dev_info->srb->sense_buffer[2]  = keys[0];
+			dev_info->srb->sense_buffer[7]  = 16 - 6;
+			dev_info->srb->sense_buffer[12] = keys[1];
+			dev_info->srb->sense_buffer[13] = keys[2];
+			dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+		}
+	}
+
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+static int ps3_stor_hdd_handle_read_capacity(struct ps3_stor_dev_info * dev_info, struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	unsigned char data[PS3_STOR_READCAP_DATA_SIZE];
+	u64 len;
+	int ret;
+
+	FUNC_START;
+	memset(data, 0, sizeof(data));
+	len = lv1_dev_info->region_info_array[srb->cmnd[1] >> 5].region_size - 1;
+	data[0] = (len >> 24) & 0xff;
+	data[1] = (len >> 16) & 0xff;
+	data[2] = (len >> 8)  & 0xff;
+	data[3] =  len        & 0xff;
+
+	len = lv1_dev_info->sector_size;
+	data[4] = (len >> 24) & 0xff;
+	data[5] = (len >> 16) & 0xff;
+	data[6] = (len >> 8)  & 0xff;
+	data[7] =  len        & 0xff;
+
+	ret = fill_from_dev_buffer(dev_info->srb, data, PS3_STOR_READCAP_DATA_SIZE);
+	dev_info->srb->result = DID_OK << 16;
+	ps3_stor_srb_done(dev_info);
+	FUNC_END;
+	return ret;
+}
+
+
+static int copy_page_data(unsigned char * buf, const unsigned char * data,
+			   int length, int changable)
+{
+	if (changable) {
+		/* reports no parameters are changable */
+		memcpy(buf, data, 2);
+		memset(buf + 2, 0, length - 2);
+	} else {
+		memcpy(buf, data, length);
+	}
+	return length;
+}
+
+static int fill_mode_page(struct ps3_stor_dev_info * dev_info,
+			  unsigned char *buf, int page, int changable)
+{
+	int length;
+
+	switch (page){
+	case 8:
+		/* TYPE_DISK; see sd_read_cache_type():sd.c */
+		length = copy_page_data(buf, page_data_8, sizeof(page_data_8), changable);
+		break;
+	case 6:
+		/* TYPE_RBC */
+		length = copy_page_data(buf, page_data_6, sizeof(page_data_6), changable);
+		break;
+	case 0x3f: /* ALL PAGES, but sd.c checks only parameter header to see WriteProtect */
+		length  = copy_page_data(buf, page_data_6, sizeof(page_data_6), changable);
+		length += copy_page_data(buf + length, page_data_8, sizeof(page_data_8), changable);
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown page=%#x\n", __FUNCTION__, page);
+		return 0;
+	}
+
+	return length;
+}
+
+/*
+ * scsi disk driver asks only PAGE= 0x3f, 6(RBC), 8(SCSI disk)
+ */
+static int ps3_stor_hdd_handle_mode_sense(struct ps3_stor_dev_info * dev_info,
+					  struct scsi_cmnd * srb)
+{
+	unsigned char sense_data[128];
+	int offset = 0;
+
+	/*
+	 * NOTE: support MODE_SENSE_10 only
+	 * see slave_cofigure()
+	 */
+	memset(sense_data, 0, sizeof(sense_data));
+	/* parameter header */
+	sense_data[2] = dev_info->lv1_dev_info->device_type;
+	sense_data[3] = 0;      /* mid layer wants to see here     */
+	/* bit 7=1 means WriteProtected    */
+	offset = fill_mode_page(dev_info,
+				&(sense_data[8]),
+				dev_info->srb->cmnd[2] & 0x3f,
+				dev_info->srb->cmnd[2] & 0xc0);
+	sense_data[1] = offset + 8;        /* parameter length */
+	sense_data[0] = (offset + 8) >> 8;
+
+	fill_from_dev_buffer(dev_info->srb, sense_data, offset + 8);
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+
+/*
+ * convert kernel virtal address to lpar address for storage IO
+ * NOTE: va should be within allocated special buffer
+ *       if DEDICATED_SPECIAL bounce type
+ */
+static u64 ps3_stor_virtual_to_lpar(struct ps3_stor_dev_info *dev_info,
+				    void *va)
+{
+	if (unlikely(dev_info->bounce_type == DEDICATED_SPECIAL)) {
+		return dev_info->separate_bounce_lpar + (va - dev_info->bounce_buf);
+	} else {
+		return ps3_mm_phys_to_lpar(__pa(va));
+	}
+}
+
+
+static int ps3_stor_common_handle_read(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	int error;
+	u64 lpar_addr;
+	unsigned int region_id;
+	u32 sectors = 0;
+	u32 start_sector = 0;
+	unsigned char *cmnd = dev_info->srb->cmnd;
+	int ret = 0;
+
+	/* check transfer length */
+	switch (cmnd[0]) {
+	case READ_10:
+		start_sector = (cmnd[2] << 24) +
+			(cmnd[3] << 16) +
+			(cmnd[4] <<  8) +
+			cmnd[5];
+		sectors = (cmnd[7] << 8) +
+			cmnd[8];
+		break;
+	case READ_6:
+		start_sector = (cmnd[1] << 16) +
+			(cmnd[2] <<  8) +
+			cmnd[3];
+		sectors = cmnd[4];
+		break;
+
+	}
+
+	/* issue read */
+	down_read(&dev_info->bounce_sem);
+	lpar_addr = ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf);
+	region_id = lv1_dev_info->region_info_array[(cmnd[1] >> 5)].region_id;
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+				 region_id,
+				 start_sector,
+				 sectors,
+				 0, /* flags */
+				 lpar_addr,
+				 &lv1_dev_info->current_tag);
+	if (error) {
+		/* error */
+		printk(KERN_ERR "%s: error lv1dev =%u ret=%d\n", __FUNCTION__,
+		       lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+		ret = -1;
+	} else {
+		/* wait irq */
+		wait_for_completion(&(dev_info->irq_done));
+		if (dev_info->lv1_status) {
+			/* error */
+			memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+			decode_lv1_status(dev_info->lv1_status,
+					  &(dev_info->srb->sense_buffer[2]),
+					  &(dev_info->srb->sense_buffer[12]),
+					  &(dev_info->srb->sense_buffer[13]));
+			dev_info->srb->sense_buffer[7] = 16 - 6;
+			dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+			ret =  1;
+		} else {
+			/* OK */
+			fill_from_dev_buffer(dev_info->srb,
+					     dev_info->bounce_buf,
+					     sectors * dev_info->sector_size);
+
+			dev_info->srb->result = DID_OK << 16;
+			ret =  0;
+		}
+	}
+
+	ps3_stor_srb_done(dev_info);
+	up_read(&dev_info->bounce_sem);
+	return ret;
+}
+
+static int ps3_stor_common_handle_write(struct ps3_stor_dev_info * dev_info,
+					struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	int ret;
+	int error;
+	u64 lpar_addr;
+	unsigned int region_id;
+	u32 start_sector = 0;
+	u32 sectors = 0;
+	unsigned char * cmnd = dev_info->srb->cmnd;
+
+	/* check transfer length */
+	switch (cmnd[0]) {
+	case WRITE_10:
+		start_sector = (cmnd[2] << 24) +
+			(cmnd[3] << 16) +
+			(cmnd[4] <<  8) +
+			cmnd[5];
+		sectors = (cmnd[7] << 8) +
+			cmnd[8];
+		break;
+	case WRITE_6:
+		start_sector = (cmnd[1] << 16) +
+			(cmnd[2] <<  8) +
+			cmnd[3];
+		sectors = cmnd[4];
+		break;
+	}
+
+	down_read(&dev_info->bounce_sem);
+	ret = fetch_to_dev_buffer(dev_info->srb,
+				  dev_info->bounce_buf,
+				  sectors * dev_info->sector_size);
+
+	lpar_addr = ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf);
+	region_id = lv1_dev_info->region_info_array[(cmnd[1] >> 5)].region_id;
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_write(lv1_dev_info->repo.did.dev_id,
+				  region_id, /* region id */
+				  start_sector,
+				  sectors,
+				  0, /* flags */
+				  lpar_addr/*srb->request_buffer*/, /* assume non SG! */
+				  &lv1_dev_info->current_tag);
+	if (error) {
+		/* error */
+		printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n", __FUNCTION__,
+		       lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+		ret = -1;
+	} else {
+
+		/* wait irq */
+		wait_for_completion(&(dev_info->irq_done));
+
+		if (dev_info->lv1_status) {
+			/* error */
+			memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+			decode_lv1_status(dev_info->lv1_status,
+					  &(dev_info->srb->sense_buffer[2]),
+					  &(dev_info->srb->sense_buffer[12]),
+					  &(dev_info->srb->sense_buffer[13]));
+			dev_info->srb->sense_buffer[7] = 16 - 6;
+			dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+			ret = 1;
+		} else {
+			/* OK */
+			dev_info->srb->result = DID_OK << 16;
+			ret = 0;
+		}
+
+	}
+	ps3_stor_srb_done(dev_info);
+	up_read(&dev_info->bounce_sem);
+	return ret;
+}
+
+static int is_aligned_flash(u32 sector, int sector_size)
+{
+	u32 flash_align_sector = FLASH_ALIGN / sector_size;
+
+	return (sector % flash_align_sector)? 0 : 1;
+}
+
+static u32 floor_align_flash(u32 sector, int sector_size)
+{
+	u32 flash_align_sector = FLASH_ALIGN / sector_size;
+
+	return sector & ~(flash_align_sector - 1);
+}
+
+static u32 ceil_align_flash(u32 sector, int sector_size)
+{
+	u32 flash_align_sector = FLASH_ALIGN / sector_size;
+
+	return (sector + (flash_align_sector - 1)) & ~(flash_align_sector - 1);
+}
+
+/*
+ * special handling for flash drive; do safer way to write in order to reduce
+ * the risk of flash corruption by sudden power off.
+ */
+static int ps3_stor_handle_write_flash(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	int ret = 0;
+	int error;
+	u64 sector_size;
+	u64 lpar_addr;
+	unsigned int region_id;
+	u64 start_sector = 0;
+	u64 start_sector_aligned = 0;
+	u64 sectors = 0;
+	u64 sectors_aligned = 0;
+	u64 current_sector;
+	u64 aligned_sector_count;
+	unsigned char * cmnd = dev_info->srb->cmnd;
+	void * current_buffer;
+	struct ps3_stor_lv1_region_info * region_info;
+
+	static int align_warned;
+
+	DPRINTK(KERN_ERR "%s: start\n", __FUNCTION__);
+
+	/* check transfer length */
+	switch (cmnd[0]) {
+	case WRITE_10:
+		start_sector = (cmnd[2] << 24) +
+			(cmnd[3] << 16) +
+			(cmnd[4] <<  8) +
+			cmnd[5];
+		sectors = (cmnd[7] << 8) +
+			cmnd[8];
+		break;
+	case WRITE_6:
+		start_sector = (cmnd[1] << 16) +
+			(cmnd[2] <<  8) +
+			cmnd[3];
+		sectors = cmnd[4];
+		break;
+	}
+
+
+        /*
+         *    start_sector_aligned
+         *   /          start_sector
+         *  /          /
+         * +----------+--------------------+---+
+         *            |<-    sectors     ->|   |
+         *            |<-   sectors_aligned  ->|
+         *
+         * ^-----------------------------------^ 256K align
+         */
+	sector_size = dev_info->sector_size;
+	aligned_sector_count = FLASH_ALIGN / sector_size;
+
+	start_sector_aligned = floor_align_flash(start_sector, sector_size);
+	sectors_aligned = ceil_align_flash(start_sector + sectors, sector_size) - start_sector;
+
+	/* check aligned border exceed region */
+	region_info = &lv1_dev_info->region_info_array[cmnd[1] >> 5];
+	if (!is_aligned_flash(region_info->region_start, sector_size) ||
+	    (region_info->region_size < (start_sector_aligned + sectors_aligned))) {
+		if (!align_warned) {
+			printk(KERN_ERR "%s: region alignment is not 256k, continue to work with norman method\n",
+			       __FUNCTION__);
+			align_warned = 1;
+		}
+		return ps3_stor_common_handle_write(dev_info, srb);
+	};
+
+	down_read(&dev_info->bounce_sem);
+	region_id = region_info->region_id;
+
+
+	DPRINTK(KERN_ERR "%s: start=%#lx(%ld) start_a=%#lx(%ld) sec=%#lx(%ld) sec_a=%#lx(%ld)\n", __FUNCTION__,
+		start_sector, start_sector,
+		start_sector_aligned, start_sector_aligned,
+		sectors, sectors,
+		sectors_aligned, sectors_aligned);
+
+	/*
+	 * loop in the case that the requested write sectors across
+	 * 245Kb alignment.  Since we have set max_sectors as 256kb,
+	 * loop count is up to 2.
+	 */
+	for (current_sector = start_sector_aligned, ret = 0;
+	     (current_sector < (start_sector + sectors_aligned)) && !ret;
+	     current_sector += aligned_sector_count) {
+
+		DPRINTK(KERN_ERR "%s: LOOP current=%#lx\n", __FUNCTION__, current_sector);
+
+		current_buffer = dev_info->bounce_buf;
+
+		/* read from (start_sector_aligned) to (start_sector) */
+		if (current_sector < start_sector) {
+			DPRINTK(KERN_ERR "%s: head read \n", __FUNCTION__);
+			lpar_addr = ps3_stor_virtual_to_lpar(dev_info,
+							     current_buffer);
+			init_completion(&(dev_info->irq_done));
+			error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+						 region_id,
+						 current_sector,
+						 start_sector - current_sector,
+						 0,
+						 lpar_addr,
+						 &lv1_dev_info->current_tag);
+			DPRINTK(KERN_ERR "HEAD start=%#lx, len=%#lx\n",
+				start_sector_aligned, (start_sector - start_sector_aligned));
+			if (error) {
+				/* error */
+				printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n",
+				       __FUNCTION__,
+				       lv1_dev_info->repo.did.dev_id, error);
+				dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+				ret = -1;
+				goto done;
+			} else {
+				/* wait irq */
+				wait_for_completion(&(dev_info->irq_done));
+			}
+			if (dev_info->lv1_status) {
+				/* error */
+				memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+				decode_lv1_status(dev_info->lv1_status,
+						  &(dev_info->srb->sense_buffer[2]),
+						  &(dev_info->srb->sense_buffer[12]),
+						  &(dev_info->srb->sense_buffer[13]));
+				dev_info->srb->sense_buffer[7] = 16 - 6;
+				dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+				ret = 1;
+				goto done;
+			} else {
+				/* OK */
+				ret = 0;
+				current_buffer += (start_sector - start_sector_aligned) * sector_size;
+			}
+		} /* head remainder */
+
+
+		if ((start_sector + sectors) < (current_sector + aligned_sector_count)) {
+			void * buf = dev_info->bounce_buf;
+			DPRINTK(KERN_ERR "%s: tail read\n", __FUNCTION__);
+			buf += (start_sector + sectors - current_sector) * sector_size;
+			lpar_addr = ps3_stor_virtual_to_lpar(dev_info, buf);
+			init_completion(&(dev_info->irq_done));
+			error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+						 region_id,
+						 start_sector + sectors,
+						 sectors_aligned - sectors,
+						 0,
+						 lpar_addr,
+						 &lv1_dev_info->current_tag);
+			DPRINTK(KERN_ERR "TAIL start=%#lx, len=%#lx\n",
+				start_sector + sectors, sectors_aligned - sectors);
+			if (error) {
+				/* error */
+				printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n",
+				       __FUNCTION__,
+				       lv1_dev_info->repo.did.dev_id, error);
+				dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+				ret = -1;
+				goto done;
+			} else {
+				/* wait irq */
+				wait_for_completion(&(dev_info->irq_done));
+			}
+			if (dev_info->lv1_status) {
+				/* error */
+				memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+				decode_lv1_status(dev_info->lv1_status,
+						  &(dev_info->srb->sense_buffer[2]),
+						  &(dev_info->srb->sense_buffer[12]),
+						  &(dev_info->srb->sense_buffer[13]));
+				dev_info->srb->sense_buffer[7] = 16 - 6;
+				dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+				ret = 1;
+				goto done;
+			} else {
+				/* OK */
+				ret = 0;
+			}
+		} /* tail remainder */
+
+		{
+			u64 copy_sectors_from, copy_sectors_to;
+
+			/* start_sector is within this iteration */
+			if ((current_sector < start_sector)  &&
+			    (start_sector < (current_sector + aligned_sector_count))) {
+				copy_sectors_from = start_sector;
+			}
+			else {
+				copy_sectors_from = current_sector;
+			}
+
+			/* start_sector+sectors is within this iteration */
+			if ((current_sector < (start_sector + sectors))  &&
+			    ((start_sector + sectors) < (current_sector + aligned_sector_count))) {
+				copy_sectors_to = start_sector + sectors;
+			}
+			else {
+				copy_sectors_to = current_sector + aligned_sector_count;
+			}
+
+			DPRINTK(KERN_ERR "%s: copy to current=%p\n", __FUNCTION__, current_buffer);
+			ret = fetch_to_dev_buffer_abs(dev_info->srb,
+						      current_buffer,
+						      (copy_sectors_from - start_sector) * sector_size,
+						      (copy_sectors_to - start_sector) * sector_size);
+		} /* write data */
+
+		/* write 256K */
+		DPRINTK(KERN_ERR "%s: WRITE sector=%#lx\n", __FUNCTION__, current_sector);
+		lpar_addr = ps3_stor_virtual_to_lpar(dev_info,
+						     dev_info->bounce_buf);
+		init_completion(&(dev_info->irq_done));
+		error = lv1_storage_write(lv1_dev_info->repo.did.dev_id,
+					  region_id,
+					  current_sector,
+					  aligned_sector_count,
+					  0,
+					  lpar_addr,
+					  &lv1_dev_info->current_tag);
+		if (error) {
+			/* error */
+			printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n",
+			       __FUNCTION__, lv1_dev_info->repo.did.dev_id,
+			       error);
+			dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+			ret = -1;
+		} else {
+
+			/* wait irq */
+			wait_for_completion(&(dev_info->irq_done));
+
+			if (dev_info->lv1_status) {
+				/* error */
+				memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+				decode_lv1_status(dev_info->lv1_status,
+						  &(dev_info->srb->sense_buffer[2]),
+						  &(dev_info->srb->sense_buffer[12]),
+						  &(dev_info->srb->sense_buffer[13]));
+				dev_info->srb->sense_buffer[7] = 16 - 6;
+				dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+				ret = 1;
+			} else {
+				/* OK */
+				dev_info->srb->result = DID_OK << 16;
+				ret = 0;
+			}
+
+		}
+	} /* for */
+ done:
+	ps3_stor_srb_done(dev_info);
+	up_read(&dev_info->bounce_sem);
+	DPRINTK(KERN_ERR "%s: end\n", __FUNCTION__);
+	return ret;
+}
+
+/*
+ * NOTE: If return 1, all buffers communicate with the device
+ *       should be in dedicated buffer area.
+ *       Currently common_handle_read, common_handle_write know this
+ *       restriction.
+ *       And should implement remap function in ps3_stor_set_max_sectors()
+ */
+static int need_dedicated_dma_region(enum ps3_dev_type device_type)
+{
+	int ret = 0;
+	switch (device_type) {
+	case PS3_DEV_TYPE_STOR_FLASH:
+		ret = 1; /* should be 1 */
+		break;
+	case PS3_DEV_TYPE_STOR_ROM:
+		ret = 0;
+		break;
+	case PS3_DEV_TYPE_STOR_DISK:
+		ret = 0;
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown type =%u\n", __FUNCTION__,
+		       device_type);
+		ret =  0;
+		break;
+	}
+	return ret;
+}
+/*
+ * allocate static(dedicated) bounce buffer
+ */
+static int get_dedicated_buffer_type(enum ps3_dev_type device_type)
+{
+	int ret = 0;
+	switch (device_type) {
+	case PS3_DEV_TYPE_STOR_FLASH:
+		ret = DEDICATED_SPECIAL;
+		break;
+	case PS3_DEV_TYPE_STOR_ROM:
+		ret = DEDICATED_KMALLOC;
+		break;
+	case PS3_DEV_TYPE_STOR_DISK:
+		ret = DEDICATED_KMALLOC;
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown type =%u\n", __FUNCTION__,
+		       device_type);
+		ret =  0;
+		break;
+	}
+	return ret;
+}
+
+
+extern unsigned long ps3_mem_total;
+extern unsigned long ps3_rm_limit;
+extern unsigned long ps3_2nd_mem_base;
+extern unsigned long ps3_2nd_mem_size;
+
+#define PS3_PCI_DMA_SIZE(mem) ((((mem -1) >> 27) + 1 ) << 27) /* 2^27=128M */
+#define PS3_PCI_IO_PAGESIZE      24
+
+static u64 ps3_allocate_dma_region(const struct ps3_device_id *did)
+{
+	u64 size, io_size, io_pagesize;
+	u64 dma, flg = 0;
+	int error;
+
+	io_size = PS3_PCI_DMA_SIZE(ps3_mem_total);
+	io_pagesize = PS3_PCI_IO_PAGESIZE;
+	error = lv1_allocate_device_dma_region(did->bus_id, did->dev_id,
+					       io_size, io_pagesize, flg,
+					       &dma);
+	if (error) {
+		printk("lv1_allocate_device_dma_region faild, error=%d\n",
+			error);
+		return 0;
+	}
+
+	size = ps3_rm_limit;
+	error = lv1_map_device_dma_region(did->bus_id, did->dev_id,
+					  0, /* lpar addr */
+					  dma, /* I/O addr */
+					  size,
+					  0xf800000000000000UL  /* flags */);
+	if (error) {
+		printk("lv1_map_device_dma_region faild, error=%d\n", error);
+		return 0;
+	}
+
+	size = ps3_2nd_mem_size;
+	error = lv1_map_device_dma_region(did->bus_id, did->dev_id,
+					  ps3_2nd_mem_base,   /* lpar addr */
+					  ps3_rm_limit + dma, /* I/O addr */
+					  size,
+					  0xf800000000000000UL  /* flags */);
+
+	if (error) {
+		printk("lv1_map_device_dma_region faild, error=%d\n", error);
+		return 0;
+	}
+	return dma;
+}
+
+static u64 ps3_free_dma_region(const struct ps3_device_id *did, u64 dma)
+{
+	u64 size, io_size, io_pagesize;
+	int error;
+
+	io_size = PS3_PCI_DMA_SIZE(ps3_mem_total);
+	io_pagesize = PS3_PCI_IO_PAGESIZE;
+
+	if (dma == 0)
+		return 0;
+
+	/* unmap dma_region */
+	size = ps3_rm_limit;
+	error = lv1_unmap_device_dma_region(did->bus_id, did->dev_id,
+					    dma, /* I/O addr */
+					    size);
+	if (error)
+		printk("lv1_unmap_device_dma_region faild, error=%d\n", error);
+	size = ps3_2nd_mem_size;
+	error = lv1_unmap_device_dma_region(did->bus_id, did->dev_id,
+					    ps3_rm_limit +  dma, /* I/O addr */
+					    size);
+
+	if (error)
+		printk("lv1_unmap_device_dma_region faild, error=%d\n", error);
+
+	/* free dma region */
+	error = lv1_free_device_dma_region(did->bus_id, did->dev_id, dma);
+	if (error)
+		printk("lv1_free_device_dma_region faild, error=%d\n", error);
+	return 0;
+}
+
+
+static void *ps3_stor_alloc_separate_memory(int alloc_size, u64 *lpar_addr)
+{
+	void * va;
+	BUG_ON(alloc_size != ps3_stor_bounce_buffer.size);
+	va = ps3_stor_bounce_buffer.address;
+	*lpar_addr = ps3_mm_phys_to_lpar(__pa(va));
+	return va;
+}
+
+static int ps3_stor_release_separate_memory(void *va, u64 lpar)
+{
+	/* Nothing to release anymore */
+	return 0;
+}
+
+
+static int get_default_max_sector(struct ps3_stor_lv1_dev_info * lv1_dev_info)
+{
+	int ret = 0;
+	switch (lv1_dev_info->device_type) {
+	case PS3_DEV_TYPE_STOR_FLASH:
+		ret = FLASH_ALIGN / lv1_dev_info->sector_size;
+		break;
+	case PS3_DEV_TYPE_STOR_ROM:
+		ret = 32;
+		break;
+	case PS3_DEV_TYPE_STOR_DISK:
+		ret =  128;
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown type =%u\n", __FUNCTION__,
+		       lv1_dev_info->device_type);
+		ret =  0;
+		break;
+	}
+	return ret;
+}
+
+
+static irqreturn_t ps3_stor_hdd_irq_handler(int irq, void * context)
+{
+	struct ps3_stor_lv1_dev_info * lv1_dev_info = context;
+	struct ps3_stor_dev_info * dev_info = lv1_dev_info->dev_info;
+	int ret_val = IRQ_HANDLED;
+	u64 tag;
+
+	if (dev_info) {
+		dev_info->lv1_retval = lv1_storage_get_async_status(lv1_dev_info->repo.did.dev_id,
+								    &tag,
+								    (u64 *)&dev_info->lv1_status);
+		/*
+		 * lv1_status = -1 may mean that ATAPI transport completed OK, but ATAPI command
+		 * itself resulted CHECK CONDITION
+		 * so, upper layer should issue REQUEST_SENSE to check the sense data
+		 */
+		if (tag != lv1_dev_info->current_tag)
+			printk("%s: tag=%#lx ctag=%#lx\n", __FUNCTION__,
+			       tag, lv1_dev_info->current_tag);
+		if (dev_info->lv1_retval) {
+			printk("%s: ret=%d status=%#lx\n", __FUNCTION__,
+			       dev_info->lv1_retval, dev_info->lv1_status);
+			//if (dev_info->lv1_retval == LV1_NO_ENTRY)
+			//ret_val = IRQ_NONE;
+		} else {
+			complete(&(dev_info->irq_done));
+		}
+	}
+	return ret_val;
+}
+
+
+/*
+ * return 1 specified region is accessible from linux
+ */
+static irqreturn_t ps3_stor_temporary_irq_handler(int irq, void * context)
+{
+	struct ps3_stor_quirk_probe_info * info = context;
+
+	info->lv1_retval = lv1_storage_get_async_status(info->device_id,
+							&info->lv1_ret_tag,
+							&info->lv1_status);
+	complete(&(info->irq_done));
+
+	return IRQ_HANDLED;
+}
+
+static int is_region_accessible(struct ps3_stor_lv1_dev_info * lv1_dev_info,
+				unsigned int region_id)
+{
+	int accessible = 0;
+	unsigned int irq_plug_id, dma_region;
+	void * buf;
+	struct ps3_stor_quirk_probe_info info;
+	int error;
+
+	/*
+	 * special case
+	 * cd-rom is assumed always accessible
+	 */
+	if (lv1_dev_info->device_type == PS3_DEV_TYPE_STOR_ROM)
+		return 1;
+
+	/*
+	 * 1. open the device
+	 * 2. register irq for the device
+	 * 3. connect irq
+	 * 4. map dma region
+	 * 5. do read
+	 * 6. umap dma region
+	 * 7. disconnect irq
+	 * 8. unregister irq
+	 * 9. close the device
+	 */
+	memset(&info, 0, sizeof(info));
+
+	error = lv1_open_device(lv1_dev_info->repo.did.bus_id,
+				lv1_dev_info->repo.did.dev_id, 0);
+	if (error)
+		return 0;
+
+	error = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+				      &lv1_dev_info->repo.did,
+				      lv1_dev_info->interrupt_id,
+				      &irq_plug_id);
+	if (error) {
+		printk("%s:%u: ps3_sb_event_receive_port_setup failed (%d)\n",
+		       __func__, __LINE__, error);
+		goto fail_close_device;
+	}
+
+	error = request_irq(irq_plug_id, ps3_stor_temporary_irq_handler,
+			    IRQF_DISABLED, "PS3 quirk", &info);
+	if (error) {
+		printk("%s:%d: request_irq failed (%d)\n", __func__, __LINE__,
+		       error);
+		goto fail_event_receive_port_destroy;
+	}
+
+	dma_region = ps3_allocate_dma_region(&lv1_dev_info->repo.did);
+	if (!dma_region)
+		goto fail_free_irq;
+
+	/* 4k buffer is for fail safe of large sector devices */
+	buf = kmalloc(4096, GFP_KERNEL);
+	if (!buf) {
+		printk(KERN_ERR "%s: no memory while probing dev=%u",
+		       __FUNCTION__, lv1_dev_info->repo.did.dev_id);
+		goto fail_free_dma_region;
+	};
+
+	init_completion(&(info.irq_done));
+	info.device_id = lv1_dev_info->repo.did.dev_id;
+	error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+				 region_id,
+				 0, /* start sector */
+				 1, /* sector count */
+				 0, /* flags */
+				 ps3_mm_phys_to_lpar(__pa(buf)), /* no need special convert */
+				 &info.lv1_tag);
+	if (error)
+		goto fail_free_buf;
+
+	wait_for_completion(&(info.irq_done));
+
+	if (!info.lv1_retval && !info.lv1_status) {
+		if (info.lv1_tag != info.lv1_ret_tag) {
+			printk(KERN_ERR "%s: tag mismached dev=%u\n",
+			       __FUNCTION__, lv1_dev_info->repo.did.dev_id);
+		} else
+			accessible = 1;
+	}
+
+fail_free_buf:
+	kfree(buf);
+fail_free_dma_region:
+	ps3_free_dma_region(&lv1_dev_info->repo.did, dma_region);
+fail_free_irq:
+	free_irq(irq_plug_id, &info);
+fail_event_receive_port_destroy:
+	ps3_sb_event_receive_port_destroy(&lv1_dev_info->repo.did,
+					  lv1_dev_info->interrupt_id,
+					  irq_plug_id);
+fail_close_device:
+	lv1_close_device(lv1_dev_info->repo.did.bus_id,
+			 lv1_dev_info->repo.did.dev_id);
+
+	return accessible;
+}
+
+static unsigned int ps3_stor_enum_storage_type(enum ps3_dev_type device_type)
+{
+	struct ps3_repository_device repo, *prev = NULL;
+	unsigned int devices = 0;
+	int error;
+	unsigned int interrupt_id, regions, region_id;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info;
+	u64 port, blksize, blocks, region_size, region_start;
+	unsigned int i, j, accessible_regions;
+
+	while (!(error = ps3_repository_find_device(PS3_BUS_TYPE_STORAGE,
+						    device_type, prev,
+						    &repo))) {
+		prev = &repo;
+		error = ps3_repository_find_interrupt(&repo,
+				PS3_INTERRUPT_TYPE_EVENT_PORT, &interrupt_id);
+		if (error) {
+			printk(KERN_ERR "%s: find_interrupt failed (%d)\n",
+			       __FUNCTION__, error);
+			continue;
+		}
+
+		error = ps3_repository_read_stor_dev_info(repo.bus_index,
+							  repo.dev_index,
+							  &port, &blksize,
+							  &blocks, &regions);
+		if (error) {
+			printk(KERN_ERR "%s: read_stor_dev_info failed\n",
+			       __FUNCTION__);
+			continue;
+		}
+
+		/* LUN limitation */
+		if (regions > 8) {
+			printk(KERN_ERR "%s: region count exceeded (%u).  the rest are ignored\n",
+			       __FUNCTION__, regions);
+			regions = 8;
+		}
+
+		lv1_dev_info = &(ps3_stor_lv1_dev_info_array[ps3_stor_lv1_devnum]);
+		INIT_LIST_HEAD(&(lv1_dev_info->bus_dev_list));
+
+		lv1_dev_info->repo = repo;
+		lv1_dev_info->device_type = device_type;
+		lv1_dev_info->interrupt_id = interrupt_id;
+		lv1_dev_info->sector_size = blksize;
+		lv1_dev_info->attached_port = port;
+		lv1_dev_info->regions = regions;
+
+		/* check how many regions are accessible */
+		accessible_regions = 0;
+		for (i = 0; i < regions; i++) {
+			if (is_region_accessible(lv1_dev_info, i)) {
+				set_bit(i, &(lv1_dev_info->accessible_region_flag));
+				accessible_regions ++;
+			}
+		}
+		if (!accessible_regions) {
+		    printk(KERN_WARNING "No accessible regions found\n");
+		    continue;
+		}
+
+		lv1_dev_info->region_info_array = kzalloc(sizeof(struct ps3_stor_lv1_region_info) * accessible_regions,
+							  GFP_KERNEL);
+		if (!lv1_dev_info->region_info_array) {
+			printk(KERN_ERR "%s: kzalloc failed for info array\n",
+			       __FUNCTION__);
+			continue;
+		}
+
+		lv1_dev_info->accessible_regions = accessible_regions;
+		for (i = j = 0; i < regions; i++) {
+			if (!test_bit(i, &lv1_dev_info->accessible_region_flag))
+				continue;
+
+			if (ps3_repository_read_stor_dev_region(repo.bus_index,
+							        repo.dev_index,
+								i, &region_id,
+							        &region_start,
+							        &region_size)) {
+				printk(KERN_ERR "%s: read_stor_dev_region failed\n",
+				       __FUNCTION__);
+				continue;
+			}
+			printk(KERN_INFO "Region %u: id %u start %lu size %lu\n",
+			       i, region_id, region_start, region_size);
+			lv1_dev_info->region_info_array[j].region_index = i;
+			lv1_dev_info->region_info_array[j].region_id = region_id;
+			lv1_dev_info->region_info_array[j].region_start = region_start;
+			lv1_dev_info->region_info_array[j].region_size = region_size;
+			j++;
+		}
+		printk(KERN_INFO "ps3_stor: dev=%u type=%u port=%lu regions=%u accessible=%u\n",
+		       repo.did.dev_id, device_type, port, regions,
+		       accessible_regions);
+		ps3_stor_lv1_devnum++;
+
+		devices++;
+	}
+	if (error != -ENODEV)
+		printk(KERN_ERR "%s: find_device failed: %d\n", __FUNCTION__,
+		       error);
+	return devices;
+}
+
+/*
+ * returns current number of found HDDs
+ * and collect device info
+ */
+static unsigned int ps3_stor_enum_storage_drives(void)
+{
+	unsigned int devices = 0;
+
+	printk("Looking for disk devices...\n");
+	devices += ps3_stor_enum_storage_type(PS3_DEV_TYPE_STOR_DISK);
+	printk("Looking for ROM devices...\n");
+	devices += ps3_stor_enum_storage_type(PS3_DEV_TYPE_STOR_ROM);
+	printk("Looking for FLASH devices...\n");
+	devices += ps3_stor_enum_storage_type(PS3_DEV_TYPE_STOR_FLASH);
+
+	return devices;
+}
+
+
+static void ps3_stor_device_release(struct device * device)
+{
+	FUNC_START;
+	// place holder
+	FUNC_END;
+}
+
+const static struct platform_device ps3_stor_platform_device = {
+	.name           = "ps3_storage",
+	.dev            = {
+		.release        = ps3_stor_device_release
+	}
+};
+
+
+/*
+  construct a host structure
+  and associated structures for
+  its devices.
+  register the host thru device_register()
+*/
+static int ps3_stor_add_adapter(struct ps3_stor_lv1_bus_info * lv1_bus_info)
+{
+	int k;
+        int error = 0;
+        struct ps3_stor_host_info *host_info;
+        struct ps3_stor_dev_info *dev_info;
+        struct list_head *lh, *lh_sf;
+
+        host_info = kzalloc(sizeof(struct ps3_stor_host_info), GFP_KERNEL);
+
+        if (NULL == host_info) {
+                printk(KERN_ERR "%s: out of memory \n", __FUNCTION__);
+                return -ENOMEM;
+        }
+        INIT_LIST_HEAD(&host_info->dev_info_list);
+	host_info->lv1_bus_info = lv1_bus_info;
+
+	/* create structures for child devices of this adapter */
+        for (k = 0; k < lv1_bus_info->devices; k++) {
+                dev_info = kzalloc(sizeof(struct ps3_stor_dev_info),
+				   GFP_KERNEL);
+                if (NULL == dev_info) {
+                        printk(KERN_ERR "%s: out of memory \n", __FUNCTION__);
+                        error = -ENOMEM;
+			goto clean;
+                }
+                dev_info->host_info = host_info;
+		INIT_LIST_HEAD(&dev_info->dev_list);
+		spin_lock_init(&dev_info->srb_lock);
+		init_rwsem(&dev_info->bounce_sem);
+                list_add_tail(&dev_info->dev_list, &host_info->dev_info_list);
+        }
+
+        spin_lock(&ps3_stor_host_list_lock);
+        list_add_tail(&host_info->host_list, &ps3_stor_host_list);
+        spin_unlock(&ps3_stor_host_list_lock);
+
+	/* copy struct platform_device */
+        host_info->dev =  ps3_stor_platform_device;
+        host_info->dev.id = ps3_stor_add_host;
+
+        error = platform_device_register(&host_info->dev);
+
+        if (error)
+		goto clean;
+
+	/* bump up registerd buses */
+	++ps3_stor_add_host;
+
+        return error;
+
+clean:
+	list_for_each_safe(lh, lh_sf, &host_info->dev_info_list) {
+		dev_info = list_entry(lh, struct ps3_stor_dev_info, dev_list);
+		list_del(&dev_info->dev_list);
+		kfree(dev_info);
+	}
+
+	kfree(host_info);
+        return error;
+}
+
+static void ps3_stor_remove_adapter(void)
+{
+        struct ps3_stor_host_info * host_info = NULL;
+
+        spin_lock(&ps3_stor_host_list_lock);
+        if (!list_empty(&ps3_stor_host_list)) {
+                host_info = list_entry(ps3_stor_host_list.prev,
+                                       struct ps3_stor_host_info, host_list);
+		list_del(&host_info->host_list);
+	}
+        spin_unlock(&ps3_stor_host_list_lock);
+
+	if (!host_info)
+		return;
+
+        platform_device_unregister(&host_info->dev);
+	kfree(host_info);
+        --ps3_stor_add_host;
+}
+
+static int ps3_stor_wait_device_ready(void)
+{
+	unsigned int bus_index, bus_id, num_of_dev;
+	int error;
+	u64 tag, status;
+	int retries;
+	int ret = 0;
+	int i;
+	u64 * buf;
+	int region_ready = 0;
+	int region_expected = 0;
+	struct device_probe_info * info_array;
+
+	/* find the storage bus */
+	error = ps3_repository_find_bus(PS3_BUS_TYPE_STORAGE, 0, &bus_index);
+	if (error) {
+		printk(KERN_ERR "%s: Cannot find storage bus (%d)\n",
+		       __FUNCTION__, error);
+		return 0;
+	}
+
+	error = ps3_repository_read_bus_id(bus_index, &bus_id);
+	if (error) {
+		printk(KERN_ERR "%s: read_bus_id failed (%d)\n", __FUNCTION__,
+		       error);
+		return 0;
+	}
+
+	error = ps3_repository_read_bus_num_dev(bus_index, &num_of_dev);
+	if (error) {
+		printk(KERN_ERR "%s: read_bus_num_dev failed (%d)\n",
+		       __FUNCTION__, error);
+		return 0;
+	}
+
+	/* 1) wait for expected devices becomes in repositry */
+	retries = 0;
+	while (retries++ < ps3_stor_wait_time)
+	{
+		if (ps3_repository_read_bus_num_dev(bus_index, &num_of_dev)) {
+			continue;
+		}
+		if (ps3_stor_wait_num_storages + 1 <= num_of_dev)
+			break;
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ);
+		printk(".");
+	}
+	printk("\n");
+
+	buf = kzalloc(512, GFP_KERNEL);
+	if (!buf)
+		return 0;
+
+	info_array = kzalloc(sizeof(struct device_probe_info) * num_of_dev, GFP_KERNEL);
+	if (!info_array) {
+		ret = -1;
+		goto cleanup_0;
+	}
+
+	/* 2) store the device info */
+	for (i = 0; i < num_of_dev; i++) {
+		if (ps3_repository_read_dev_id(bus_index, i,
+					       &info_array[i].device_id)) {
+			BUG();
+		}
+		ps3_repository_read_dev_type(bus_index, i,
+					     &info_array[i].device_type);
+		info_array[i].found = 1;
+
+		switch (info_array[i].device_type) {
+		case PS3_DEV_TYPE_STOR_DISK:
+		case PS3_DEV_TYPE_STOR_FLASH:
+			info_array[i].region_expected = 1;
+			region_expected ++;
+			ret ++;
+			break;
+		case PS3_DEV_TYPE_STOR_ROM:
+			ret ++;
+		default:
+			break;
+		}
+	} /* for */
+
+
+	/* 2-1) open special event device */
+	error = lv1_open_device(bus_id, NOTIFICATION_DEVID, 0);
+	if (error) {
+		printk(KERN_ERR "%s: open failed notification dev %d\n",
+		       __FUNCTION__, error);
+		ret = 0;
+		goto cleanup_1;
+	}
+
+	/* 2-2) write info to request notify */
+	buf[0] = 0;
+	buf[1] = (1 << 1); /* region update info only */
+	error = lv1_storage_write(NOTIFICATION_DEVID,
+				  0, /* region */
+				  0, /* lba */
+				  1, /* sectors to write */
+				  0, /* flags */
+				  ps3_mm_phys_to_lpar(__pa(buf)), /* no need special convert */
+				  &tag);
+	if (error) {
+		printk(KERN_ERR "%s: notify request write failed %d\n",
+		       __FUNCTION__, error);
+		ret = 0;
+		goto cleanup_2;
+	}
+
+	/* wait for completion in one sec */
+	retries = 0;
+	while ((error = lv1_storage_check_async_status(NOTIFICATION_DEVID, tag,
+						       &status)) &&
+	       (retries++ < 1000)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+	if (error) {
+		/* write not completed */
+		printk(KERN_ERR "%s: write not completed %d\n", __FUNCTION__,
+		       error);
+		ret = 0;
+		goto cleanup_2;
+	}
+
+	/* 2-3) read to wait region notification for each device */
+	while (region_ready < region_expected) {
+		memset(buf, 0, 512);
+		error = lv1_storage_read(NOTIFICATION_DEVID,
+					 0, /* region */
+					 0, /* lba */
+					 1, /* sectors to read */
+					 0, /* flags */
+					 ps3_mm_phys_to_lpar(__pa(buf)), /* no need special convert */
+					 &tag);
+		retries = 0;
+		while ((error = lv1_storage_check_async_status(NOTIFICATION_DEVID, tag, &status)) &&
+		       (retries++ < 1000)) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		}
+		if (error) {
+			/* read not completed */
+			printk(KERN_ERR "%s: read not complated %d\n",
+			       __FUNCTION__, error);
+			break;
+		}
+
+		/* 2-4) verify the notification */
+		if (buf[0] != 1) {
+			/* other info notified */
+			printk(KERN_ERR "%s: notification info %ld dev=%lx type=%lx\n", __FUNCTION__,
+			       buf[0], buf[2], buf[3]);
+		}
+
+		for (i = 0; i < num_of_dev; i++) {
+			if (info_array[i].found && info_array[i].device_id == buf[2]) {
+				info_array[i].region_ready = 1;
+				region_ready ++;
+				break;
+			}
+		} /* for */
+	} /* while */
+
+ cleanup_2:
+	lv1_close_device(bus_id, NOTIFICATION_DEVID);
+
+ cleanup_1:
+	kfree(info_array);
+ cleanup_0:
+	kfree(buf);
+	return ret;
+}
+
+
+static const struct scsi_command_handler_info scsi_cmnd_info_table_hdd[256] =
+{
+	[INQUIRY]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_inquiry},
+	[REQUEST_SENSE]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_request_sense},
+	[TEST_UNIT_READY]         = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_just_ok},
+	[READ_CAPACITY]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_read_capacity},
+	[MODE_SENSE_10]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_mode_sense},
+	[SYNCHRONIZE_CACHE]       = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_sync_cache},
+	[READ_10]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[READ_6]                  = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[WRITE_10]                = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write},
+	[WRITE_6]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write}
+};
+
+static const struct scsi_command_handler_info scsi_cmnd_info_table_flash[256] =
+{
+	[INQUIRY]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_inquiry},
+	[REQUEST_SENSE]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_request_sense},
+	[TEST_UNIT_READY]         = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_just_ok},
+	[READ_CAPACITY]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_read_capacity},
+	[MODE_SENSE_10]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_mode_sense},
+	[SYNCHRONIZE_CACHE]       = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_sync_cache},
+	[READ_10]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[READ_6]                  = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[WRITE_10]                = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_handle_write_flash},
+	[WRITE_6]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_handle_write_flash}
+};
+
+static const struct scsi_command_handler_info scsi_cmnd_info_table_atapi[256] =
+{
+	[INQUIRY]                 = {USE_SRB_6, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[REQUEST_SENSE]           = {USE_SRB_6, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_request_sense},
+	[START_STOP]              = {0, NON_DATA_PROTO, DIR_NA,
+				     ps3_stor_atapi_handle_simple},
+	[ALLOW_MEDIUM_REMOVAL]    = {0, NON_DATA_PROTO, DIR_NA,
+				     ps3_stor_atapi_handle_simple},
+	[TEST_UNIT_READY]         = {0, NON_DATA_PROTO, DIR_NA,
+				     ps3_stor_atapi_handle_simple},
+	[READ_CAPACITY]           = {8, PIO_DATA_IN_PROTO,  DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[MODE_SENSE_10]           = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[READ_TOC]                = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[GPCMD_GET_CONFIGURATION] = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[GPCMD_READ_DISC_INFO]    = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[READ_10]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[READ_6]                  = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[WRITE_10]                = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write},
+	[WRITE_6]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write},
+	[GPCMD_READ_CD]           = {USE_CDDA_FRAME_RAW, DMA_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple}
+};
+
+
+/*
+ * called from scsi mid layer when it want to probe a
+ * device.
+ * Prepare so that mid can issue SCSI commands later (slave_configure)
+ */
+static int ps3_stor_slave_alloc(struct scsi_device * scsi_dev)
+{
+        int error = 0;
+        struct ps3_stor_host_info * host_info = NULL;
+	struct ps3_stor_dev_info * dev_info = NULL;
+        struct Scsi_Host *scsi_host;
+	struct ps3_stor_lv1_bus_info * lv1_bus_info;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info = NULL;
+	struct list_head * pos;
+	int found;
+	char thread_name[64];
+
+	FUNC_START;
+
+	scsi_host = scsi_dev->host;
+	host_info = *(struct ps3_stor_host_info **)(scsi_host->hostdata);
+	lv1_bus_info = host_info->lv1_bus_info;
+	/*
+	 * connect lv1_dev_info with scsi_device
+	 * assume SCSI mid layer started scsi id with ZERO '0'
+	 */
+	found = 0;
+	list_for_each(pos, &(lv1_bus_info->dev_list)) {
+		lv1_dev_info = list_entry(pos, struct ps3_stor_lv1_dev_info,
+					  bus_dev_list);
+
+		if ((lv1_dev_info->bus_device_index == scsi_dev->id) &&
+		    (scsi_dev->lun < lv1_dev_info->accessible_regions)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		error = -ENXIO;
+		goto out;
+	}
+
+	/*
+	 * connect scsi_dev with dev_info
+	 */
+	found = 0;
+	list_for_each(pos, &(host_info->dev_info_list)) {
+		dev_info = list_entry(pos, struct ps3_stor_dev_info, dev_list);
+		if (!dev_info->used) {
+			dev_info->used = 1;
+			dev_info->target = scsi_dev->id;
+			dev_info->lv1_dev_info = lv1_dev_info;
+			switch (lv1_dev_info->device_type)
+			{
+			case PS3_DEV_TYPE_STOR_DISK:
+				dev_info->handler_info = scsi_cmnd_info_table_hdd;
+				break;
+			case PS3_DEV_TYPE_STOR_FLASH:
+				dev_info->handler_info = scsi_cmnd_info_table_flash;
+				break;
+			case PS3_DEV_TYPE_STOR_ROM:
+				dev_info->handler_info = scsi_cmnd_info_table_atapi;
+				break;
+			default:
+				break;
+			}
+			/* reverse link */
+			lv1_dev_info->dev_info = dev_info;
+			scsi_dev->hostdata = dev_info;
+			/* copy sector length and capacity */
+			dev_info->sector_size = lv1_dev_info->sector_size;
+			found = 1;
+			break;
+		} else {
+			if (dev_info->target == scsi_dev->id) {
+				/* another lun ? */
+				if (scsi_dev->lun < lv1_dev_info->accessible_regions) {
+					/* ok, support this lun */
+					scsi_dev->hostdata = dev_info;
+					goto skip_per_device_configure;
+				}
+			}
+		}
+	}
+
+	if (!found) {
+		printk(KERN_ERR "%s: no empty dev_info for device id=%d lun=%d \n", __FUNCTION__,
+		       scsi_dev->id, scsi_dev->lun);
+		error = -ENODEV;
+		goto out;
+	}
+	FUNC_STEP_C("1");
+
+	/* open lv1 device */
+	error = lv1_open_device(lv1_dev_info->repo.did.bus_id,
+			        lv1_dev_info->repo.did.dev_id, 0);
+	if (error) {
+		printk(KERN_ERR "%s:open failed %d\n", __FUNCTION__, error);
+		error = -ENODEV;
+		goto out;
+	}
+
+	error = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+						&lv1_dev_info->repo.did /* host_info->dev.did */,
+						lv1_dev_info->interrupt_id,
+						&lv1_dev_info->irq_plug_id);
+	if (error) {
+		printk("%s:%u: ps3_sb_event_receive_port_setup failed (%d)\n",
+		       __func__, __LINE__, error);
+		error = -EPERM;
+		goto fail_close_device;
+	}
+
+	FUNC_STEP_C("2");
+
+	error = request_irq(lv1_dev_info->irq_plug_id,
+			    ps3_stor_hdd_irq_handler, IRQF_DISABLED,
+			    "PS3 stor", lv1_dev_info);
+	if (error) {
+		printk("%s:%d: request_irq failed (%d)\n", __func__, __LINE__,
+		       error);
+		goto fail_event_receive_port_destroy;
+	}
+
+	FUNC_STEP_C("3");
+
+	/* prepare dma regions for the device */
+	down_write(&dev_info->bounce_sem);
+	switch (get_dedicated_buffer_type(lv1_dev_info->device_type)) {
+	case DEDICATED_KMALLOC:
+		/*
+		 * adjust max_sector count.
+		 * mid layer already set default value from host template
+		 */
+		blk_queue_max_sectors(scsi_dev->request_queue, get_default_max_sector(lv1_dev_info));
+		/* create its own static bouce buffer */
+		dev_info->dedicated_bounce_size = get_default_max_sector(lv1_dev_info) * lv1_dev_info->sector_size;
+		dev_info->bounce_buf = kmalloc(dev_info->dedicated_bounce_size, GFP_KERNEL | __GFP_DMA);
+		up_write(&dev_info->bounce_sem);
+		if (!dev_info->bounce_buf) {
+			printk(KERN_ERR "%s:kmalloc for static bounce buffer failed %#x\n", __FUNCTION__,
+			       dev_info->dedicated_bounce_size);
+			error = -ENOMEM;
+			goto fail_free_irq;
+		}
+		dev_info->bounce_type = DEDICATED_KMALLOC;
+		break;
+	case DEDICATED_SPECIAL:
+		blk_queue_max_sectors(scsi_dev->request_queue, get_default_max_sector(lv1_dev_info));
+		/* use static buffer, kmalloc can not allocate 256K */
+		dev_info->dedicated_bounce_size = FLASH_ALIGN;
+		dev_info->bounce_buf = ps3_stor_alloc_separate_memory(FLASH_ALIGN,
+								      &dev_info->separate_bounce_lpar);
+		if (!dev_info->bounce_buf) {
+			error = -ENOMEM;
+			goto fail_free_irq;
+		}
+		up_write(&dev_info->bounce_sem);
+		dev_info->bounce_type = DEDICATED_SPECIAL;
+		break;
+	}
+	/* allocate dma region */
+	if (need_dedicated_dma_region(lv1_dev_info->device_type)) {
+		error = lv1_allocate_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						       lv1_dev_info->repo.did.dev_id,
+						       CEIL_ALIGN_4K(dev_info->dedicated_bounce_size),
+						       12 /* 4K */,
+						       0,
+						       &lv1_dev_info->dma_region);
+		if (error || !lv1_dev_info->dma_region) {
+			printk(KERN_ERR "%s:allocate dma region failed %d\n",
+			       __FUNCTION__, error);
+			error = -ENOMEM;
+			goto fail_free_irq;
+		}
+		error = lv1_map_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						  lv1_dev_info->repo.did.dev_id,
+						  ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf),
+						  lv1_dev_info->dma_region,
+						  CEIL_ALIGN_4K(dev_info->dedicated_bounce_size),
+						  0xf800000000000000UL);
+		DPRINTK(KERN_ERR "%s:map bounce buffer %d va=%p lp=%#lx pa=%#lx size=%#x dma=%#lx\n",
+			__FUNCTION__, error, dev_info->bounce_buf,
+			ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf),
+		       __pa(dev_info->bounce_buf),
+		       dev_info->dedicated_bounce_size,
+		       lv1_dev_info->dma_region);
+		if (error) {
+			lv1_free_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						   lv1_dev_info->repo.did.dev_id,
+						   lv1_dev_info->dma_region);
+
+			error = -ENODEV;
+			goto fail_free_irq;
+		}
+		dev_info->dedicated_dma_region = 1;
+
+	} else {
+		lv1_dev_info->dma_region =
+			ps3_allocate_dma_region(&lv1_dev_info->repo.did);
+		if (!lv1_dev_info->dma_region) {
+			printk(KERN_ERR "%s:create dma region failed\n",
+			       __FUNCTION__);
+			error = -ENODEV;
+			goto fail_free_irq;
+		}
+	}
+	FUNC_STEP_C("4");
+
+	/* create receive thread */
+	sprintf(thread_name, "ps3stor-%d-%d",
+		scsi_host->host_no, scsi_dev->id);
+	dev_info->thread_struct = kthread_create(ps3_stor_main_thread,
+						 dev_info, thread_name);
+	if (IS_ERR(dev_info->thread_struct)) {
+		error = -ENOMEM;
+		dev_info->thread_struct = NULL;
+		goto fail_free_irq;
+	}
+	init_MUTEX_LOCKED(&(dev_info->thread_sema));
+	wake_up_process(dev_info->thread_struct);
+
+skip_per_device_configure:
+	FUNC_END;
+        return 0;
+
+fail_free_irq:
+	FUNC_STEP_C("5");
+	free_irq(lv1_dev_info->irq_plug_id, lv1_dev_info);
+fail_event_receive_port_destroy:
+	FUNC_STEP_C("6");
+	ps3_sb_event_receive_port_destroy(&lv1_dev_info->repo.did,
+					  lv1_dev_info->interrupt_id,
+					  lv1_dev_info->irq_plug_id);
+fail_close_device:
+	FUNC_STEP_C("7");
+	lv1_close_device(lv1_dev_info->repo.did.bus_id, lv1_dev_info->repo.did.dev_id);
+out:
+	FUNC_END_C("error");
+	return error;/* say failed to alloc */
+}
+
+static int ps3_stor_slave_configure(struct scsi_device * scsi_dev)
+{
+
+	if (scsi_dev->host->max_cmd_len != PS3_STOR_MAX_CMD_LEN)
+		scsi_dev->host->max_cmd_len = PS3_STOR_MAX_CMD_LEN;
+
+	if (scsi_dev->host->cmd_per_lun)
+		scsi_adjust_queue_depth(scsi_dev, 0, scsi_dev->host->cmd_per_lun);
+	/*
+	 * ATAPI SFF8020 devices use MODE_SENSE_10,
+	 * so we can prohibit MODE_SENSE_6
+	 */
+	scsi_dev->use_10_for_ms = 1;
+
+	return 0;
+}
+
+static void ps3_stor_slave_destroy(struct scsi_device * scsi_dev)
+{
+	int error;
+	struct ps3_stor_dev_info * dev_info =
+				(struct ps3_stor_dev_info *)scsi_dev->hostdata;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info = dev_info->lv1_dev_info;
+
+	/* only LUN=0 should do */
+	if (scsi_dev->lun != 0) {
+		printk(KERN_ERR "%s: id=%d lun=%d skipped\n", __FUNCTION__,
+		       scsi_dev->id, scsi_dev->lun);
+		return;
+	}
+
+	/* terminate main thread */
+	dev_info->thread_wakeup_reason = THREAD_TERMINATE;
+	init_completion(&(dev_info->thread_terminated));
+	up(&(dev_info)->thread_sema);
+	wait_for_completion(&(dev_info->thread_terminated));
+
+
+	/* free resources */
+	switch (dev_info->bounce_type) {
+	case DEDICATED_SPECIAL:
+		ps3_stor_release_separate_memory(dev_info->bounce_buf,
+						 dev_info->separate_bounce_lpar);
+		dev_info->bounce_buf = NULL;
+		break;
+	case DEDICATED_KMALLOC:
+		kfree(dev_info->bounce_buf);
+		dev_info->bounce_buf = NULL;
+		break;
+	}
+
+	if (dev_info->dedicated_dma_region) {
+		error = lv1_unmap_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						    lv1_dev_info->repo.did.dev_id,
+						    lv1_dev_info->dma_region,
+						    CEIL_ALIGN_4K(dev_info->dedicated_bounce_size));
+		if (error) {
+			printk(KERN_ERR "%s: unmap dma region failed %d\n",
+			       __FUNCTION__, error);
+		}
+		error = lv1_free_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						   lv1_dev_info->repo.did.dev_id,
+						   lv1_dev_info->dma_region);
+		if (error) {
+			printk(KERN_ERR "%s: unmap dma region failed %d\n",
+			       __FUNCTION__, error);
+		}
+		dev_info->dedicated_dma_region = 0;
+	} else {
+		error = ps3_free_dma_region(&lv1_dev_info->repo.did,
+					    lv1_dev_info->dma_region);
+		if (error) {
+			printk(KERN_ERR "%s: free dma region failed %d\n",
+			       __FUNCTION__, error);
+		}
+	}
+
+	free_irq(lv1_dev_info->irq_plug_id, lv1_dev_info);
+
+	ps3_sb_event_receive_port_destroy(&lv1_dev_info->repo.did,
+					  lv1_dev_info->interrupt_id,
+					  lv1_dev_info->irq_plug_id);
+	if (error)
+		printk(KERN_ERR "%s: disconnect event irq %d\n", __FUNCTION__,
+		       error);
+
+	error = lv1_close_device(lv1_dev_info->repo.did.bus_id,
+				 lv1_dev_info->repo.did.dev_id);
+	if (error)
+		printk(KERN_ERR "%s: close device %d\n", __FUNCTION__, error);
+
+	if (dev_info) {
+		/* make this slot avaliable for re-use */
+		dev_info->used = 0;
+		scsi_dev->hostdata = NULL;
+	}
+
+}
+
+static int ps3_stor_queuecommand(struct scsi_cmnd * srb,
+				 void (*done)(struct scsi_cmnd *))
+{
+	struct ps3_stor_dev_info * dev_info;
+	unsigned long flags;
+	int ret = 0;
+	dev_info = (struct ps3_stor_dev_info *)srb->device->hostdata;
+
+	spin_lock_irqsave(&dev_info->srb_lock, flags);
+	{
+		if (dev_info->srb) {
+			/* no more than one can be processed */
+			printk(KERN_ERR "%s: more than 1 SRB queued %d %d\n", __FUNCTION__,
+			       srb->device->host->host_no, srb->device->id);
+			ret = SCSI_MLQUEUE_HOST_BUSY;
+		} else {
+			srb->scsi_done = done;
+			dev_info->srb = srb;
+
+			dev_info->thread_wakeup_reason = SRB_QUEUED;
+			up(&(dev_info->thread_sema));
+			ret = 0;
+		};
+	}
+	spin_unlock_irqrestore(&(dev_info->srb_lock), flags);
+	return ret;
+}
+
+static int ps3_stor_host_reset(struct scsi_cmnd * srb)
+{
+	return FAILED;
+}
+
+
+static ssize_t ps3_stor_get_max_sectors(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct scsi_device *scsi_dev = from_dev_to_scsi_device(dev);
+	struct ps3_stor_dev_info * dev_info =
+		(struct ps3_stor_dev_info *)scsi_dev->hostdata;
+	ssize_t ret;
+
+	down_read(&dev_info->bounce_sem);
+	ret = sprintf(buf, "%u\n", scsi_dev->request_queue->max_sectors);
+	up_read(&dev_info->bounce_sem);
+	return ret;
+}
+
+static ssize_t ps3_stor_set_max_sectors(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct scsi_device *scsi_dev = from_dev_to_scsi_device(dev);
+	struct ps3_stor_dev_info * dev_info;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info;
+	unsigned short max_sectors;
+	void * bounce_buf;
+
+	if (sscanf(buf, "%hu", &max_sectors) > 0 && max_sectors <= SCSI_DEFAULT_MAX_SECTORS) {
+		dev_info = (struct ps3_stor_dev_info *)scsi_dev->hostdata;
+		lv1_dev_info = dev_info->lv1_dev_info;
+		/* if dedicated dma region, refuse to reset buffer */
+		if (need_dedicated_dma_region(lv1_dev_info->device_type)) {
+			/* FIXME: need remap dma region !!! */
+			return -EINVAL;
+		}
+		down_write(&dev_info->bounce_sem);
+		if (dev_info->bounce_type == DEDICATED_KMALLOC) {
+			/* try to allocate new bounce buffer */
+			bounce_buf = kmalloc(max_sectors * lv1_dev_info->sector_size, GFP_NOIO | __GFP_DMA | __GFP_NOWARN);
+			if (!bounce_buf) {
+				up_write(&dev_info->bounce_sem);
+				return -ENOMEM;
+			}
+			kfree(dev_info->bounce_buf);
+			dev_info->bounce_buf = bounce_buf;
+			dev_info->dedicated_bounce_size = max_sectors * lv1_dev_info->sector_size;
+		}
+		blk_queue_max_sectors(scsi_dev->request_queue, max_sectors);
+		up_write(&dev_info->bounce_sem);
+		return strlen(buf);
+	}
+	return -EINVAL;
+}
+
+
+static DEVICE_ATTR(max_sectors, S_IRUGO | S_IWUSR, ps3_stor_get_max_sectors,
+		   ps3_stor_set_max_sectors);
+
+static struct device_attribute *ps3_stor_sysfs_device_attr_list[] = {
+	&dev_attr_max_sectors,
+	NULL,
+};
+
+static struct scsi_host_template ps3_stor_driver_template = {
+	.name =			"ps3_stor",
+	.slave_alloc =		ps3_stor_slave_alloc,
+	.slave_configure =	ps3_stor_slave_configure,
+	.slave_destroy =	ps3_stor_slave_destroy,
+	.queuecommand =		ps3_stor_queuecommand,
+	.eh_host_reset_handler = ps3_stor_host_reset,
+	.can_queue =		PS3_STOR_CANQUEUE,
+	.this_id =		7,
+	.sg_tablesize =		SG_ALL,
+	.cmd_per_lun =		1,
+	.emulated =             1,   /* only sg driver uses this       */
+	.max_sectors =		128, /* multiple of pagesize, reset later */
+	.unchecked_isa_dma =	0,
+	.use_clustering =	ENABLE_CLUSTERING,
+	.sdev_attrs =           ps3_stor_sysfs_device_attr_list,
+	.module =		THIS_MODULE,
+};
+
+
+static int ps3_stor_driver_probe(struct platform_device * dev)
+{
+        int error = 0;
+        struct ps3_stor_host_info *host_info;
+        struct ps3_stor_lv1_bus_info *lv1_bus_info;
+        struct Scsi_Host *scsi_host;
+
+	host_info = from_dev_to_ps3_stor_host(dev);
+	lv1_bus_info = host_info->lv1_bus_info;
+
+        scsi_host = scsi_host_alloc(&ps3_stor_driver_template,
+				    sizeof(struct ps3_stor_host_info*));
+        if (NULL == scsi_host) {
+                printk(KERN_ERR "%s: scsi_register failed\n", __FUNCTION__);
+                error = -ENODEV;
+		return error;
+        }
+
+        host_info->scsi_host = scsi_host;
+	*((struct ps3_stor_host_info **)scsi_host->hostdata) = host_info;
+
+	/*
+	 * set maximum id as same as number of child devices
+	 */
+	scsi_host->max_id = lv1_bus_info->devices;
+	scsi_host->max_lun = 8;
+
+        error = scsi_add_host(scsi_host, &host_info->dev.dev);
+
+        if (error) {
+                printk(KERN_ERR "%s: scsi_add_host failed\n", __FUNCTION__);
+                error = -ENODEV;
+		scsi_host_put(scsi_host);
+        } else {
+		scsi_scan_host(scsi_host);
+	}
+
+
+        return error;
+}
+
+static int ps3_stor_driver_remove(struct platform_device * dev)
+{
+        struct list_head *lh, *lh_sf;
+        struct ps3_stor_host_info *host_info;
+        struct ps3_stor_dev_info *dev_info;
+
+	host_info = from_dev_to_ps3_stor_host(dev);
+
+	if (!host_info) {
+		printk(KERN_ERR "%s: Unable to locate host info\n",
+		       __FUNCTION__);
+		return -ENODEV;
+	}
+
+        scsi_remove_host(host_info->scsi_host);
+
+        list_for_each_safe(lh, lh_sf, &host_info->dev_info_list) {
+                dev_info = list_entry(lh, struct ps3_stor_dev_info, dev_list);
+                list_del(&dev_info->dev_list);
+                kfree(dev_info);
+        }
+
+        scsi_host_put(host_info->scsi_host);
+
+        return 0;
+}
+
+static void ps3_stor_driver_shutdown(struct platform_device * dev)
+{
+	ps3_stor_driver_remove(dev);
+}
+
+
+static struct platform_driver ps3_stor_platform_driver = {
+	.driver = {
+		.name = "ps3_storage"
+	},
+	.probe          = ps3_stor_driver_probe,
+	.remove         = ps3_stor_driver_remove,
+	.shutdown       = ps3_stor_driver_shutdown
+};
+
+static int __init ps3_stor_init(void)
+{
+	int host_to_add;
+	unsigned int devices, index;
+
+	FUNC_START;
+
+	/* register this driver thru devfs */
+	platform_driver_register(&ps3_stor_platform_driver);
+
+	/* wait until expected number of devices becomes ready */
+	devices = ps3_stor_wait_device_ready();
+	if (devices <= 0)
+		return -ENODEV;
+
+	/* init lv1_bus_info */
+	for (index = 0; index < PS3_STORAGE_NUM_OF_BUS_TYPES; index++) {
+		ps3_stor_lv1_bus_info_array[index].bus_type = index;
+		INIT_LIST_HEAD(&(ps3_stor_lv1_bus_info_array[index].dev_list));
+	}
+
+	/* alloc lv1_dev_info for devices */
+	ps3_stor_lv1_dev_info_array =
+		kzalloc(sizeof(struct ps3_stor_lv1_dev_info) * devices,
+			GFP_KERNEL);
+
+	if (!ps3_stor_lv1_dev_info_array) {
+		printk("init failed\n");
+		goto clean;
+	}
+	for (index = 0; index < devices; index++) {
+		INIT_LIST_HEAD(&(ps3_stor_lv1_dev_info_array[index].bus_dev_list));
+	}
+
+	/* calc how many HBA to add */
+	ps3_stor_lv1_devnum = 0;
+	devices = ps3_stor_enum_storage_drives();
+
+	for (index = 0; index < devices; index++) {
+		struct ps3_stor_lv1_dev_info *dev_info =
+			&ps3_stor_lv1_dev_info_array[index];
+		if (dev_info->device_type == PS3_DEV_TYPE_STOR_DISK ||
+		    dev_info->device_type == PS3_DEV_TYPE_STOR_ROM) {
+			if (dev_info->attached_port & (1 << 1)) {
+				dev_info->bus_device_index =
+					ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_1].devices ++;
+				list_add_tail(&(dev_info->bus_dev_list),
+					      &(ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_1].dev_list));
+			} else {
+				dev_info->bus_device_index =
+					ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_0].devices ++;
+				list_add_tail(&(dev_info->bus_dev_list),
+					      &(ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_0].dev_list));
+			}
+
+		}
+
+		if (dev_info->device_type == PS3_DEV_TYPE_STOR_FLASH) {
+			dev_info->bus_device_index =
+				ps3_stor_lv1_bus_info_array[PS3_STORAGE_FLASH].devices ++;
+			list_add_tail(&(dev_info->bus_dev_list),
+				      &(ps3_stor_lv1_bus_info_array[PS3_STORAGE_FLASH].dev_list));
+		}
+
+	}
+
+	host_to_add = 0;
+	for (index = 0; index < PS3_STORAGE_NUM_OF_BUS_TYPES; index++) {
+		if (ps3_stor_lv1_bus_info_array[index].devices)
+			host_to_add ++;
+	}
+
+
+        /* add HBAs */
+	ps3_stor_add_host = 0;
+	for (index = 0; index < PS3_STORAGE_NUM_OF_BUS_TYPES; index++) {
+		if (ps3_stor_lv1_bus_info_array[index].devices) {
+			if (ps3_stor_add_adapter(&(ps3_stor_lv1_bus_info_array[index]))) {
+				printk(KERN_ERR "ps3_stor_init: ps3_stor_add_adapter failed\n");
+				break;
+			} else
+				host_to_add --;
+		}
+	}
+
+	FUNC_END;
+	return 0;
+
+ clean:
+	platform_driver_unregister(&ps3_stor_platform_driver);
+	return -ENOMEM;
+}
+
+static void __exit ps3_stor_exit(void)
+{
+	int k;
+
+	for (k = ps3_stor_add_host; k; k--)
+		ps3_stor_remove_adapter();
+	platform_driver_unregister(&ps3_stor_platform_driver);
+
+	for (k = 0; k < ps3_stor_lv1_devnum; k++) {
+		if (ps3_stor_lv1_dev_info_array[k].region_info_array) {
+			kfree(ps3_stor_lv1_dev_info_array[k].region_info_array);
+		}
+	}
+	kfree(ps3_stor_lv1_dev_info_array);
+}
+
+
+device_initcall(ps3_stor_init);
+module_exit(ps3_stor_exit);
diff -Naur linux-2.6.21.1-org/drivers/block/ps3_storage.h linux-2.6.21.1-ps3/drivers/block/ps3_storage.h
--- linux-2.6.21.1-org/drivers/block/ps3_storage.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/drivers/block/ps3_storage.h	2007-05-21 13:50:28.940351238 +0200
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * Copyright 2006, 2007 Sony Corporation
+ * storage support for PS3
+ *
+ * based on scsi_debug.h
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef _PS3_STOR_H
+#define _PS3_STOR_H
+
+#include <linux/types.h>
+#include <../arch/powerpc/platforms/ps3/platform.h>
+
+#define LV1_STORAGE_SEND_ATAPI_COMMAND	(1)
+#define LV1_STORAGE_ATA_HDDOUT		(0x23)
+
+#define PS3_STOR_MAX_INQUIRY_DATA_SIZE	(128)
+#define PS3_STOR_INQUIRY_DATA_SIZE	(86)
+#define PS3_STOR_READCAP_DATA_SIZE	(8)
+#define PS3_STOR_SENSE_LEN		(32)
+#define PS3_STOR_VERSION		"1.00"
+#define PS3_STOR_CANQUEUE		(1)
+#define PS3_STOR_MAX_CMD_LEN		(16)
+
+struct lv1_atapi_cmnd_block {
+	u8	pkt[32];	/* packet command block           */
+	u32	pktlen;		/* should be 12 for ATAPI 8020    */
+	u32	blocks;
+	u32	block_size;
+	u32	proto;		/* transfer mode                  */
+	u32	in_out;		/* transfer direction             */
+	u64	buffer;		/* parameter except command block */
+	u32	arglen;		/* length above                   */
+};
+
+enum lv1_atapi_proto {
+	NA_PROTO = -1,
+	NON_DATA_PROTO     = 0,
+	PIO_DATA_IN_PROTO  = 1,
+	PIO_DATA_OUT_PROTO = 2,
+	DMA_PROTO = 3
+};
+
+enum lv1_atapi_in_out {
+	DIR_NA = -1,
+	DIR_WRITE = 0, /* memory -> device */
+	DIR_READ = 1 /* device -> memory */
+};
+
+/*
+ * describe protocol of an ATAPI command
+ */
+struct ps3_stor_dev_info;
+
+struct scsi_command_handler_info {
+	int buflen;
+	int proto;
+	int in_out;
+	int (*cmnd_handler)(struct ps3_stor_dev_info *, struct scsi_cmnd *);
+};
+
+/*
+ * to position parameter
+ */
+enum {
+	NOT_AVAIL          = -1,
+	USE_SRB_10         = -2,
+	USE_SRB_6          = -3,
+	USE_CDDA_FRAME_RAW = -4
+};
+/*
+ * for LV1 maintainance
+ */
+enum  {
+	PS3_STORAGE_PATA_0, /* primary   PATA bus */
+	PS3_STORAGE_PATA_1, /* secondary PATA bus */
+	PS3_STORAGE_FLASH,
+	PS3_STORAGE_NUM_OF_BUS_TYPES /* terminator */
+};
+
+/*
+ * LV1 per physical bus info:
+ * PATA0, PATA1, FLASH
+ */
+struct ps3_stor_lv1_bus_info {
+	int bus_type;           /* PATA0, PATA1, FLASH */
+	int devices;            /* number of devices on the bus */
+	struct list_head dev_list;
+};
+
+/*
+ * LV1 per region info
+ */
+struct ps3_stor_lv1_region_info {
+	int region_index;	/* index of this region       */
+	unsigned int region_id;	/* id of this region          */
+	u64 region_size;	/* region size in sector      */
+	u64 region_start;	/* start sector */
+};
+
+/*
+ * LV1 per device info
+ */
+struct ps3_stor_lv1_dev_info {
+	struct list_head bus_dev_list; /* device list of devices          */
+				       /* which share same physical bus   */
+	struct ps3_stor_dev_info * dev_info;
+	/* repository values */
+	struct ps3_repository_device repo;
+	enum ps3_dev_type device_type;	/* bus#X.dev#Y.type     */
+	u64 attached_port;		/* bus#x.dev#Y.port     */
+	u64 sector_size;		/* bus#X.dev#Y.blk_size */
+
+	/* house keeping */
+	int bus_type;			/* PATA0,1 or FLASH */
+	unsigned int irq_plug_id;
+	unsigned int interrupt_id;
+	u64 dma_region;
+	u64 current_tag;
+	int bus_device_index;		/*
+					 * device index of same lv1 phy bus.
+					 * 0 for first device, 1 for second.
+					 * should be same as SCSI id
+					 */
+	/* regions */
+	unsigned int regions;	/* number of regions reported thru repository */
+	unsigned long accessible_region_flag; /* flag of accessible regions */
+	unsigned int accessible_regions; /* number of accessible regions of this dev.
+				 * currently, this includes region #0
+				 * NOTE: maximum is 8, if exceed, the rest of
+				 * regions are ignored
+				 */
+	struct ps3_stor_lv1_region_info * region_info_array;
+};
+
+enum read_or_write {
+	SCSIDEBUG_READ,
+	SCSIDEBUG_WRITE
+};
+
+
+enum thread_wakeup_reason {
+	SRB_QUEUED,
+	THREAD_TERMINATE
+};
+
+enum bounce_buffer_type {
+	DEDICATED_KMALLOC,
+	DEDICATED_SPECIAL,
+};
+
+struct ps3_stor_dev_info {
+	struct list_head dev_list;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info;
+	struct ps3_stor_host_info *host_info;
+	const struct scsi_command_handler_info * handler_info;
+	unsigned int target;
+
+	u64 sector_size;	/* copied from lv1 repository at initialize */
+	/* devices may change these value */
+	struct rw_semaphore bounce_sem;	/* protect the following members:
+					* bounce_buf (pointer itself, not buffer),
+					* dedicated_bounce_size
+					* max_sectors in scsi_dev->request_queue
+					*/
+	int  dedicated_bounce;	/* set nonzero if the bounce buffer is dedicated */
+	int  dedicated_bounce_size;
+	int  dedicated_dma_region; /* set if partial dma region allocated */
+	enum bounce_buffer_type bounce_type;	/* bounce buffer type */
+	void * bounce_buf;
+	u64 separate_bounce_lpar; /* lpar address for separated buffer  */
+
+	char used;
+
+	/* main thread communication */
+	struct task_struct * thread_struct;
+	spinlock_t srb_lock;
+	struct scsi_cmnd * srb;              /* queued srb; just one srb allowd             */
+	struct semaphore thread_sema;        /* device main thread wakeup                   */
+	struct completion thread_terminated; /* notify thread temination to slave_destory() */
+	int thread_wakeup_reason;
+
+	/* interrupt handler communication */
+	struct completion irq_done;
+	volatile u64 lv1_status;	/* result of get_async_status() */
+	volatile int lv1_retval;	/* return value of get_async_status() */
+
+};
+
+struct ps3_stor_host_info {
+	struct list_head host_list;
+	struct Scsi_Host *scsi_host;
+	struct platform_device dev;
+	struct list_head dev_info_list;
+	struct ps3_stor_lv1_bus_info * lv1_bus_info;
+};
+
+#define from_dev_to_ps3_stor_host(p) \
+	container_of(p, struct ps3_stor_host_info, dev)
+#define from_dev_to_scsi_device(p) \
+	container_of(p, struct scsi_device, sdev_gendev)
+
+
+struct ps3_stor_quirk_probe_info {
+	struct completion irq_done;
+	unsigned int device_id;
+	int lv1_retval;
+	u64 lv1_status;
+	u64 lv1_tag;
+	u64 lv1_ret_tag;
+};
+
+
+#define NOTIFICATION_DEVID ((u64)(-1L))
+
+struct device_probe_info {
+	unsigned int device_id;
+	enum ps3_dev_type device_type;
+	int      found;
+	int      region_expected;
+	int      region_ready;
+};
+
+#endif
--- linux-2.6.21.1-org/drivers/net/Kconfig	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/net/Kconfig	2007-05-24 10:52:03.802978668 +0200
@@ -2259,6 +2259,16 @@
 	     To compile this driver as a module, choose M here: the module
 	     will be called tsi108_eth.
 
+config GELIC_NET
+	tristate "PS3 Gigabit Ethernet driver"
+	depends on PPC_PS3
+	help
+	  This driver supports the Gigabit Ethernet device on the
+	  PS3 game console.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gelic_net.
+
 config GIANFAR
 	tristate "Gianfar Ethernet"
 	depends on 85xx || 83xx || PPC_86xx
diff -Naur linux-2.6.21.1-org/drivers/net/Makefile linux-2.6.21.1-ps3/drivers/net/Makefile
--- linux-2.6.21.1-org/drivers/net/Makefile	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/net/Makefile	2007-05-21 13:50:29.232335690 +0200
@@ -60,6 +60,7 @@
 obj-$(CONFIG_BNX2) += bnx2.o
 spidernet-y += spider_net.o spider_net_ethtool.o
 obj-$(CONFIG_SPIDER_NET) += spidernet.o sungem_phy.o
+obj-$(CONFIG_GELIC_NET) += gelic_net.o
 obj-$(CONFIG_TC35815) += tc35815.o
 obj-$(CONFIG_SKGE) += skge.o
 obj-$(CONFIG_SKY2) += sky2.o
diff -Naur linux-2.6.21.1-org/drivers/net/gelic_net.c linux-2.6.21.1-ps3/drivers/net/gelic_net.c
--- linux-2.6.21.1-org/drivers/net/gelic_net.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/drivers/net/gelic_net.c	2007-05-21 13:50:29.368328449 +0200
@@ -0,0 +1,1880 @@
+/*
+ *  PS3 Platfom gelic network driver.
+ *
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ *
+ *  this file is based on: spider_net.c
+ *
+ * Network device driver for Cell Processor-Based Blade
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Authors : Utz Bacher <utz.bacher@de.ibm.com>
+ *           Jens Osterkamp <Jens.Osterkamp@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define DEBUG 1
+
+#include <linux/compiler.h>
+#include <linux/crc32.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/firmware.h>
+#include <linux/if_vlan.h>
+#include <linux/in.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/mii.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/device.h>
+#include <linux/pci.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <asm/bitops.h>
+#include <asm/pci-bridge.h>
+#include <net/checksum.h>
+#include <asm/io.h>
+#include <asm/firmware.h>
+#include <asm/ps3.h>
+#include <asm/lv1call.h>
+
+#define GELIC_NET_DRV_NAME "Gelic Network Driver"
+#define GELIC_NET_DRV_VERSION "1.0"
+
+#define GELIC_NET_DEBUG
+
+#ifdef GELIC_NET_DEBUG
+#define DPRINTK(fmt,arg...)   printk(KERN_ERR fmt ,##arg)
+#define DPRINTKK(fmt,arg...)  printk(KERN_ERR fmt ,##arg)
+#else
+#define DPRINTK(fmt,arg...)
+#define DPRINTKK(fmt,arg...)
+#endif
+
+#define GELIC_NET_ETHTOOL               /* use ethtool */
+
+/* ioctl */
+#define GELIC_NET_GET_MODE              (SIOCDEVPRIVATE + 0)
+#define GELIC_NET_SET_MODE              (SIOCDEVPRIVATE + 1)
+
+/* descriptors */
+#define GELIC_NET_RX_DESCRIPTORS        128 /* num of descriptors */
+#define GELIC_NET_TX_DESCRIPTORS        128 /* num of descriptors */
+
+#define GELIC_NET_MAX_MTU               2308
+#define GELIC_NET_MIN_MTU               64
+#define GELIC_NET_RXBUF_ALIGN           128
+#define GELIC_NET_RX_CSUM_DEFAULT       1 /* hw chksum */
+#define GELIC_NET_WATCHDOG_TIMEOUT      5*HZ
+#define GELIC_NET_NAPI_WEIGHT           64
+#define GELIC_NET_BROADCAST_ADDR        0xffffffffffff
+#define GELIC_NET_VLAN_POS              (VLAN_ETH_ALEN * 2)
+#define GELIC_NET_VLAN_MAX              4
+#define GELIC_NET_MC_COUNT_MAX          32 /* multicast address list */
+
+enum gelic_net_int0_status {
+	GELIC_NET_GDTDCEINT  = 24,
+	GELIC_NET_GRFANMINT  = 28,
+};
+
+/* GHIINT1STS bits */
+enum gelic_net_int1_status {
+	GELIC_NET_GDADCEINT = 14,
+};
+
+/* interrupt mask */
+#define GELIC_NET_TXINT                   (1L << (GELIC_NET_GDTDCEINT + 32))
+
+#define GELIC_NET_RXINT0                  (1L << (GELIC_NET_GRFANMINT + 32))
+#define GELIC_NET_RXINT1                  (1L << GELIC_NET_GDADCEINT)
+#define GELIC_NET_RXINT                   (GELIC_NET_RXINT0 | GELIC_NET_RXINT1)
+
+ /* descriptor data_status bits */
+#define GELIC_NET_RXIPCHK                 29
+#define GELIC_NET_TCPUDPIPCHK             28
+#define GELIC_NET_DATA_STATUS_CHK_MASK    (1 << GELIC_NET_RXIPCHK | \
+                                           1 << GELIC_NET_TCPUDPIPCHK)
+
+/* descriptor data_error bits */
+#define GELIC_NET_RXIPCHKERR              27
+#define GELIC_NET_RXTCPCHKERR             26
+#define GELIC_NET_DATA_ERROR_CHK_MASK     (1 << GELIC_NET_RXIPCHKERR | \
+                                           1 << GELIC_NET_RXTCPCHKERR)
+
+#define GELIC_NET_DMAC_CMDSTAT_NOCS       0xa0080000 /* middle of frame */
+#define GELIC_NET_DMAC_CMDSTAT_TCPCS      0xa00a0000
+#define GELIC_NET_DMAC_CMDSTAT_UDPCS      0xa00b0000
+#define GELIC_NET_DMAC_CMDSTAT_END_FRAME  0x00040000 /* end of frame */
+
+#define GELIC_NET_DMAC_CMDSTAT_CHAIN_END  0x00000002 /* RXDCEIS:DMA stopped */
+
+#define GELIC_NET_DESCR_IND_PROC_SHIFT    28
+#define GELIC_NET_DESCR_IND_PROC_MASKO    0x0fffffff
+
+/* ignore ipsec ans multicast */
+#define GELIC_NET_DATA_ERROR_MASK         0xfdefbfff
+/* ignore unmatched sp on sp, drop_packet, multicast address frame*/
+#define GELIC_NET_DATA_ERROR_FLG          0x7def8000
+
+enum gelic_net_descr_status {
+	GELIC_NET_DESCR_COMPLETE            = 0x00, /* used in rx and tx */
+	GELIC_NET_DESCR_RESPONSE_ERROR      = 0x01, /* used in rx and tx */
+	GELIC_NET_DESCR_PROTECTION_ERROR    = 0x02, /* used in rx and tx */
+	GELIC_NET_DESCR_FRAME_END           = 0x04, /* used in rx */
+	GELIC_NET_DESCR_FORCE_END           = 0x05, /* used in rx and tx */
+	GELIC_NET_DESCR_CARDOWNED           = 0x0a, /* used in rx and tx */
+	GELIC_NET_DESCR_NOT_IN_USE                  /* any other value */
+};
+#define GELIC_NET_DMAC_CMDSTAT_NOT_IN_USE 0xb0000000
+
+#define GELIC_NET_DESCR_SIZE              32
+struct gelic_net_descr {
+	/* as defined by the hardware */
+	uint32_t buf_addr;
+	uint32_t buf_size;
+	uint32_t next_descr_addr;
+	uint32_t dmac_cmd_status;
+	uint32_t result_size;
+	uint32_t valid_size;	/* all zeroes for tx */
+	uint32_t data_status;
+	uint32_t data_error;	/* all zeroes for tx */
+
+	/* used in the driver */
+	struct sk_buff *skb;
+	dma_addr_t bus_addr;
+	struct gelic_net_descr *next;
+	struct gelic_net_descr *prev;
+	struct vlan_ethhdr vlan;
+} __attribute__((aligned(32)));
+
+struct gelic_net_descr_chain {
+	/* we walk from tail to head */
+	struct gelic_net_descr *head;
+	struct gelic_net_descr *tail;
+	spinlock_t lock;
+};
+
+struct gelic_net_card {
+	struct net_device *netdev;
+	uint64_t ghiintmask;
+	struct ps3_system_bus_device *dev;
+	uint32_t vlan_id[GELIC_NET_VLAN_MAX];
+	int vlan_index;
+
+	struct gelic_net_descr_chain tx_chain;
+	struct gelic_net_descr_chain rx_chain;
+	spinlock_t chain_lock;
+
+	struct net_device_stats netdev_stats;
+	int rx_csum;
+	spinlock_t intmask_lock;
+
+	struct work_struct tx_timeout_task;
+	atomic_t tx_timeout_task_counter;
+	wait_queue_head_t waitq;
+
+	struct gelic_net_descr *tx_top, *rx_top;
+
+	struct gelic_net_descr descr[0];
+};
+
+static int ps3_gelic_param = 1; /* vlan desc support */
+#ifdef CONFIG_GELIC_NET_MODULE
+module_param(ps3_gelic_param, int, S_IRUGO);
+#endif
+
+struct gelic_net_card *gcard;
+static uint64_t gelic_irq_status;
+
+static int dmac_status = 0;
+
+/* for lv1_net_control */
+#define GELIC_NET_GET_MAC_ADDRESS               0x0000000000000001
+#define GELIC_NET_GET_ETH_PORT_STATUS           0x0000000000000002
+#define GELIC_NET_SET_NEGOTIATION_MODE          0x0000000000000003
+#define GELIC_NET_GET_VLAN_ID                   0x0000000000000004
+
+#define GELIC_NET_LINK_UP                       0x0000000000000001
+#define GELIC_NET_FULL_DUPLEX                   0x0000000000000002
+#define GELIC_NET_AUTO_NEG                      0x0000000000000004
+#define GELIC_NET_SPEED_10                      0x0000000000000010
+#define GELIC_NET_SPEED_100                     0x0000000000000020
+#define GELIC_NET_SPEED_1000                    0x0000000000000040
+
+#define GELIC_NET_VLAN_ALL                      0x0000000000000001
+#define GELIC_NET_VLAN_WIRED                    0x0000000000000002
+#define GELIC_NET_VLAN_WIRELESS                 0x0000000000000003
+#define GELIC_NET_VLAN_PSP                      0x0000000000000004
+#define GELIC_NET_VLAN_PORT0                    0x0000000000000010
+#define GELIC_NET_VLAN_PORT1                    0x0000000000000011
+#define GELIC_NET_VLAN_PORT2                    0x0000000000000012
+#define GELIC_NET_VLAN_DAEMON_CLIENT_BSS        0x0000000000000013
+#define GELIC_NET_VLAN_LIBERO_CLIENT_BSS        0x0000000000000014
+#define GELIC_NET_VLAN_NO_ENTRY                 -6
+
+#define GELIC_NET_PORT                          2 /* for port status */
+
+
+MODULE_AUTHOR("SCE Inc.");
+MODULE_DESCRIPTION("Gelic Network driver");
+MODULE_LICENSE("GPL");
+
+static int rx_descriptors = GELIC_NET_RX_DESCRIPTORS;
+static int tx_descriptors = GELIC_NET_TX_DESCRIPTORS;
+
+
+/* set irq_mask */
+static int
+gelic_net_set_irq_mask(struct gelic_net_card *card, uint64_t mask)
+{
+	uint64_t status = 0;
+
+	status = lv1_net_set_interrupt_mask(card->dev->did.bus_id,
+		card->dev->did.dev_id, mask, 0);
+	if (status) {
+		printk("lv1_net_set_interrupt_mask failed, status=%ld\n",
+			status);
+	}
+	return status;
+}
+
+/**
+ * gelic_net_get_descr_status -- returns the status of a descriptor
+ * @descr: descriptor to look at
+ *
+ * returns the status as in the dmac_cmd_status field of the descriptor
+ */
+enum gelic_net_descr_status
+gelic_net_get_descr_status(struct gelic_net_descr *descr)
+{
+	uint32_t cmd_status;
+
+	rmb();
+	cmd_status = descr->dmac_cmd_status;
+	rmb();
+	cmd_status >>= GELIC_NET_DESCR_IND_PROC_SHIFT;
+	return cmd_status;
+}
+
+/**
+ * gelic_net_set_descr_status -- sets the status of a descriptor
+ * @descr: descriptor to change
+ * @status: status to set in the descriptor
+ *
+ * changes the status to the specified value. Doesn't change other bits
+ * in the status
+ */
+static void
+gelic_net_set_descr_status(struct gelic_net_descr *descr,
+			    enum gelic_net_descr_status status)
+{
+	uint32_t cmd_status;
+
+	/* read the status */
+	mb();
+	cmd_status = descr->dmac_cmd_status;
+	/* clean the upper 4 bits */
+	cmd_status &= GELIC_NET_DESCR_IND_PROC_MASKO;
+	/* add the status to it */
+	cmd_status |= ((uint32_t)status)<<GELIC_NET_DESCR_IND_PROC_SHIFT;
+	/* and write it back */
+	descr->dmac_cmd_status = cmd_status;
+	wmb();
+}
+
+/**
+ * gelic_net_free_chain - free descriptor chain
+ * @card: card structure
+ * @descr_in: address of desc
+ */
+static void
+gelic_net_free_chain(struct gelic_net_card *card,
+		      struct gelic_net_descr *descr_in)
+{
+	struct gelic_net_descr *descr;
+
+	for (descr = descr_in; descr && !descr->bus_addr; descr = descr->next) {
+		dma_unmap_single(&card->dev->core, descr->bus_addr,
+				 GELIC_NET_DESCR_SIZE, PCI_DMA_BIDIRECTIONAL);
+		descr->bus_addr = 0;
+	}
+}
+
+/**
+ * gelic_net_init_chain - links descriptor chain
+ * @card: card structure
+ * @chain: address of chain
+ * @start_descr: address of descriptor array
+ * @no: number of descriptors
+ *
+ * we manage a circular list that mirrors the hardware structure,
+ * except that the hardware uses bus addresses.
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int
+gelic_net_init_chain(struct gelic_net_card *card,
+		       struct gelic_net_descr_chain *chain,
+		       struct gelic_net_descr *start_descr, int no)
+{
+	int i;
+	struct gelic_net_descr *descr;
+
+	spin_lock_init(&chain->lock);
+	descr = start_descr;
+	memset(descr, 0, sizeof(*descr) * no);
+
+	/* set up the hardware pointers in each descriptor */
+	for (i=0; i<no; i++, descr++) {
+		gelic_net_set_descr_status(descr, GELIC_NET_DESCR_NOT_IN_USE);
+		descr->bus_addr =
+			dma_map_single(&card->dev->core, descr,
+				       GELIC_NET_DESCR_SIZE,
+				       PCI_DMA_BIDIRECTIONAL);
+
+		if (descr->bus_addr == DMA_ERROR_CODE)
+			goto iommu_error;
+
+		descr->next = descr + 1;
+		descr->prev = descr - 1;
+	}
+	/* do actual chain list */
+	(descr-1)->next = start_descr;
+	start_descr->prev = (descr-1);
+
+	descr = start_descr;
+	for (i=0; i < no; i++, descr++) {
+		if (descr->next) {
+			descr->next_descr_addr = descr->next->bus_addr;
+		} else {
+			descr->next_descr_addr = 0;
+		}
+	}
+
+	chain->head = start_descr;
+	chain->tail = start_descr;
+	(descr-1)->next_descr_addr = 0; /* last descr */
+	return 0;
+
+iommu_error:
+	descr = start_descr;
+	for (i=0; i < no; i++, descr++)
+		if (descr->bus_addr)
+			dma_unmap_single(&card->dev->core, descr->bus_addr,
+					 GELIC_NET_DESCR_SIZE,
+					 PCI_DMA_BIDIRECTIONAL);
+	return -ENOMEM;
+}
+
+/**
+ * gelic_net_prepare_rx_descr - reinitializes a rx descriptor
+ * @card: card structure
+ * @descr: descriptor to re-init
+ *
+ * return 0 on succes, <0 on failure
+ *
+ * allocates a new rx skb, iommu-maps it and attaches it to the descriptor.
+ * Activate the descriptor state-wise
+ */
+static int
+gelic_net_prepare_rx_descr(struct gelic_net_card *card,
+			    struct gelic_net_descr *descr)
+{
+	dma_addr_t buf;
+	int error = 0;
+	int offset;
+	int bufsize;
+
+	if( gelic_net_get_descr_status(descr) !=  GELIC_NET_DESCR_NOT_IN_USE) {
+		printk("%s: ERROR status \n", __FUNCTION__);
+	}
+	/* we need to round up the buffer size to a multiple of 128 */
+	bufsize = (GELIC_NET_MAX_MTU + GELIC_NET_RXBUF_ALIGN - 1) &
+		(~(GELIC_NET_RXBUF_ALIGN - 1));
+
+	/* and we need to have it 128 byte aligned, therefore we allocate a
+	 * bit more */
+	/* allocate an skb */
+	descr->skb = dev_alloc_skb(bufsize + GELIC_NET_RXBUF_ALIGN - 1);
+	if (!descr->skb) {
+		if (net_ratelimit())
+			printk("Not enough memory to allocate rx buffer\n");
+		return -ENOMEM;
+	}
+	descr->buf_size = bufsize;
+	descr->dmac_cmd_status = 0;
+	descr->result_size = 0;
+	descr->valid_size = 0;
+	descr->data_error = 0;
+
+	offset = ((unsigned long)descr->skb->data) &
+		(GELIC_NET_RXBUF_ALIGN - 1);
+	if (offset)
+		skb_reserve(descr->skb, GELIC_NET_RXBUF_ALIGN - offset);
+	/* io-mmu-map the skb */
+	buf = dma_map_single(&card->dev->core, descr->skb->data,
+					GELIC_NET_MAX_MTU,
+					PCI_DMA_BIDIRECTIONAL);
+	descr->buf_addr = buf;
+	if (buf == DMA_ERROR_CODE) {
+		dev_kfree_skb_any(descr->skb);
+		printk("Could not iommu-map rx buffer\n");
+		gelic_net_set_descr_status(descr, GELIC_NET_DESCR_NOT_IN_USE);
+	} else {
+		gelic_net_set_descr_status(descr, GELIC_NET_DESCR_CARDOWNED);
+	}
+
+	return error;
+}
+
+/**
+ * gelic_net_release_rx_chain - free all rx descr
+ * @card: card structure
+ *
+ */
+static void
+gelic_net_release_rx_chain(struct gelic_net_card *card)
+{
+	struct gelic_net_descr_chain *chain = &card->rx_chain;
+
+	while(chain->tail != chain->head) {
+		if (chain->tail->skb) {
+			dma_unmap_single(&card->dev->core,
+						chain->tail->buf_addr,
+						chain->tail->skb->len,
+						PCI_DMA_BIDIRECTIONAL);
+			chain->tail->buf_addr = 0;
+			dev_kfree_skb_any(chain->tail->skb);
+			chain->tail->skb = NULL;
+			chain->tail->dmac_cmd_status =
+						GELIC_NET_DESCR_NOT_IN_USE;
+			chain->tail = chain->tail->next;
+		}
+	}
+}
+
+/**
+ * gelic_net_enable_rxdmac - enables a receive DMA controller
+ * @card: card structure
+ *
+ * gelic_net_enable_rxdmac enables the DMA controller by setting RX_DMA_EN
+ * in the GDADMACCNTR register
+ */
+static void
+gelic_net_enable_rxdmac(struct gelic_net_card *card)
+{
+	uint64_t status;
+
+	status = lv1_net_start_rx_dma(card->dev->did.bus_id,
+				card->dev->did.dev_id,
+				(uint64_t)card->rx_chain.tail->bus_addr, 0);
+	if (status) {
+		printk("lv1_net_start_rx_dma failed, status=%ld\n", status);
+	}
+}
+
+/**
+ * gelic_net_refill_rx_chain - refills descriptors/skbs in the rx chains
+ * @card: card structure
+ *
+ * refills descriptors in all chains (last used chain first): allocates skbs
+ * and iommu-maps them.
+ */
+static void
+gelic_net_refill_rx_chain(struct gelic_net_card *card)
+{
+	struct gelic_net_descr_chain *chain;
+	int count = 0;
+
+	chain = &card->rx_chain;
+	while (chain->head && gelic_net_get_descr_status(chain->head) ==
+		GELIC_NET_DESCR_NOT_IN_USE) {
+		if (gelic_net_prepare_rx_descr(card, chain->head))
+			break;
+		count++;
+		chain->head = chain->head->next;
+	}
+}
+
+/**
+ * gelic_net_alloc_rx_skbs - allocates rx skbs in rx descriptor chains
+ * @card: card structure
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int
+gelic_net_alloc_rx_skbs(struct gelic_net_card *card)
+{
+	struct gelic_net_descr_chain *chain;
+
+	chain = &card->rx_chain;
+	gelic_net_refill_rx_chain(card);
+	chain->head = card->rx_top->prev; /* point to the last */
+	return 0;
+}
+
+/**
+ * gelic_net_release_tx_descr - processes a used tx descriptor
+ * @card: card structure
+ * @descr: descriptor to release
+ *
+ * releases a used tx descriptor (unmapping, freeing of skb)
+ */
+static void
+gelic_net_release_tx_descr(struct gelic_net_card *card,
+			    struct gelic_net_descr *descr)
+{
+	struct sk_buff *skb;
+
+  if (!ps3_gelic_param) {
+	/* unmap the skb */
+	skb = descr->skb;
+	dma_unmap_single(&card->dev->core, descr->buf_addr, skb->len,
+			 PCI_DMA_BIDIRECTIONAL);
+
+	dev_kfree_skb_any(skb);
+  } else {
+	if ((descr->data_status & 0x00000001) == 1) { /* end of frame */
+		skb = descr->skb;
+		dma_unmap_single(&card->dev->core, descr->buf_addr, skb->len,
+			 PCI_DMA_BIDIRECTIONAL);
+		dev_kfree_skb_any(skb);
+	} else {
+		dma_unmap_single(&card->dev->core, descr->buf_addr,
+			descr->buf_size, PCI_DMA_BIDIRECTIONAL);
+	}
+  }
+	descr->buf_addr = 0;
+	descr->buf_size = 0;
+	descr->next_descr_addr = 0;
+	descr->result_size = 0;
+	descr->valid_size = 0;
+	descr->data_status = 0;
+	descr->data_error = 0;
+	descr->skb = NULL;
+	card->tx_chain.tail = card->tx_chain.tail->next;
+
+	/* set descr status */
+	descr->dmac_cmd_status = GELIC_NET_DMAC_CMDSTAT_NOT_IN_USE;
+}
+
+/**
+ * gelic_net_release_tx_chain - processes sent tx descriptors
+ * @card: adapter structure
+ * @stop: net_stop sequence
+ *
+ * releases the tx descriptors that gelic has finished with
+ */
+static void
+gelic_net_release_tx_chain(struct gelic_net_card *card, int stop)
+{
+	struct gelic_net_descr_chain *tx_chain = &card->tx_chain;
+	enum gelic_net_descr_status status;
+	int release = 0;
+
+	for (;tx_chain->head != tx_chain->tail && tx_chain->tail;) {
+		status = gelic_net_get_descr_status(tx_chain->tail);
+		switch (status) {
+		case GELIC_NET_DESCR_RESPONSE_ERROR:
+		case GELIC_NET_DESCR_PROTECTION_ERROR:
+		case GELIC_NET_DESCR_FORCE_END:
+			printk("%s: forcing end of tx descriptor "
+			       "with status x%02x\n",
+			       card->netdev->name, status);
+			card->netdev_stats.tx_dropped++;
+			break;
+
+		case GELIC_NET_DESCR_COMPLETE:
+			card->netdev_stats.tx_packets++;
+			card->netdev_stats.tx_bytes +=
+				tx_chain->tail->skb->len;
+			break;
+
+		case GELIC_NET_DESCR_CARDOWNED:
+		default: /* any other value (== GELIC_NET_DESCR_NOT_IN_USE) */
+			goto out;
+		}
+		gelic_net_release_tx_descr(card, tx_chain->tail);
+		release = 1;
+	}
+out:
+	/* status NOT_IN_USE or chain end */
+	if (!tx_chain->tail) {
+		/* release all chains */
+		if(card->tx_chain.head) printk("ERROR tx_chain.head is NULL\n");
+		card->tx_chain.tail = card->tx_top;
+		card->tx_chain.head = card->tx_top;
+	}
+	if (!stop && release && netif_queue_stopped(card->netdev)) {
+		netif_wake_queue(card->netdev);
+	}
+}
+
+/**
+ * gelic_net_set_multi - sets multicast addresses and promisc flags
+ * @netdev: interface device structure
+ *
+ * gelic_net_set_multi configures multicast addresses as needed for the
+ * netdev interface. It also sets up multicast, allmulti and promisc
+ * flags appropriately
+ */
+static void
+gelic_net_set_multi(struct net_device *netdev)
+{
+	int i;
+	uint8_t *p;
+	uint64_t addr, status;
+	struct dev_mc_list *mc;
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	/* clear all multicast address */
+	status = lv1_net_remove_multicast_address(card->dev->did.bus_id,
+				card->dev->did.dev_id, 0, 1);
+	if (status) {
+		printk("lv1_net_remove_multicast_address failed, status=%ld\n",\
+			status);
+	}
+	/* set broadcast address */
+	status = lv1_net_add_multicast_address(card->dev->did.bus_id,
+			card->dev->did.dev_id, GELIC_NET_BROADCAST_ADDR, 0);
+	if (status) {
+		printk("lv1_net_add_multicast_address failed, status=%ld\n",\
+			status);
+	}
+
+	if (netdev->flags & IFF_ALLMULTI
+		|| netdev->mc_count > GELIC_NET_MC_COUNT_MAX) { /* list max */
+		status = lv1_net_add_multicast_address(card->dev->did.bus_id,
+				card->dev->did.dev_id,
+				0, 1);
+		if (status) {
+			printk("lv1_net_add_multicast_address failed, status=%ld\n",\
+				status);
+		}
+		return ;
+	}
+
+	/* set multicalst address */
+	for ( mc = netdev->mc_list; mc; mc = mc->next) {
+		addr = 0;
+		p = mc->dmi_addr;
+		for (i = 0; i < ETH_ALEN; i++) {
+			addr <<= 8;
+			addr |= *p++;
+		}
+		status = lv1_net_add_multicast_address(card->dev->did.bus_id,
+				card->dev->did.dev_id,
+				addr, 0);
+		if (status) {
+			printk("lv1_net_add_multicast_address failed, status=%ld\n",\
+				status);
+		}
+	}
+}
+
+/**
+ * gelic_net_disable_rxdmac - disables the receive DMA controller
+ * @card: card structure
+ *
+ * gelic_net_disable_rxdmac terminates processing on the DMA controller by
+ * turing off DMA and issueing a force end
+ */
+static void
+gelic_net_disable_rxdmac(struct gelic_net_card *card)
+{
+	uint64_t status;
+
+	status = lv1_net_stop_rx_dma(card->dev->did.bus_id,
+		card->dev->did.dev_id, 0);
+	if (status) {
+		printk("lv1_net_stop_rx_dma faild, status=%ld\n", status);
+	}
+}
+
+/**
+ * gelic_net_disable_txdmac - disables the transmit DMA controller
+ * @card: card structure
+ *
+ * gelic_net_disable_txdmac terminates processing on the DMA controller by
+ * turing off DMA and issueing a force end
+ */
+static void
+gelic_net_disable_txdmac(struct gelic_net_card *card)
+{
+	uint64_t status;
+
+	status = lv1_net_stop_tx_dma(card->dev->did.bus_id,
+		card->dev->did.dev_id, 0);
+	if (status) {
+		printk("lv1_net_stop_tx_dma faild, status=%ld\n", status);
+	}
+}
+
+/**
+ * gelic_net_stop - called upon ifconfig down
+ * @netdev: interface device structure
+ *
+ * always returns 0
+ */
+int
+gelic_net_stop(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	netif_poll_disable(netdev);
+	netif_stop_queue(netdev);
+
+	/* turn off DMA, force end */
+	gelic_net_disable_rxdmac(card);
+	gelic_net_disable_txdmac(card);
+
+	gelic_net_set_irq_mask(card, 0);
+
+	/* disconnect event port */
+	free_irq(card->netdev->irq, card->netdev);
+	ps3_sb_event_receive_port_destroy(&card->dev->did,
+		card->dev->interrupt_id, card->netdev->irq);
+	card->netdev->irq = NO_IRQ;
+
+	netif_carrier_off(netdev);
+
+	/* release chains */
+	gelic_net_release_tx_chain(card, 1);
+	gelic_net_release_rx_chain(card);
+
+	gelic_net_free_chain(card, card->tx_top);
+	gelic_net_free_chain(card, card->rx_top);
+
+	return 0;
+}
+
+/**
+ * gelic_net_get_next_tx_descr - returns the next available tx descriptor
+ * @card: device structure to get descriptor from
+ *
+ * returns the address of the next descriptor, or NULL if not available.
+ */
+static struct gelic_net_descr *
+gelic_net_get_next_tx_descr(struct gelic_net_card *card)
+{
+	if (card->tx_chain.head == NULL) return NULL;
+	/* check, if head points to not-in-use descr */
+  if (!ps3_gelic_param) {
+	if ( card->tx_chain.tail != card->tx_chain.head->next
+		&& gelic_net_get_descr_status(card->tx_chain.head) ==
+		     GELIC_NET_DESCR_NOT_IN_USE ) {
+		return card->tx_chain.head;
+	} else {
+		return NULL;
+	}
+  } else {
+	if ( card->tx_chain.tail != card->tx_chain.head->next
+		&& card->tx_chain.tail != card->tx_chain.head->next->next
+		&& gelic_net_get_descr_status(card->tx_chain.head) ==
+		     GELIC_NET_DESCR_NOT_IN_USE
+		&& gelic_net_get_descr_status(card->tx_chain.head->next) ==
+		     GELIC_NET_DESCR_NOT_IN_USE ) {
+		return card->tx_chain.head;
+	} else {
+		return NULL;
+	}
+  }
+}
+
+/**
+ * gelic_net_set_txdescr_cmdstat - sets the tx descriptor command field
+ * @descr: descriptor structure to fill out
+ * @skb: packet to consider
+ * @middle: middle of frame
+ *
+ * fills out the command and status field of the descriptor structure,
+ * depending on hardware checksum settings. This function assumes a wmb()
+ * has executed before.
+ */
+static void
+gelic_net_set_txdescr_cmdstat(struct gelic_net_descr *descr,
+			       struct sk_buff *skb, int middle)
+{
+	uint32_t nocs, tcpcs, udpcs;
+
+	if (middle) {
+		nocs =  GELIC_NET_DMAC_CMDSTAT_NOCS;
+		tcpcs = GELIC_NET_DMAC_CMDSTAT_TCPCS;
+		udpcs = GELIC_NET_DMAC_CMDSTAT_UDPCS;
+	}else {
+		nocs =  GELIC_NET_DMAC_CMDSTAT_NOCS
+			| GELIC_NET_DMAC_CMDSTAT_END_FRAME;
+		tcpcs = GELIC_NET_DMAC_CMDSTAT_TCPCS
+			| GELIC_NET_DMAC_CMDSTAT_END_FRAME;
+		udpcs = GELIC_NET_DMAC_CMDSTAT_UDPCS
+			| GELIC_NET_DMAC_CMDSTAT_END_FRAME;
+	}
+
+	if (skb->ip_summed != CHECKSUM_PARTIAL) {
+		descr->dmac_cmd_status = nocs;
+	} else {
+		/* is packet ip?
+		 * if yes: tcp? udp? */
+		if (skb->protocol == htons(ETH_P_IP)) {
+			if (skb->nh.iph->protocol == IPPROTO_TCP) {
+				descr->dmac_cmd_status = tcpcs;
+			} else if (skb->nh.iph->protocol == IPPROTO_UDP) {
+				descr->dmac_cmd_status = udpcs;
+			} else { /* the stack should checksum non-tcp and non-udp
+				    packets on his own: NETIF_F_IP_CSUM */
+				descr->dmac_cmd_status = nocs;
+			}
+		}
+	}
+}
+
+/**
+ * gelic_net_prepare_tx_descr - get dma address of skb_data
+ * @card: card structure
+ * @descr: descriptor structure
+ * @skb: packet to use
+ *
+ * returns 0 on success, <0 on failure.
+ *
+ */
+static int
+gelic_net_prepare_tx_descr_v(struct gelic_net_card *card,
+			    struct gelic_net_descr *descr,
+			    struct sk_buff *skb)
+{
+	dma_addr_t buf;
+	uint8_t *hdr;
+	struct vlan_ethhdr *v_hdr;
+	int vlan_len;
+
+	if (skb->len < GELIC_NET_VLAN_POS) {
+		printk("error: skb->len:%d\n", skb->len);
+		return -EINVAL;
+	}
+	hdr = skb->data;
+	v_hdr = (struct vlan_ethhdr *)skb->data;
+	memcpy(&descr->vlan, v_hdr, GELIC_NET_VLAN_POS);
+	if (card->vlan_index != -1) {
+		descr->vlan.h_vlan_proto = htons(ETH_P_8021Q); /* vlan 0x8100*/
+		descr->vlan.h_vlan_TCI = htons(card->vlan_id[card->vlan_index]);
+		vlan_len = GELIC_NET_VLAN_POS + VLAN_HLEN; /* VLAN_HLEN=4 */
+	} else {
+		vlan_len = GELIC_NET_VLAN_POS; /* no vlan tag */
+	}
+
+	/* first descr */
+	buf = dma_map_single(&card->dev->core, &descr->vlan,
+					 vlan_len, PCI_DMA_BIDIRECTIONAL);
+
+	if (buf == DMA_ERROR_CODE) {
+		printk("could not iommu-map packet (%p, %i). "
+			  "Dropping packet\n", v_hdr, vlan_len);
+		return -ENOMEM;
+	}
+
+	descr->buf_addr = buf;
+	descr->buf_size = vlan_len;
+	descr->skb = skb; /* not used */
+	descr->data_status = 0;
+	gelic_net_set_txdescr_cmdstat(descr, skb, 1); /* not the frame end */
+
+	/* second descr */
+	card->tx_chain.head = card->tx_chain.head->next;
+	descr->next_descr_addr = descr->next->bus_addr;
+	descr = descr->next;
+	if (gelic_net_get_descr_status(descr) !=
+			GELIC_NET_DESCR_NOT_IN_USE) {
+		printk("ERROR descr()\n"); /* XXX will be removed */
+	}
+	buf = dma_map_single(&card->dev->core, hdr + GELIC_NET_VLAN_POS,
+				skb->len - GELIC_NET_VLAN_POS,
+				PCI_DMA_BIDIRECTIONAL);
+
+	if (buf == DMA_ERROR_CODE) {
+		printk("could not iommu-map packet (%p, %i). "
+			  "Dropping packet\n", hdr + GELIC_NET_VLAN_POS,
+			  skb->len - GELIC_NET_VLAN_POS);
+		return -ENOMEM;
+	}
+
+	descr->buf_addr = buf;
+	descr->buf_size = skb->len - GELIC_NET_VLAN_POS;
+	descr->skb = skb;
+	descr->data_status = 0;
+	descr->next_descr_addr= 0;
+	gelic_net_set_txdescr_cmdstat(descr,skb, 0);
+
+	return 0;
+}
+
+static int
+gelic_net_prepare_tx_descr(struct gelic_net_card *card,
+			    struct gelic_net_descr *descr,
+			    struct sk_buff *skb)
+{
+	dma_addr_t buf = dma_map_single(&card->dev->core, skb->data,
+					 skb->len, PCI_DMA_BIDIRECTIONAL);
+
+	if (buf == DMA_ERROR_CODE) {
+		printk("could not iommu-map packet (%p, %i). "
+			  "Dropping packet\n", skb->data, skb->len);
+		return -ENOMEM;
+	}
+
+	descr->buf_addr = buf;
+	descr->buf_size = skb->len;
+	descr->skb = skb;
+	descr->data_status = 0;
+
+	return 0;
+}
+
+static void
+gelic_net_set_frame_end(struct gelic_net_card *card,
+		struct gelic_net_descr *descr, struct sk_buff *skb)
+{
+	descr->next_descr_addr= 0;
+	gelic_net_set_txdescr_cmdstat(descr,skb, 0);
+	wmb();
+	if (descr->prev) {
+		descr->prev->next_descr_addr = descr->bus_addr;
+	}
+}
+
+/**
+ * gelic_net_kick_txdma - enables TX DMA processing
+ * @card: card structure
+ * @descr: descriptor address to enable TX processing at
+ *
+ */
+static void
+gelic_net_kick_txdma(struct gelic_net_card *card,
+		       struct gelic_net_descr *descr)
+{
+	uint64_t status = -1;
+	int count = 10;
+
+	if (dmac_status) {
+		return ;
+	}
+
+	if (gelic_net_get_descr_status(descr) == GELIC_NET_DESCR_CARDOWNED) {
+		/* kick */
+		dmac_status = 1;
+
+		while(count--) {
+			status = lv1_net_start_tx_dma(card->dev->did.bus_id,
+					card->dev->did.dev_id,
+					(uint64_t)descr->bus_addr, 0);
+			if (!status) {
+				break;
+			}
+		}
+		if (!count) {
+			printk("lv1_net_start_txdma failed, status=%ld %016lx\n",\
+				status, gelic_irq_status);
+		}
+	}
+}
+
+/**
+ * gelic_net_xmit - transmits a frame over the device
+ * @skb: packet to send out
+ * @netdev: interface device structure
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int
+gelic_net_xmit(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	struct gelic_net_descr *descr = NULL;
+	int result;
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->intmask_lock, flags);
+
+	gelic_net_release_tx_chain(card, 0);
+	if (skb == NULL){
+		goto kick;
+	}
+	descr = gelic_net_get_next_tx_descr(card); /* get tx_chain.head */
+	if (!descr) {
+		netif_stop_queue(netdev);
+		spin_unlock_irqrestore(&card->intmask_lock, flags);
+		return 1;
+	}
+  if (!ps3_gelic_param) {
+	result = gelic_net_prepare_tx_descr(card, descr, skb);
+  } else {
+	result = gelic_net_prepare_tx_descr_v(card, descr, skb);
+  }
+	if (result)
+		goto error;
+
+	card->tx_chain.head = card->tx_chain.head->next;
+  if (!ps3_gelic_param) {
+	gelic_net_set_frame_end(card, descr, skb);
+  } else {
+	if (descr->prev) {
+		descr->prev->next_descr_addr = descr->bus_addr;
+	}
+  }
+kick:
+	wmb();
+	gelic_net_kick_txdma(card, card->tx_chain.tail);
+
+	netdev->trans_start = jiffies;
+	spin_unlock_irqrestore(&card->intmask_lock, flags);
+	return NETDEV_TX_OK;
+
+error:
+	card->netdev_stats.tx_dropped++;
+	spin_unlock_irqrestore(&card->intmask_lock, flags);
+	return NETDEV_TX_LOCKED;
+}
+
+/**
+ * gelic_net_pass_skb_up - takes an skb from a descriptor and passes it on
+ * @descr: descriptor to process
+ * @card: card structure
+ *
+ * returns 1 on success, 0 if no packet was passed to the stack
+ *
+ * iommu-unmaps the skb, fills out skb structure and passes the data to the
+ * stack. The descriptor state is not changed.
+ */
+static int
+gelic_net_pass_skb_up(struct gelic_net_descr *descr,
+		       struct gelic_net_card *card)
+{
+	struct sk_buff *skb;
+	struct net_device *netdev;
+	uint32_t data_status, data_error;
+
+	data_status = descr->data_status;
+	data_error = descr->data_error;
+
+	netdev = card->netdev;
+	/* check for errors in the data_error flag */
+	if ((data_error & GELIC_NET_DATA_ERROR_MASK))
+		DPRINTK("error in received descriptor found, "
+		       "data_status=x%08x, data_error=x%08x\n",
+		       data_status, data_error);
+	/* prepare skb, unmap descriptor */
+	skb = descr->skb;
+	dma_unmap_single(&card->dev->core, descr->buf_addr, GELIC_NET_MAX_MTU,
+			 PCI_DMA_BIDIRECTIONAL);
+
+	/* the cases we'll throw away the packet immediately */
+	if (data_error & GELIC_NET_DATA_ERROR_FLG) {
+		DPRINTK("ERROR DESTROY:%x\n", data_error);
+		return 0;
+	}
+
+	skb->dev = netdev;
+	skb_put(skb, descr->valid_size);
+	descr->skb = NULL;
+	/* the card seems to add 2 bytes of junk in front
+	 * of the ethernet frame */
+#define GELIC_NET_MISALIGN		2
+	skb_pull(skb, GELIC_NET_MISALIGN);
+	skb->protocol = eth_type_trans(skb, netdev);
+
+	/* checksum offload */
+	if (card->rx_csum) {
+		if ( (data_status & GELIC_NET_DATA_STATUS_CHK_MASK) &&
+		     (!(data_error & GELIC_NET_DATA_ERROR_CHK_MASK)) )
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+		else
+			skb->ip_summed = CHECKSUM_NONE;
+	} else {
+		skb->ip_summed = CHECKSUM_NONE;
+	}
+
+	/* pass skb up to stack */
+	netif_receive_skb(skb);
+
+	/* update netdevice statistics */
+	card->netdev_stats.rx_packets++;
+	card->netdev_stats.rx_bytes += skb->len;
+
+	return 1;
+}
+
+/**
+ * gelic_net_decode_descr - processes an rx descriptor
+ * @card: card structure
+ *
+ * returns 1 if a packet has been sent to the stack, otherwise 0
+ *
+ * processes an rx descriptor by iommu-unmapping the data buffer and passing
+ * the packet up to the stack
+ */
+static int
+gelic_net_decode_one_descr(struct gelic_net_card *card)
+{
+	enum gelic_net_descr_status status;
+	struct gelic_net_descr *descr;
+	struct gelic_net_descr_chain *chain = &card->rx_chain;
+	int result = 0;
+	int kick = 0;
+	uint32_t cmd_status;
+
+	descr = chain->tail;
+	cmd_status = chain->tail->dmac_cmd_status;
+	rmb();
+	status = cmd_status >> GELIC_NET_DESCR_IND_PROC_SHIFT;
+	if (status == GELIC_NET_DESCR_CARDOWNED) {
+		goto no_decode;
+	}
+	if (status == GELIC_NET_DESCR_NOT_IN_USE) {
+		printk("err: decode_one_descr\n");
+		goto no_decode;
+	}
+
+	if ( (status == GELIC_NET_DESCR_RESPONSE_ERROR) ||
+	     (status == GELIC_NET_DESCR_PROTECTION_ERROR) ||
+	     (status == GELIC_NET_DESCR_FORCE_END) ) {
+		printk("%s: dropping RX descriptor with state %d\n",
+		       card->netdev->name, status);
+		card->netdev_stats.rx_dropped++;
+		goto refill;
+	}
+
+	if ( (status != GELIC_NET_DESCR_COMPLETE) &&
+	     (status != GELIC_NET_DESCR_FRAME_END) ) {
+		printk("%s: RX descriptor with state %d\n",
+		       card->netdev->name, status);
+		goto refill;
+	}
+
+	/* ok, we've got a packet in descr */
+	result = gelic_net_pass_skb_up(descr, card); /* 1: skb_up sccess */
+	if (cmd_status & GELIC_NET_DMAC_CMDSTAT_CHAIN_END) {
+		kick = 1;
+	}
+refill:
+	descr->next_descr_addr = 0; /* unlink the descr */
+	wmb();
+	gelic_net_set_descr_status(descr, GELIC_NET_DESCR_NOT_IN_USE);
+	/* change the descriptor state: */
+	gelic_net_prepare_rx_descr(card, descr); /* refill one desc */
+	chain->head = descr;
+	chain->tail = descr->next;
+	descr->prev->next_descr_addr = descr->bus_addr;
+	if(kick) {
+		wmb();
+		gelic_net_enable_rxdmac(card);
+	}
+	return result;
+
+no_decode:
+	return 0;
+}
+
+/**
+ * gelic_net_poll - NAPI poll function called by the stack to return packets
+ * @netdev: interface device structure
+ * @budget: number of packets we can pass to the stack at most
+ *
+ * returns 0 if no more packets available to the driver/stack. Returns 1,
+ * if the quota is exceeded, but the driver has still packets.
+ *
+ */
+static int
+gelic_net_poll(struct net_device *netdev, int *budget)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	int packets_to_do, packets_done = 0;
+	int no_more_packets = 0;
+
+	packets_to_do = min(*budget, netdev->quota);
+
+	while (packets_to_do) {
+		if (gelic_net_decode_one_descr(card)) {
+			packets_done++;
+			packets_to_do--;
+		} else {
+			/* no more packets for the stack */
+			no_more_packets = 1;
+			break;
+		}
+	}
+	netdev->quota -= packets_done;
+	*budget -= packets_done;
+	if (no_more_packets == 1) {
+		netif_rx_complete(netdev);
+
+		/* one more check */
+		while (1) {
+			if (!gelic_net_decode_one_descr(card) ) break;
+		};
+
+		return 0;
+	}else {
+		return 1;
+	}
+}
+
+/**
+ * gelic_net_get_stats - get interface statistics
+ * @netdev: interface device structure
+ *
+ * returns the interface statistics residing in the gelic_net_card struct
+ */
+static struct net_device_stats *
+gelic_net_get_stats(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	struct net_device_stats *stats = &card->netdev_stats;
+
+	return stats;
+}
+
+/**
+ * gelic_net_change_mtu - changes the MTU of an interface
+ * @netdev: interface device structure
+ * @new_mtu: new MTU value
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int
+gelic_net_change_mtu(struct net_device *netdev, int new_mtu)
+{
+	/* no need to re-alloc skbs or so -- the max mtu is about 2.3k
+	 * and mtu is outbound only anyway */
+	if ( (new_mtu < GELIC_NET_MIN_MTU ) ||
+		(new_mtu > GELIC_NET_MAX_MTU) ) {
+		return -EINVAL;
+	}
+	netdev->mtu = new_mtu;
+	return 0;
+}
+
+/**
+ * gelic_net_interrupt - event handler for gelic_net
+ */
+static irqreturn_t
+gelic_net_interrupt(int irq, void *ptr)
+{
+	struct net_device *netdev = ptr;
+	struct gelic_net_card *card = netdev_priv(netdev);
+	uint32_t status0, status1, status2;
+	unsigned long flags;
+	uint64_t status;
+
+	status = gelic_irq_status;
+	rmb();
+	status0 = (uint32_t)(status >> 32);
+	status1 = (uint32_t)(status & 0xffffffff);
+	status2 = 0;
+
+	if (!status0 && !status1 && !status2) {
+		return IRQ_NONE;
+	}
+
+	if(status1 & (1 << GELIC_NET_GDADCEINT) )  {
+		netif_rx_schedule(netdev);
+	}else
+	if (status0 & (1 << GELIC_NET_GRFANMINT) ) {
+		netif_rx_schedule(netdev);
+	}
+
+	if (status0 & (1 << GELIC_NET_GDTDCEINT) ) {
+		spin_lock_irqsave(&card->intmask_lock, flags);
+		dmac_status = 0;
+		spin_unlock_irqrestore(&card->intmask_lock, flags);
+		gelic_net_xmit(NULL, netdev);
+	}
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/**
+ * gelic_net_poll_controller - artificial interrupt for netconsole etc.
+ * @netdev: interface device structure
+ *
+ * see Documentation/networking/netconsole.txt
+ */
+static void
+gelic_net_poll_controller(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	gelic_net_set_irq_mask(card, 0);
+	gelic_net_interrupt(netdev->irq, netdev);
+	gelic_net_set_irq_mask(card, card->ghiintmask);
+}
+#endif /* CONFIG_NET_POLL_CONTROLLER */
+
+/**
+ * gelic_net_open_device - open device and map dma region
+ * @card: card structure
+ */
+static int
+gelic_net_open_device(struct gelic_net_card *card)
+{
+	unsigned long result;
+	int ret;
+
+	result = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+		&card->dev->did, card->dev->interrupt_id, &card->netdev->irq);
+
+	if (result) {
+		printk("%s:%d: gelic_net_open_device failed (%ld)\n",
+			__func__, __LINE__, result);
+		ret = -EPERM;
+		goto fail_alloc_irq;
+	}
+
+	ret = request_irq(card->netdev->irq, gelic_net_interrupt, IRQF_DISABLED,
+		"gelic network", card->netdev);
+
+	if (ret) {
+		printk("%s:%d: request_irq failed (%ld)\n",
+			__func__, __LINE__, result);
+		goto fail_request_irq;
+	}
+
+	return 0;
+
+fail_request_irq:
+	ps3_sb_event_receive_port_destroy(&card->dev->did,
+		card->dev->interrupt_id, card->netdev->irq);
+	card->netdev->irq = NO_IRQ;
+fail_alloc_irq:
+	return ret;
+}
+
+
+/**
+ * gelic_net_open - called upon ifonfig up
+ * @netdev: interface device structure
+ *
+ * returns 0 on success, <0 on failure
+ *
+ * gelic_net_open allocates all the descriptors and memory needed for
+ * operation, sets up multicast list and enables interrupts
+ */
+int
+gelic_net_open(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	printk(" -> %s:%d\n", __func__, __LINE__);
+
+	gelic_net_open_device(card);
+
+	if (gelic_net_init_chain(card, &card->tx_chain,
+			card->descr, tx_descriptors))
+		goto alloc_tx_failed;
+	if (gelic_net_init_chain(card, &card->rx_chain,
+			card->descr + tx_descriptors, rx_descriptors))
+		goto alloc_rx_failed;
+
+	/* head of chain */
+	card->tx_top = card->tx_chain.head;
+	card->rx_top = card->rx_chain.head;
+
+	/* allocate rx skbs */
+	if (gelic_net_alloc_rx_skbs(card))
+		goto alloc_skbs_failed;
+
+	dmac_status = 0;
+	card->ghiintmask = GELIC_NET_RXINT | GELIC_NET_TXINT;
+	gelic_net_set_irq_mask(card, card->ghiintmask);
+	gelic_net_enable_rxdmac(card);
+
+	netif_start_queue(netdev);
+	netif_carrier_on(netdev);
+	netif_poll_enable(netdev);
+
+	return 0;
+
+alloc_skbs_failed:
+	gelic_net_free_chain(card, card->rx_top);
+alloc_rx_failed:
+	gelic_net_free_chain(card, card->tx_top);
+alloc_tx_failed:
+	return -ENOMEM;
+}
+
+#ifdef GELIC_NET_ETHTOOL
+static void
+gelic_net_get_drvinfo (struct net_device *netdev, struct ethtool_drvinfo *info)
+{
+	strncpy(info->driver, GELIC_NET_DRV_NAME, sizeof(info->driver) - 1);
+	strncpy(info->version, GELIC_NET_DRV_VERSION, sizeof(info->version) - 1);
+}
+
+static int
+gelic_net_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	uint64_t status, v1, v2;
+	int speed, duplex;
+
+	speed = duplex = -1;
+	status = lv1_net_control(card->dev->did.bus_id, card->dev->did.dev_id,
+			GELIC_NET_GET_ETH_PORT_STATUS, GELIC_NET_PORT, 0, 0,
+			&v1, &v2);
+	if (status) {
+		/* link down */
+	} else {
+		if (v1 & GELIC_NET_FULL_DUPLEX) {
+			duplex = DUPLEX_FULL;
+		} else {
+			duplex = DUPLEX_HALF;
+		}
+
+		if (v1 & GELIC_NET_SPEED_10 ) {
+			speed = SPEED_10;
+		} else if (v1 & GELIC_NET_SPEED_100) {
+			speed = SPEED_100;
+		} else if (v1 & GELIC_NET_SPEED_1000) {
+			speed = SPEED_1000;
+		}
+	}
+	cmd->supported = SUPPORTED_TP | SUPPORTED_Autoneg |
+			SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+			SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+			SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full;
+	cmd->advertising = cmd->supported;
+	cmd->speed = speed;
+	cmd->duplex = duplex;
+	cmd->autoneg = AUTONEG_ENABLE; /* always enabled */
+	cmd->port = PORT_TP;
+
+	return 0;
+}
+
+static uint32_t
+gelic_net_get_link(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	uint64_t status, v1, v2;
+	int link;
+
+	status = lv1_net_control(card->dev->did.bus_id, card->dev->did.dev_id,
+			GELIC_NET_GET_ETH_PORT_STATUS, GELIC_NET_PORT, 0, 0,
+			&v1, &v2);
+	if (status) {
+		return 0; /* link down */
+	}
+	if (v1 & GELIC_NET_LINK_UP)
+		link = 1;
+	else
+		link = 0;
+	return link;
+}
+
+static int
+gelic_net_nway_reset(struct net_device *netdev)
+{
+	if (netif_running(netdev)) {
+		gelic_net_stop(netdev);
+		gelic_net_open(netdev);
+	}
+	return 0;
+}
+
+static uint32_t
+gelic_net_get_tx_csum(struct net_device *netdev)
+{
+	return (netdev->features & NETIF_F_IP_CSUM) != 0;
+}
+
+static int
+gelic_net_set_tx_csum(struct net_device *netdev, uint32_t data)
+{
+	if (data)
+		netdev->features |= NETIF_F_IP_CSUM;
+	else
+		netdev->features &= ~NETIF_F_IP_CSUM;
+
+	return 0;
+}
+
+static uint32_t
+gelic_net_get_rx_csum(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	return card->rx_csum;
+}
+
+static int
+gelic_net_set_rx_csum(struct net_device *netdev, uint32_t data)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	card->rx_csum = data;
+	return 0;
+}
+
+static struct ethtool_ops gelic_net_ethtool_ops = {
+	.get_drvinfo	= gelic_net_get_drvinfo,
+	.get_settings	= gelic_net_get_settings,
+	.get_link	= gelic_net_get_link,
+	.nway_reset	= gelic_net_nway_reset,
+	.get_tx_csum	= gelic_net_get_tx_csum,
+	.set_tx_csum	= gelic_net_set_tx_csum,
+	.get_rx_csum	= gelic_net_get_rx_csum,
+	.set_rx_csum	= gelic_net_set_rx_csum,
+};
+#endif
+
+static int
+gelic_net_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	void __user *addr = (void __user *) ifr->ifr_ifru.ifru_data;
+	int mode, res = 0;
+
+	switch(cmd) {
+	case GELIC_NET_GET_MODE:
+		DPRINTK("GELIC_NET_GET_MODE:\n");
+		mode = card->vlan_index;
+		if (copy_to_user(addr, &mode, sizeof(mode)) ) {
+			printk("error copy_to_user\n");
+		}
+		res = 0;
+		break;
+	case GELIC_NET_SET_MODE:
+		if (card->vlan_index == -1) {
+			res = -EOPNOTSUPP; /* vlan mode only */
+			break;
+		}
+		if (copy_from_user(&mode, addr, sizeof(mode)) ) {
+			printk("error copy_from_user\n");
+		}
+		DPRINTK("GELIC_NET_SET_MODE:%x --> %x \n",
+				card->vlan_index, mode);
+		if (mode > GELIC_NET_VLAN_MAX -1 || mode < -1)
+			mode = GELIC_NET_VLAN_WIRED - 1;
+
+		if (card->vlan_index != mode) {
+			card->vlan_index = mode;
+			if (netif_running(netdev)) {
+				gelic_net_stop(netdev);
+				gelic_net_open(netdev);
+			}
+		}
+		res = 0;
+		break;
+	default:
+		res = -EOPNOTSUPP;
+		break;
+	}
+
+	return res;
+}
+
+/**
+ * gelic_net_tx_timeout_task - task scheduled by the watchdog timeout
+ * function (to be called not under interrupt status)
+ * @data: data, is interface device structure
+ *
+ * called as task when tx hangs, resets interface (if interface is up)
+ */
+static void
+gelic_net_tx_timeout_task(struct work_struct *work)
+{
+	struct gelic_net_card *card =
+		container_of(work, struct gelic_net_card, tx_timeout_task);
+	struct net_device *netdev = card->netdev;
+
+	printk("Timed out. Restarting... \n");
+
+	if (!(netdev->flags & IFF_UP))
+		goto out;
+
+	netif_device_detach(netdev);
+	gelic_net_stop(netdev);
+
+	gelic_net_open(netdev);
+	netif_device_attach(netdev);
+
+out:
+	atomic_dec(&card->tx_timeout_task_counter);
+}
+
+/**
+ * gelic_net_tx_timeout - called when the tx timeout watchdog kicks in.
+ * @netdev: interface device structure
+ *
+ * called, if tx hangs. Schedules a task that resets the interface
+ */
+static void
+gelic_net_tx_timeout(struct net_device *netdev)
+{
+	struct gelic_net_card *card;
+
+	card = netdev_priv(netdev);
+	atomic_inc(&card->tx_timeout_task_counter);
+	if (netdev->flags & IFF_UP)
+		schedule_work(&card->tx_timeout_task);
+	else
+		atomic_dec(&card->tx_timeout_task_counter);
+}
+
+/**
+ * gelic_net_setup_netdev_ops - initialization of net_device operations
+ * @netdev: net_device structure
+ *
+ * fills out function pointers in the net_device structure
+ */
+static void
+gelic_net_setup_netdev_ops(struct net_device *netdev)
+{
+	netdev->open = &gelic_net_open;
+	netdev->stop = &gelic_net_stop;
+	netdev->hard_start_xmit = &gelic_net_xmit;
+	netdev->get_stats = &gelic_net_get_stats;
+	netdev->set_multicast_list = &gelic_net_set_multi;
+	netdev->change_mtu = &gelic_net_change_mtu;
+	/* tx watchdog */
+	netdev->tx_timeout = &gelic_net_tx_timeout;
+	netdev->watchdog_timeo = GELIC_NET_WATCHDOG_TIMEOUT;
+	/* NAPI */
+	netdev->poll = &gelic_net_poll;
+	netdev->weight = GELIC_NET_NAPI_WEIGHT;
+#ifdef GELIC_NET_ETHTOOL
+	netdev->ethtool_ops = &gelic_net_ethtool_ops;
+#endif
+	netdev->do_ioctl = &gelic_net_ioctl;
+}
+
+/**
+ * gelic_net_setup_netdev - initialization of net_device
+ * @card: card structure
+ *
+ * Returns 0 on success or <0 on failure
+ *
+ * gelic_net_setup_netdev initializes the net_device structure
+ **/
+static int
+gelic_net_setup_netdev(struct gelic_net_card *card)
+{
+	int i, result;
+	struct net_device *netdev = card->netdev;
+	struct sockaddr addr;
+	uint8_t *mac;
+	uint64_t status, v1, v2;
+
+	SET_MODULE_OWNER(netdev);
+	spin_lock_init(&card->intmask_lock);
+
+	card->rx_csum = GELIC_NET_RX_CSUM_DEFAULT;
+
+	gelic_net_setup_netdev_ops(netdev);
+
+	netdev->features = NETIF_F_IP_CSUM;
+
+	status = lv1_net_control(card->dev->did.bus_id, card->dev->did.dev_id,
+				GELIC_NET_GET_MAC_ADDRESS,
+				0, 0, 0, &v1, &v2);
+	if (status || !v1) {
+		printk("lv1_net_control GET_MAC_ADDR not supported, status=%ld\n",
+			status);
+		return -EINVAL;
+	}
+	v1 <<= 16;
+	mac = (uint8_t *)&v1;
+	memcpy(addr.sa_data, mac, ETH_ALEN);
+	memcpy(netdev->dev_addr, addr.sa_data, ETH_ALEN);
+
+	result = register_netdev(netdev);
+	if (result) {
+			printk("Couldn't register net_device: %i\n", result);
+		return result;
+	}
+
+	printk("%s: %s\n", netdev->name, GELIC_NET_DRV_NAME);
+	printk("%s: Ethernet Address: %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X\n",
+		netdev->name,
+		netdev->dev_addr[0], netdev->dev_addr[1], netdev->dev_addr[2],
+		netdev->dev_addr[3], netdev->dev_addr[4], netdev->dev_addr[5]);
+
+	card->vlan_index = -1;	/* no vlan */
+	for (i = 0; i < GELIC_NET_VLAN_MAX ;i++) {
+		status = lv1_net_control(card->dev->did.bus_id,
+					card->dev->did.dev_id,
+					GELIC_NET_GET_VLAN_ID,
+					i + 1, /* GELIC_NET_VLAN_X */
+					0, 0, &v1, &v2);
+		if (status == GELIC_NET_VLAN_NO_ENTRY) {
+			DPRINTK("GELIC_VLAN_ID no entry:%ld, VLAN disabled\n",
+				status);
+			card->vlan_id[i] = 0;
+		} else if (status) {
+			printk("GELIC_NET_VLAN_ID faild, status=%ld\n", status);
+			card->vlan_id[i] = 0;
+		} else {
+			card->vlan_id[i] = (uint32_t)v1;
+			DPRINTK("vlan_id:%d, %lx\n", i, v1);
+		}
+	}
+	if (card->vlan_id[GELIC_NET_VLAN_WIRED - 1]) {
+		card->vlan_index = GELIC_NET_VLAN_WIRED - 1;
+	}
+	return 0;
+}
+
+/**
+ * gelic_net_alloc_card - allocates net_device and card structure
+ *
+ * returns the card structure or NULL in case of errors
+ *
+ * the card and net_device structures are linked to each other
+ */
+static struct gelic_net_card *
+gelic_net_alloc_card(void)
+{
+	struct net_device *netdev;
+	struct gelic_net_card *card;
+	size_t alloc_size;
+
+	alloc_size = sizeof (*card) +
+		sizeof (struct gelic_net_descr) * rx_descriptors +
+		sizeof (struct gelic_net_descr) * tx_descriptors;
+	netdev = alloc_etherdev(alloc_size);
+	if (!netdev)
+		return NULL;
+
+	card = netdev_priv(netdev);
+	card->netdev = netdev;
+	INIT_WORK(&card->tx_timeout_task, gelic_net_tx_timeout_task);
+	init_waitqueue_head(&card->waitq);
+	atomic_set(&card->tx_timeout_task_counter, 0);
+
+	return card;
+}
+
+/**
+ * ps3_gelic_driver_probe - add a device to the control of this driver
+ */
+static int ps3_gelic_driver_probe (struct ps3_system_bus_device *dev)
+{
+	struct gelic_net_card *card;
+	int error = -EIO;
+	uint64_t status;
+	uint64_t lpar;
+
+	card = gelic_net_alloc_card();
+	if (!card) {
+		printk("Couldn't allocate net_device structure, aborting.\n");
+		return -ENOMEM;
+	}
+	gcard = card;
+	card->dev = dev;
+
+	/* setup status indicator */
+	lpar = ps3_mm_phys_to_lpar(__pa(&gelic_irq_status));
+	status = lv1_net_set_interrupt_status_indicator(
+						card->dev->did.bus_id,
+						card->dev->did.dev_id,
+						lpar, 0);
+	if (status) {
+		printk("lv1_net_set_interrupt_status_indicator failed, status=%ld\n",
+			status);
+		goto error;
+	}
+
+	error = gelic_net_setup_netdev(card);
+	if (error) {
+		printk("gelic_net_setup_netdev() failed: error = %d\n", error);
+		goto error;
+	}
+	return 0;
+
+error:
+	free_netdev(card->netdev);
+	return error;
+}
+
+/**
+ * ps3_gelic_driver_remove - remove a device from the control of this driver
+ */
+
+static int
+ps3_gelic_driver_remove (struct ps3_system_bus_device *dev)
+{
+	struct net_device *netdev;
+	struct gelic_net_card *card;
+
+	card = gcard;
+	netdev = card->netdev;
+
+	wait_event(card->waitq,
+		   atomic_read(&card->tx_timeout_task_counter) == 0);
+
+	unregister_netdev(netdev);
+	free_netdev(netdev);
+
+	return 0;
+}
+
+static struct ps3_system_bus_driver ps3_gelic_driver = {
+	.match_id = PS3_MATCH_ID_GELIC,
+	.probe = ps3_gelic_driver_probe,
+	.remove = ps3_gelic_driver_remove,
+	.core = {
+		.name = "ps3_gelic_driver",
+	},
+};
+
+static int __init
+ps3_gelic_driver_init (void)
+{
+	return firmware_has_feature(FW_FEATURE_PS3_LV1)
+		? ps3_system_bus_driver_register(&ps3_gelic_driver)
+		: -ENODEV;
+}
+
+static void __exit
+ps3_gelic_driver_exit (void)
+{
+	ps3_system_bus_driver_unregister(&ps3_gelic_driver);
+}
+
+module_init (ps3_gelic_driver_init);
+module_exit (ps3_gelic_driver_exit);
+
+#ifdef CONFIG_GELIC_NET
+static int __init early_param_gelic_net(char *p)
+{
+	if (strstr(p, "n")) {
+		ps3_gelic_param = 0;	/* gelic_vlan off */
+		printk("ps3_gelic_param:vlan off\n");
+	} else {
+		ps3_gelic_param = 1;	/* gelic_vlan on */
+	}
+	return 0;
+
+}
+early_param("gelic_vlan", early_param_gelic_net);
+#endif
diff -Naur linux-2.6.21.1-org/drivers/ps3/ps3av.c linux-2.6.21.1-ps3/drivers/ps3/ps3av.c
--- linux-2.6.21.1-org/drivers/ps3/ps3av.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/ps3/ps3av.c	2007-05-21 13:50:29.494321740 +0200
@@ -38,7 +38,24 @@
 static int timeout = 5000;	/* in msec ( 5 sec ) */
 module_param(timeout, int, 0644);
 
-static struct ps3av ps3av;
+static struct ps3av {
+	int available;
+	struct mutex mutex;
+	struct work_struct work;
+	struct completion done;
+	struct workqueue_struct *wq;
+	int open_count;
+	struct ps3_vuart_port_device *dev;
+
+	int region;
+	struct ps3av_pkt_av_get_hw_conf av_hw_conf;
+	u32 av_port[PS3AV_AV_PORT_MAX + PS3AV_OPT_PORT_MAX];
+	u32 opt_port[PS3AV_OPT_PORT_MAX];
+	u32 head[PS3AV_HEAD_MAX];
+	u32 audio_port;
+	int ps3av_mode;
+	int ps3av_mode_old;
+} ps3av;
 
 static struct ps3_vuart_port_device ps3av_dev = {
 	.match_id = PS3_MATCH_ID_AV_SETTINGS
@@ -159,7 +176,7 @@
 		else
 			printk(KERN_ERR
 			       "%s: failed event packet, cid:%08x size:%d\n",
-			       __FUNCTION__, hdr->cid, hdr->size);
+			       __func__, hdr->cid, hdr->size);
 		return 1;	/* receive event packet */
 	}
 	return 0;
@@ -181,7 +198,7 @@
 	if (res < 0) {
 		dev_dbg(&ps3av_dev.core,
 			"%s: ps3av_vuart_write() failed (result=%d)\n",
-			__FUNCTION__, res);
+			__func__, res);
 		return res;
 	}
 
@@ -194,7 +211,7 @@
 		if (res != PS3AV_HDR_SIZE) {
 			dev_dbg(&ps3av_dev.core,
 				"%s: ps3av_vuart_read() failed (result=%d)\n",
-				__FUNCTION__, res);
+				__func__, res);
 			return res;
 		}
 
@@ -204,7 +221,7 @@
 		if (res < 0) {
 			dev_dbg(&ps3av_dev.core,
 				"%s: ps3av_vuart_read() failed (result=%d)\n",
-				__FUNCTION__, res);
+				__func__, res);
 			return res;
 		}
 		res += PS3AV_HDR_SIZE;	/* total len */
@@ -214,7 +231,7 @@
 
 	if ((cmd | PS3AV_REPLY_BIT) != recv_buf->cid) {
 		dev_dbg(&ps3av_dev.core, "%s: reply err (result=%x)\n",
-			__FUNCTION__, recv_buf->cid);
+			__func__, recv_buf->cid);
 		return -EINVAL;
 	}
 
@@ -250,7 +267,7 @@
 		 struct ps3av_send_hdr *buf)
 {
 	int res = 0;
-	union {
+	static union {
 		struct ps3av_reply_hdr reply_hdr;
 		u8 raw[PS3AV_BUF_SIZE];
 	} recv_buf;
@@ -259,8 +276,7 @@
 
 	BUG_ON(!ps3av.available);
 
-	if (down_interruptible(&ps3av.sem))
-		return -ERESTARTSYS;
+	mutex_lock(&ps3av.mutex);
 
 	table = ps3av_search_cmd_table(cid, PS3AV_CID_MASK);
 	BUG_ON(!table);
@@ -277,7 +293,7 @@
 	if (res < 0) {
 		printk(KERN_ERR
 		       "%s: ps3av_send_cmd_pkt() failed (result=%d)\n",
-		       __FUNCTION__, res);
+		       __func__, res);
 		goto err;
 	}
 
@@ -286,16 +302,16 @@
 					 usr_buf_size);
 	if (res < 0) {
 		printk(KERN_ERR "%s: put_return_status() failed (result=%d)\n",
-		       __FUNCTION__, res);
+		       __func__, res);
 		goto err;
 	}
 
-	up(&ps3av.sem);
+	mutex_unlock(&ps3av.mutex);
 	return 0;
 
       err:
-	up(&ps3av.sem);
-	printk(KERN_ERR "%s: failed cid:%x res:%d\n", __FUNCTION__, cid, res);
+	mutex_unlock(&ps3av.mutex);
+	printk(KERN_ERR "%s: failed cid:%x res:%d\n", __func__, cid, res);
 	return res;
 }
 
@@ -440,7 +456,7 @@
 	ps3av_set_av_video_mute(PS3AV_CMD_MUTE_ON);
 
 	/* wake up ps3avd to do the actual video mode setting */
-	up(&ps3av.ping);
+	queue_work(ps3av.wq, &ps3av.work);
 
 	return 0;
 }
@@ -506,7 +522,7 @@
 	if (res == PS3AV_STATUS_NO_SYNC_HEAD)
 		printk(KERN_WARNING
 		       "%s: Command failed. Please try your request again. \n",
-		       __FUNCTION__);
+		       __func__);
 	else if (res)
 		dev_dbg(&ps3av_dev.core, "ps3av_cmd_avb_param failed\n");
 
@@ -515,18 +531,10 @@
 	ps3av_set_av_video_mute(PS3AV_CMD_MUTE_OFF);
 }
 
-static int ps3avd(void *p)
+static void ps3avd(struct work_struct *work)
 {
-	struct ps3av *info = p;
-
-	daemonize("ps3avd");
-	while (1) {
-		down(&info->ping);
-		ps3av_set_videomode_cont(info->ps3av_mode,
-					 info->ps3av_mode_old);
-		up(&info->pong);
-	}
-	return 0;
+	ps3av_set_videomode_cont(ps3av.ps3av_mode, ps3av.ps3av_mode_old);
+	complete(&ps3av.done);
 }
 
 static int ps3av_vid2table_id(int vid)
@@ -707,8 +715,7 @@
 
 	size = ARRAY_SIZE(video_mode_table);
 	if ((id & PS3AV_MODE_MASK) > size - 1 || id < 0) {
-		dev_dbg(&ps3av_dev.core, "%s: error id :%d\n", __FUNCTION__,
-			id);
+		dev_dbg(&ps3av_dev.core, "%s: error id :%d\n", __func__, id);
 		return -EINVAL;
 	}
 
@@ -717,15 +724,14 @@
 	if ((id & PS3AV_MODE_MASK) == 0) {
 		id = ps3av_auto_videomode(&ps3av.av_hw_conf, boot);
 		if (id < 1) {
-			printk(KERN_ERR "%s: invalid id :%d\n", __FUNCTION__,
-			       id);
+			printk(KERN_ERR "%s: invalid id :%d\n", __func__, id);
 			return -EINVAL;
 		}
 		id |= option;
 	}
 
 	/* set videomode */
-	down(&ps3av.pong);
+	wait_for_completion(&ps3av.done);
 	ps3av.ps3av_mode_old = ps3av.ps3av_mode;
 	ps3av.ps3av_mode = id;
 	if (ps3av_set_videomode())
@@ -736,6 +742,13 @@
 
 EXPORT_SYMBOL_GPL(ps3av_set_video_mode);
 
+int ps3av_get_auto_mode(int boot)
+{
+	return ps3av_auto_videomode(&ps3av.av_hw_conf, boot);
+}
+
+EXPORT_SYMBOL_GPL(ps3av_get_auto_mode);
+
 int ps3av_set_mode(u32 id, int boot)
 {
 	int res;
@@ -771,7 +784,7 @@
 	id = id & PS3AV_MODE_MASK;
 	size = ARRAY_SIZE(video_mode_table);
 	if (id > size - 1 || id < 0) {
-		printk(KERN_ERR "%s: invalid mode %d\n", __FUNCTION__, id);
+		printk(KERN_ERR "%s: invalid mode %d\n", __func__, id);
 		return -EINVAL;
 	}
 	return video_mode_table[id].interlace;
@@ -786,7 +799,7 @@
 	id = id & PS3AV_MODE_MASK;
 	size = ARRAY_SIZE(video_mode_table);
 	if (id > size - 1 || id < 0) {
-		printk(KERN_ERR "%s: invalid mode %d\n", __FUNCTION__, id);
+		printk(KERN_ERR "%s: invalid mode %d\n", __func__, id);
 		return -EINVAL;
 	}
 	return video_mode_table[id].freq;
@@ -802,7 +815,7 @@
 	id = id & PS3AV_MODE_MASK;
 	size = ARRAY_SIZE(video_mode_table);
 	if (id > size - 1 || id < 0) {
-		printk(KERN_ERR "%s: invalid mode %d\n", __FUNCTION__, id);
+		printk(KERN_ERR "%s: invalid mode %d\n", __func__, id);
 		return -EINVAL;
 	}
 	*xres = video_mode_table[id].x;
@@ -838,7 +851,7 @@
 		status = lv1_gpu_open(0);
 		if (status) {
 			printk(KERN_ERR "%s: lv1_gpu_open failed %d\n",
-			       __FUNCTION__, status);
+			       __func__, status);
 			ps3av.open_count--;
 		}
 	}
@@ -855,13 +868,13 @@
 
 	mutex_lock(&ps3av.mutex);
 	if (ps3av.open_count <= 0) {
-		printk(KERN_ERR "%s: GPU already closed\n", __FUNCTION__);
+		printk(KERN_ERR "%s: GPU already closed\n", __func__);
 		status = -1;
 	} else if (!--ps3av.open_count) {
 		status = lv1_gpu_close();
 		if (status)
 			printk(KERN_WARNING "%s: lv1_gpu_close failed %d\n",
-			       __FUNCTION__, status);
+			       __func__, status);
 	}
 	mutex_unlock(&ps3av.mutex);
 
@@ -880,13 +893,16 @@
 
 	memset(&ps3av, 0, sizeof(ps3av));
 
-	init_MUTEX(&ps3av.sem);
-	init_MUTEX_LOCKED(&ps3av.ping);
-	init_MUTEX(&ps3av.pong);
 	mutex_init(&ps3av.mutex);
 	ps3av.ps3av_mode = 0;
 	ps3av.dev = dev;
-	kernel_thread(ps3avd, &ps3av, CLONE_KERNEL);
+
+	INIT_WORK(&ps3av.work, ps3avd);
+	init_completion(&ps3av.done);
+	complete(&ps3av.done);
+	ps3av.wq = create_singlethread_workqueue("ps3avd");
+	if (!ps3av.wq)
+		return -ENOMEM;
 
 	ps3av.available = 1;
 	switch (ps3_os_area_get_av_multi_out()) {
@@ -908,7 +924,7 @@
 	/* init avsetting modules */
 	res = ps3av_cmd_init();
 	if (res < 0)
-		printk(KERN_ERR "%s: ps3av_cmd_init failed %d\n", __FUNCTION__,
+		printk(KERN_ERR "%s: ps3av_cmd_init failed %d\n", __func__,
 		       res);
 
 	ps3av_get_hw_conf(&ps3av);
@@ -926,6 +942,8 @@
 {
 	if (ps3av.available) {
 		ps3av_cmd_fin();
+		if (ps3av.wq)
+			destroy_workqueue(ps3av.wq);
 		ps3av.available = 0;
 	}
 
@@ -958,7 +976,7 @@
 	if (error) {
 		printk(KERN_ERR
 		       "%s: ps3_vuart_port_driver_register failed %d\n",
-		       __FUNCTION__, error);
+		       __func__, error);
 		return error;
 	}
 
@@ -966,7 +984,7 @@
 	if (error)
 		printk(KERN_ERR
 		       "%s: ps3_vuart_port_device_register failed %d\n",
-		       __FUNCTION__, error);
+		       __func__, error);
 
 	return error;
 }
diff -Naur linux-2.6.21.1-org/drivers/ps3/ps3av_cmd.c linux-2.6.21.1-ps3/drivers/ps3/ps3av_cmd.c
--- linux-2.6.21.1-org/drivers/ps3/ps3av_cmd.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/ps3/ps3av_cmd.c	2007-05-21 13:50:29.514320676 +0200
@@ -395,7 +395,7 @@
 	video_mode->video_order = ps3av_video_fmt_table[video_fmt].order;
 
 	pr_debug("%s: video_mode:vid:%x width:%d height:%d pitch:%d out_format:%d format:%x order:%x\n",
-		__FUNCTION__, video_vid, video_mode->width, video_mode->height,
+		__func__, video_vid, video_mode->width, video_mode->height,
 		video_mode->pitch, video_mode->video_out_format,
 		video_mode->video_format, video_mode->video_order);
 	return sizeof(*video_mode);
@@ -477,7 +477,7 @@
 		if (ps3av_cnv_mclk_table[i].fs == fs)
 			return ps3av_cnv_mclk_table[i].mclk;
 
-	printk(KERN_ERR "%s failed, fs:%x\n", __FUNCTION__, fs);
+	printk(KERN_ERR "%s failed, fs:%x\n", __func__, fs);
 	return 0;
 }
 
@@ -526,13 +526,12 @@
 		d = 4;
 		break;
 	default:
-		printk(KERN_ERR "%s failed, vid:%x\n", __FUNCTION__,
-		       video_vid);
+		printk(KERN_ERR "%s failed, vid:%x\n", __func__, video_vid);
 		break;
 	}
 
 	if (fs < PS3AV_CMD_AUDIO_FS_44K || fs > PS3AV_CMD_AUDIO_FS_192K)
-		printk(KERN_ERR "%s failed, fs:%x\n", __FUNCTION__, fs);
+		printk(KERN_ERR "%s failed, fs:%x\n", __func__, fs);
 	else
 		ns_val = ps3av_ns_table[PS3AV_CMD_AUDIO_FS_44K-BASE][d];
 
@@ -555,8 +554,7 @@
 		ret = ((p[0] << 4) + (p[1] << 5) + (p[2] << 6) + (p[3] << 7)) |
 		      0x01;
 	} else
-		printk(KERN_ERR "%s failed, source:%x\n", __FUNCTION__,
-		       source);
+		printk(KERN_ERR "%s failed, source:%x\n", __func__, source);
 	return ret;
 }
 
@@ -585,7 +583,7 @@
 		ret = PS3AV_CMD_AV_INPUTLEN_24;
 		break;
 	default:
-		printk(KERN_ERR "%s failed, word_bits:%x\n", __FUNCTION__,
+		printk(KERN_ERR "%s failed, word_bits:%x\n", __func__,
 		       word_bits);
 		break;
 	}
@@ -595,7 +593,7 @@
 static u8 ps3av_cnv_layout(u32 num_of_ch)
 {
 	if (num_of_ch > PS3AV_CMD_AUDIO_NUM_OF_CH_8) {
-		printk(KERN_ERR "%s failed, num_of_ch:%x\n", __FUNCTION__,
+		printk(KERN_ERR "%s failed, num_of_ch:%x\n", __func__,
 		       num_of_ch);
 		return 0;
 	}
@@ -864,7 +862,7 @@
 
 	res = get_status(avb);
 	if (res)
-		pr_debug("%s: PS3AV_CID_AVB_PARAM: failed %x\n", __FUNCTION__,
+		pr_debug("%s: PS3AV_CID_AVB_PARAM: failed %x\n", __func__,
 			 res);
 
       out:
@@ -1013,7 +1011,7 @@
 			return size;
 		if (error != -EAGAIN) {
 			printk(KERN_ERR "%s: ps3_vuart_read failed %d\n",
-			       __FUNCTION__, error);
+			       __func__, error);
 			return error;
 		}
 		msleep(POLLING_INTERVAL);
diff -Naur linux-2.6.21.1-org/drivers/ps3/vuart.c linux-2.6.21.1-ps3/drivers/ps3/vuart.c
--- linux-2.6.21.1-org/drivers/ps3/vuart.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/ps3/vuart.c	2007-05-21 13:50:29.531319770 +0200
@@ -894,12 +894,12 @@
 
 	if (++vuart_bus_priv.use_count == 1) {
 
-		result = ps3_alloc_vuart_irq(PS3_BINDING_CPU_ANY,
+		result = ps3_vuart_irq_setup(PS3_BINDING_CPU_ANY,
 			(void*)&vuart_bus_priv.bmp.status, &vuart_bus_priv.virq);
 
 		if (result) {
 			dev_dbg(&dev->core,
-				"%s:%d: ps3_alloc_vuart_irq failed (%d)\n",
+				"%s:%d: ps3_vuart_irq_setup failed (%d)\n",
 				__func__, __LINE__, result);
 			result = -EPERM;
 			goto fail_alloc_irq;
@@ -945,7 +945,7 @@
 fail_probe:
 	ps3_vuart_set_interrupt_mask(dev, 0);
 fail_request_irq:
-	ps3_free_vuart_irq(vuart_bus_priv.virq);
+	ps3_vuart_irq_destroy(vuart_bus_priv.virq);
 	vuart_bus_priv.virq = NO_IRQ;
 fail_alloc_irq:
 	--vuart_bus_priv.use_count;
@@ -983,7 +983,7 @@
 	if (--vuart_bus_priv.use_count == 0) {
 		BUG();
 		free_irq(vuart_bus_priv.virq, &vuart_bus_priv);
-		ps3_free_vuart_irq(vuart_bus_priv.virq);
+		ps3_vuart_irq_destroy(vuart_bus_priv.virq);
 		vuart_bus_priv.virq = NO_IRQ;
 	}
 
diff -Naur linux-2.6.21.1-org/drivers/usb/host/ehci-ps3.c linux-2.6.21.1-ps3/drivers/usb/host/ehci-ps3.c
--- linux-2.6.21.1-org/drivers/usb/host/ehci-ps3.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/usb/host/ehci-ps3.c	2007-05-21 13:50:29.584316948 +0200
@@ -104,7 +104,7 @@
 	dev_dbg(&dev->core, "%s:%d: mmio mapped_addr %lxh\n", __func__,
 		__LINE__, dev->m_region->lpar_addr);
 
-	result = ps3_alloc_io_irq(PS3_BINDING_CPU_ANY, dev->interrupt_id, &virq);
+	result = ps3_io_irq_setup(PS3_BINDING_CPU_ANY, dev->interrupt_id, &virq);
 
 	if (result) {
 		dev_dbg(&dev->core, "%s:%d: ps3_construct_io_irq(%d) failed.\n",
@@ -162,7 +162,7 @@
 fail_ioremap:
 	usb_put_hcd(hcd);
 fail_create_hcd:
-	ps3_free_io_irq(virq);
+	ps3_io_irq_destroy(virq);
 fail_irq:
 	ps3_free_mmio_region(dev->m_region);
 fail_mmio:
diff -Naur linux-2.6.21.1-org/drivers/usb/host/ehci-sched.c linux-2.6.21.1-ps3/drivers/usb/host/ehci-sched.c
--- linux-2.6.21.1-org/drivers/usb/host/ehci-sched.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/usb/host/ehci-sched.c	2007-05-21 13:50:29.646313647 +0200
@@ -1168,8 +1168,21 @@
 		if (likely (!list_empty(&stream->free_list))) {
 			itd = list_entry (stream->free_list.prev,
 					 struct ehci_itd, itd_list);
-			list_del (&itd->itd_list);
-			itd_dma = itd->itd_dma;
+#if defined(CONFIG_PPC_PS3)
+			/* Fix for Cell SCC ISO transfer (PS3 Bluetooth). */
+			if (firmware_has_feature(FW_FEATURE_PS3_LV1)
+				&& itd->frame == ((ehci_readl(ehci,
+				&ehci->regs->frame_index) >> 3)
+				% ehci->periodic_size))
+				itd = NULL;
+			else {
+				list_del (&itd->itd_list);
+				itd_dma = itd->itd_dma;
+			}
+#else
+                       list_del (&itd->itd_list);
+                       itd_dma = itd->itd_dma;
+#endif
 		} else
 			itd = NULL;
 
@@ -1784,8 +1797,21 @@
 		if (!list_empty(&stream->free_list)) {
 			sitd = list_entry (stream->free_list.prev,
 					 struct ehci_sitd, sitd_list);
-			list_del (&sitd->sitd_list);
-			sitd_dma = sitd->sitd_dma;
+#if defined(CONFIG_PPC_PS3)
+			/* Fix for Cell SCC ISO transfer (PS3 Bluetooth). */
+			if (firmware_has_feature(FW_FEATURE_PS3_LV1)
+				&& sitd->frame == ((ehci_readl(ehci,
+				&ehci->regs->frame_index) >> 3)
+				% ehci->periodic_size))
+				sitd = NULL;
+			else {
+				list_del (&sitd->sitd_list);
+				sitd_dma = sitd->sitd_dma;
+			}
+#else
+                       list_del (&sitd->sitd_list);
+                       sitd_dma = sitd->sitd_dma;
+#endif
 		} else
 			sitd = NULL;
 
diff -Naur linux-2.6.21.1-org/drivers/usb/host/ohci-ps3.c linux-2.6.21.1-ps3/drivers/usb/host/ohci-ps3.c
--- linux-2.6.21.1-org/drivers/usb/host/ohci-ps3.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/usb/host/ohci-ps3.c	2007-05-21 13:50:29.664312689 +0200
@@ -107,7 +107,7 @@
 	dev_dbg(&dev->core, "%s:%d: mmio mapped_addr %lxh\n", __func__,
 		__LINE__, dev->m_region->lpar_addr);
 
-	result = ps3_alloc_io_irq(PS3_BINDING_CPU_ANY, dev->interrupt_id, &virq);
+	result = ps3_io_irq_setup(PS3_BINDING_CPU_ANY, dev->interrupt_id, &virq);
 
 	if (result) {
 		dev_dbg(&dev->core, "%s:%d: ps3_construct_io_irq(%d) failed.\n",
@@ -165,7 +165,7 @@
 fail_ioremap:
 	usb_put_hcd(hcd);
 fail_create_hcd:
-	ps3_free_io_irq(virq);
+	ps3_io_irq_destroy(virq);
 fail_irq:
 	ps3_free_mmio_region(dev->m_region);
 fail_mmio:
diff -Naur linux-2.6.21.1-org/drivers/video/console/fbcon.c linux-2.6.21.1-ps3/drivers/video/console/fbcon.c
--- linux-2.6.21.1-org/drivers/video/console/fbcon.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/video/console/fbcon.c	2007-05-21 13:50:29.681311784 +0200
@@ -618,8 +618,13 @@
 			r -= cols;
 		}
 		if (!save) {
-			vc->vc_y += logo_lines;
-			vc->vc_pos += logo_lines * vc->vc_size_row;
+			int lines;
+			if (vc->vc_y + logo_lines >= rows)
+				lines = rows - vc->vc_y - 1;
+			else
+				lines = logo_lines;
+			vc->vc_y += lines;
+			vc->vc_pos += lines * vc->vc_size_row;
 		}
 	}
 	scr_memsetw((unsigned short *) vc->vc_origin,
diff -Naur linux-2.6.21.1-org/drivers/video/fbmem.c linux-2.6.21.1-ps3/drivers/video/fbmem.c
--- linux-2.6.21.1-org/drivers/video/fbmem.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/video/fbmem.c	2007-05-21 13:50:29.698310879 +0200
@@ -318,6 +318,13 @@
 	const struct linux_logo *logo;
 } fb_logo __read_mostly;
 
+#define FB_LOGO_EX_NUM_MAX 10
+static struct logo_data_extra {
+	const struct linux_logo *logo;
+	unsigned int n;
+} fb_logo_ex[FB_LOGO_EX_NUM_MAX];
+static unsigned int fb_logo_ex_num = 0;
+
 static void fb_rotate_logo_ud(const u8 *in, u8 *out, u32 width, u32 height)
 {
 	u32 size = width * height, i;
@@ -354,67 +361,77 @@
 	if (rotate == FB_ROTATE_UD) {
 		fb_rotate_logo_ud(image->data, dst, image->width,
 				  image->height);
-		image->dx = info->var.xres - image->width;
-		image->dy = info->var.yres - image->height;
+		image->dx = info->var.xres - image->width - image->dx;
+		image->dy = info->var.yres - image->height - image->dy;
 	} else if (rotate == FB_ROTATE_CW) {
 		fb_rotate_logo_cw(image->data, dst, image->width,
 				  image->height);
 		tmp = image->width;
 		image->width = image->height;
 		image->height = tmp;
-		image->dx = info->var.xres - image->width;
+		tmp = image->dy;
+		image->dy = image->dx;
+		image->dx = info->var.xres - image->width - tmp;
 	} else if (rotate == FB_ROTATE_CCW) {
 		fb_rotate_logo_ccw(image->data, dst, image->width,
 				   image->height);
 		tmp = image->width;
 		image->width = image->height;
 		image->height = tmp;
-		image->dy = info->var.yres - image->height;
+		tmp = image->dx;
+		image->dx = image->dy;
+		image->dy = info->var.yres - image->height - tmp;
 	}
 
 	image->data = dst;
 }
 
 static void fb_do_show_logo(struct fb_info *info, struct fb_image *image,
-			    int rotate)
+			    int rotate, unsigned int num)
 {
-	int x;
+	unsigned int x;
 
 	if (rotate == FB_ROTATE_UR) {
-		for (x = 0; x < num_online_cpus() &&
-			     x * (fb_logo.logo->width + 8) <=
-			     info->var.xres - fb_logo.logo->width; x++) {
+		for (x = 0;
+		     x < num && image->dx + image->width <= info->var.xres;
+		     x++) {
 			info->fbops->fb_imageblit(info, image);
-			image->dx += fb_logo.logo->width + 8;
+			image->dx += image->width + 8;
 		}
 	} else if (rotate == FB_ROTATE_UD) {
-		for (x = 0; x < num_online_cpus() &&
-			     x * (fb_logo.logo->width + 8) <=
-			     info->var.xres - fb_logo.logo->width; x++) {
+		for (x = 0; x < num && image->dx >= 0; x++) {
 			info->fbops->fb_imageblit(info, image);
-			image->dx -= fb_logo.logo->width + 8;
+			image->dx -= image->width + 8;
 		}
 	} else if (rotate == FB_ROTATE_CW) {
-		for (x = 0; x < num_online_cpus() &&
-			     x * (fb_logo.logo->width + 8) <=
-			     info->var.yres - fb_logo.logo->width; x++) {
+		for (x = 0;
+		     x < num && image->dy + image->height <= info->var.yres;
+		     x++) {
 			info->fbops->fb_imageblit(info, image);
-			image->dy += fb_logo.logo->width + 8;
+			image->dy += image->height + 8;
 		}
 	} else if (rotate == FB_ROTATE_CCW) {
-		for (x = 0; x < num_online_cpus() &&
-			     x * (fb_logo.logo->width + 8) <=
-			     info->var.yres - fb_logo.logo->width; x++) {
+		for (x = 0; x < num && image->dy >= 0; x++) {
 			info->fbops->fb_imageblit(info, image);
-			image->dy -= fb_logo.logo->width + 8;
+			image->dy -= image->height + 8;
 		}
 	}
 }
 
+void fb_append_extra_logo(const struct linux_logo *logo, unsigned int n)
+{
+	if (!n || fb_logo_ex_num == FB_LOGO_EX_NUM_MAX)
+		return;
+
+	fb_logo_ex[fb_logo_ex_num].logo = logo;
+	fb_logo_ex[fb_logo_ex_num].n = n;
+	fb_logo_ex_num++;
+}
+
 int fb_prepare_logo(struct fb_info *info, int rotate)
 {
 	int depth = fb_get_color_depth(&info->var, &info->fix);
-	int yres;
+	unsigned int yres, height, i;
 
 	memset(&fb_logo, 0, sizeof(struct logo_data));
 
@@ -473,24 +490,40 @@
 		fb_logo.depth = 4;
 	else
 		fb_logo.depth = 1;		
-	return fb_logo.logo->height;
+
+	/* FIXME: logo_ex supports only truecolor fb. */
+	if (info->fix.visual != FB_VISUAL_TRUECOLOR)
+		fb_logo_ex_num = 0;
+
+	height = fb_logo.logo->height;
+	for (i = 0; i < fb_logo_ex_num; i++) {
+		height += fb_logo_ex[i].logo->height;
+		if (height > yres) {
+			height -= fb_logo_ex[i].logo->height;
+			fb_logo_ex_num = i;
+			break;
+		}
+	}
+	return height;
 }
 
-int fb_show_logo(struct fb_info *info, int rotate)
+static int fb_show_logo_line(struct fb_info *info, int rotate,
+			     const struct linux_logo *logo, int y,
+			     unsigned int n)
 {
 	u32 *palette = NULL, *saved_pseudo_palette = NULL;
 	unsigned char *logo_new = NULL, *logo_rotate = NULL;
 	struct fb_image image;
 
 	/* Return if the frame buffer is not mapped or suspended */
-	if (fb_logo.logo == NULL || info->state != FBINFO_STATE_RUNNING)
+	if (logo == NULL || info->state != FBINFO_STATE_RUNNING)
 		return 0;
 
 	image.depth = 8;
-	image.data = fb_logo.logo->data;
+	image.data = logo->data;
 
 	if (fb_logo.needs_cmapreset)
-		fb_set_logocmap(info, fb_logo.logo);
+		fb_set_logocmap(info, logo);
 
 	if (fb_logo.needs_truepalette || 
 	    fb_logo.needs_directpalette) {
@@ -499,17 +532,16 @@
 			return 0;
 
 		if (fb_logo.needs_truepalette)
-			fb_set_logo_truepalette(info, fb_logo.logo, palette);
+			fb_set_logo_truepalette(info, logo, palette);
 		else
-			fb_set_logo_directpalette(info, fb_logo.logo, palette);
+			fb_set_logo_directpalette(info, logo, palette);
 
 		saved_pseudo_palette = info->pseudo_palette;
 		info->pseudo_palette = palette;
 	}
 
 	if (fb_logo.depth <= 4) {
-		logo_new = kmalloc(fb_logo.logo->width * fb_logo.logo->height, 
-				   GFP_KERNEL);
+		logo_new = kmalloc(logo->width * logo->height, GFP_KERNEL);
 		if (logo_new == NULL) {
 			kfree(palette);
 			if (saved_pseudo_palette)
@@ -517,29 +549,44 @@
 			return 0;
 		}
 		image.data = logo_new;
-		fb_set_logo(info, fb_logo.logo, logo_new, fb_logo.depth);
+		fb_set_logo(info, logo, logo_new, fb_logo.depth);
 	}
 
 	image.dx = 0;
-	image.dy = 0;
-	image.width = fb_logo.logo->width;
-	image.height = fb_logo.logo->height;
+	image.dy = y;
+	image.width = logo->width;
+	image.height = logo->height;
 
 	if (rotate) {
-		logo_rotate = kmalloc(fb_logo.logo->width *
-				      fb_logo.logo->height, GFP_KERNEL);
+		logo_rotate = kmalloc(logo->width *
+				      logo->height, GFP_KERNEL);
 		if (logo_rotate)
 			fb_rotate_logo(info, logo_rotate, &image, rotate);
 	}
 
-	fb_do_show_logo(info, &image, rotate);
+	fb_do_show_logo(info, &image, rotate, n);
 
 	kfree(palette);
 	if (saved_pseudo_palette != NULL)
 		info->pseudo_palette = saved_pseudo_palette;
 	kfree(logo_new);
 	kfree(logo_rotate);
-	return fb_logo.logo->height;
+	return logo->height;
+}
+
+int fb_show_logo(struct fb_info *info, int rotate)
+{
+	int y, i;
+
+	y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,
+			      num_online_cpus());
+
+	for (i = 0; i < fb_logo_ex_num; i++) {
+		y += fb_show_logo_line(info, rotate,
+				       fb_logo_ex[i].logo, y, fb_logo_ex[i].n);
+	}
+
+	return y;
 }
 #else
 int fb_prepare_logo(struct fb_info *info, int rotate) { return 0; }
diff -Naur linux-2.6.21.1-org/drivers/video/logo/logo.c linux-2.6.21.1-ps3/drivers/video/logo/logo.c
--- linux-2.6.21.1-org/drivers/video/logo/logo.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/video/logo/logo.c	2007-05-21 13:50:29.735308909 +0200
@@ -21,19 +21,6 @@
 #include <asm/bootinfo.h>
 #endif
 
-extern const struct linux_logo logo_linux_mono;
-extern const struct linux_logo logo_linux_vga16;
-extern const struct linux_logo logo_linux_clut224;
-extern const struct linux_logo logo_dec_clut224;
-extern const struct linux_logo logo_mac_clut224;
-extern const struct linux_logo logo_parisc_clut224;
-extern const struct linux_logo logo_sgi_clut224;
-extern const struct linux_logo logo_sun_clut224;
-extern const struct linux_logo logo_superh_mono;
-extern const struct linux_logo logo_superh_vga16;
-extern const struct linux_logo logo_superh_clut224;
-extern const struct linux_logo logo_m32r_clut224;
-
 
 const struct linux_logo *fb_find_logo(int depth)
 {
diff -Naur linux-2.6.21.1-org/drivers/video/ps3fb.c linux-2.6.21.1-ps3/drivers/video/ps3fb.c
--- linux-2.6.21.1-org/drivers/video/ps3fb.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/drivers/video/ps3fb.c	2007-05-21 13:50:29.787306140 +0200
@@ -32,6 +32,8 @@
 #include <linux/ioctl.h>
 #include <linux/notifier.h>
 #include <linux/reboot.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
 
 #include <asm/uaccess.h>
 #include <linux/fb.h>
@@ -45,7 +47,7 @@
 #include <asm/ps3.h>
 
 #ifdef PS3FB_DEBUG
-#define DPRINTK(fmt, args...) printk("%s: " fmt, __FUNCTION__ , ##args)
+#define DPRINTK(fmt, args...) printk("%s: " fmt, __func__ , ##args)
 #else
 #define DPRINTK(fmt, args...)
 #endif
@@ -129,7 +131,6 @@
 	u64 context_handle, memory_handle;
 	void *xdr_ea;
 	struct gpu_driver_info *dinfo;
-	struct semaphore sem;
 	u32 res_index;
 
 	u64 vblank_count;	/* frame count */
@@ -139,6 +140,8 @@
 	atomic_t ext_flip;	/* on/off flip with vsync */
 	atomic_t f_count;	/* fb_open count */
 	int is_blanked;
+	int is_kicked;
+	struct task_struct *task;
 };
 static struct ps3fb_priv ps3fb;
 
@@ -294,10 +297,10 @@
 #define VP_OFF(i)	(WIDTH(i) * Y_OFF(i) * BPP + X_OFF(i) * BPP)
 #define FB_OFF(i)	(GPU_OFFSET - VP_OFF(i) % GPU_OFFSET)
 
-static int ps3fb_mode = 0;
+static int ps3fb_mode;
 module_param(ps3fb_mode, bool, 0);
 
-static char *mode_option __initdata = NULL;
+static char *mode_option __initdata;
 
 
 static int ps3fb_get_res_table(u32 xres, u32 yres)
@@ -393,7 +396,7 @@
 
 	if (frame > ps3fb.num_frames - 1) {
 		printk(KERN_WARNING "%s: invalid frame number (%u)\n",
-		       __FUNCTION__, frame);
+		       __func__, frame);
 		return -EINVAL;
 	}
 	offset = xres * yres * BPP * frame;
@@ -406,23 +409,26 @@
 					   (xres << 16) | yres,
 					   xres * BPP);	/* line_length */
 	if (status)
-		printk(KERN_ERR "%s: lv1_gpu_context_attribute FB_BLIT failed: %d\n",
-		       __FUNCTION__, status);
+		printk(KERN_ERR
+		       "%s: lv1_gpu_context_attribute FB_BLIT failed: %d\n",
+		       __func__, status);
 #ifdef HEAD_A
 	status = lv1_gpu_context_attribute(ps3fb.context_handle,
 					   L1GPU_CONTEXT_ATTRIBUTE_DISPLAY_FLIP,
 					   0, offset, 0, 0);
 	if (status)
-		printk(KERN_ERR "%s: lv1_gpu_context_attribute FLIP failed: %d\n",
-		       __FUNCTION__, status);
+		printk(KERN_ERR
+		       "%s: lv1_gpu_context_attribute FLIP failed: %d\n",
+		       __func__, status);
 #endif
 #ifdef HEAD_B
 	status = lv1_gpu_context_attribute(ps3fb.context_handle,
 					   L1GPU_CONTEXT_ATTRIBUTE_DISPLAY_FLIP,
 					   1, offset, 0, 0);
 	if (status)
-		printk(KERN_ERR "%s: lv1_gpu_context_attribute FLIP failed: %d\n",
-		       __FUNCTION__, status);
+		printk(KERN_ERR
+		       "%s: lv1_gpu_context_attribute FLIP failed: %d\n",
+		       __func__, status);
 #endif
 	return 0;
 }
@@ -631,7 +637,7 @@
 {
 	int retval;
 
-	DPRINTK("%s: blank:%d\n", __FUNCTION__, blank);
+	DPRINTK("%s: blank:%d\n", __func__, blank);
 	switch (blank) {
 	case FB_BLANK_POWERDOWN:
 	case FB_BLANK_HSYNC_SUSPEND:
@@ -677,13 +683,10 @@
 
 void ps3fb_flip_ctl(int on)
 {
-	if (on) {
-		if (atomic_read(&ps3fb.ext_flip) > 0) {
-			atomic_dec(&ps3fb.ext_flip);
-		}
-	} else {
+	if (on)
+		atomic_dec_if_positive(&ps3fb.ext_flip);
+	else
 		atomic_inc(&ps3fb.ext_flip);
-	}
 }
 
 EXPORT_SYMBOL_GPL(ps3fb_flip_ctl);
@@ -732,6 +735,11 @@
 			if (copy_from_user(&val, argp, sizeof(val)))
 				break;
 
+			if (!(val & PS3AV_MODE_MASK)) {
+				u32 id = ps3av_get_auto_mode(0);
+				if (id > 0)
+					val = (val & ~PS3AV_MODE_MASK) | id;
+			}
 			DPRINTK("PS3FB_IOCTL_SETMODE:%x\n", val);
 			retval = -EINVAL;
 			old_mode = ps3fb_mode;
@@ -783,8 +791,7 @@
 
 	case PS3FB_IOCTL_OFF:
 		DPRINTK("PS3FB_IOCTL_OFF:\n");
-		if (atomic_read(&ps3fb.ext_flip) > 0)
-			atomic_dec(&ps3fb.ext_flip);
+		atomic_dec_if_positive(&ps3fb.ext_flip);
 		retval = 0;
 		break;
 
@@ -805,11 +812,14 @@
 
 static int ps3fbd(void *arg)
 {
-	daemonize("ps3fbd");
-	for (;;) {
-		down(&ps3fb.sem);
-		if (atomic_read(&ps3fb.ext_flip) == 0)
+	while (!kthread_should_stop()) {
+		try_to_freeze();
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (ps3fb.is_kicked) {
+			ps3fb.is_kicked = 0;
 			ps3fb_sync(0);	/* single buffer */
+		}
+		schedule();
 	}
 	return 0;
 }
@@ -823,15 +833,18 @@
 	status = lv1_gpu_context_intr(ps3fb.context_handle, &v1);
 	if (status) {
 		printk(KERN_ERR "%s: lv1_gpu_context_intr failed: %d\n",
-		       __FUNCTION__, status);
+		       __func__, status);
 		return IRQ_NONE;
 	}
 
 	if (v1 & (1 << GPU_INTR_STATUS_VSYNC_1)) {
 		/* VSYNC */
 		ps3fb.vblank_count = head->vblank_count;
-		if (!ps3fb.is_blanked)
-			up(&ps3fb.sem);
+		if (ps3fb.task && !ps3fb.is_blanked &&
+		    !atomic_read(&ps3fb.ext_flip)) {
+			ps3fb.is_kicked = 1;
+			wake_up_process(ps3fb.task);
+		}
 		wake_up_interruptible(&ps3fb.wait_vsync);
 	}
 
@@ -879,16 +892,16 @@
 		dinfo->nvcore_frequency/1000000, dinfo->memory_frequency/1000000);
 
 	if (dinfo->version_driver != GPU_DRIVER_INFO_VERSION) {
-		printk(KERN_ERR "%s: version_driver err:%x\n", __FUNCTION__,
+		printk(KERN_ERR "%s: version_driver err:%x\n", __func__,
 		       dinfo->version_driver);
 		return -EINVAL;
 	}
 
 	ps3fb.dev = dev;
-	error = ps3_alloc_irq(PS3_BINDING_CPU_ANY, dinfo->irq.irq_outlet,
-			      &ps3fb.irq_no);
+	error = ps3_irq_plug_setup(PS3_BINDING_CPU_ANY, dinfo->irq.irq_outlet,
+				   &ps3fb.irq_no);
 	if (error) {
-		printk(KERN_ERR "%s: ps3_alloc_irq failed %d\n", __FUNCTION__,
+		printk(KERN_ERR "%s: ps3_alloc_irq failed %d\n", __func__,
 		       error);
 		return error;
 	}
@@ -896,9 +909,9 @@
 	error = request_irq(ps3fb.irq_no, ps3fb_vsync_interrupt, IRQF_DISABLED,
 			    "ps3fb vsync", ps3fb.dev);
 	if (error) {
-		printk(KERN_ERR "%s: request_irq failed %d\n", __FUNCTION__,
+		printk(KERN_ERR "%s: request_irq failed %d\n", __func__,
 		       error);
-		ps3_free_irq(ps3fb.irq_no);
+		ps3_irq_plug_destroy(ps3fb.irq_no);
 		return error;
 	}
 
@@ -915,7 +928,7 @@
 				       xdr_lpar, ps3fb_videomemory.size, 0);
 	if (status) {
 		printk(KERN_ERR "%s: lv1_gpu_context_iomap failed: %d\n",
-		       __FUNCTION__, status);
+		       __func__, status);
 		return -ENXIO;
 	}
 	DPRINTK("video:%p xdr_ea:%p ioif:%lx lpar:%lx phys:%lx size:%lx\n",
@@ -927,8 +940,9 @@
 					   xdr_lpar, ps3fb_videomemory.size,
 					   GPU_IOIF, 0);
 	if (status) {
-		printk(KERN_ERR "%s: lv1_gpu_context_attribute FB_SETUP failed: %d\n",
-		       __FUNCTION__, status);
+		printk(KERN_ERR
+		       "%s: lv1_gpu_context_attribute FB_SETUP failed: %d\n",
+		       __func__, status);
 		return -ENXIO;
 	}
 	return 0;
@@ -968,13 +982,14 @@
 	u64 xdr_lpar;
 	int status;
 	unsigned long offset;
+	struct task_struct *task;
 
 	/* get gpu context handle */
 	status = lv1_gpu_memory_allocate(DDR_SIZE, 0, 0, 0, 0,
 					 &ps3fb.memory_handle, &ddr_lpar);
 	if (status) {
 		printk(KERN_ERR "%s: lv1_gpu_memory_allocate failed: %d\n",
-		       __FUNCTION__, status);
+		       __func__, status);
 		goto err;
 	}
 	DPRINTK("ddr:lpar:0x%lx\n", ddr_lpar);
@@ -985,14 +1000,14 @@
 					  &lpar_reports, &lpar_reports_size);
 	if (status) {
 		printk(KERN_ERR "%s: lv1_gpu_context_attribute failed: %d\n",
-		       __FUNCTION__, status);
+		       __func__, status);
 		goto err_gpu_memory_free;
 	}
 
 	/* vsync interrupt */
 	ps3fb.dinfo = ioremap(lpar_driver_info, 128 * 1024);
 	if (!ps3fb.dinfo) {
-		printk(KERN_ERR "%s: ioremap failed\n", __FUNCTION__);
+		printk(KERN_ERR "%s: ioremap failed\n", __func__);
 		goto err_gpu_context_free;
 	}
 
@@ -1050,16 +1065,25 @@
 	       "fb%d: PS3 frame buffer device, using %ld KiB of video memory\n",
 	       info->node, ps3fb_videomemory.size >> 10);
 
-	kernel_thread(ps3fbd, info, CLONE_KERNEL);
+	task = kthread_run(ps3fbd, info, "ps3fbd");
+	if (IS_ERR(task)) {
+		retval = PTR_ERR(task);
+		goto err_unregister_framebuffer;
+	}
+
+	ps3fb.task = task;
+
 	return 0;
 
+err_unregister_framebuffer:
+	unregister_framebuffer(info);
 err_fb_dealloc:
 	fb_dealloc_cmap(&info->cmap);
 err_framebuffer_release:
 	framebuffer_release(info);
 err_free_irq:
 	free_irq(ps3fb.irq_no, ps3fb.dev);
-	ps3_free_irq(ps3fb.irq_no);
+	ps3_irq_plug_destroy(ps3fb.irq_no);
 err_iounmap_dinfo:
 	iounmap((u8 __iomem *)ps3fb.dinfo);
 err_gpu_context_free:
@@ -1075,7 +1099,7 @@
 	ps3fb_flip_ctl(0);	/* flip off */
 	ps3fb.dinfo->irq.mask = 0;
 	free_irq(ps3fb.irq_no, ps3fb.dev);
-	ps3_free_irq(ps3fb.irq_no);
+	ps3_irq_plug_destroy(ps3fb.irq_no);
 	iounmap((u8 __iomem *)ps3fb.dinfo);
 }
 
@@ -1083,9 +1107,14 @@
 {
 	int status;
 
+	if (ps3fb.task) {
+		struct task_struct *task = ps3fb.task;
+		ps3fb.task = NULL;
+		kthread_stop(task);
+	}
 	if (ps3fb.irq_no) {
 		free_irq(ps3fb.irq_no, ps3fb.dev);
-		ps3_free_irq(ps3fb.irq_no);
+		ps3_irq_plug_destroy(ps3fb.irq_no);
 	}
 	iounmap((u8 __iomem *)ps3fb.dinfo);
 
@@ -1137,8 +1166,9 @@
 					   L1GPU_CONTEXT_ATTRIBUTE_DISPLAY_SYNC,
 					   0, L1GPU_DISPLAY_SYNC_VSYNC, 0, 0);
 	if (status) {
-		printk(KERN_ERR "%s: lv1_gpu_context_attribute DISPLAY_SYNC failed: %d\n",
-		       __FUNCTION__, status);
+		printk(KERN_ERR
+		       "%s: lv1_gpu_context_attribute DISPLAY_SYNC failed: %d\n",
+		       __func__, status);
 		return -1;
 	}
 #endif
@@ -1148,8 +1178,9 @@
 					   1, L1GPU_DISPLAY_SYNC_VSYNC, 0, 0);
 
 	if (status) {
-		printk(KERN_ERR "%s: lv1_gpu_context_attribute DISPLAY_MODE failed: %d\n",
-		       __FUNCTION__, status);
+		printk(KERN_ERR
+		       "%s: lv1_gpu_context_attribute DISPLAY_MODE failed: %d\n",
+		       __func__, status);
 		return -1;
 	}
 #endif
@@ -1174,7 +1205,7 @@
 
 	error = ps3av_dev_open();
 	if (error) {
-		printk(KERN_ERR "%s: ps3av_dev_open failed\n", __FUNCTION__);
+		printk(KERN_ERR "%s: ps3av_dev_open failed\n", __func__);
 		goto err;
 	}
 
@@ -1195,7 +1226,6 @@
 
 	atomic_set(&ps3fb.f_count, -1);	/* fbcon opens ps3fb */
 	atomic_set(&ps3fb.ext_flip, 0);	/* for flip with vsync */
-	init_MUTEX(&ps3fb.sem);
 	init_waitqueue_head(&ps3fb.wait_vsync);
 	ps3fb.num_frames = 1;
 
diff -Naur linux-2.6.21.1-org/include/asm-powerpc/lv1call.h linux-2.6.21.1-ps3/include/asm-powerpc/lv1call.h
--- linux-2.6.21.1-org/include/asm-powerpc/lv1call.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/include/asm-powerpc/lv1call.h	2007-05-21 13:50:30.067291232 +0200
@@ -238,6 +238,7 @@
 LV1_CALL(configure_irq_state_bitmap,                    3, 0,  11 )
 LV1_CALL(connect_irq_plug_ext,                          5, 0,  12 )
 LV1_CALL(release_memory,                                1, 0,  13 )
+LV1_CALL(put_iopte,                                     5, 0,  15 )
 LV1_CALL(disconnect_irq_plug_ext,                       3, 0,  17 )
 LV1_CALL(construct_event_receive_port,                  0, 1,  18 )
 LV1_CALL(destruct_event_receive_port,                   1, 0,  19 )
@@ -268,6 +269,8 @@
 LV1_CALL(read_htab_entries,                             2, 5,  95 )
 LV1_CALL(set_dabr,                                      2, 0,  96 )
 LV1_CALL(get_total_execution_time,                      2, 1, 103 )
+LV1_CALL(allocate_io_segment,                           3, 1, 116 )
+LV1_CALL(release_io_segment,                            2, 0, 117 )
 LV1_CALL(construct_io_irq_outlet,                       1, 1, 120 )
 LV1_CALL(destruct_io_irq_outlet,                        1, 0, 121 )
 LV1_CALL(map_htab,                                      1, 1, 122 )
diff -Naur linux-2.6.21.1-org/include/asm-powerpc/ps3.h linux-2.6.21.1-ps3/include/asm-powerpc/ps3.h
--- linux-2.6.21.1-org/include/asm-powerpc/ps3.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/include/asm-powerpc/ps3.h	2007-05-21 13:50:30.078290646 +0200
@@ -167,26 +167,31 @@
 	PS3_BINDING_CPU_1 = 1,
 };
 
-int ps3_alloc_io_irq(enum ps3_cpu_binding cpu, unsigned int interrupt_id,
+int ps3_virq_setup(enum ps3_cpu_binding cpu, unsigned long outlet,
 	unsigned int *virq);
-int ps3_free_io_irq(unsigned int virq);
-int ps3_alloc_event_irq(enum ps3_cpu_binding cpu, unsigned int *virq);
-int ps3_free_event_irq(unsigned int virq);
+int ps3_virq_destroy(unsigned int virq);
+int ps3_irq_plug_setup(enum ps3_cpu_binding cpu, unsigned long outlet,
+	unsigned int *virq);
+int ps3_irq_plug_destroy(unsigned int virq);
+int ps3_event_receive_port_setup(enum ps3_cpu_binding cpu, unsigned int *virq);
+int ps3_event_receive_port_destroy(unsigned int virq);
 int ps3_send_event_locally(unsigned int virq);
-int ps3_connect_event_irq(enum ps3_cpu_binding cpu,
-	const struct ps3_device_id *did, unsigned int interrupt_id,
+
+int ps3_io_irq_setup(enum ps3_cpu_binding cpu, unsigned int interrupt_id,
 	unsigned int *virq);
-int ps3_disconnect_event_irq(const struct ps3_device_id *did,
-	unsigned int interrupt_id, unsigned int virq);
-int ps3_alloc_vuart_irq(enum ps3_cpu_binding cpu, void* virt_addr_bmp,
+int ps3_io_irq_destroy(unsigned int virq);
+int ps3_vuart_irq_setup(enum ps3_cpu_binding cpu, void* virt_addr_bmp,
 	unsigned int *virq);
-int ps3_free_vuart_irq(unsigned int virq);
-int ps3_alloc_spe_irq(enum ps3_cpu_binding cpu, unsigned long spe_id,
+int ps3_vuart_irq_destroy(unsigned int virq);
+int ps3_spe_irq_setup(enum ps3_cpu_binding cpu, unsigned long spe_id,
 	unsigned int class, unsigned int *virq);
-int ps3_free_spe_irq(unsigned int virq);
-int ps3_alloc_irq(enum ps3_cpu_binding cpu, unsigned long outlet,
+int ps3_spe_irq_destroy(unsigned int virq);
+
+int ps3_sb_event_receive_port_setup(enum ps3_cpu_binding cpu,
+	const struct ps3_device_id *did, unsigned int interrupt_id,
 	unsigned int *virq);
-int ps3_free_irq(unsigned int virq);
+int ps3_sb_event_receive_port_destroy(const struct ps3_device_id *did,
+	unsigned int interrupt_id, unsigned int virq);
 
 /* lv1 result codes */
 
@@ -383,5 +388,6 @@
 };
 
 extern struct ps3_prealloc ps3fb_videomemory;
+extern struct ps3_prealloc ps3_stor_bounce_buffer;
 
 #endif
diff -Naur linux-2.6.21.1-org/include/asm-powerpc/ps3av.h linux-2.6.21.1-ps3/include/asm-powerpc/ps3av.h
--- linux-2.6.21.1-org/include/asm-powerpc/ps3av.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/include/asm-powerpc/ps3av.h	2007-05-21 13:50:30.096289688 +0200
@@ -18,8 +18,6 @@
 #ifndef _ASM_POWERPC_PS3AV_H_
 #define _ASM_POWERPC_PS3AV_H_
 
-#include <linux/mutex.h>
-
 /** command for ioctl() **/
 #define PS3AV_VERSION 0x205	/* version of ps3av command */
 
@@ -643,24 +641,6 @@
 	u8 buf[PS3AV_PKT_AVB_PARAM_MAX_BUF_SIZE];
 };
 
-struct ps3av {
-	int available;
-	struct semaphore sem;
-	struct semaphore ping;
-	struct semaphore pong;
-	struct mutex mutex;
-	int open_count;
-	struct ps3_vuart_port_device *dev;
-
-	int region;
-	struct ps3av_pkt_av_get_hw_conf av_hw_conf;
-	u32 av_port[PS3AV_AV_PORT_MAX + PS3AV_OPT_PORT_MAX];
-	u32 opt_port[PS3AV_OPT_PORT_MAX];
-	u32 head[PS3AV_HEAD_MAX];
-	u32 audio_port;
-	int ps3av_mode;
-	int ps3av_mode_old;
-};
 
 /** command status **/
 #define PS3AV_STATUS_SUCCESS			0x0000	/* success */
@@ -718,6 +698,7 @@
 extern int ps3av_cmd_video_get_monitor_info(struct ps3av_pkt_av_get_monitor_info *,
 					    u32);
 
+struct ps3_vuart_port_device;
 extern int ps3av_vuart_write(struct ps3_vuart_port_device *dev,
 			     const void *buf, unsigned long size);
 extern int ps3av_vuart_read(struct ps3_vuart_port_device *dev, void *buf,
@@ -725,6 +706,7 @@
 
 extern int ps3av_set_video_mode(u32, int);
 extern int ps3av_set_audio_mode(u32, u32, u32, u32, u32);
+extern int ps3av_get_auto_mode(int);
 extern int ps3av_set_mode(u32, int);
 extern int ps3av_get_mode(void);
 extern int ps3av_get_scanmode(int);
diff -Naur linux-2.6.21.1-org/include/asm-powerpc/spu.h linux-2.6.21.1-ps3/include/asm-powerpc/spu.h
--- linux-2.6.21.1-org/include/asm-powerpc/spu.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/include/asm-powerpc/spu.h	2007-05-21 13:50:30.113288783 +0200
@@ -122,6 +122,7 @@
 	u64 flags;
 	u64 dar;
 	u64 dsisr;
+	u64 class_0_pending;
 	size_t ls_size;
 	unsigned int slb_replace;
 	struct mm_struct *mm;
@@ -129,7 +130,6 @@
 	struct spu_runqueue *rq;
 	unsigned long long timestamp;
 	pid_t pid;
-	int class_0_pending;
 	spinlock_t register_lock;
 
 	void (* wbox_callback)(struct spu *spu);
diff -Naur linux-2.6.21.1-org/include/asm-powerpc/spu_priv1.h linux-2.6.21.1-ps3/include/asm-powerpc/spu_priv1.h
--- linux-2.6.21.1-org/include/asm-powerpc/spu_priv1.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/include/asm-powerpc/spu_priv1.h	2007-05-21 13:50:30.154286600 +0200
@@ -178,6 +178,8 @@
 	int (*enumerate_spus)(int (*fn)(void *data));
 	int (*create_spu)(struct spu *spu, void *data);
 	int (*destroy_spu)(struct spu *spu);
+	int (*enable_spu)(struct spu_context *ctx);
+	int (*disable_spu)(struct spu_context *ctx);
 };
 
 extern const struct spu_management_ops* spu_management_ops;
@@ -200,6 +202,18 @@
 	return spu_management_ops->destroy_spu(spu);
 }
 
+static inline int
+spu_enable_spu (struct spu_context *ctx)
+{
+	return spu_management_ops->enable_spu(ctx);
+}
+
+static inline int
+spu_disable_spu (struct spu_context *ctx)
+{
+	return spu_management_ops->disable_spu(ctx);
+}
+
 /*
  * The declarations folowing are put here for convenience
  * and only intended to be used by the platform setup code.
diff -Naur linux-2.6.21.1-org/include/linux/linux_logo.h linux-2.6.21.1-ps3/include/linux/linux_logo.h
--- linux-2.6.21.1-org/include/linux/linux_logo.h	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/include/linux/linux_logo.h	2007-05-21 13:50:30.223282926 +0200
@@ -32,6 +32,28 @@
 	const unsigned char *data;
 };
 
+extern const struct linux_logo logo_linux_mono;
+extern const struct linux_logo logo_linux_vga16;
+extern const struct linux_logo logo_linux_clut224;
+extern const struct linux_logo logo_dec_clut224;
+extern const struct linux_logo logo_mac_clut224;
+extern const struct linux_logo logo_parisc_clut224;
+extern const struct linux_logo logo_sgi_clut224;
+extern const struct linux_logo logo_sun_clut224;
+extern const struct linux_logo logo_superh_mono;
+extern const struct linux_logo logo_superh_vga16;
+extern const struct linux_logo logo_superh_clut224;
+extern const struct linux_logo logo_m32r_clut224;
+extern const struct linux_logo logo_spe_clut224;
+
 extern const struct linux_logo *fb_find_logo(int depth);
+#ifdef CONFIG_LOGO
+extern void fb_append_extra_logo(const struct linux_logo *logo,
+				 unsigned int n);
+#else
+static inline void fb_append_extra_logo(const struct linux_logo *logo,
+					unsigned int n)
+{}
+#endif
 
 #endif /* _LINUX_LINUX_LOGO_H */
diff -Naur linux-2.6.21.1-org/scripts/pnmtologo.c linux-2.6.21.1-ps3/scripts/pnmtologo.c
--- linux-2.6.21.1-org/scripts/pnmtologo.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/scripts/pnmtologo.c	2007-05-21 13:50:30.540266047 +0200
@@ -244,7 +244,7 @@
 static void write_footer(void)
 {
     fputs("\n};\n\n", out);
-    fprintf(out, "struct linux_logo %s __initdata = {\n", logoname);
+    fprintf(out, "const struct linux_logo %s __initdata = {\n", logoname);
     fprintf(out, "    .type\t= %s,\n", logo_types[logo_type]);
     fprintf(out, "    .width\t= %d,\n", logo_width);
     fprintf(out, "    .height\t= %d,\n", logo_height);
diff -Naur linux-2.6.21.1-org/sound/ppc/Kconfig linux-2.6.21.1-ps3/sound/ppc/Kconfig
--- linux-2.6.21.1-org/sound/ppc/Kconfig	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/sound/ppc/Kconfig	2007-05-21 13:50:30.556265196 +0200
@@ -33,3 +33,23 @@
 	  option.
 
 endmenu
+
+menu "ALSA PowerPC devices"
+	depends on SND!=n && ( PPC64 || PPC32 )
+
+config SND_PS3
+	tristate "PS3 Audio support"
+	depends on SND && PS3_PS3AV
+	select SND_PCM
+	default m
+	help
+	  Say Y here to include support for audio on the PS3
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd_ps3.
+
+config SND_PS3_DEFAULT_START_DELAY
+	int "Startup delay time in ms"
+	depends on SND_PS3
+	default "2000"
+endmenu
diff -Naur linux-2.6.21.1-org/sound/ppc/Makefile linux-2.6.21.1-ps3/sound/ppc/Makefile
--- linux-2.6.21.1-org/sound/ppc/Makefile	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21.1-ps3/sound/ppc/Makefile	2007-05-21 13:50:30.573264290 +0200
@@ -6,4 +6,5 @@
 snd-powermac-objs := powermac.o pmac.o awacs.o burgundy.o daca.o tumbler.o keywest.o beep.o
 
 # Toplevel Module Dependency
-obj-$(CONFIG_SND_POWERMAC) += snd-powermac.o
+obj-$(CONFIG_SND_POWERMAC)	+= snd-powermac.o
+obj-$(CONFIG_SND_PS3)		+= snd_ps3.o
diff -Naur linux-2.6.21.1-org/sound/ppc/snd_ps3.c linux-2.6.21.1-ps3/sound/ppc/snd_ps3.c
--- linux-2.6.21.1-org/sound/ppc/snd_ps3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/sound/ppc/snd_ps3.c	2007-05-21 13:50:30.586263598 +0200
@@ -0,0 +1,1536 @@
+/*
+ * Audio support for PS3
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * All rights reserved.
+ * Copyright 2006, 2007 Sony Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2 of the Licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/asound.h>
+#include <sound/memalloc.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <linux/dmapool.h>
+#include <linux/dma-mapping.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/lv1call.h>
+#include <asm/ps3.h>
+#include <asm/ps3av.h>
+
+#include "snd_ps3_reg.h"
+#include "snd_ps3.h"
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("PS3 sound driver");
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+
+static int index = SNDRV_DEFAULT_IDX1;
+static char *id = SNDRV_DEFAULT_STR1;
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for PS3 soundchip.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for PS3 soundchip.");
+
+module_init(snd_ps3_init);
+module_exit(snd_ps3_exit);
+
+static DEVICE_ATTR(start_delay,
+		   S_IRUGO | S_IWUSR,
+		   snd_ps3_get_start_delay,
+		   snd_ps3_set_start_delay);
+
+/* system memory info */
+extern unsigned long ps3_rm_limit, ps3_2nd_mem_base;
+extern unsigned long ps3_2nd_mem_size, ps3_mem_total;
+
+/*
+ * global
+ */
+struct snd_ps3_card_info the_card;
+
+static struct ioif_map_info * ioif_map_info_array;
+static int ioif_map_info_count;
+static int snd_ps3_start_delay = CONFIG_SND_PS3_DEFAULT_START_DELAY;
+
+module_param_named(start_delay, snd_ps3_start_delay, int, 0444);
+MODULE_PARM_DESC(start_delay, "time to insert silent data in milisec");
+
+/*
+ * PS3 audio register access macros
+ */
+
+/*
+ * chip: pointer to snd_ps3_card_info
+ * name: register offset value; PS3_AUDIO_XXXX
+ */
+#define AUDIOREGPTR(chip, name) (volatile uint32_t *)(chip->mapped_vaddr + name)
+
+#define AUDIOREG(chip, name) *(AUDIOREGPTR(chip, name))
+
+/*
+ * ALSA defs
+ */
+const static struct snd_pcm_hardware snd_ps3_pcm_hw = {
+        .info = (SNDRV_PCM_INFO_MMAP |
+                 SNDRV_PCM_INFO_NONINTERLEAVED |
+                 SNDRV_PCM_INFO_MMAP_VALID),
+        .formats = (SNDRV_PCM_FMTBIT_S16_BE |
+		    SNDRV_PCM_FMTBIT_S24_BE),
+        .rates = (SNDRV_PCM_RATE_44100 |
+		  SNDRV_PCM_RATE_48000 |
+		  SNDRV_PCM_RATE_88200 |
+		  SNDRV_PCM_RATE_96000),
+        .rate_min = 44100,
+        .rate_max = 96000,
+
+        .channels_min = 2, /* stereo only */
+        .channels_max = 2,
+
+        .buffer_bytes_max = PS3_AUDIO_FIFO_SIZE * 64,
+
+	/* interrupt by four stages */
+        .period_bytes_min = PS3_AUDIO_FIFO_STAGE_SIZE * 4,
+        .period_bytes_max = PS3_AUDIO_FIFO_STAGE_SIZE * 4,
+
+        .periods_min = 16,
+	.periods_max = 32, /* buffer_size_max/ period_bytes_max */
+
+	.fifo_size = PS3_AUDIO_FIFO_SIZE
+};
+
+static struct snd_pcm_ops snd_ps3_pcm_spdif_ops =
+{
+	.open = snd_ps3_pcm_open,
+	.close = snd_ps3_pcm_close,
+	.prepare = snd_ps3_pcm_prepare,
+	.ioctl = snd_pcm_lib_ioctl,
+	.trigger = snd_ps3_pcm_trigger,
+	.pointer = snd_ps3_pcm_pointer,
+	.hw_params = snd_ps3_pcm_hw_params,
+	.hw_free = snd_ps3_pcm_hw_free
+};
+
+static struct snd_kcontrol_new snd_ps3_vol_control =
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "PCM Playback Volume",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value = SND_PS3_MAX_VOL,/* not used */
+	.info = snd_ps3_info_vol_control,
+	.put = snd_ps3_put_vol_control,
+	.get = snd_ps3_get_vol_control
+};
+
+/*
+ * PCM operators
+ */
+static int snd_ps3_pcm_open(struct snd_pcm_substream * substream)
+{
+	struct snd_pcm_runtime * runtime = substream->runtime;
+	struct snd_ps3_card_info * card = snd_pcm_substream_chip(substream);
+	int pcm_index;
+
+	_SF;
+	pcm_index = substream->pcm->device;
+	/* to retrieve substream/runtime in interrupt handler */
+	card->substream = substream;
+
+	runtime->hw = snd_ps3_pcm_hw;
+
+	/* mute off */
+	snd_ps3_mute(substream, 0); // this function sleep
+
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+				   PS3_AUDIO_FIFO_STAGE_SIZE * 4 * 2);
+	_EF;
+	return 0;
+};
+
+static int snd_ps3_pcm_hw_params(struct snd_pcm_substream * substream,
+				 struct snd_pcm_hw_params * hw_params)
+{
+	size_t size;
+
+	_SF;
+	/* alloc transport buffer */
+	size = params_buffer_bytes(hw_params);
+	snd_pcm_lib_malloc_pages(substream, size);
+	_EF;
+	return 0;
+};
+
+static int snd_ps3_delay_to_bytes(struct snd_pcm_substream * substream,
+				  unsigned int delay_ms)
+{
+	int ret;
+	int rate ;
+
+	rate = substream->runtime->rate;
+	ret = snd_pcm_format_size(substream->runtime->format,
+				  rate * delay_ms / 1000)
+		* substream->runtime->channels;
+#if defined(_SND_PS3_DEBUG)
+	printk(KERN_ERR "%s: time=%d rate=%d bytes=%ld, frames=%d, ret=%d\n",
+	       __FUNCTION__,
+	       delay_ms,
+	       rate,
+	       snd_pcm_format_size(substream->runtime->format, rate),
+	       rate * delay_ms / 1000,
+	       ret);
+#endif
+	return ret;
+};
+
+static int snd_ps3_pcm_prepare(struct snd_pcm_substream * substream)
+{
+	struct snd_pcm_runtime * runtime = substream->runtime;
+	struct snd_ps3_card_info * card = snd_pcm_substream_chip(substream);
+	unsigned long irqsave;
+	_SF;
+
+	if (!snd_ps3_set_avsetting(substream)) {
+		/* some parameter changed */
+		AUDIOREG(card, PS3_AUDIO_AX_IE) = (PS3_AUDIO_AX_IE_ASOBEIE(0) |
+						   PS3_AUDIO_AX_IE_ASOBUIE(0));
+		/*
+		 * let SPDIF device re-lock with SPDIF signal,
+		 * start with some silence
+		 */
+		read_lock(&card->start_delay_lock);
+		card->silent = snd_ps3_delay_to_bytes(substream,
+						      card->start_delay) /
+			(PS3_AUDIO_FIFO_STAGE_SIZE * 4); /* every 4 times */
+		read_unlock(&card->start_delay_lock);
+	}
+
+	/* restart ring buffer pointer */
+	write_lock_irqsave(&card->dma_lock, irqsave);
+	{
+		card->dma_last_transfer_vaddr[SND_PS3_CH_L] =
+			card->dma_next_transfer_vaddr[SND_PS3_CH_L] =
+			card->dma_start_vaddr[SND_PS3_CH_L] = runtime->dma_area;
+
+		card->dma_buffer_size = runtime->dma_bytes;
+
+		card->dma_last_transfer_vaddr[SND_PS3_CH_R] =
+			card->dma_next_transfer_vaddr[SND_PS3_CH_R] =
+			card->dma_start_vaddr[SND_PS3_CH_R] =
+			runtime->dma_area + (runtime->dma_bytes / 2);
+	}
+	write_unlock_irqrestore(&card->dma_lock, irqsave);
+
+	mb();
+
+	_EF;
+	return 0;
+};
+
+/*
+ * atomic
+ */
+static int snd_ps3_pcm_trigger(struct snd_pcm_substream * substream,
+			       int cmd)
+{
+	struct snd_ps3_card_info * card = snd_pcm_substream_chip(substream);
+	int ret = 0;
+	unsigned long irqsave;
+
+	_SF;
+	switch (cmd)
+	{
+	case SNDRV_PCM_TRIGGER_START:
+		/* clear outstanding interrupts  */
+		AUDIOREG(card, PS3_AUDIO_AX_IS) = -1;
+
+		write_lock_irqsave(&card->dma_lock, irqsave);
+		{
+			card->running = 1;
+		}
+		write_unlock_irqrestore(&card->dma_lock, irqsave);
+
+		snd_ps3_program_dma(card,
+				    SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);
+		snd_ps3_kick_dma(card);
+		while (AUDIOREG(card, PS3_AUDIO_KICK(7)) &
+		       PS3_AUDIO_KICK_STATUS_MASK) {
+			udelay(1);
+		}
+		snd_ps3_program_dma(card, SND_PS3_DMA_FILLTYPE_SILENT_RUNNING);
+		snd_ps3_kick_dma(card);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		write_lock_irqsave(&card->dma_lock, irqsave);
+		{
+			card->running = 0;
+		}
+		write_unlock_irqrestore(&card->dma_lock, irqsave);
+		snd_ps3_wait_for_dma_stop(card);
+		break;
+	default:
+		break;
+
+	}
+
+	_EF;
+	return ret;
+};
+
+/*
+ * report current pointer
+ */
+static snd_pcm_uframes_t snd_ps3_pcm_pointer(
+	struct snd_pcm_substream * substream)
+{
+	struct snd_ps3_card_info * card = snd_pcm_substream_chip(substream);
+	unsigned long irqsave;
+	size_t bytes;
+	snd_pcm_uframes_t ret;
+
+	_SF;
+
+ 	read_lock_irqsave(&card->dma_lock, irqsave);
+	{
+		bytes = (size_t)(card->dma_last_transfer_vaddr[SND_PS3_CH_L] -
+				 card->dma_start_vaddr[SND_PS3_CH_L]);
+	}
+ 	read_unlock_irqrestore(&card->dma_lock, irqsave);
+
+	ret = bytes_to_frames(substream->runtime, bytes * 2);
+	_EF;
+	return ret;
+};
+
+static int snd_ps3_pcm_hw_free(struct snd_pcm_substream * substream)
+{
+	int ret;
+	_SF;
+	ret = snd_pcm_lib_free_pages(substream);
+	_EF;
+	return ret;
+};
+
+static int snd_ps3_pcm_close(struct snd_pcm_substream * substream)
+{
+	_SF;
+	/* mute on */
+	snd_ps3_mute(substream, 1); // this function sleep
+	_EF;
+	return 0;
+};
+
+static void snd_ps3_audio_fixup(struct snd_ps3_card_info * card)
+{
+	/*
+	 * avsetting driver seems to never change the followings
+	 * so, init them here once
+	 */
+
+	/* no dma interrupt needed */
+	AUDIOREG(card, PS3_AUDIO_INTR_EN_0) = 0;
+
+	/* use every 4 buffer empty interrupt */
+	AUDIOREG(card, PS3_AUDIO_AX_IC) = ((AUDIOREG(card, PS3_AUDIO_AX_IC) &
+					    PS3_AUDIO_AX_IC_AASOIMD_MASK) |
+					   PS3_AUDIO_AX_IC_AASOIMD_EVERY4);
+
+	/* enable 3wire clocks */
+	AUDIOREG(card, PS3_AUDIO_AO_3WMCTRL) &=
+		~(PS3_AUDIO_AO_3WMCTRL_ASOBCLKD_DISABLED |
+		  PS3_AUDIO_AO_3WMCTRL_ASOLRCKD_DISABLED);
+	AUDIOREG(card, PS3_AUDIO_AO_3WMCTRL) |=
+		PS3_AUDIO_AO_3WMCTRL_ASOPLRCK_DEFAULT;
+}
+
+/*
+ * av setting
+ * NOTE: calling this function may generate audio interrupt.
+ */
+static int snd_ps3_change_avsetting(struct snd_ps3_card_info * card)
+{
+	int ret, retries, i;
+	_SF;
+
+	ret = ps3av_set_audio_mode(card->avs.avs_audio_ch,
+				  card->avs.avs_audio_rate,
+				  card->avs.avs_audio_width,
+				  card->avs.avs_audio_format,
+				  card->avs.avs_audio_source);
+	/*
+	 * Reset the following unwanted settings:
+	 */
+
+	/* disable all 3wire buffers */
+	AUDIOREG(card, PS3_AUDIO_AO_3WMCTRL) &=
+		~(PS3_AUDIO_AO_3WMCTRL_ASOEN(0) |
+		  PS3_AUDIO_AO_3WMCTRL_ASOEN(1) |
+		  PS3_AUDIO_AO_3WMCTRL_ASOEN(2) |
+		  PS3_AUDIO_AO_3WMCTRL_ASOEN(3));
+	mb();
+	/* wait for actually stopped */
+	retries = 1000;
+	while ((AUDIOREG(card, PS3_AUDIO_AO_3WMCTRL) &
+		(PS3_AUDIO_AO_3WMCTRL_ASORUN(0) |
+		 PS3_AUDIO_AO_3WMCTRL_ASORUN(1) |
+		 PS3_AUDIO_AO_3WMCTRL_ASORUN(2) |
+		 PS3_AUDIO_AO_3WMCTRL_ASORUN(3))) &&
+	       --retries) {
+		udelay(1);
+	}
+	mb();
+	/* reset buffer pointer */
+	for (i = 0; i < 4; i++) {
+		AUDIOREG(card, PS3_AUDIO_AO_3WCTRL(i)) |=
+			PS3_AUDIO_AO_3WCTRL_ASOBRST_RESET;
+		udelay(10);
+	}
+	mb();
+
+	/* enable 3wire#0 buffer */
+	AUDIOREG(card, PS3_AUDIO_AO_3WMCTRL) |= PS3_AUDIO_AO_3WMCTRL_ASOEN(0);
+	mb();
+
+	/* In 24bit mode,ALSA inserts a zero byte at first byte of per sample */
+	AUDIOREG(card, PS3_AUDIO_AO_3WCTRL(0)) =
+		((AUDIOREG(card, PS3_AUDIO_AO_3WCTRL(0)) &
+		  ~PS3_AUDIO_AO_3WCTRL_ASODF) |
+		 PS3_AUDIO_AO_3WCTRL_ASODF_LSB);
+	AUDIOREG(card, PS3_AUDIO_AO_SPDCTRL(0)) =
+		((AUDIOREG(card, PS3_AUDIO_AO_SPDCTRL(0)) &
+		  ~PS3_AUDIO_AO_SPDCTRL_SPODF) |
+		 PS3_AUDIO_AO_SPDCTRL_SPODF_LSB);
+	mb();
+	/* avsetting driver altered AX_IE, caller must reset it if you want */
+	_EF;
+	return ret;
+}
+
+static int snd_ps3_init_avsetting(struct snd_ps3_card_info * card)
+{
+	int ret;
+
+	_SF;
+	card->avs.avs_audio_ch = PS3AV_CMD_AUDIO_NUM_OF_CH_2;
+	card->avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_48K;
+	card->avs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_16;
+	card->avs.avs_audio_format = PS3AV_CMD_AUDIO_FORMAT_PCM;
+	card->avs.avs_audio_source = PS3AV_CMD_AUDIO_SOURCE_SERIAL;
+
+	ret = snd_ps3_change_avsetting(card);
+
+	snd_ps3_audio_fixup(card);
+
+	/* to start to generate SPDIF signal, fill data */
+	snd_ps3_program_dma(card, SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);
+	snd_ps3_kick_dma(card);
+	_EF;
+	return ret;
+}
+
+/*
+ *  set sampling rate according to the substream
+ */
+static int snd_ps3_set_avsetting(struct snd_pcm_substream * substream)
+{
+	struct snd_ps3_card_info * card = snd_pcm_substream_chip(substream);
+	struct snd_ps3_avsetting_info avs;
+
+	avs = card->avs;
+
+#if defined(_SND_PS3_DEBUG)
+	printk(KERN_ERR "%s: called freq=%d width=%d\n", __FUNCTION__,
+	       substream->runtime->rate,
+	       snd_pcm_format_width(substream->runtime->format));
+
+	printk(KERN_ERR "%s: before freq=%d width=%d\n", __FUNCTION__,
+	       card->avs.avs_audio_rate, card->avs.avs_audio_width);
+
+#endif
+	/* sample rate */
+	switch (substream->runtime->rate)
+	{
+	case 44100:
+		avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_44K;
+		break;
+	case 48000:
+		avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_48K;
+		break;
+	case 88200:
+		avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_88K;
+		break;
+	case 96000:
+		avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_96K;
+		break;
+	default:
+		printk(KERN_ERR "%s: invalid rate %d\n", __FUNCTION__,
+		       substream->runtime->rate);
+		return 1;
+	}
+
+	/* width */
+	switch (snd_pcm_format_width(substream->runtime->format))
+	{
+	case 16:
+		avs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_16;
+		break;
+	case 24:
+		avs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_24;
+		break;
+	default:
+		printk(KERN_ERR "%s: invalid width %d\n", __FUNCTION__,
+		       snd_pcm_format_width(substream->runtime->format));
+		return 1;
+	}
+
+	if ((card->avs.avs_audio_width != avs.avs_audio_width) ||
+	    (card->avs.avs_audio_rate != avs.avs_audio_rate)) {
+		card->avs = avs;
+		snd_ps3_change_avsetting(card);
+#if defined(_SND_PS3_DEBUG)
+		printk(KERN_ERR "%s: after freq=%d width=%d\n", __FUNCTION__,
+		       card->avs.avs_audio_rate, card->avs.avs_audio_width);
+#endif
+		return 0;
+	} else
+		return 1;
+}
+
+/*
+ * audio mute on/off
+ * mute_on : 0 output enabled
+ *           1 mute
+ */
+static int snd_ps3_mute(struct snd_pcm_substream * substream, int mute_on)
+{
+	(void) substream;
+
+	return ps3av_audio_mute(mute_on);
+}
+
+static int snd_ps3_kick_dma(struct snd_ps3_card_info * card)
+{
+
+	/* kick dma */
+	AUDIOREG(card, PS3_AUDIO_KICK(0)) |= PS3_AUDIO_KICK_REQUEST;
+	mb();
+
+	return 0;
+}
+
+static int snd_ps3_verify_dma_stop(struct snd_ps3_card_info * card,
+				   int count, int force_stop)
+{
+	int dma_ch, done, retries, stop_forced = 0;
+	uint32_t status;
+
+	for (dma_ch = 0; dma_ch < 8; dma_ch ++) {
+		retries = count;
+		do {
+			status = AUDIOREG(card, PS3_AUDIO_KICK(dma_ch)) &
+				PS3_AUDIO_KICK_STATUS_MASK;
+			switch (status) {
+			case PS3_AUDIO_KICK_STATUS_DONE:
+			case PS3_AUDIO_KICK_STATUS_NOTIFY:
+			case PS3_AUDIO_KICK_STATUS_CLEAR:
+			case PS3_AUDIO_KICK_STATUS_ERROR:
+				done = 1;
+				break;
+			default:
+				done = 0;
+				udelay(10);
+			}
+		} while (!done && --retries);
+		if (!retries && force_stop) {
+			printk(KERN_ERR "%s: DMA ch %d is not stopped.",
+			       __FUNCTION__, dma_ch);
+			/* last resort. force to stop dma.
+			 *  NOTE: this cause DMA done interrupts
+			 */
+			AUDIOREG(card, PS3_AUDIO_CONFIG) |=
+				PS3_AUDIO_CONFIG_CLEAR;
+			stop_forced = 1;
+		}
+	}
+	return stop_forced;
+}
+
+/*
+ * wait for all dma is done.
+ * NOTE: caller should reset card->running before call.
+ *       If not, the interrupt handler will re-start DMA,
+ *       then DMA is never stopped.
+ */
+static void snd_ps3_wait_for_dma_stop(struct snd_ps3_card_info * card)
+{
+	int stop_forced;
+	_SF;
+	/*
+	 * wait for the last dma is done
+	 */
+
+	/*
+	 * expected maximum DMA done time is 5.7ms + something (DMA itself).
+	 * 5.7ms is from 16bit/sample 2ch 44.1Khz; the time next
+	 * DMA kick event would occur.
+	 */
+	stop_forced = snd_ps3_verify_dma_stop(card, 700, 1);
+
+	/*
+	 * clear outstanding interrupts.
+	 */
+	AUDIOREG(card, PS3_AUDIO_INTR_0) = -1;
+	AUDIOREG(card, PS3_AUDIO_AX_IS) = -1;
+
+	/*
+	 *revert CLEAR bit since it will not reset automatically after DMA stop
+	 */
+	if (stop_forced) {
+		AUDIOREG(card, PS3_AUDIO_CONFIG) &= ~PS3_AUDIO_CONFIG_CLEAR;
+	}
+	mb();
+	_EF;
+}
+
+/*
+ * increment ring buffer pointer.
+ * NOTE: caller must hold write spinlock
+ */
+static void snd_ps3_bump_buffer(struct snd_ps3_card_info * card,
+				enum snd_ps3_ch ch, size_t byte_count,
+				int stage)
+{
+	if (!stage)
+		card->dma_last_transfer_vaddr[ch] =
+			card->dma_next_transfer_vaddr[ch];
+	card->dma_next_transfer_vaddr[ch] += byte_count;
+	if ((card->dma_start_vaddr[ch] + (card->dma_buffer_size / 2)) <=
+	    card->dma_next_transfer_vaddr[ch]) {
+		card->dma_next_transfer_vaddr[ch] = card->dma_start_vaddr[ch];
+	}
+}
+
+/*
+ * setup dmac to send data to audio and attenuate samples on the ring buffer
+ */
+static int snd_ps3_program_dma(struct snd_ps3_card_info * card,
+			       enum snd_ps3_dma_filltype filltype)
+{
+	uint32_t dma_addr;
+	int fill_stages, dma_ch, stage;
+	enum snd_ps3_ch ch;
+	uint32_t ch0_kick_event = 0; /* initialize to mute gcc */
+	void * start_vaddr;
+	unsigned long irqsave;
+	int silent = 0;
+
+	switch (filltype) {
+	case SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL:
+		silent = 1;
+		/* intentionally fall thru */
+	case SND_PS3_DMA_FILLTYPE_FIRSTFILL:
+		ch0_kick_event = PS3_AUDIO_KICK_EVENT_ALWAYS;
+		break;
+
+	case SND_PS3_DMA_FILLTYPE_SILENT_RUNNING:
+		silent = 1;
+		/* intentionally fall thru */
+	case SND_PS3_DMA_FILLTYPE_RUNNING:
+		ch0_kick_event = PS3_AUDIO_KICK_EVENT_SERIALOUT0_EMPTY;
+		break;
+	}
+
+	snd_ps3_verify_dma_stop(card, 700, 0);
+	fill_stages = 4;
+ 	write_lock_irqsave(&card->dma_lock, irqsave);
+	if (likely(!silent))
+		snd_ps3_soft_attenuate(card,
+				       card->dma_next_transfer_vaddr[0],
+				       card->dma_next_transfer_vaddr[1],
+				       PS3_AUDIO_DMAC_BLOCK_SIZE * 4);
+	for (ch = 0; ch < 2; ch++) {
+		start_vaddr = card->dma_next_transfer_vaddr[0];
+		for (stage = 0; stage < fill_stages; stage ++) {
+			//dma_ch = fill_stages * ch + stage;
+			dma_ch = stage * 2 + ch;
+			if (silent) {
+				dma_addr =
+				p_to_dma(__pa(card->null_buffer_start_vaddr));
+			}
+			else {
+				dma_addr =
+				p_to_dma(__pa(card->dma_next_transfer_vaddr[ch]));
+			}
+
+			AUDIOREG(card, PS3_AUDIO_SOURCE(dma_ch)) =
+				(PS3_AUDIO_SOURCE_TARGET_SYSTEM_MEMORY |
+				 dma_addr);
+
+			/* dst: fixed to 3wire#0 */
+			if (ch == 0)
+				AUDIOREG(card, PS3_AUDIO_DEST(dma_ch)) =
+					(PS3_AUDIO_DEST_TARGET_AUDIOFIFO |
+					 PS3_AUDIO_AO_3W_LDATA(0));
+			else
+				AUDIOREG(card, PS3_AUDIO_DEST(dma_ch)) =
+					(PS3_AUDIO_DEST_TARGET_AUDIOFIFO |
+					 PS3_AUDIO_AO_3W_RDATA(0));
+
+			/* count always 1 DMA block (1/2 stage = 128 bytes) */
+			AUDIOREG(card, PS3_AUDIO_DMASIZE(dma_ch)) = 0;
+			/* bump pointer if needed */
+			if (!silent)
+				snd_ps3_bump_buffer(card, ch,
+						    PS3_AUDIO_DMAC_BLOCK_SIZE,
+						    stage);
+
+			/* kick event  */
+			if (dma_ch == 0) {
+				AUDIOREG(card, PS3_AUDIO_KICK(dma_ch)) =
+					ch0_kick_event;
+			} else {
+				AUDIOREG(card, PS3_AUDIO_KICK(dma_ch)) =
+					(PS3_AUDIO_KICK_EVENT_AUDIO_DMA(dma_ch -
+									1) |
+					 PS3_AUDIO_KICK_REQUEST);
+			}
+		}
+	}
+	mb();
+	write_unlock_irqrestore(&card->dma_lock, irqsave);
+
+	mb();
+	return 0;
+}
+
+/****************************************************************************
+ *
+ * real initializer. called once
+ *
+ */
+static int __init snd_ps3_driver_probe(struct platform_device * device)
+{
+	int ret;
+	_SF;
+
+	memset(&the_card, 0, sizeof(the_card));
+	rwlock_init(&the_card.dma_lock);
+	rwlock_init(&the_card.start_delay_lock);
+
+	/* CONFIG_SND_PS3_DEFAULT_START_DELAY */
+	the_card.start_delay = snd_ps3_start_delay;
+	the_card.platform_device = device;
+
+	/* map audio register, etc */
+	if ((ret = snd_ps3_init_audio())) {
+		return -ENOMEM;
+	}
+
+	/* create card instance */
+	the_card.card = snd_card_new(index, id, THIS_MODULE, 0);
+	if (!the_card.card) {
+		goto error0;
+	}
+	strcpy(the_card.card->driver, "snd_ps3");
+	strcpy(the_card.card->shortname, "PS3");
+	strcpy(the_card.card->longname, "PS3 sound");
+	/* create PCM devices instance */
+	/* NOTE:this driver works assuming pcm:substream = 1:1 */
+	ret = snd_pcm_new(the_card.card,
+			  "SPDIF",
+			  0, /* instance index, will be stored pcm.device*/
+			  1, /* output substream */
+			  0, /* input substream */
+			  &(the_card.pcm));
+	if (ret)
+		goto error1;
+
+	the_card.pcm->private_data = &the_card;
+	strcpy(the_card.pcm->name, "SPDIF");
+
+	/* set pcm ops */
+	snd_pcm_set_ops(the_card.pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_ps3_pcm_spdif_ops);
+
+	the_card.pcm->info_flags = SNDRV_PCM_INFO_NONINTERLEAVED;
+	/* pre-alloc buffer */
+	ret = snd_pcm_lib_preallocate_pages_for_all(the_card.pcm,
+					SNDRV_DMA_TYPE_CONTINUOUS,
+					snd_dma_continuous_data(GFP_KERNEL),
+					PS3_AUDIO_DMAC_BLOCK_SIZE *
+					PS3_AUDIO_DMAC_MAX_BLOCKS * 4,
+					PS3_AUDIO_DMAC_BLOCK_SIZE *
+					PS3_AUDIO_DMAC_MAX_BLOCKS * 4);
+
+	if (ret < 0) {
+		printk(KERN_ERR "%s: prealloc failed\n", __FUNCTION__);
+		goto error1;
+	}
+
+	/*
+	 * allocate null buffer
+	 * its size should be lager than PS3_AUDIO_FIFO_STAGE_SIZE * 2
+	 */
+	if (!(the_card.null_buffer_start_vaddr = get_zeroed_page(GFP_KERNEL))) {
+		printk(KERN_ERR "%s: nullbuffer alloc failed\n", __FUNCTION__);
+		goto error2;
+	}
+	/* set default sample rate/word width */
+	snd_ps3_init_avsetting(&the_card);
+
+	/* add volume control */
+	the_card.vol_control = snd_ctl_new1(&snd_ps3_vol_control, &the_card);
+	if ((ret = snd_ctl_add(the_card.card, the_card.vol_control)) < 0) {
+		goto error3;
+	}
+	/* register the card */
+	ret = snd_card_register(the_card.card);
+	if (ret < 0)
+		goto error4;
+
+	platform_set_drvdata(device, &the_card);
+
+	printk("%s started. start_delay=%dms\n",
+	       the_card.card->longname, the_card.start_delay);
+	_EF;
+	return 0;
+
+ error4:
+	/* no need call to snd_control_free_one() here*/
+	snd_ctl_remove(the_card.card, the_card.vol_control);
+ error3:
+	free_page(the_card.null_buffer_start_vaddr);
+ error2:
+	snd_pcm_lib_preallocate_free_for_all(the_card.pcm);
+ error1:
+	snd_card_free(the_card.card);
+ error0:
+	snd_ps3_free_audio();
+	/*
+	 * there is no destructor function to pcm.
+	 * midlayer automatically releases if the card removed
+	 */
+	_EF1("error");
+	return ret;
+}; /* snd_ps3_probe */
+
+/* called when system shutdown */
+static void snd_ps3_driver_shutdown(struct platform_device * device)
+{
+	_SF;
+	snd_ps3_driver_remove(device);
+	_EF;
+}
+
+/* called when module removal */
+static int snd_ps3_driver_remove(struct platform_device * device)
+{
+	_SF;
+
+	platform_set_drvdata(device, NULL);
+	snd_ctl_remove(the_card.card, the_card.vol_control);
+	snd_pcm_lib_preallocate_free_for_all(the_card.pcm);
+	snd_card_free(the_card.card);
+	free_page(the_card.null_buffer_start_vaddr);
+	snd_ps3_free_audio();
+
+	_EF;
+	return 0;
+} /* snd_ps3_remove */
+
+static struct platform_driver snd_ps3_platform_driver =
+{
+	.probe = snd_ps3_driver_probe,
+	.remove = snd_ps3_driver_remove,
+	.shutdown = snd_ps3_driver_shutdown,
+	.driver = {
+		.name = SND_PS3_DRIVER_NAME
+	}
+};
+
+static struct platform_device * the_platform_device;
+
+/*
+ * module initialize/terminate
+ */
+static int __init snd_ps3_init(void)
+{
+	int ret;
+
+	ret = ps3av_dev_open();
+
+	if (ret) {
+		printk(KERN_ERR "%s: open failed %d\n", __FUNCTION__, ret);
+		return ret;
+	}
+
+	ret = platform_driver_register(&snd_ps3_platform_driver);
+	if (ret < 0)
+		return ret;
+
+	the_platform_device =
+		platform_device_register_simple(SND_PS3_DRIVER_NAME,
+						0, NULL, 0);
+	if (IS_ERR(the_platform_device)) {
+		ret = PTR_ERR(the_platform_device);
+		goto error0;
+	}
+
+	ret = device_create_file(&(the_platform_device->dev),
+				 &dev_attr_start_delay);
+
+	return ret;
+ error0:
+	platform_driver_unregister(&snd_ps3_platform_driver);
+	return ret;
+}
+
+static void __exit snd_ps3_exit(void)
+{
+	device_remove_file(&(the_platform_device->dev), &dev_attr_start_delay);
+	platform_device_unregister(the_platform_device);
+	platform_driver_unregister(&snd_ps3_platform_driver);
+}
+
+
+/*
+ * create iosegment and iopte for DMA area
+ * map audio audio registers
+ * allocate irq
+ */
+
+static int snd_ps3_init_audio(void)
+{
+	int ret, map;
+
+	if ((ret = snd_ps3_create_iopt()))
+		return ret;
+
+ 	/* map registers and irq info */
+	map = 1;
+	ret = lv1_gpu_device_map(map, &the_card.audio_lpar_addr,
+				 &the_card.audio_lpar_size);
+	if (ret) {
+		printk(KERN_ERR "%s: device map 1 failed %d\n", __FUNCTION__,
+		       ret);
+		ret = -ENXIO;
+		goto cleanup;
+	}
+
+	the_card.mapped_vaddr = ioremap(the_card.audio_lpar_addr,
+					the_card.audio_lpar_size);
+
+	if (!the_card.mapped_vaddr) {
+		printk(KERN_ERR "%s: ioremap 1 failed \n", __FUNCTION__);
+		ret = -ENXIO;
+		goto cleanup_1;
+	}
+
+
+	the_card.audio_irq_outlet = *(uint64_t*)the_card.mapped_vaddr;
+
+	/* no more needed */
+	iounmap(the_card.mapped_vaddr);
+	lv1_gpu_device_unmap(map);
+
+	map = 2;
+	ret = lv1_gpu_device_map(map, &the_card.audio_lpar_addr,
+				 &the_card.audio_lpar_size);
+	if (ret) {
+		printk(KERN_ERR "%s: device map 2 failed %d\n", __FUNCTION__,
+		       ret);
+		ret = -ENXIO;
+		goto cleanup;
+	}
+
+	the_card.mapped_vaddr = ioremap(the_card.audio_lpar_addr,
+					the_card.audio_lpar_size);
+
+	if (!the_card.mapped_vaddr) {
+		printk(KERN_ERR "%s: ioremap 0 failed \n", __FUNCTION__);
+		ret = -ENXIO;
+		goto cleanup_1;
+	}
+
+	/* irq */
+	ret = ps3_irq_plug_setup(PS3_BINDING_CPU_ANY, the_card.audio_irq_outlet,
+				 &the_card.irq_no);
+	if (ret) {
+		printk("%s:%u: ps3_alloc_irq failed (%d)\n", __FUNCTION__,
+		       __LINE__, ret);
+		goto cleanup_2;
+	}
+
+	ret = request_irq(the_card.irq_no, snd_ps3_interrupt, IRQF_DISABLED,
+			  SND_PS3_DRIVER_NAME, &the_card);
+	if (ret) {
+		printk("%s:%u: request_irq failed (%d)\n", __FUNCTION__,
+		       __LINE__, ret);
+		goto cleanup_3;
+	}
+
+	/*
+	 * OK, PPU side setup done,
+	 * tell io address for DMA to audio controller
+	 */
+	snd_ps3_audio_set_base_addr(ioif_map_info_array[0].ioif_addr);
+
+	_EF;
+
+	return 0;
+ cleanup_3:
+	ps3_irq_plug_destroy(the_card.irq_no);
+ cleanup_2:
+	iounmap(the_card.mapped_vaddr);
+
+ cleanup_1:
+	lv1_gpu_device_unmap(map);
+
+ cleanup:
+
+	return ret;
+};
+
+
+static void snd_ps3_free_audio(void)
+{
+	int ret;
+
+	_SF;
+	/* irq */
+	free_irq(the_card.irq_no, &the_card);
+	ps3_irq_plug_destroy(the_card.irq_no);
+
+	iounmap(the_card.mapped_vaddr);
+
+	/* unmap registers */
+	ret = lv1_gpu_device_unmap(2);
+	if (ret)
+		printk(KERN_ERR "%s: device unmap failed %d\n", __FUNCTION__,
+		       ret);
+
+	ps3av_dev_close();
+
+	/* iopte */
+	snd_ps3_destruct_iopt();
+	_EF;
+
+};
+
+
+
+/*
+ * request iopte for device dma
+ */
+static void snd_ps3_audio_set_base_addr(uint64_t ioaddr_start)
+{
+	uint64_t val;
+	int ret;
+
+	_SF;
+
+	val = (ioaddr_start & (0x0fUL << 32)) >> (32 - 20) |
+		(0x03UL << 24) |
+		(0x0fUL << 12) |
+		(1);
+
+	ret = lv1_gpu_attribute(0x100, 0x007, val, 0, 0);
+	if (ret)
+		printk(KERN_ERR "%s: gpu_attribute failed %d\n", __FUNCTION__,
+		       ret);
+	_EF;
+}
+
+#define PS3_AUDIO_IOID       (1UL)
+#define IO_PAGESIZE_4K_SHIFT   (12)
+#define IO_PAGESIZE_64K_SHIFT  (16)
+#define IO_PAGESIZE_1M_SHIFT   (20)
+#define IO_PAGESIZE_16M_SHIFT  (24)
+#define IO_PAGESIZE_SHIFT      IO_PAGESIZE_16M_SHIFT
+#define IO_PAGESIZE            (1UL << IO_PAGESIZE_SHIFT)
+#define IO_SEGMENTSIZE_SHIFT   (28)
+#define IO_SEGMENTSIZE         (1UL << IO_SEGMENTSIZE_SHIFT)
+#define IOPTE_READONLY         (1UL << 62)
+#define IOPTE_READWRITE        (3UL << 62)
+#define IOPTE_INVALID          (0UL << 62)
+
+#define IOPTE_COHERENT         (1UL << 61)
+#define IOPTE_STRICT_ORDER     (3UL << 59)
+#define IOPTE_HINT             (1UL << 11)
+/*
+ * convert physical addr to ioif bus addr.
+ * Since we mapped physical addr 0 as seg[0].ioif_addr
+ * no need to convert to lpar address here.
+ * NOTE: no boudary check performed
+ */
+static uint64_t p_to_dma(uint64_t paddr)
+{
+	int seg;
+#if defined(CONFIG_PS3_USE_LPAR_ADDR)
+	if (ps3_rm_limit <= paddr)
+		paddr = paddr - ps3_2nd_mem_base + ps3_rm_limit;
+#endif
+	seg = paddr >> IO_SEGMENTSIZE_SHIFT;
+
+
+	return ioif_map_info_array[seg].ioif_addr + (paddr & ~IO_SEGMENTSIZE);
+};
+
+static uint64_t inc_paddr(uint64_t curpos, uint64_t offset)
+{
+	uint64_t ret = curpos + offset;
+
+#if defined(CONFIG_PS3_USE_LPAR_ADDR)
+	if ((ps3_rm_limit <= ret) && (ret < ps3_2nd_mem_base))
+		ret = ps3_2nd_mem_base;
+#endif
+	return ret;
+}
+/*
+ * create io segments for DMA and iopte
+ * and also AUDIO ioif setup
+ * Note: segments cover whole mememory area Linux uses.
+ *       See ps3_get_memsize for LPAR memory layout.
+ * we assume the followings:
+ *   o total system memory size is multiple of 16MB
+ *   o hvc allocates all io address under 4G
+ */
+static int snd_ps3_create_iopt(void)
+{
+	int ret, pages_remain, current_segment, current_page;
+	uint64_t current_paddr;
+	_SF;
+	/*
+	 * since we allocated memory from hvc as pagesize 16MB,
+	 * total allocated size should be multiple of 16MB
+	 */
+	if (ps3_mem_total % IO_PAGESIZE) {
+		printk(KERN_ERR "%s: pagesize differ %lx!!\n", __FUNCTION__,
+		       ps3_mem_total);
+		panic("!");
+	}
+	/*
+	 * calc how many segment needed
+	 * assumed 1 or 2 for current ps3 memory size
+	 */
+	ioif_map_info_count = (ps3_mem_total >> IO_SEGMENTSIZE_SHIFT) + 1;
+
+	if (!(ioif_map_info_array =
+	      kzalloc(sizeof(struct ioif_map_info) * ioif_map_info_count,
+		      GFP_KERNEL))) {
+		printk(KERN_ERR "%s: no memory\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	pages_remain = ps3_mem_total >> IO_PAGESIZE_SHIFT;
+	/* physical address start from 0 */
+	current_paddr = 0;
+	for (current_segment = 0;
+	     current_segment < ioif_map_info_count;
+	     current_segment++) {
+
+		ioif_map_info_array[current_segment].start_paddr =
+			current_paddr;
+		ioif_map_info_array[current_segment].start_lpar_addr =
+			ps3_mm_phys_to_lpar(current_paddr);
+		ioif_map_info_array[current_segment].area_size = IO_SEGMENTSIZE;
+
+		ret = lv1_allocate_io_segment(0, /* io space */
+			IO_SEGMENTSIZE, /* segment size */
+			IO_PAGESIZE_SHIFT, /* io page size */
+			&(ioif_map_info_array[current_segment].ioif_addr));
+
+		if (ret) {
+			printk(KERN_ERR "%s: alloc_io_seg %d failed %d\n",
+			       __FUNCTION__, current_segment, ret);
+			goto cleanup0;
+		}
+
+		if (ioif_map_info_array[current_segment].ioif_addr >> 32) {
+			printk(KERN_CRIT "%s: io addr is alloc above 4G! %lx\n",
+			       __FUNCTION__,
+			       ioif_map_info_array[current_segment].ioif_addr);
+			panic("!");
+		}
+		/* create iopte for this segment */
+		for (current_page = 0;
+		     current_page < (IO_SEGMENTSIZE / IO_PAGESIZE) &&
+			     pages_remain;
+		     current_page ++, current_paddr =
+			     inc_paddr(current_paddr, IO_PAGESIZE)) {
+			ret = lv1_put_iopte(0, /* io address space id */
+				ioif_map_info_array[current_segment].ioif_addr +
+				current_page * IO_PAGESIZE, /* ioif addr */
+				ps3_mm_phys_to_lpar(current_paddr),
+				PS3_AUDIO_IOID,
+				IOPTE_READONLY | IOPTE_COHERENT |
+					    IOPTE_STRICT_ORDER);
+			if (ret) {
+				printk(KERN_ERR "%s: put_iopte failed (%d) " \
+				       "seg=%d paddr=%#lx lpar=%#lx page=%d\n",
+				       __FUNCTION__, ret, current_segment,
+				       current_paddr,
+				       ps3_mm_phys_to_lpar(current_paddr),
+				       current_page);
+				printk(KERN_ERR "%s: rm_limit=%#lx " \
+				       "2nd_base=%#lx 2nd_size=%#lx "\
+				       "total=%#lx\n",
+				       __FUNCTION__,
+				       ps3_rm_limit, ps3_2nd_mem_base,
+				       ps3_2nd_mem_size, ps3_mem_total);
+				current_segment ++;
+				goto cleanup0;
+			}
+			pages_remain --;
+		}
+	}
+
+	if (0 < pages_remain) {
+		panic("unmaped page remain\n");
+	}
+
+	_EF;
+	return 0;
+
+ cleanup0:
+	snd_ps3_destruct_iopt_helper();
+	return -ENOMEM;
+}
+
+/*
+ * invalidate all iopte and free io segment
+ */
+static void snd_ps3_destruct_iopt_helper(void)
+{
+	int ret, pages_remain, current_segment, current_page;
+	uint64_t current_paddr;
+
+	_SF;
+
+	pages_remain = ps3_mem_total >> IO_PAGESIZE_SHIFT;
+	/* physical address start from 0 */
+	current_paddr = 0;
+
+	/*
+	 * invalidate iopte first , then release io segment
+	 */
+	for (current_segment = 0;
+	     current_segment < ioif_map_info_count; current_segment++) {
+		/* create iopte for this segment */
+		for (current_page = 0;
+		     current_page < (IO_SEGMENTSIZE / IO_PAGESIZE) &&
+			     pages_remain;
+		     current_page ++, current_paddr =
+			     inc_paddr(current_paddr,IO_PAGESIZE)) {
+			ret = lv1_put_iopte(0, /* io address space id */
+				ioif_map_info_array[current_segment].ioif_addr +
+					    current_page *
+					    IO_PAGESIZE, /* ioif addr */
+				ps3_mm_phys_to_lpar(current_paddr),
+				PS3_AUDIO_IOID, IOPTE_INVALID);
+			if (ret) {
+				printk(KERN_ERR "%s: put_iopte failed (%d) "\
+				       "seg=%d paddr=%#lx lpar=%#lx page=%d\n",
+				       __FUNCTION__, ret, current_segment,
+				       current_paddr,
+				       ps3_mm_phys_to_lpar(current_paddr),
+				       current_page);
+				printk(KERN_ERR "%s: rm_limit=%#lx "\
+				       "2nd_base=%#lx 2nd_size=%#lx "\
+				       "total=%#lx\n", __FUNCTION__,
+				       ps3_rm_limit, ps3_2nd_mem_base,
+				       ps3_2nd_mem_size, ps3_mem_total);
+				current_segment ++;
+			}
+			pages_remain --;
+		}
+
+		ret = lv1_release_io_segment(0, /* io space */
+			     ioif_map_info_array[current_segment].ioif_addr);
+
+		if (ret)
+			printk(KERN_ERR "%s: release_io_seg %d failed %d\n",
+			       __FUNCTION__, current_segment, ret);
+	}
+
+	kfree(ioif_map_info_array);
+	ioif_map_info_array = 0;
+	_EF;
+}
+
+static void snd_ps3_destruct_iopt(void)
+{
+	snd_ps3_destruct_iopt_helper();
+}
+
+/*
+ * Interrupt handler
+ */
+static irqreturn_t snd_ps3_interrupt(int irq, void * dev_id)
+{
+
+	uint32_t port_intr;
+	int underflow_occured = 0;
+	struct snd_ps3_card_info * card = dev_id;
+
+
+
+	if (!card->running) {
+		AUDIOREG(card, PS3_AUDIO_AX_IS) = -1;
+		AUDIOREG(card, PS3_AUDIO_INTR_0) = -1;
+		return IRQ_HANDLED;
+	}
+
+	port_intr = AUDIOREG(card, PS3_AUDIO_AX_IS);
+	/*
+	 *serial buffer empty detected (every 4 times),
+	 *program next dma and kick it
+	 */
+	if (port_intr & PS3_AUDIO_AX_IE_ASOBEIE(0)) {
+		AUDIOREG(card, PS3_AUDIO_AX_IS) = PS3_AUDIO_AX_IE_ASOBEIE(0);
+		if (port_intr & PS3_AUDIO_AX_IE_ASOBUIE(0)) {
+			AUDIOREG(card, PS3_AUDIO_AX_IS) = port_intr;
+			underflow_occured = 1;
+		}
+		if (card->silent) {
+			/* we are still in silent time */
+			snd_ps3_program_dma(card,
+				(underflow_occured) ?
+				SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL :
+				SND_PS3_DMA_FILLTYPE_SILENT_RUNNING);
+			snd_ps3_kick_dma(card);
+			card->silent --;
+		} else {
+			snd_ps3_program_dma(card,
+				(underflow_occured) ?
+				SND_PS3_DMA_FILLTYPE_FIRSTFILL :
+				SND_PS3_DMA_FILLTYPE_RUNNING);
+			snd_ps3_kick_dma(card);
+			snd_pcm_period_elapsed(card->substream);
+		}
+	} else if (port_intr & PS3_AUDIO_AX_IE_ASOBUIE(0)) {
+		AUDIOREG(card, PS3_AUDIO_AX_IS) = PS3_AUDIO_AX_IE_ASOBUIE(0);
+                /*
+		 * serial out underflow, but buffer empty not detected.
+		 * in this case, fill fifo with 0 to recover.  After
+		 * filling dummy data, serial automatically start to
+		 * consume them and then will generate normal buffer
+		 * empty interrupts.
+		 * If both buffer underflow and buffer empty are occured,
+		 * it is better to do nomal data transfer than empty one
+		 */
+		snd_ps3_program_dma(card,
+				    SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);
+		snd_ps3_kick_dma(card);
+		snd_ps3_program_dma(card,
+				    SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);
+		snd_ps3_kick_dma(card);
+	}
+	/* clear interrupt cause */
+	return IRQ_HANDLED;
+};
+
+/*
+ * sysfs
+ */
+static ssize_t snd_ps3_get_start_delay(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct platform_device * plat_dev =
+		container_of(dev, struct platform_device, dev);
+	struct snd_ps3_card_info * card = platform_get_drvdata(plat_dev);
+	ssize_t ret;
+
+	read_lock(&card->start_delay_lock);
+	ret = sprintf(buf, "%u\n", card->start_delay);
+	read_unlock(&card->start_delay_lock);
+	return ret;
+}
+
+static ssize_t snd_ps3_set_start_delay(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf,
+				       size_t count)
+{
+	unsigned int start_delay;
+	struct platform_device * plat_dev =
+		container_of(dev, struct platform_device, dev);
+	struct snd_ps3_card_info * card = platform_get_drvdata(plat_dev);
+
+	if (sscanf(buf, "%u", &start_delay) > 0) {
+ 		write_lock(&card->start_delay_lock);
+		card->start_delay = start_delay;
+		write_unlock(&card->start_delay_lock);
+		return strlen(buf);
+	}
+	return -EINVAL;
+}
+
+
+static int snd_ps3_info_vol_control(struct snd_kcontrol * kcontrol,
+				    struct snd_ctl_elem_info * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = SND_PS3_CH_MAX; /* stereo */
+	uinfo->value.integer.min = SND_PS3_MIN_VOL;
+	uinfo->value.integer.max = SND_PS3_MAX_VOL;
+	return 0;
+};
+
+static int snd_ps3_get_vol_control(struct snd_kcontrol * kcontrol,
+				   struct snd_ctl_elem_value * ucontrol)
+{
+	struct snd_ps3_card_info * card = snd_kcontrol_chip(kcontrol);
+	int i;
+	for (i = 0; i < SND_PS3_CH_MAX; i++)
+		ucontrol->value.integer.value[i] =
+			SND_PS3_MAX_VOL - card->attenuater[i];
+	return 0;
+};
+
+static int snd_ps3_put_vol_control(struct snd_kcontrol * kcontrol,
+				   struct snd_ctl_elem_value * ucontrol)
+{
+	struct snd_ps3_card_info * card = snd_kcontrol_chip(kcontrol);
+	int i;
+	int changed = 0;
+
+	for (i = 0; i < SND_PS3_CH_MAX; i++)
+		if ((ucontrol->value.integer.value[i] < SND_PS3_MIN_VOL) ||
+		    (SND_PS3_MAX_VOL < ucontrol->value.integer.value[i]))
+			return -EINVAL;
+
+	for (i = 0; i < SND_PS3_CH_MAX; i++)
+		if ((SND_PS3_MAX_VOL - card->attenuater[i]) !=
+		    ucontrol->value.integer.value[i]) {
+			card->attenuater[i] = SND_PS3_MAX_VOL -
+				ucontrol->value.integer.value[i];
+			changed = 1;
+		}
+	return changed;
+};
+
+typedef struct
+{
+	unsigned char numerator;
+	unsigned char denominator;
+} attenuater_divisor;
+
+static const attenuater_divisor
+attenuater_divisor_array[SND_PS3_MAX_VOL - SND_PS3_MIN_VOL + 1] =
+{
+	[ 0] = {   1,   1}, /* 0db; not used */
+	[ 1] = { 177, 250}, /*  -1.5 db 0.708 */
+	[ 2] = {   1,   2}, /*  -3.0 db 0.501 */
+	[ 3] = {  71, 200}, /*  -4.5 db 0.355 */
+	[ 4] = {   1,   4}, /*  -6.0 db 0.251 */
+	[ 5] = {  45, 250}, /*  -7.5 db 0.178 */
+	[ 6] = {   1,   8}, /*  -9.0 db 0.126 */
+	[ 7] = {  22, 250}, /* -10.5 db 89.1m */
+	[ 8] = {   1,  16}, /* -12.0 db 63.1m */
+	[ 9] = {  11, 250}, /* -13.5 db 44.7m */
+	[10] = {   1,  32}, /* -15.0 db 31.6m */
+	[11] = {   5, 250}, /* -16.5 db 22.4m */
+	[12] = {   1,  64}, /* -18.0 db 15.8m */
+	[13] = {   2, 178}, /* -19.5 db 11.2m */
+	[14] = {   1, 128}, /* -21.0 db  7.94m*/
+	[15] = {   0,   1} /* mute; not used */
+};
+
+/*
+ * software volume control
+ */
+static void snd_ps3_do_attenuate_16(int attenuate, signed short int * start,
+				    int samples)
+{
+	int i;
+
+	if (unlikely(attenuate == SND_PS3_MIN_ATT)) {
+		return;
+	} else if (attenuate == SND_PS3_MAX_ATT) {
+		memset(start, 0, sizeof(short int) * samples);
+		return;
+	} else {
+		for (i = 0; i < samples; i++) {
+			start[i] = start[i] *
+				attenuater_divisor_array[attenuate].numerator /
+				attenuater_divisor_array[attenuate].denominator;
+		}
+	}
+}
+
+static void snd_ps3_do_attenuate_24(int attenuate, uint32_t * start,
+				    int samples)
+{
+	int i;
+	int32_t temp, temp2;
+
+	if (unlikely(attenuate == SND_PS3_MIN_ATT)) {
+		return;
+	} else if (attenuate == SND_PS3_MAX_ATT) {
+		memset(start, 0, sizeof(uint32_t) * samples);
+		return;
+	} else {
+		for (i = 0; i < samples; i++) {
+			/* 24bit -> 32bit */
+			temp = (int32_t)(start[i] << 8);
+			/* shift alithmetic */
+			temp2 = temp >> 8;
+			/*
+			 * Since upper 8 bits will be disposed of by the
+			 * hardware, leave it untouched.
+			 */
+			start[i] = temp2 *
+				attenuater_divisor_array[attenuate].numerator /
+				attenuater_divisor_array[attenuate].denominator;
+		}
+	}
+}
+
+static int snd_ps3_soft_attenuate(struct snd_ps3_card_info *card,
+				  void * start_l, void * start_r, int bytes)
+{
+
+	switch(snd_pcm_format_width(card->substream->runtime->format)) {
+	case 16:
+		snd_ps3_do_attenuate_16(card->attenuater[SND_PS3_CH_L],
+					start_l, bytes / 2);
+		snd_ps3_do_attenuate_16(card->attenuater[SND_PS3_CH_R],
+					start_r, bytes / 2);
+		break;
+	case 24:
+		snd_ps3_do_attenuate_24(card->attenuater[SND_PS3_CH_L],
+					start_l, bytes / 4);
+		snd_ps3_do_attenuate_24(card->attenuater[SND_PS3_CH_R],
+					start_r, bytes / 4);
+		break;
+	default:
+		printk(KERN_ERR "%s: invalid width %d\n", __FUNCTION__,
+		       snd_pcm_format_width(card->substream->runtime->format));
+		return -EINVAL;
+	}
+	return 0;
+}
diff -Naur linux-2.6.21.1-org/sound/ppc/snd_ps3.h linux-2.6.21.1-ps3/sound/ppc/snd_ps3.h
--- linux-2.6.21.1-org/sound/ppc/snd_ps3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/sound/ppc/snd_ps3.h	2007-05-21 13:50:30.602262746 +0200
@@ -0,0 +1,232 @@
+/*
+ * Audio support for PS3
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * All rights reserved.
+ * Copyright 2006, 2007 Sony Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2 of the Licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#if !defined(_SND_PS3_H_)
+#define _SND_PS3_H_
+
+#include <linux/irqreturn.h>
+
+
+/*
+ * enable the following for  dummy driver
+ */
+#define _SND_PS3_DUMMY
+
+/*
+ * enable the following for debug traces
+ */
+#undef _SND_PS3_DEBUG
+
+#undef _SND_PS3_TRACE
+#if defined(_SND_PS3_TRACE)
+#define _SF     printk(KERN_ERR "%s: start\n", __FUNCTION__)
+#define _STEPF(x) printk(KERN_ERR "%s: %s\n", __FUNCTION__, x)
+#define _EF     printk(KERN_ERR "%s: end\n", __FUNCTION__)
+#define _EF1(x) printk(KERN_ERR "%s: end %s\n", __FUNCTION__, x)
+#else
+#define _SF do {} while (0)
+#define _EF _SF
+#define _EF1(x) _SF
+#define _STEPF(x) _SF
+#endif
+
+#define SND_PS3_DRIVER_NAME "snd_ps3"
+
+enum snd_ps3_out_channel {
+	SND_PS3_OUT_SPDIF_0,
+	SND_PS3_OUT_SPDIF_1,
+	SND_PS3_OUT_SERIAL_0,
+	SND_PS3_OUT_DEVS
+};
+
+enum snd_ps3_dma_filltype {
+	SND_PS3_DMA_FILLTYPE_FIRSTFILL,
+	SND_PS3_DMA_FILLTYPE_RUNNING,
+	SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL,
+	SND_PS3_DMA_FILLTYPE_SILENT_RUNNING
+};
+
+enum snd_ps3_ch {
+	SND_PS3_CH_L = 0,
+	SND_PS3_CH_R = 1,
+	SND_PS3_CH_MAX = 2
+};
+
+struct snd_ps3_avsetting_info {
+	uint32_t avs_audio_ch;     /* fixed */
+	uint32_t avs_audio_rate;
+	uint32_t avs_audio_width;
+	uint32_t avs_audio_format; /* fixed */
+	uint32_t avs_audio_source; /* fixed */
+};
+/*
+ * PS3 audio 'card' instance
+ * there should be only ONE hardware.
+ */
+struct snd_ps3_card_info {
+	struct platform_device * platform_device;
+	struct snd_card * card;
+
+	struct snd_pcm * pcm;
+	struct snd_pcm_substream * substream;
+
+	/* hvc info */
+	uint64_t audio_lpar_addr;
+	uint64_t audio_lpar_size;
+
+	void *   mapped_vaddr; /* registers */
+
+	uint64_t audio_irq_outlet;
+
+	unsigned int irq_no;
+
+	/* remember avsetting */
+	struct snd_ps3_avsetting_info avs;
+
+	/* remember dmac setting */
+	uint32_t dmac_transfer_count;
+
+	/* dma buffer management */
+	rwlock_t dma_lock;
+	/* dma_lock start */
+		void * dma_start_vaddr[2]; /* 0 for L, 1 for R */
+		size_t dma_buffer_size;
+		void * dma_last_transfer_vaddr[2];
+		void * dma_next_transfer_vaddr[2];
+		int    silent;
+		int running;
+	/* dma_lock end */
+
+	unsigned long null_buffer_start_vaddr;
+
+	rwlock_t start_delay_lock;
+	/* start_delay_lock start */
+		unsigned int start_delay;
+	/* start_delay_lock end */
+
+	struct snd_kcontrol * vol_control;
+	int attenuater[2]; /* store by attenuation, not volume*/
+};
+
+
+/* module  entries */
+static int __init snd_ps3_init(void);
+static void __exit snd_ps3_exit(void);
+
+/* ALSA snd driver ops */
+static int snd_ps3_pcm_open(struct snd_pcm_substream * substream);
+static int snd_ps3_pcm_close(struct snd_pcm_substream * substream);
+static int snd_ps3_pcm_prepare(struct snd_pcm_substream * substream);
+static int snd_ps3_pcm_trigger(struct snd_pcm_substream * substream,
+				 int cmd);
+static snd_pcm_uframes_t snd_ps3_pcm_pointer(struct snd_pcm_substream *
+					     substream);
+static int snd_ps3_pcm_hw_params(struct snd_pcm_substream * substream,
+				 struct snd_pcm_hw_params * hw_params);
+static int snd_ps3_pcm_hw_free(struct snd_pcm_substream * substream);
+
+/* PS3 audio chip */
+static int snd_ps3_init_audio(void);
+
+static void snd_ps3_free_audio(void);
+
+/* platform driver entries */
+static int __init snd_ps3_driver_probe(struct platform_device * device);
+static void snd_ps3_driver_shutdown(struct platform_device * device);
+static int snd_ps3_driver_remove(struct platform_device * device);
+
+/* address setup */
+static int snd_ps3_create_iopt(void);
+static void snd_ps3_destruct_iopt_helper(void);
+static void snd_ps3_destruct_iopt(void);
+static void snd_ps3_audio_set_base_addr(uint64_t ioaddr_start);
+
+/* interrupt handler */
+static irqreturn_t snd_ps3_interrupt(int irq, void * dev_id);
+
+
+/* set sampling rate/format */
+static int snd_ps3_set_avsetting(struct snd_pcm_substream * substream);
+/* take effect parameter change */
+static int snd_ps3_change_avsetting(struct snd_ps3_card_info * card);
+/* initialize avsetting and take it effect */
+static int snd_ps3_init_avsetting(struct snd_ps3_card_info * card);
+/* setup dma */
+static int snd_ps3_program_dma(struct snd_ps3_card_info * card,
+			       enum snd_ps3_dma_filltype filltype);
+static int snd_ps3_kick_dma(struct snd_ps3_card_info * card);
+static void snd_ps3_wait_for_dma_stop(struct snd_ps3_card_info * card);
+
+static uint64_t p_to_dma(uint64_t paddr);
+/* mute control */
+static int snd_ps3_mute(struct snd_pcm_substream * substream, int mute_on);
+
+static ssize_t snd_ps3_get_start_delay(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf);
+static ssize_t snd_ps3_set_start_delay(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count);
+
+
+static int snd_ps3_info_vol_control(struct snd_kcontrol * kcontrol,
+				    struct snd_ctl_elem_info * uinfo);
+static int snd_ps3_get_vol_control(struct snd_kcontrol * kcontrol,
+				   struct snd_ctl_elem_value * ucontrol);
+static int snd_ps3_put_vol_control(struct snd_kcontrol * kcontrol,
+				   struct snd_ctl_elem_value * ucontrol);
+
+static int snd_ps3_soft_attenuate(struct snd_ps3_card_info * card,
+				  void * start_l, void * star_r, int bytes);
+/*
+ * iopte management
+ */
+struct ioif_map_info {
+	uint64_t ioif_addr;
+	uint64_t start_paddr;
+	uint64_t start_lpar_addr;
+	uint64_t area_size;
+};
+
+/* PS3 audio DMAC block size in bytes */
+#define PS3_AUDIO_DMAC_BLOCK_SIZE (128)
+/* one stage (stereo)  of audio FIFO in bytes */
+#define PS3_AUDIO_FIFO_STAGE_SIZE (256)
+/* how many stages the fifo have */
+#define PS3_AUDIO_FIFO_STAGE_COUNT (8)
+/* fifo size 128 bytes * 8 stages * stereo (2ch) */
+#define PS3_AUDIO_FIFO_SIZE \
+	(PS3_AUDIO_FIFO_STAGE_SIZE * PS3_AUDIO_FIFO_STAGE_COUNT)
+
+/* PS3 audio DMAC max block count in one dma shot = 128 (0x80) blocks*/
+#define PS3_AUDIO_DMAC_MAX_BLOCKS  (PS3_AUDIO_DMASIZE_BLOCKS_MASK + 1)
+
+#define PS3_AUDIO_NORMAL_DMA_START_CH (0)
+#define PS3_AUDIO_NORMAL_DMA_COUNT    (8)
+#define PS3_AUDIO_NULL_DMA_START_CH \
+	(PS3_AUDIO_NORMAL_DMA_START_CH + PS3_AUDIO_NORMAL_DMA_COUNT)
+#define PS3_AUDIO_NULL_DMA_COUNT      (2)
+
+#define SND_PS3_MAX_VOL (0x0F)
+#define SND_PS3_MIN_VOL (0x00)
+#define SND_PS3_MIN_ATT SND_PS3_MIN_VOL
+#define SND_PS3_MAX_ATT SND_PS3_MAX_VOL
+
+#endif /* _SND_PS3_H_ */
diff -Naur linux-2.6.21.1-org/sound/ppc/snd_ps3_reg.h linux-2.6.21.1-ps3/sound/ppc/snd_ps3_reg.h
--- linux-2.6.21.1-org/sound/ppc/snd_ps3_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21.1-ps3/sound/ppc/snd_ps3_reg.h	2007-05-21 13:50:30.620261788 +0200
@@ -0,0 +1,856 @@
+/*
+ * Audio support for PS3
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * Copyright 2006, 2007 Sony Corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/*
+ * interrupt / configure registers
+ */
+
+#define PS3_AUDIO_INTR_0                 (0x00000100)
+#define PS3_AUDIO_INTR_EN_0              (0x00000140)
+#define PS3_AUDIO_CONFIG                 (0x00000200)
+
+/*
+ * DMAC registers
+ * n:0..9
+ */
+#define PS3_AUDIO_DMAC_REGBASE(x)         (0x0000210 + 0x20 * (x))
+
+#define PS3_AUDIO_KICK(n)                 (PS3_AUDIO_DMAC_REGBASE(n) + 0x00)
+#define PS3_AUDIO_SOURCE(n)               (PS3_AUDIO_DMAC_REGBASE(n) + 0x04)
+#define PS3_AUDIO_DEST(n)                 (PS3_AUDIO_DMAC_REGBASE(n) + 0x08)
+#define PS3_AUDIO_DMASIZE(n)              (PS3_AUDIO_DMAC_REGBASE(n) + 0x0C)
+
+/*
+ * mute control
+ */
+#define PS3_AUDIO_AX_MCTRL                (0x00004000)
+#define PS3_AUDIO_AX_ISBP                 (0x00004004)
+#define PS3_AUDIO_AX_AOBP                 (0x00004008)
+#define PS3_AUDIO_AX_IC                   (0x00004010)
+#define PS3_AUDIO_AX_IE                   (0x00004014)
+#define PS3_AUDIO_AX_IS                   (0x00004018)
+
+/*
+ * three wire serial
+ * n:0..3
+ */
+#define PS3_AUDIO_AO_MCTRL                (0x00006000)
+#define PS3_AUDIO_AO_3WMCTRL              (0x00006004)
+
+#define PS3_AUDIO_AO_3WCTRL(n)            (0x00006200 + 0x200 * (n))
+
+/*
+ * S/PDIF
+ * n:0..1
+ * x:0..11
+ * y:0..5
+ */
+#define PS3_AUDIO_AO_SPD_REGBASE(n)       (0x00007200 + 0x200 * (n))
+
+#define PS3_AUDIO_AO_SPDCTRL(n)           (PS3_AUDIO_AO_SPD_REGBASE(n) + 0x00)
+#define PS3_AUDIO_AO_SPDUB(n,x)           (PS3_AUDIO_AO_SPD_REGBASE(n) + 0x04 + 0x04 * (x))
+#define PS3_AUDIO_AO_SPDCS(n,y)           (PS3_AUDIO_AO_SPD_REGBASE(n) + 0x34 + 0x04 * (y))
+
+
+/*
+  PS3_AUDIO_INTR_0 register tells an interrupt handler which audio
+  DMA channel triggered the interrupt.  The interrupt status for a channel
+  can be cleared by writing a '1' to the corresponding bit.  A new interrupt
+  cannot be generated until the previous interrupt has been cleared.
+
+  Note that the status reported by PS3_AUDIO_INTR_0 is independent of the
+  value of PS3_AUDIO_INTR_EN_0.
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0 0 0 0 0 0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C| INTR_0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+#define PS3_AUDIO_INTR_0_CHAN(n)                    (1 << ((n) * 2))
+#define PS3_AUDIO_INTR_0_CHAN9                      PS3_AUDIO_INTR_0_CHAN(9)
+#define PS3_AUDIO_INTR_0_CHAN8                      PS3_AUDIO_INTR_0_CHAN(8)
+#define PS3_AUDIO_INTR_0_CHAN7                      PS3_AUDIO_INTR_0_CHAN(7)
+#define PS3_AUDIO_INTR_0_CHAN6                      PS3_AUDIO_INTR_0_CHAN(6)
+#define PS3_AUDIO_INTR_0_CHAN5                      PS3_AUDIO_INTR_0_CHAN(5)
+#define PS3_AUDIO_INTR_0_CHAN4                      PS3_AUDIO_INTR_0_CHAN(4)
+#define PS3_AUDIO_INTR_0_CHAN3                      PS3_AUDIO_INTR_0_CHAN(3)
+#define PS3_AUDIO_INTR_0_CHAN2                      PS3_AUDIO_INTR_0_CHAN(2)
+#define PS3_AUDIO_INTR_0_CHAN1                      PS3_AUDIO_INTR_0_CHAN(1)
+#define PS3_AUDIO_INTR_0_CHAN0                      PS3_AUDIO_INTR_0_CHAN(0)
+
+/*
+  The PS3_AUDIO_INTR_EN_0 register specifies which DMA channels can generate
+  an interrupt to the PU.  Each bit of PS3_AUDIO_INTR_EN_0 is ANDed with the
+  corresponding bit in PS3_AUDIO_INTR_0.  The resulting bits are OR'd together
+  to generate the Audio interrupt.
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0 0 0 0 0 0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C| INTR_EN_0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+  Bit assignments are same as PS3_AUDIO_INTR_0
+*/
+
+/*
+  PS3_AUDIO_CONFIG
+  31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 C|0 0 0 0 0 0 0 0| CONFIG
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+*/
+
+/* The CLEAR field cancels all pending transfers, and stops any running DMA
+   transfers.  Any interrupts associated with the canceled transfers
+   will occur as if the transfer had finished.
+   Since this bit is designed to recover from DMA related issues
+   which are caused by unpredictable situations, it is prefered to wait
+   for normal DMA transfer end without using this bit.
+*/
+#define PS3_AUDIO_CONFIG_CLEAR                           (1 << 8)  /* RWIVF */
+
+/*
+  PS3_AUDIO_AX_MCTRL: Audio Port Mute Control Register
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|A|A|A|0 0 0 0 0 0 0|S|S|A|A|A|A| AX_MCTRL
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+/* 3 Wire Audio Serial Output Channel Mutes (0..3)  */
+#define PS3_AUDIO_AX_MCTRL_ASOMT(n)                      (1 << (3 - (n)))  /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_ASO3MT                        (1 << 0)          /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_ASO2MT                        (1 << 1)          /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_ASO1MT                        (1 << 2)          /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_ASO0MT                        (1 << 3)          /* RWIVF */
+
+/* S/PDIF mutes (0,1)*/
+#define PS3_AUDIO_AX_MCTRL_SPOMT(n)                      (1 << (5 - (n)))  /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_SPO1MT                        (1 << 4)          /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_SPO0MT                        (1 << 5)          /* RWIVF */
+
+/* All 3 Wire Serial Outputs Mute */
+#define PS3_AUDIO_AX_MCTRL_AASOMT                        (1 << 13)         /* RWIVF */
+
+/* All S/PDIF Mute */
+#define PS3_AUDIO_AX_MCTRL_ASPOMT                        (1 << 14)         /* RWIVF */
+
+/* All Audio Outputs Mute */
+#define PS3_AUDIO_AX_MCTRL_AAOMT                         (1 << 15)         /* RWIVF */
+
+/*
+  S/PDIF Outputs Buffer Read/Write Pointer Register
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0|0|SPO0B|0|SPO1B|0 0 0 0 0 0 0 0|0|SPO0B|0|SPO1B| AX_ISBP
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+*/
+/*
+ S/PDIF Output Channel Read Buffer Numbers
+ Buffer number is  value of field.
+ Indicates current read access buffer ID from Audio Data
+ Transfer controller of S/PDIF Output
+*/
+
+#define PS3_AUDIO_AX_ISBP_SPOBRN_MASK(n)                 (0x7 << 4 * (1 - (n))) /* R-IUF */
+#define PS3_AUDIO_AX_ISBP_SPO1BRN_MASK                   (0x7 << 0) /* R-IUF */
+#define PS3_AUDIO_AX_ISBP_SPO0BRN_MASK                   (0x7 << 4) /* R-IUF */
+
+/*
+S/PDIF Output Channel Buffer Write Numbers
+Indicates current write access buffer ID from bus master.
+*/
+#define PS3_AUDIO_AX_ISBP_SPOBWN_MASK(n)                 (0x7 <<  4 * (5 - (n))) /* R-IUF */
+#define PS3_AUDIO_AX_ISBP_SPO1BWN_MASK                   (0x7 << 16) /* R-IUF */
+#define PS3_AUDIO_AX_ISBP_SPO0BWN_MASK                   (0x7 << 20) /* R-IUF */
+
+/*
+  3 Wire Audio Serial Outputs Buffer Read/Write
+  Pointer Register
+  Buffer number is  value of field
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0|ASO0B|0|ASO1B|0|ASO2B|0|ASO3B|0|ASO0B|0|ASO1B|0|ASO2B|0|ASO3B| AX_AOBP
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+/*
+3 Wire Audio Serial Output Channel Buffer Read Numbers
+Indicates current read access buffer Id from Audio Data Transfer
+Controller of 3 Wire Audio Serial Output Channels
+*/
+#define PS3_AUDIO_AX_AOBP_ASOBRN_MASK(n)                 (0x7 << 4 * (3 - (n))) /* R-IUF */
+
+#define PS3_AUDIO_AX_AOBP_ASO3BRN_MASK                   (0x7 << 0) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO2BRN_MASK                   (0x7 << 4) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO1BRN_MASK                   (0x7 << 8) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO0BRN_MASK                   (0x7 << 12) /* R-IUF */
+
+/*
+3 Wire Audio Serial Output Channel Buffer Write Numbers
+Indicates current write access buffer ID from bus master.
+*/
+#define PS3_AUDIO_AX_AOBP_ASOBWN_MASK(n)                 (0x7 << 4 * (7 - (n))) /* R-IUF */
+
+#define PS3_AUDIO_AX_AOBP_ASO3BWN_MASK                   (0x7 << 16) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO2BWN_MASK                   (0x7 << 20) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO1BWN_MASK                   (0x7 << 24) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO0BWN_MASK                   (0x7 << 28) /* R-IUF */
+
+
+
+/*
+Audio Port Interrupt Condition Register
+For the fields in this register, the following values apply:
+0 = Interrupt is generated every interrupt event.
+1 = Interrupt is generated every 2 interrupt events.
+2 = Interrupt is generated every 4 interrupt events.
+3 = Reserved
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0|0 0|SPO|0 0|SPO|0 0|AAS|0 0 0 0 0 0 0 0 0 0 0 0| AX_IC
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+/*
+All 3-Wire Audio Serial Outputs Interrupt Mode
+Configures the Interrupt and Signal Notification
+condition of all 3-wire Audio Serial Outputs.
+*/
+#define PS3_AUDIO_AX_IC_AASOIMD_MASK                     (0x3 << 12) /* RWIVF */
+#define PS3_AUDIO_AX_IC_AASOIMD_EVERY1                   (0x0 << 12) /* RWI-V */
+#define PS3_AUDIO_AX_IC_AASOIMD_EVERY2                   (0x1 << 12) /* RW--V */
+#define PS3_AUDIO_AX_IC_AASOIMD_EVERY4                   (0x2 << 12) /* RW--V */
+
+/*
+S/PDIF Output Channel Interrupt Modes
+Configures the Interrupt and signal Notification
+conditions of S/PDIF output channels.
+*/
+#define PS3_AUDIO_AX_IC_SPO1IMD_MASK                     (0x3 << 16) /* RWIVF */
+#define PS3_AUDIO_AX_IC_SPO1IMD_EVERY1                   (0x0 << 16) /* RWI-V */
+#define PS3_AUDIO_AX_IC_SPO1IMD_EVERY2                   (0x1 << 16) /* RW--V */
+#define PS3_AUDIO_AX_IC_SPO1IMD_EVERY4                   (0x2 << 16) /* RW--V */
+
+#define PS3_AUDIO_AX_IC_SPO0IMD_MASK                     (0x3 << 20) /* RWIVF */
+#define PS3_AUDIO_AX_IC_SPO0IMD_EVERY1                   (0x0 << 20) /* RWI-V */
+#define PS3_AUDIO_AX_IC_SPO0IMD_EVERY2                   (0x1 << 20) /* RW--V */
+#define PS3_AUDIO_AX_IC_SPO0IMD_EVERY4                   (0x2 << 20) /* RW--V */
+
+/*
+Audio Port interrupt Enable Register
+Configures whether to enable or disable each Interrupt Generation.
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0|S|S|0 0|A|A|A|A|0 0 0 0|S|S|0 0|S|S|0 0|A|A|A|A| AX_IE
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+*/
+
+/*
+3 Wire Audio Serial Output Channel Buffer Underflow
+Interrupt Enables
+Select enable/disable of Buffer Underflow Interrupts for
+3-Wire Audio Serial Output Channels
+DISABLED=Interrupt generation disabled.
+*/
+#define PS3_AUDIO_AX_IE_ASOBUIE(n)                       (1 << (3 - (n))) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO3BUIE                         (1 << 0) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO2BUIE                         (1 << 1) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO1BUIE                         (1 << 2) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO0BUIE                         (1 << 3) /* RWIVF */
+
+/* S/PDIF Output Channel Buffer Underflow Interrupt Enables */
+
+#define PS3_AUDIO_AX_IE_SPOBUIE(n)                       (1 << (7 - (n))) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO1BUIE                         (1 << 6) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO0BUIE                         (1 << 7) /* RWIVF */
+
+/* S/PDIF Output Channel One Block Transfer Completion Interrupt Enables */
+
+#define PS3_AUDIO_AX_IE_SPOBTCIE(n)                      (1 << (11 - (n))) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO1BTCIE                        (1 << 10) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO0BTCIE                        (1 << 11) /* RWIVF */
+
+/* 3-Wire Audio Serial Output Channel Buffer Empty Interrupt Enables */
+
+#define PS3_AUDIO_AX_IE_ASOBEIE(n)                       (1 << (19 - (n))) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO3BEIE                         (1 << 16) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO2BEIE                         (1 << 17) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO1BEIE                         (1 << 18) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO0BEIE                         (1 << 19) /* RWIVF */
+
+/* S/PDIF Output Channel Buffer Empty Interrupt Enables */
+
+#define PS3_AUDIO_AX_IE_SPOBEIE(n)                       (1 << (23 - (n))) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO1BEIE                         (1 << 22) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO0BEIE                         (1 << 23) /* RWIVF */
+
+/*
+Audio Port Interrupt Status Register
+Indicates Interrupt status, which interrupt has occured, and can clear
+each interrupt in this register.
+Writing 1b to a field containing 1b clears field and de-asserts interrupt.
+Writing 0b to a field has no effect.
+Field vaules are the following:
+0 - Interrupt hasn't occured.
+1 - Interrupt has occured.
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0|S|S|0 0|A|A|A|A|0 0 0 0|S|S|0 0|S|S|0 0|A|A|A|A| AX_IS
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+ Bit assignment are same as AX_IE
+*/
+
+/*
+Audio Output Master Control Register
+Configures Master Clock and other master Audio Output Settings
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0|SCKSE|0|SCKSE|  MR0  |  MR1  |MCL|MCL|0 0 0 0|0 0 0 0 0 0 0 0| AO_MCTRL
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+/*
+MCLK Output Control
+Controls mclko[1] output.
+0 - Disable output (fixed at High)
+1 - Output clock produced by clock selected
+with scksel1 by mr1
+2 - Reserved
+3 - Reserved
+*/
+
+#define PS3_AUDIO_AO_MCTRL_MCLKC1_MASK                   (0x3 << 12) /* RWIVF */
+#define PS3_AUDIO_AO_MCTRL_MCLKC1_DISABLED               (0x0 << 12) /* RWI-V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC1_ENABLED                (0x1 << 12) /* RW--V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC1_RESVD2                 (0x2 << 12) /* RW--V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC1_RESVD3                 (0x3 << 12) /* RW--V */
+
+/*
+MCLK Output Control
+Controls mclko[0] output.
+0 - Disable output (fixed at High)
+1 - Output clock produced by clock selected
+with SCKSEL0 by MR0
+2 - Reserved
+3 - Reserved
+*/
+#define PS3_AUDIO_AO_MCTRL_MCLKC0_MASK                   (0x3 << 14) /* RWIVF */
+#define PS3_AUDIO_AO_MCTRL_MCLKC0_DISABLED               (0x0 << 14) /* RWI-V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC0_ENABLED                (0x1 << 14) /* RW--V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC0_RESVD2                 (0x2 << 14) /* RW--V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC0_RESVD3                 (0x3 << 14) /* RW--V */
+/*
+Master Clock Rate 1
+Sets the divide ration of Master Clock1 (clock output from
+mclko[1] for the input clock selected by scksel1.
+*/
+#define PS3_AUDIO_AO_MCTRL_MR1_MASK                      (0xf << 16)
+#define PS3_AUDIO_AO_MCTRL_MR1_DEFAULT                   (0x0 << 16) /* RWI-V */
+/*
+Master Clock Rate 0
+Sets the divide ratio of Master Clock0 (clock output from
+mclko[0] for the input clock selected by scksel0).
+*/
+#define PS3_AUDIO_AO_MCTRL_MR0_MASK                      (0xf << 20) /* RWIVF */
+#define PS3_AUDIO_AO_MCTRL_MR0_DEFAULT                   (0x0 << 20) /* RWI-V */
+/*
+System Clock Select 0/1
+Selects the system clock to be used as Master Clock 0/1
+Input the system clock that is appropriate for the sampling
+rate.
+*/
+#define PS3_AUDIO_AO_MCTRL_SCKSEL1_MASK                  (0x7 << 24) /* RWIVF */
+#define PS3_AUDIO_AO_MCTRL_SCKSEL1_DEFAULT               (0x2 << 24) /* RWI-V */
+
+#define PS3_AUDIO_AO_MCTRL_SCKSEL0_MASK                  (0x7 << 28) /* RWIVF */
+#define PS3_AUDIO_AO_MCTRL_SCKSEL0_DEFAULT               (0x2 << 28) /* RWI-V */
+
+
+/*
+3-Wire Audio Output Master Control Register
+Configures clock, 3-Wire Audio Serial Output Enable, and
+other 3-Wire Audio Serial Output Master Settings
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |A|A|A|A|0 0 0|A| ASOSR |0 0 0 0|A|A|A|A|A|A|0|1|0 0 0 0 0 0 0 0| AO_3WMCTRL
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+
+/*
+LRCKO Polarity
+0 - Reserved
+1 - default
+*/
+#define PS3_AUDIO_AO_3WMCTRL_ASOPLRCK                    (1 << 8) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOPLRCK_DEFAULT            (1 << 8) /* RW--V */
+
+/* LRCK Output Disable */
+
+#define PS3_AUDIO_AO_3WMCTRL_ASOLRCKD                    (1 << 10) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOLRCKD_ENABLED            (0 << 10) /* RW--V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOLRCKD_DISABLED           (1 << 10) /* RWI-V */
+
+/* Bit Clock Output Disable */
+
+#define PS3_AUDIO_AO_3WMCTRL_ASOBCLKD                    (1 << 11) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOBCLKD_ENABLED            (0 << 11) /* RW--V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOBCLKD_DISABLED           (1 << 11) /* RWI-V */
+
+/*
+3-Wire Audio Serial Output Channel 0-3 Operational
+Status.  Each bit becomes 1 after each 3-Wire Audio
+Serial Output Channel N is in action by setting 1 to
+asoen.
+Each bit becomes 0 after each 3-Wire Audio Serial Output
+Channel N is out of action by setting 0 to asoen.
+*/
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN(n)                   (1 << (15 - (n))) /* R-IVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN_STOPPED(n)           (0 << (15 - (n))) /* R-I-V */
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN_RUNNING(n)           (1 << (15 - (n))) /* R---V */
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN0                     PS3_AUDIO_AO_3WMCTRL_ASORUN(0)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN0_STOPPED             PS3_AUDIO_AO_3WMCTRL_ASORUN_STOPPED(0)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN0_RUNNING             PS3_AUDIO_AO_3WMCTRL_ASORUN_RUNNING(0)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN1                     PS3_AUDIO_AO_3WMCTRL_ASORUN(1)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN1_STOPPED             PS3_AUDIO_AO_3WMCTRL_ASORUN_STOPPED(1)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN1_RUNNING             PS3_AUDIO_AO_3WMCTRL_ASORUN_RUNNING(1)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN2                     PS3_AUDIO_AO_3WMCTRL_ASORUN(2)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN2_STOPPED             PS3_AUDIO_AO_3WMCTRL_ASORUN_STOPPED(2)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN2_RUNNING             PS3_AUDIO_AO_3WMCTRL_ASORUN_RUNNING(2)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN3                     PS3_AUDIO_AO_3WMCTRL_ASORUN(3)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN3_STOPPED             PS3_AUDIO_AO_3WMCTRL_ASORUN_STOPPED(3)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN3_RUNNING             PS3_AUDIO_AO_3WMCTRL_ASORUN_RUNNING(3)
+
+/*
+Sampling Rate
+Specifies the divide ratio of the bit clock (clock output
+from bclko) used by the 3-wire Audio Output Clock, whcih
+is applied to the master clock selected by mcksel.
+Data output is synchronized with this clock.
+*/
+#define PS3_AUDIO_AO_3WMCTRL_ASOSR_MASK                  (0xf << 20) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOSR_DIV2                  (0x1 << 20) /* RWI-V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOSR_DIV4                  (0x2 << 20) /* RW--V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOSR_DIV8                  (0x4 << 20) /* RW--V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOSR_DIV12                 (0x6 << 20) /* RW--V */
+
+/*
+Master Clock Select
+0 - Master Clock 0
+1 - Master Clock 1
+*/
+#define PS3_AUDIO_AO_3WMCTRL_ASOMCKSEL                   (1 << 24) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOMCKSEL_CLK0              (0 << 24) /* RWI-V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOMCKSEL_CLK1              (1 << 24) /* RW--V */
+
+/*
+Enables and disables 4ch 3-Wire Audio Serial Output
+operation.  Each Bit from 0 to 3 corresponds to an
+output channel, which means that each output channel
+can be enabled or disabled individually.  When
+multiple channels are enabled at the same time, output
+operations are performed in synchronization.
+Bit 0 - Output Channel 0 (SDOUT[0])
+Bit 1 - Output Channel 1 (SDOUT[1])
+Bit 2 - Output Channel 2 (SDOUT[2])
+Bit 3 - Output Channel 3 (SDOUT[3])
+*/
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN(n)                    (1 << (31 - (n))) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN_DISABLED(n)           (0 << (31 - (n))) /* RWI-V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN_ENABLED(n)            (1 << (31 - (n))) /* RW--V */
+
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN0                      PS3_AUDIO_AO_3WMCTRL_ASOEN(0) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN0_DISABLED             PS3_AUDIO_AO_3WMCTRL_ASOEN_DISABLED(0) /* RWI-V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN0_ENABLED              PS3_AUDIO_AO_3WMCTRL_ASOEN_ENABLED(0) /* RW--V */
+#define PS3_AUDIO_A1_3WMCTRL_ASOEN0                      PS3_AUDIO_AO_3WMCTRL_ASOEN(1) /* RWIVF */
+#define PS3_AUDIO_A1_3WMCTRL_ASOEN0_DISABLED             PS3_AUDIO_AO_3WMCTRL_ASOEN_DISABLED(1) /* RWI-V */
+#define PS3_AUDIO_A1_3WMCTRL_ASOEN0_ENABLED              PS3_AUDIO_AO_3WMCTRL_ASOEN_ENABLED(1) /* RW--V */
+#define PS3_AUDIO_A2_3WMCTRL_ASOEN0                      PS3_AUDIO_AO_3WMCTRL_ASOEN(2) /* RWIVF */
+#define PS3_AUDIO_A2_3WMCTRL_ASOEN0_DISABLED             PS3_AUDIO_AO_3WMCTRL_ASOEN_DISABLED(2) /* RWI-V */
+#define PS3_AUDIO_A2_3WMCTRL_ASOEN0_ENABLED              PS3_AUDIO_AO_3WMCTRL_ASOEN_ENABLED(2) /* RW--V */
+#define PS3_AUDIO_A3_3WMCTRL_ASOEN0                      PS3_AUDIO_AO_3WMCTRL_ASOEN(3) /* RWIVF */
+#define PS3_AUDIO_A3_3WMCTRL_ASOEN0_DISABLED             PS3_AUDIO_AO_3WMCTRL_ASOEN_DISABLED(3) /* RWI-V */
+#define PS3_AUDIO_A3_3WMCTRL_ASOEN0_ENABLED              PS3_AUDIO_AO_3WMCTRL_ASOEN_ENABLED(3) /* RW--V */
+
+/*
+3-Wire Audio Serial output Channel 0-3 Control Register
+Configures settings for 3-Wire Serial Audio Output Channel 0-3
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|A|0 0 0 0|A|0|ASO|0 0 0|0|0|0|0|0| AO_3WCTRL
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+*/
+/*
+Data Bit Mode
+Specifies the number of data bits
+0 - 16 bits
+1 - reserved
+2 - 20 bits
+3 - 24 bits
+*/
+#define PS3_AUDIO_AO_3WCTRL_ASODB_MASK                   (0x3 << 8) /* RWIVF */
+#define PS3_AUDIO_AO_3WCTRL_ASODB_16BIT                  (0x0 << 8) /* RWI-V */
+#define PS3_AUDIO_AO_3WCTRL_ASODB_RESVD                  (0x1 << 8) /* RWI-V */
+#define PS3_AUDIO_AO_3WCTRL_ASODB_20BIT                  (0x2 << 8) /* RW--V */
+#define PS3_AUDIO_AO_3WCTRL_ASODB_24BIT                  (0x3 << 8) /* RW--V */
+/*
+Data Format Mode
+Specifies the data format where (LSB side or MSB) the data(in 20 bit
+or 24 bit resolution mode) is put in a 32 bit field.
+0 - Data put on LSB side
+1 - Data put on MSB side
+*/
+#define PS3_AUDIO_AO_3WCTRL_ASODF                        (1 << 11) /* RWIVF */
+#define PS3_AUDIO_AO_3WCTRL_ASODF_LSB                    (0 << 11) /* RWI-V */
+#define PS3_AUDIO_AO_3WCTRL_ASODF_MSB                    (1 << 11) /* RW--V */
+/*
+Buffer Reset
+Performs buffer reset.  Writing 1 to this bit initializes the
+corresponding 3-Wire Audio Output buffers(both L and R).
+*/
+#define PS3_AUDIO_AO_3WCTRL_ASOBRST                      (1 << 16) /* CWIVF */
+#define PS3_AUDIO_AO_3WCTRL_ASOBRST_IDLE                 (0 << 16) /* -WI-V */
+#define PS3_AUDIO_AO_3WCTRL_ASOBRST_RESET                (1 << 16) /* -W--T */
+
+/*
+S/PDIF Audio Output Channel 0/1 Control Register
+Configures settings for S/PDIF Audio Output Channel 0/1.
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |S|0 0 0|S|0 0|S| SPOSR |0 0|SPO|0 0 0 0|S|0|SPO|0 0 0 0 0 0 0|S| AO_SPDCTRL
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+/*
+Buffer reset.  Writing 1 to this bit initializes the
+corresponding S/PDIF output buffer pointer.
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPOBRST                     (1 << 0) /* CWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPOBRST_IDLE                (0 << 0) /* -WI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOBRST_RESET               (1 << 0) /* -W--T */
+
+/*
+Data Bit Mode
+Specifies number of data bits
+0 - 16 bits
+1 - Reserved
+2 - 20 bits
+3 - 24 bits
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPODB_MASK                  (0x3 << 8) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPODB_16BIT                 (0x0 << 8) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPODB_RESVD                 (0x1 << 8) /* RW--V */
+#define PS3_AUDIO_AO_SPDCTRL_SPODB_20BIT                 (0x2 << 8) /* RW--V */
+#define PS3_AUDIO_AO_SPDCTRL_SPODB_24BIT                 (0x3 << 8) /* RW--V */
+/*
+Data format Mode
+Specifies the data format, where (LSB side or MSB)
+the data(in 20 or 24 bit resolution) is put in the
+32 bit field.
+0 - LSB Side
+1 - MSB Side
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPODF                       (1 << 11) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPODF_LSB                   (0 << 11) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPODF_MSB                   (1 << 11) /* RW--V */
+/*
+Source Select
+Specifies the source of the S/PDIF output.  When 0, output
+operation is controlled by 3wen[0] of AO_3WMCTRL register.
+The SR must have the same setting as the a0_3wmctrl reg.
+0 - 3-Wire Audio OUT Ch0 Buffer
+1 - S/PDIF buffer
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPOSS_MASK                  (0x3 << 16) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSS_3WEN                  (0x0 << 16) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSS_SPDIF                 (0x1 << 16) /* RW--V */
+/*
+Sampling Rate
+Specifies the divide ratio of the bit clock (clock output
+from bclko) used by the S/PDIF Output Clock, which
+is applied to the master clock selected by mcksel.
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPOSR                       (0xf << 20) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSR_DIV2                  (0x1 << 20) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSR_DIV4                  (0x2 << 20) /* RW--V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSR_DIV8                  (0x4 << 20) /* RW--V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSR_DIV12                 (0x6 << 20) /* RW--V */
+/*
+Master Clock Select
+0 - Master Clock 0
+1 - Master Clock 1
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPOMCKSEL                   (1 << 24) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPOMCKSEL_CLK0              (0 << 24) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOMCKSEL_CLK1              (1 << 24) /* RW--V */
+
+/*
+S/PDIF Output Channel Operational Status
+This bit becomes 1 after S/PDIF Output Channel is in
+action by setting 1 to spoen.  This bit becomes 0
+after S/PDIF Output Channel is out of action by setting
+0 to spoen.
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPORUN                      (1 << 27) /* R-IVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPORUN_STOPPED              (0 << 27) /* R-I-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPORUN_RUNNING              (1 << 27) /* R---V */
+
+/*
+S/PDIF Audio Output Channel Output Enable
+Enables and disables output operation.  This bit is used
+only when sposs = 1
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPOEN                       (1 << 31) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPOEN_DISABLED              (0 << 31) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOEN_ENABLED               (1 << 31) /* RW--V */
+
+/*
+S/PDIF Audio Output Channel Channel Status
+Setting Registers.
+Configures channel status bit settings for each block
+(192 bits).
+Output is performed from the MSB(AO_SPDCS0 register bit 31).
+The same value is added for subframes within the same frame.
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |                             SPOCS                             | AO_SPDCS
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+S/PDIF Audio Output Channel User Bit Setting
+Configures user bit settings for each block (384 bits).
+Output is performed from the MSB(ao_spdub0 register bit 31).
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |                             SPOUB                             | AO_SPDUB
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+/*******************************************************************************
+ *
+ * DMAC register
+ *
+ *******************************************************************************/
+/*
+The PS3_AUDIO_KICK register is used to initiate a DMA transfer and monitor its status
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0|STATU|0 0 0|  EVENT  |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|R| KICK
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+/*
+The REQUEST field is written to ACTIVE to initiate a DMA request when EVENT occurs.
+It will return to the DONE state when the request is completed.
+The registers for a DMA channel should only be written if REQUEST is IDLE.
+*/
+
+#define PS3_AUDIO_KICK_REQUEST                           (1 << 0) /* RWIVF */
+#define PS3_AUDIO_KICK_REQUEST_IDLE                      (0 << 0) /* RWI-V */
+#define PS3_AUDIO_KICK_REQUEST_ACTIVE                    (1 << 0) /* -W--T */
+
+/* The EVENT field is used to set the event in which the DMA request becomes active. */
+#define PS3_AUDIO_KICK_EVENT_MASK                        (0x1f << 16) /* RWIVF */
+#define PS3_AUDIO_KICK_EVENT_ALWAYS                      (0x00 << 16) /* RWI-V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT0_EMPTY            (0x01 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT0_UNDERFLOW        (0x02 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT1_EMPTY            (0x03 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT1_UNDERFLOW        (0x04 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT2_EMPTY            (0x05 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT2_UNDERFLOW        (0x06 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT3_EMPTY            (0x07 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT3_UNDERFLOW        (0x08 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF0_BLOCKTRANSFERCOMPLETE (0x09 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF0_UNDERFLOW            (0x0A << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF0_EMPTY                (0x0B << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF1_BLOCKTRANSFERCOMPLETE (0x0C << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF1_UNDERFLOW            (0x0D << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF1_EMPTY                (0x0E << 16) /* RW--V */
+
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA(n)                ((0x13 + (n)) << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA0                  (0x13 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA1                  (0x14 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA2                  (0x15 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA3                  (0x16 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA4                  (0x17 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA5                  (0x18 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA6                  (0x19 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA7                  (0x1A << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA8                  (0x1B << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA9                  (0x1C << 16) /* RW--V */
+
+/*
+The STATUS field can be used to monitor the progress of a DMA request.
+DONE indicates the previous request has completed.
+EVENT indicates that the DMA engine is waiting for the EVENT to occur.
+PENDING indicates that the DMA engine has not started processing this
+request, but the EVENT has occured.
+DMA indicates that the data transfer is in progress.
+NOTIFY indicates that the notifier signalling end of transfer is being written.
+CLEAR indicated that the previous transfer was cleared.
+ERROR indicates the previous transfer requested an unsupported source/destination combination.
+*/
+
+#define PS3_AUDIO_KICK_STATUS_MASK                       (0x7 << 24) /* R-IVF */
+#define PS3_AUDIO_KICK_STATUS_DONE                       (0x0 << 24) /* R-I-V */
+#define PS3_AUDIO_KICK_STATUS_EVENT                      (0x1 << 24) /* R---V */
+#define PS3_AUDIO_KICK_STATUS_PENDING                    (0x2 << 24) /* R---V */
+#define PS3_AUDIO_KICK_STATUS_DMA                        (0x3 << 24) /* R---V */
+#define PS3_AUDIO_KICK_STATUS_NOTIFY                     (0x4 << 24) /* R---V */
+#define PS3_AUDIO_KICK_STATUS_CLEAR                      (0x5 << 24) /* R---V */
+#define PS3_AUDIO_KICK_STATUS_ERROR                      (0x6 << 24) /* R---V */
+
+/*
+The PS3_AUDIO_SOURCE register specifies the source address for transfers.
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |                      START                      |0 0 0 0 0|TAR| SOURCE
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+/*
+The Audio DMA engine uses 128-byte transfers, thus the address must be aligned
+to a 128 byte boundary.  The low seven bits are assumed to be 0.
+*/
+
+#define PS3_AUDIO_SOURCE_START_MASK                      (0x01FFFFFF << 7) /* RWIUF */
+
+/*
+The TARGET field specifies the memory space containing the source address.
+*/
+
+#define PS3_AUDIO_SOURCE_TARGET_MASK                     (3 << 0) /* RWIVF */
+#define PS3_AUDIO_SOURCE_TARGET_SYSTEM_MEMORY            (2 << 0) /* RW--V */
+
+/*
+The PS3_AUDIO_DEST register specifies the destination address for transfers.
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |                      START                      |0 0 0 0 0|TAR| DEST
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+/*
+The Audio DMA engine uses 128-byte transfers, thus the address must be aligned
+to a 128 byte boundary.  The low seven bits are assumed to be 0.
+*/
+
+#define PS3_AUDIO_DEST_START_MASK                       (0x01FFFFFF << 7) /* RWIUF */
+
+/*
+The TARGET field specifies the memory space containing the destination address
+AUDIOFIFO = Audio WriteData FIFO,
+*/
+
+#define PS3_AUDIO_DEST_TARGET_MASK                       (3 << 0) /* RWIVF */
+#define PS3_AUDIO_DEST_TARGET_AUDIOFIFO                  (1 << 0) /* RW--V */
+
+/*
+PS3_AUDIO_DMASIZE specifies the number of 128-byte blocks + 1 to transfer.
+So a value of 0 means 128-bytes will get transfered.
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|   BLOCKS    | DMASIZE
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+
+#define PS3_AUDIO_DMASIZE_BLOCKS_MASK                    (0x7f << 0) /* RWIUF */
+
+/*
+ * source/destination address for internal fifos
+ */
+#define PS3_AUDIO_AO_3W_LDATA(n)                         (0x1000 + (0x100 * (n)))
+#define PS3_AUDIO_AO_3W_RDATA(n)                         (0x1080 + (0x100 * (n)))
+
+#define PS3_AUDIO_AO_SPD_DATA(n)                         (0x2000 + (0x400 * (n)))
+
+
+/************************************************************************
+ field attiribute
+
+	Read
+	  ' ' = Other Information
+	  '-' = Field is part of a write-only register
+	  'C' = Value read is always the same, constant value line follows (C)
+	  'R' = Value is read
+
+	Write
+	  ' ' = Other Information
+	  '-' = Must not be written (D), value ignored when written (R,A,F)
+	  'W' = Can be written
+
+	Internal State
+	  ' ' = Other Information
+	  '-' = No internal state
+	  'X' = Internal state, initial value is unknown
+	  'I' = Internal state, initial value is known and follows (I)
+
+	Declaration/Size
+	  ' ' = Other Information
+	  '-' = Does Not Apply
+	  'V' = Type is void
+	  'U' = Type is unsigned integer
+	  'S' = Type is signed integer
+	  'F' = Type is IEEE floating point
+	  '1' = Byte size (008)
+	  '2' = Short size (016)
+	  '3' = Three byte size (024)
+	  '4' = Word size (032)
+	  '8' = Double size (064)
+
+	Define Indicator
+	  ' ' = Other Information
+	  'D' = Device
+	  'M' = Memory
+	  'R' = Register
+	  'A' = Array of Registers
+	  'F' = Field
+	  'V' = Value
+          'T' = Task
+
+ **********************************************************************/
