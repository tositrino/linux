diff -Naur linux-2.6.22-org/arch/powerpc/boot/dts/ps3.dts linux-2.6.22-ps3/arch/powerpc/boot/dts/ps3.dts
--- linux-2.6.22-org/arch/powerpc/boot/dts/ps3.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/arch/powerpc/boot/dts/ps3.dts	2007-08-22 07:57:29.000000000 +0200
@@ -0,0 +1,74 @@
+/*
+ *  PS3 Game Console device tree.
+ *
+ *  Copyright (C) 2006 Sony Computer Entertainment Inc.
+ *  Copyright 2006 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+/ {
+	model = "PS3 Game Console";
+	compatible = "PS3";
+	#size-cells = <2>;
+	#address-cells = <2>;
+
+	/*
+	 * Need to keep linux,platform for a while, not used by kernel.
+	 */
+
+	chosen {
+		linux,platform = <0>;
+	};
+
+	/*
+	 * dtc expects a memory entry, so we'll put a null entry here.
+	 * We'll get the size of the bootmem block from lv1 after startup.
+	 */
+
+	memory {
+		device_type = "memory";
+		reg = <0 0 0 0>;
+	};
+
+	/*
+	 * dtc expects a clock-frequency and timebase-frequency entries, so
+	 * we'll put a null entries here.  These will be initialized after
+	 * startup with data from lv1.
+	 *
+	 * The boot cpu is always zero for PS3.
+	 *
+	 * Seems the only way currently to indicate a processor has multiple
+	 * threads is with an ibm,ppc-interrupt-server#s entry.  We'll put one
+	 * here so we can bring up both of ours.  See smp_setup_cpu_maps().
+	 */
+
+	cpus {
+		#size-cells = <0>;
+		#address-cells = <1>;
+
+		CBE,PPE {
+			device_type = "cpu";
+			reg = <0>;
+			ibm,ppc-interrupt-server#s = <0 1>;
+			clock-frequency = <0>;
+			timebase-frequency = <0>;
+			i-cache-size = <8000>;
+			d-cache-size = <8000>;
+			i-cache-line-size = <80>;
+			d-cache-line-size = <80>;
+		};
+	};
+};
diff -Naur linux-2.6.22-org/arch/powerpc/boot/elf.h linux-2.6.22-ps3/arch/powerpc/boot/elf.h
--- linux-2.6.22-org/arch/powerpc/boot/elf.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/boot/elf.h	2007-08-24 12:34:21.000000000 +0200
@@ -151,6 +151,7 @@
 	unsigned long memsize;
 	unsigned long elfoffset;
 };
+
 int parse_elf64(void *hdr, struct elf_info *info);
 int parse_elf32(void *hdr, struct elf_info *info);
 
diff -Naur linux-2.6.22-org/arch/powerpc/boot/ops.h linux-2.6.22-ps3/arch/powerpc/boot/ops.h
--- linux-2.6.22-org/arch/powerpc/boot/ops.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/boot/ops.h	2007-08-22 07:57:30.000000000 +0200
@@ -51,7 +51,7 @@
 /* Console operations */
 struct console_ops {
 	int	(*open)(void);
-	void	(*write)(char *buf, int len);
+	void	(*write)(const char *buf, int len);
 	void	(*edit_cmdline)(char *buf, int len);
 	void	(*close)(void);
 	void	*data;
@@ -114,6 +114,12 @@
 
 	return -1;
 }
+#define fatal(args...) { printf(args); exit(); }
+
+
+#define PLATFORM_STACK(size) \
+	char _platform_stack[size]; \
+	void *_platform_stack_top = _platform_stack + sizeof(_platform_stack);
 
 static inline void *get_parent(const char *devp)
 {
diff -Naur linux-2.6.22-org/arch/powerpc/boot/ps3-head.S linux-2.6.22-ps3/arch/powerpc/boot/ps3-head.S
--- linux-2.6.22-org/arch/powerpc/boot/ps3-head.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/arch/powerpc/boot/ps3-head.S	2007-08-22 07:57:30.000000000 +0200
@@ -0,0 +1,47 @@
+/*
+ *  PS3 zImage exception vector entry.
+ *
+ *  Copyright (C) 2007 Sony Computer Entertainment Inc.
+ *  Copyright 2007 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ppc_asm.h"
+
+/*
+ * __system_reset_entry - PS3 first stage entry.
+ */
+
+	.section .vectors,"ax"
+	. = 0x100
+	.globl __system_reset_entry
+__system_reset_entry:
+
+	/* Switch to 32-bit mode. */
+	mfmsr	r9
+	clrldi	r9,r9,1
+	mtmsrd	r9
+	nop
+
+	/* Get thread number in r3 and branch. */
+
+	mfspr	r3, 0x88
+	cntlzw.	r3, r3
+	li	r4, 0
+	li	r5, 0
+	beq	1f
+	b	smp_secondary_hold
+1:
+	b	_zimage_start
diff -Naur linux-2.6.22-org/arch/powerpc/boot/ps3-hvcall.S linux-2.6.22-ps3/arch/powerpc/boot/ps3-hvcall.S
--- linux-2.6.22-org/arch/powerpc/boot/ps3-hvcall.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/arch/powerpc/boot/ps3-hvcall.S	2007-08-22 07:57:30.000000000 +0200
@@ -0,0 +1,297 @@
+/*
+ *  PS3 hvcall interface.
+ *
+ *  Copyright (C) 2006 Sony Computer Entertainment Inc.
+ *  Copyright 2006 Sony Corp.
+ *  Copyright 2003, 2004 (c) MontaVista Software, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ppc_asm.h"
+
+/*
+ *  wrapper           lv1
+ *  32-bit (h,l)      64-bit
+ *
+ *  1: r3,r4          <-> r3
+ *  2: r5,r6          <-> r4
+ *  3: r7,r8          <-> r5
+ *  4: r9,r10         <-> r6
+ *  5: 8(r1),12(r1)   <-> r7
+ *  6: 16(r1),20(r1)  <-> r8
+ *  7: 24(r1),28(r1)  <-> r9
+ *  8: 32(r1),36(r1)  <-> r10
+ *
+ */
+
+.macro global name
+	.section ".text"
+	.balign 4
+	.globl \name
+\name:
+.endm
+
+.macro no_support name
+	GLOBAL \name
+	b ps3_no_support
+.endm
+
+.macro hvcall
+	.long 0x44000022
+	extsw r3, r3
+.endm
+
+.macro save_lr offset=4
+	mflr r0
+	stw r0, \offset(r1)
+.endm
+
+.macro load_lr offset=4
+	lwz r0, \offset(r1)
+	mtlr r0
+.endm
+
+.macro load_64_reg target,high,low
+	sldi r11, \high, 32
+	or \target, r11, \low
+.endm
+
+.macro load_64_stack target,offset
+	ld \target, \offset(r1)
+.endm
+
+.macro load_r3
+	LOAD_64_REG r3,r3,r4
+.endm
+
+.macro load_r4
+	LOAD_64_REG r4,r5,r6
+.endm
+
+.macro load_r5
+	LOAD_64_REG r5,r7,r8
+.endm
+
+.macro load_r6
+	LOAD_64_REG r6,r9,r10
+.endm
+
+.macro load_r7
+	LOAD_64_STACK r7,8
+.endm
+
+.macro load_r8
+	LOAD_64_STACK r8,16
+.endm
+
+.macro load_r9
+	LOAD_64_STACK r9,24
+.endm
+
+.macro load_r10
+	LOAD_64_STACK r10,32
+.endm
+
+.macro load_regs_5
+	LOAD_R3
+	LOAD_R4
+	LOAD_R5
+	LOAD_R6
+	LOAD_R7
+.endm
+
+.macro load_regs_6
+	LOAD_REGS_5
+	LOAD_R8
+.endm
+
+.macro load_regs_8
+	LOAD_REGS_6
+	LOAD_R9
+	LOAD_R10
+.endm
+
+.macro store_regs_0_1
+	lwz r11, 8(r1)
+	std r4, 0(r11)
+.endm
+
+.macro store_regs_5_2
+	lwz r11, 16(r1)
+	std r4, 0(r11)
+	lwz r11, 24(r1)
+	std r5, 0(r11)
+.endm
+
+.macro store_regs_6_1
+	lwz r11, 24(r1)
+	std r4, 0(r11)
+.endm
+
+#define LV1_N_IN_0_OUT(API_NAME, API_NUMBER)	\
+GLOBAL _##API_NAME;				\
+	SAVE_LR;				\
+	LOAD_REGS_8;				\
+	li      r11, API_NUMBER;		\
+	HVCALL;					\
+	LOAD_LR;				\
+	blr
+
+#define LV1_0_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_1_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_2_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_3_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_4_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_5_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_6_IN_0_OUT LV1_N_IN_0_OUT
+#define LV1_7_IN_0_OUT LV1_N_IN_0_OUT
+
+.macro save_r5
+	stw r5, 8(r1)
+.endm
+
+.macro save_r6
+	stw r6, 12(r1)
+.endm
+
+.macro save_1
+	SAVE_R5
+	SAVE_R6
+.endm
+
+#define LV1_0_IN_1_OUT(API_NAME, API_NUMBER)	\
+GLOBAL _##API_NAME;				\
+	SAVE_LR;				\
+	stwu r1,-16(r1);			\
+	stw r3, 8(r1);				\
+	li      r11, API_NUMBER;		\
+	HVCALL;					\
+	lwz r11, 8(r1);				\
+	std r4, 0(r11);				\
+	mr r4, r3;				\
+	li r3, 0;				\
+	addi r1,r1,16;				\
+	LOAD_LR;				\
+	blr
+
+#define LV1_0_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_0_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_0_IN_7_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_4_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_5_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_1_IN_6_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT
+
+#define LV1_1_IN_7_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_2_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_2_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_2_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_2_IN_4_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_2_IN_5_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_3_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_3_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_3_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_4_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_4_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_4_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_5_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_5_IN_2_OUT(API_NAME, API_NUMBER)	\
+GLOBAL _##API_NAME;				\
+	SAVE_LR;				\
+	LOAD_REGS_5;				\
+	li      r11, API_NUMBER;		\
+	HVCALL;					\
+	STORE_REGS_5_2;				\
+	LOAD_LR;				\
+	blr
+
+#define LV1_5_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_6_IN_1_OUT(API_NAME, API_NUMBER)	\
+GLOBAL _##API_NAME;				\
+	SAVE_LR;				\
+	LOAD_REGS_6;				\
+	li      r11, API_NUMBER;		\
+	HVCALL;					\
+	STORE_REGS_6_1;				\
+	LOAD_LR;				\
+	blr
+
+#define LV1_6_IN_2_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_6_IN_3_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_7_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_7_IN_6_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+#define LV1_8_IN_1_OUT(API_NAME, API_NUMBER)	\
+	NO_SUPPORT _##API_NAME
+
+/* the lv1 underscored call definitions expand here */
+
+#define LV1_CALL(name, in, out, num) LV1_##in##_IN_##out##_OUT(lv1_##name, num)
+#include "lv1call.h"
+
diff -Naur linux-2.6.22-org/arch/powerpc/boot/ps3.c linux-2.6.22-ps3/arch/powerpc/boot/ps3.c
--- linux-2.6.22-org/arch/powerpc/boot/ps3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/arch/powerpc/boot/ps3.c	2007-08-22 07:57:30.000000000 +0200
@@ -0,0 +1,123 @@
+/*
+ *  PS3 bootwrapper support.
+ *
+ *  Copyright (C) 2007 Sony Computer Entertainment Inc.
+ *  Copyright 2007 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdarg.h>
+#include <stddef.h>
+#include "types.h"
+#include "elf.h"
+#include "string.h"
+#include "stdio.h"
+#include "page.h"
+#include "ops.h"
+#include "lv1call.h"
+
+#if defined(DEBUG)
+#define DBG(fmt...) printf(fmt)
+#else
+static inline int __attribute__ ((format (printf, 1, 2))) DBG(
+	const char *fmt, ...) {return 0;}
+#endif
+
+extern char _start[];
+extern char _end[];
+extern char _dtb_start[];
+extern char _dtb_end[];
+
+PLATFORM_STACK(4096);
+
+static void ps3_console_write(const char *buf, int len)
+{
+}
+
+static void ps3_exit(void)
+{
+	printf("ps3_exit\n");
+	lv1_panic(0); /* zero = no reboot */
+	while(1);
+}
+
+static int ps3_repository_read_rm_size(u64 *rm_size)
+{
+	int result;
+	u64 lpar_id;
+	u64 ppe_id;
+	u64 v2;
+
+	result = lv1_get_logical_partition_id(&lpar_id);
+
+	if (result)
+		return -1;
+
+	result = lv1_get_logical_ppe_id(&ppe_id);
+
+	if (result)
+		return -1;
+
+	/*
+	 * n1: 0000000062690000 : ....bi..
+	 * n2: 7075000000000000 : pu......
+	 * n3: 0000000000000001 : ........
+	 * n4: 726d5f73697a6500 : rm_size.
+	*/
+
+	result = lv1_get_repository_node_value(lpar_id, 0x0000000062690000ULL,
+		0x7075000000000000ULL, ppe_id, 0x726d5f73697a6500ULL, rm_size,
+		&v2);
+
+	printf("%s:%d: ppe_id  %lu \n", __func__, __LINE__,
+		(unsigned long)ppe_id);
+	printf("%s:%d: lpar_id %lu \n", __func__, __LINE__,
+		(unsigned long)lpar_id);
+	printf("%s:%d: rm_size %llxh \n", __func__, __LINE__, *rm_size);
+
+	return result;
+}
+
+static void ps3_fixups(void)
+{
+	u64 rm_size;
+
+	ps3_repository_read_rm_size(&rm_size);
+	dt_fixup_memory(0, rm_size);
+}
+
+int platform_init(void)
+{
+	const u32 heapsize = 0x4000000 - (u32)_end; /* 64M */
+
+	console_ops.write = ps3_console_write;
+	platform_ops.secondary_release = smp_secondary_release;
+	platform_ops.exit = ps3_exit;
+
+	printf("\n-- PS3 bootwrapper --\n");
+
+	simple_alloc_init(_end, heapsize, 32, 64);
+	platform_ops.vmlinux_alloc = platform_ops.malloc;
+	platform_ops.fixups = ps3_fixups;
+	ft_init(_dtb_start, 0, 4);
+
+	return 0;
+}
+
+void ps3_no_support(void)
+{
+	printf("\n*** bootwrapper BUG: ps3_no_support() called!\n");
+	ps3_exit();
+}
diff -Naur linux-2.6.22-org/arch/powerpc/boot/serial.c linux-2.6.22-ps3/arch/powerpc/boot/serial.c
--- linux-2.6.22-org/arch/powerpc/boot/serial.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/boot/serial.c	2007-08-22 07:57:30.000000000 +0200
@@ -27,7 +27,7 @@
 	return scdp->open();
 }
 
-static void serial_write(char *buf, int len)
+static void serial_write(const char *buf, int len)
 {
 	struct serial_console_data *scdp = console_ops.data;
 
diff -Naur linux-2.6.22-org/arch/powerpc/boot/smp.S linux-2.6.22-ps3/arch/powerpc/boot/smp.S
--- linux-2.6.22-org/arch/powerpc/boot/smp.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/arch/powerpc/boot/smp.S	2007-08-22 07:57:30.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ *  zImage SMP support.
+ *
+ *  Copyright (C) 2007 Sony Computer Entertainment Inc.
+ *  Copyright 2007 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ppc_asm.h"
+
+	.data
+	.balign 4
+smp_secondary_entry:
+	.long 0
+
+	.text
+
+/**
+ * smp_secondary_hold - Hold any secondary cpus until kernel is ready to enter.
+ * !!!Need to make this do a kexec entry!!!
+ */
+
+	.balign 4
+	.globl smp_secondary_hold
+smp_secondary_hold:
+
+	lis	r9, smp_secondary_entry@ha
+	addi	r9, r9, smp_secondary_entry@l
+	lwz	r9, 0(r9)
+	cmpwi	r9, 0
+	beq	smp_secondary_hold
+	li	r3, 0
+	li	r4, 0
+	li	r5, 0
+	mtctr	r9
+	bctr
+
+/**
+ * smp_secondary_release - Release any secondary cpus.
+ * @kentry: The kernel entry for secondary cpus.
+ *
+ * Typically called by the primary cpu after the kernel is ready for entry.
+ */
+
+	.balign 4
+	.globl smp_secondary_release
+smp_secondary_release:
+	lis	r9, smp_secondary_entry@ha
+	addi	r9, r9, smp_secondary_entry@l
+	stw	r3, 0(r9)
+	sync
+	blr
diff -Naur linux-2.6.22-org/arch/powerpc/boot/stdio.c linux-2.6.22-ps3/arch/powerpc/boot/stdio.c
--- linux-2.6.22-org/arch/powerpc/boot/stdio.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/boot/stdio.c	2007-08-22 07:57:30.000000000 +0200
@@ -190,7 +190,11 @@
 
 		/* get the conversion qualifier */
 		qualifier = -1;
-		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt =='Z') {
+		if (*fmt == 'l' && *(fmt + 1) =='l') {
+			qualifier = 'q';
+			fmt += 2;
+		} else if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L'
+			|| *fmt =='Z') {
 			qualifier = *fmt;
 			++fmt;
 		}
@@ -281,6 +285,10 @@
 			num = va_arg(args, unsigned long);
 			if (flags & SIGN)
 				num = (signed long) num;
+		} else if (qualifier == 'q') {
+			num = va_arg(args, unsigned long long);
+			if (flags & SIGN)
+				num = (signed long long) num;
 		} else if (qualifier == 'Z') {
 			num = va_arg(args, size_t);
 		} else if (qualifier == 'h') {
diff -Naur linux-2.6.22-org/arch/powerpc/boot/types.h linux-2.6.22-ps3/arch/powerpc/boot/types.h
--- linux-2.6.22-org/arch/powerpc/boot/types.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/boot/types.h	2007-08-22 07:57:30.000000000 +0200
@@ -7,6 +7,10 @@
 typedef unsigned short		u16;
 typedef unsigned int		u32;
 typedef unsigned long long	u64;
+typedef signed char		s8;
+typedef short			s16;
+typedef int			s32;
+typedef long long		s64;
 
 #define min(x,y) ({ \
 	typeof(x) _x = (x);	\
diff -Naur linux-2.6.22-org/arch/powerpc/boot/wrapper linux-2.6.22-ps3/arch/powerpc/boot/wrapper
--- linux-2.6.22-org/arch/powerpc/boot/wrapper	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/boot/wrapper	2007-08-22 07:57:30.000000000 +0200
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/sh -x
 
 # Copyright (C) 2006 Paul Mackerras, IBM Corporation <paulus@samba.org>
 # This program may be used under the terms of version 2 of the GNU
diff -Naur linux-2.6.22-org/arch/powerpc/boot/zImage.ps3.lds.S linux-2.6.22-ps3/arch/powerpc/boot/zImage.ps3.lds.S
--- linux-2.6.22-org/arch/powerpc/boot/zImage.ps3.lds.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/arch/powerpc/boot/zImage.ps3.lds.S	2007-08-22 07:57:30.000000000 +0200
@@ -0,0 +1,55 @@
+OUTPUT_ARCH(powerpc:common)
+ENTRY(_zimage_start)
+EXTERN(_zimage_start)
+SECTIONS
+{
+  .vectors 0 : { *(.vectors) }
+
+  . = (8M);
+
+  _start = .;
+  .text      :
+  {
+    *(.text)
+    *(.fixup)
+  }
+  _etext = .;
+  . = ALIGN(4096);
+  .data    :
+  {
+    *(.rodata*)
+    *(.data*)
+    *(.sdata*)
+    __got2_start = .;
+    *(.got2)
+    __got2_end = .;
+  }
+
+  . = ALIGN(8);
+  _dtb_start = .;
+  .kernel:dtb : { *(.kernel:dtb) }
+  _dtb_end = .;
+
+  . = ALIGN(4096);
+  _vmlinux_start =  .;
+  .kernel:vmlinux.strip : { *(.kernel:vmlinux.strip) }
+  _vmlinux_end =  .;
+
+  . = ALIGN(4096);
+  _initrd_start =  .;
+  .kernel:initrd : { *(.kernel:initrd) }
+  _initrd_end =  .;
+
+  . = ALIGN(4096);
+  _edata  =  .;
+
+  . = ALIGN(4096);
+  __bss_start = .;
+  .bss       :
+  {
+   *(.sbss)
+   *(.bss)
+  }
+  . = ALIGN(4096);
+  _end = . ;
+}
diff -Naur linux-2.6.22-org/arch/powerpc/configs/ps3_defconfig linux-2.6.22-ps3/arch/powerpc/configs/ps3_defconfig
--- linux-2.6.22-org/arch/powerpc/configs/ps3_defconfig	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/configs/ps3_defconfig	2007-08-22 07:57:30.000000000 +0200
@@ -614,6 +614,11 @@
 # CONFIG_MFD_SM501 is not set
 
 #
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
diff -Naur linux-2.6.22-org/arch/powerpc/kernel/head_64.S linux-2.6.22-ps3/arch/powerpc/kernel/head_64.S
--- linux-2.6.22-org/arch/powerpc/kernel/head_64.S	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/kernel/head_64.S	2007-08-22 07:57:30.000000000 +0200
@@ -103,8 +103,8 @@
 
 	. = 0x60
 /*
- * The following code is used on pSeries to hold secondary processors
- * in a spin loop after they have been freed from OpenFirmware, but
+ * The following code is used to hold secondary processors
+ * in a spin loop after they have entered the kernel, but
  * before the bulk of the kernel has been relocated.  This code
  * is relocated to physical address 0x60 before prom_init is run.
  * All of it must fit below the first exception vector at 0x100.
@@ -1695,9 +1695,32 @@
 2:
 
 	/* Switch off MMU if not already */
-	LOAD_REG_IMMEDIATE(r4, .__after_prom_start - KERNELBASE)
+	LOAD_REG_IMMEDIATE(r4, __mmu_off_return - KERNELBASE)
 	add	r4,r4,r30
 	bl	.__mmu_off
+__mmu_off_return:
+
+	/* Test if this is a secondary cpu and if so send it off to
+	 * __secondary_hold with a thread number in r3.  Secondary processors
+	 * call _start with regs r3,r4,r5 zeroed.
+	 * Pass cpu number in r6???
+	 */
+	or.	r3, r31, r30
+	bne	1f
+	li	r3, 1
+	b	.__secondary_hold
+1:
+
+	/* The primary cpu waits here for all the expected secondary cpus to
+	 * enter the kernel, after which time it is safe to reclaim the
+	 * memory use by the bootwrapper.
+	 * How to know what to wait for???
+	 * !!! need to use the kexec entry mechanism here!!!!
+	*/
+1:	LOAD_REG_IMMEDIATE(r4, __secondary_hold_acknowledge)
+	cmpwi	r4, 0
+	beq	1b
+	mr	r3, r30
 	b	.__after_prom_start
 
 _STATIC(__boot_from_prom)
diff -Naur linux-2.6.22-org/arch/powerpc/kernel/prom.c linux-2.6.22-ps3/arch/powerpc/kernel/prom.c
--- linux-2.6.22-org/arch/powerpc/kernel/prom.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/kernel/prom.c	2007-08-22 07:57:30.000000000 +0200
@@ -750,6 +750,7 @@
 					    const char *uname, int depth, void *data)
 {
 	unsigned long *lprop;
+	u32 *prop;
 	unsigned long l;
 	char *p;
 
@@ -793,6 +794,22 @@
 
 	early_init_dt_check_for_initrd(node);
 
+#ifdef CONFIG_BLK_DEV_INITRD
+	DBG("Looking for initrd properties... ");
+	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &l);
+	if (prop) {
+		initrd_start = (unsigned long)__va(of_read_ulong(prop, l/4));
+		prop = of_get_flat_dt_prop(node, "linux,initrd-end", &l);
+		if (prop) {
+			initrd_end = (unsigned long)__va(of_read_ulong(prop, l/4));
+			initrd_below_start_ok = 1;
+		} else {
+			initrd_start = 0;
+		}
+	}
+	DBG("initrd_start=0x%lx  initrd_end=0x%lx\n", initrd_start, initrd_end);
+#endif /* CONFIG_BLK_DEV_INITRD */
+
 	/* Retreive command line */
  	p = of_get_flat_dt_prop(node, "bootargs", &l);
 	if (p != NULL && l > 0)
@@ -939,6 +956,12 @@
 				size = 0x80000000ul - base;
 		}
 #endif
+#if defined(CONFIG_PPC_PS3)
+	/* temporary hack for the legacy bootloader */
+	if (of_flat_dt_is_compatible(of_get_flat_dt_root(), "PS3PF")) {
+		size = 0x8000000;
+	}
+#endif
 		lmb_add(base, size);
 	}
 	return 0;
@@ -965,6 +988,12 @@
 		lmb_reserve(__pa(initrd_start), initrd_end - initrd_start);
 #endif /* CONFIG_BLK_DEV_INITRD */
 
+#ifdef CONFIG_BLK_DEV_INITRD
+	/* then reserve the initrd, if any */
+	if (initrd_start && (initrd_end > initrd_start))
+		lmb_reserve(__pa(initrd_start), initrd_end - initrd_start);
+#endif /* CONFIG_BLK_DEV_INITRD */
+
 #ifdef CONFIG_PPC32
 	/* 
 	 * Handle the case where we might be booting from an old kexec
@@ -1005,7 +1034,7 @@
 
 void __init early_init_devtree(void *params)
 {
-	DBG(" -> early_init_devtree()\n");
+	DBG(" -> early_init_devtree(%p)\n", params);
 
 	/* Setup flat device-tree pointer */
 	initial_boot_params = params;
diff -Naur linux-2.6.22-org/arch/powerpc/kernel/prom_init.c linux-2.6.22-ps3/arch/powerpc/kernel/prom_init.c
--- linux-2.6.22-org/arch/powerpc/kernel/prom_init.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/kernel/prom_init.c	2007-08-22 07:57:30.000000000 +0200
@@ -44,10 +44,7 @@
 #include <asm/sections.h>
 #include <asm/machdep.h>
 
-#ifdef CONFIG_LOGO_LINUX_CLUT224
 #include <linux/linux_logo.h>
-extern const struct linux_logo logo_linux_clut224;
-#endif
 
 /*
  * Properties whose value is longer than this get excluded from our
diff -Naur linux-2.6.22-org/arch/powerpc/mm/lmb.c linux-2.6.22-ps3/arch/powerpc/mm/lmb.c
--- linux-2.6.22-org/arch/powerpc/mm/lmb.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/mm/lmb.c	2007-08-22 07:57:30.000000000 +0200
@@ -150,6 +150,10 @@
 			/* Already have this region, so we're done */
 			return 0;
 
+		if ((rgnbase == base) && (rgnsize == size))
+			/* Already have this region, so we're done */
+			return 0;
+
 		adjacent = lmb_addrs_adjacent(base,size,rgnbase,rgnsize);
 		if ( adjacent > 0 ) {
 			rgn->region[i].base -= size;
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/cell/spu_base.c linux-2.6.22-ps3/arch/powerpc/platforms/cell/spu_base.c
--- linux-2.6.22-org/arch/powerpc/platforms/cell/spu_base.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/cell/spu_base.c	2007-08-23 15:54:52.000000000 +0200
@@ -31,6 +31,7 @@
 #include <linux/mm.h>
 #include <linux/io.h>
 #include <linux/mutex.h>
+#include <linux/linux_logo.h>
 #include <asm/spu.h>
 #include <asm/spu_priv1.h>
 #include <asm/xmon.h>
@@ -39,14 +40,13 @@
 EXPORT_SYMBOL_GPL(spu_management_ops);
 
 const struct spu_priv1_ops *spu_priv1_ops;
+EXPORT_SYMBOL_GPL(spu_priv1_ops);
 
 static struct list_head spu_list[MAX_NUMNODES];
 static LIST_HEAD(spu_full_list);
 static DEFINE_MUTEX(spu_mutex);
 static DEFINE_SPINLOCK(spu_list_lock);
 
-EXPORT_SYMBOL_GPL(spu_priv1_ops);
-
 void spu_invalidate_slbs(struct spu *spu)
 {
 	struct spu_priv2 __iomem *priv2 = spu->priv2;
@@ -217,27 +217,34 @@
 spu_irq_class_0(int irq, void *data)
 {
 	struct spu *spu;
+	unsigned long stat, mask;
 
 	spu = data;
-	spu->class_0_pending = 1;
+
+	mask = spu_int_mask_get(spu, 0);
+	stat = spu_int_stat_get(spu, 0);
+	stat &= mask;
+
+	spin_lock(&spu->register_lock);
+	spu->class_0_pending |= stat;
+	spin_unlock(&spu->register_lock);
+
 	spu->stop_callback(spu);
 
+	spu_int_stat_clear(spu, 0, stat);
+
 	return IRQ_HANDLED;
 }
 
 int
 spu_irq_class_0_bottom(struct spu *spu)
 {
-	unsigned long stat, mask;
 	unsigned long flags;
-
-	spu->class_0_pending = 0;
+	unsigned long stat;
 
 	spin_lock_irqsave(&spu->register_lock, flags);
-	mask = spu_int_mask_get(spu, 0);
-	stat = spu_int_stat_get(spu, 0);
-
-	stat &= mask;
+	stat = spu->class_0_pending;
+	spu->class_0_pending = 0;
 
 	if (stat & 1) /* invalid DMA alignment */
 		__spu_trap_dma_align(spu);
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/cell/spu_manage.c linux-2.6.22-ps3/arch/powerpc/platforms/cell/spu_manage.c
--- linux-2.6.22-org/arch/powerpc/platforms/cell/spu_manage.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/cell/spu_manage.c	2007-08-22 07:57:30.000000000 +0200
@@ -35,6 +35,7 @@
 #include <asm/firmware.h>
 #include <asm/prom.h>
 
+#include "spufs/spufs.h"
 #include "interrupt.h"
 
 struct device_node *spu_devnode(struct spu *spu)
@@ -279,6 +280,7 @@
 {
 	int ret;
 	struct device_node *node;
+	unsigned int n = 0;
 
 	ret = -ENODEV;
 	for (node = of_find_node_by_type(NULL, "spe");
@@ -289,8 +291,9 @@
 				__FUNCTION__, node->name);
 			break;
 		}
+		n++;
 	}
-	return ret;
+	return ret ? ret : n;
 }
 
 static int __init of_create_spu(struct spu *spu, void *data)
@@ -359,8 +362,22 @@
 	return 0;
 }
 
+static int enable_spu_by_master_run(struct spu_context *ctx)
+{
+	ctx->ops->master_start(ctx);
+	return 0;
+}
+
+static int disable_spu_by_master_run(struct spu_context *ctx)
+{
+	ctx->ops->master_stop(ctx);
+	return 0;
+}
+
 const struct spu_management_ops spu_management_of_ops = {
 	.enumerate_spus = of_enumerate_spus,
 	.create_spu = of_create_spu,
 	.destroy_spu = of_destroy_spu,
+	.enable_spu = enable_spu_by_master_run,
+	.disable_spu = disable_spu_by_master_run,
 };
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/cell/spufs/backing_ops.c linux-2.6.22-ps3/arch/powerpc/platforms/cell/spufs/backing_ops.c
--- linux-2.6.22-org/arch/powerpc/platforms/cell/spufs/backing_ops.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/cell/spufs/backing_ops.c	2007-08-22 07:57:30.000000000 +0200
@@ -284,6 +284,11 @@
 	spin_unlock(&ctx->csa.register_lock);
 }
 
+static void spu_backing_runcntl_stop(struct spu_context *ctx)
+{
+	spu_backing_runcntl_write(ctx, SPU_RUNCNTL_STOP);
+}
+
 static void spu_backing_master_start(struct spu_context *ctx)
 {
 	struct spu_state *csa = &ctx->csa;
@@ -374,6 +379,7 @@
 	.get_ls = spu_backing_get_ls,
 	.runcntl_read = spu_backing_runcntl_read,
 	.runcntl_write = spu_backing_runcntl_write,
+	.runcntl_stop = spu_backing_runcntl_stop,
 	.master_start = spu_backing_master_start,
 	.master_stop = spu_backing_master_stop,
 	.set_mfc_query = spu_backing_set_mfc_query,
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/cell/spufs/hw_ops.c linux-2.6.22-ps3/arch/powerpc/platforms/cell/spufs/hw_ops.c
--- linux-2.6.22-org/arch/powerpc/platforms/cell/spufs/hw_ops.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/cell/spufs/hw_ops.c	2007-08-22 07:57:31.000000000 +0200
@@ -220,6 +220,15 @@
 	spin_unlock_irq(&ctx->spu->register_lock);
 }
 
+static void spu_hw_runcntl_stop(struct spu_context *ctx)
+{
+	spin_lock_irq(&ctx->spu->register_lock);
+	out_be32(&ctx->spu->problem->spu_runcntl_RW, SPU_RUNCNTL_STOP);
+	while(in_be32(&ctx->spu->problem->spu_status_R) & SPU_STATUS_RUNNING)
+		cpu_relax();
+	spin_unlock_irq(&ctx->spu->register_lock);
+}
+
 static void spu_hw_master_start(struct spu_context *ctx)
 {
 	struct spu *spu = ctx->spu;
@@ -321,6 +330,7 @@
 	.get_ls = spu_hw_get_ls,
 	.runcntl_read = spu_hw_runcntl_read,
 	.runcntl_write = spu_hw_runcntl_write,
+	.runcntl_stop = spu_hw_runcntl_stop,
 	.master_start = spu_hw_master_start,
 	.master_stop = spu_hw_master_stop,
 	.set_mfc_query = spu_hw_set_mfc_query,
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/cell/spufs/run.c linux-2.6.22-ps3/arch/powerpc/platforms/cell/spufs/run.c
--- linux-2.6.22-org/arch/powerpc/platforms/cell/spufs/run.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/cell/spufs/run.c	2007-08-22 07:57:31.000000000 +0200
@@ -295,7 +295,7 @@
 	if (mutex_lock_interruptible(&ctx->run_mutex))
 		return -ERESTARTSYS;
 
-	ctx->ops->master_start(ctx);
+	spu_enable_spu(ctx);
 	ctx->event_return = 0;
 
 	ret = spu_acquire_runnable(ctx, 0);
@@ -336,7 +336,7 @@
 	} while (!ret && !(status & (SPU_STATUS_STOPPED_BY_STOP |
 				      SPU_STATUS_STOPPED_BY_HALT)));
 
-	ctx->ops->master_stop(ctx);
+	spu_disable_spu(ctx);
 	ret = spu_run_fini(ctx, npc, &status);
 	spu_yield(ctx);
 
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/cell/spufs/spufs.h linux-2.6.22-ps3/arch/powerpc/platforms/cell/spufs/spufs.h
--- linux-2.6.22-org/arch/powerpc/platforms/cell/spufs/spufs.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/cell/spufs/spufs.h	2007-08-22 07:57:31.000000000 +0200
@@ -130,6 +130,7 @@
 	char*(*get_ls) (struct spu_context * ctx);
 	 u32 (*runcntl_read) (struct spu_context * ctx);
 	void (*runcntl_write) (struct spu_context * ctx, u32 data);
+	void (*runcntl_stop) (struct spu_context * ctx);
 	void (*master_start) (struct spu_context * ctx);
 	void (*master_stop) (struct spu_context * ctx);
 	int (*set_mfc_query)(struct spu_context * ctx, u32 mask, u32 mode);
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/ps3/Makefile linux-2.6.22-ps3/arch/powerpc/platforms/ps3/Makefile
--- linux-2.6.22-org/arch/powerpc/platforms/ps3/Makefile	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/ps3/Makefile	2007-08-22 07:57:31.000000000 +0200
@@ -1,6 +1,7 @@
 obj-y += setup.o mm.o time.o hvcall.o htab.o repository.o
 obj-y += interrupt.o exports.o os-area.o
 obj-y += system-bus.o
+obj-y += device-init.o
 
 obj-$(CONFIG_SMP) += smp.o
 obj-$(CONFIG_SPU_BASE) += spu.o
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/ps3/device-init.c linux-2.6.22-ps3/arch/powerpc/platforms/ps3/device-init.c
--- linux-2.6.22-org/arch/powerpc/platforms/ps3/device-init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/arch/powerpc/platforms/ps3/device-init.c	2007-08-22 07:57:31.000000000 +0200
@@ -0,0 +1,463 @@
+/*
+ *  PS3 device init routines.
+ *
+ *  Copyright (C) 2006 Sony Computer Entertainment Inc.
+ *  Copyright 2006 Sony Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define DEBUG 1
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/firmware.h>
+
+#include "platform.h"
+
+static int __devinit
+ps3_register_gelic (void)
+{
+	int result;
+	struct ps3_system_bus_device *dev;
+	struct ps3_repository_device repo;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	dev = kzalloc(sizeof(struct ps3_system_bus_device)
+		+ sizeof(struct ps3_dma_region), GFP_KERNEL);
+
+	dev->match_id = PS3_MATCH_ID_GELIC;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_GELIC, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_first_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	dev->did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_EVENT_PORT, &dev->interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	BUG_ON(dev->interrupt_id != 0);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_get_interrupt_id failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	dev->d_region = (struct ps3_dma_region *)((char*)dev
+		+ sizeof(struct ps3_system_bus_device));
+
+	ps3_dma_region_init(dev->d_region, &dev->did, PS3_DMA_64K,
+		PS3_DMA_OTHER);
+
+	result = ps3_system_bus_device_register(dev);
+
+	if (result) {
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(dev, 0xad, sizeof(struct ps3_system_bus_device)
+		+ sizeof(struct ps3_dma_region));
+#endif
+	kfree(dev);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ohci_0 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ohci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ohci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_OHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_OHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_OHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 16);
+	BUG_ON(bus_addr != 0x3010000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ohci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ohci_1 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ohci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ohci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_OHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	result = ps3_repository_find_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_OHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_OHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 17);
+	BUG_ON(bus_addr != 0x3020000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ohci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ehci_0 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ehci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ehci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_EHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_EHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_EHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 10);
+	BUG_ON(bus_addr != 0x3810000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ehci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_ehci_1 (void)
+{
+	int result;
+	struct ps3_repository_device repo;
+	u64 bus_addr;
+	u64 len;
+
+	/* Puts the regions at the end of the system_bus_device. */
+
+	struct ehci_layout {
+		struct ps3_system_bus_device dev;
+		struct ps3_dma_region d_region;
+		struct ps3_mmio_region m_region;
+	} *p;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	p = kzalloc(sizeof(struct ehci_layout), GFP_KERNEL);
+
+	p->dev.d_region = &p->d_region;
+	p->dev.m_region = &p->m_region;
+	p->dev.match_id = PS3_MATCH_ID_EHCI;
+
+	result = ps3_repository_find_first_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	result = ps3_repository_find_device(PS3_BUS_TYPE_SB,
+		PS3_DEV_TYPE_SB_USB, &repo, &repo);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_device failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	p->dev.did = repo.did;
+
+	result = ps3_repository_find_interrupt(&repo,
+		PS3_INTERRUPT_TYPE_SB_EHCI, &p->dev.interrupt_id);
+
+	if (result) {
+		pr_debug("%s:%d ps3_repository_find_interrupt failed\n",
+			__func__, __LINE__);
+		goto fail;
+	}
+
+	ps3_repository_find_reg(&repo, PS3_REG_TYPE_SB_EHCI,
+		&bus_addr, &len);
+
+	BUG_ON(p->dev.interrupt_id != 11);
+	BUG_ON(bus_addr != 0x3820000);
+	BUG_ON(len != 0x10000);
+
+	ps3_dma_region_init(p->dev.d_region, &p->dev.did, PS3_DMA_64K,
+		PS3_DMA_INTERNAL);
+
+	ps3_mmio_region_init(p->dev.m_region, &p->dev.did, bus_addr,
+		len, PS3_MMIO_4K);
+
+	result = ps3_system_bus_device_register(&p->dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_system_bus_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+
+fail:
+#if defined(DEBUG)
+	memset(p, 0xad, sizeof(struct ehci_layout));
+#endif
+	kfree(p);
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+static int __devinit
+ps3_register_sys_manager (void)
+{
+	int result;
+	static struct ps3_vuart_port_device dev = {
+		.match_id = PS3_MATCH_ID_SYSTEM_MANAGER,
+	};
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	result = ps3_vuart_port_device_register(&dev);
+
+	if (result)
+		pr_debug("%s:%d ps3_vuart_port_device_register failed\n",
+			__func__, __LINE__);
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+int __init
+ps3_register_known_devices (void)
+{
+	int result;
+
+	if (!firmware_has_feature(FW_FEATURE_PS3_LV1))
+		return -ENODEV;
+
+	pr_debug(" -> %s:%d\n", __func__, __LINE__);
+
+	//ps3_repository_dump_bus_info();
+
+	result = ps3_register_ohci_0();
+	result = ps3_register_ehci_0();
+	result = ps3_register_ohci_1();
+	result = ps3_register_ehci_1();
+#if defined(CONFIG_PS3_SYS_MANAGER)
+	result = ps3_register_sys_manager();
+#endif
+	result = ps3_register_gelic();
+
+	pr_debug(" <- %s:%d\n", __func__, __LINE__);
+	return result;
+}
+
+device_initcall(ps3_register_known_devices);
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/ps3/mm.c linux-2.6.22-ps3/arch/powerpc/platforms/ps3/mm.c
--- linux-2.6.22-org/arch/powerpc/platforms/ps3/mm.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/ps3/mm.c	2007-08-22 07:57:31.000000000 +0200
@@ -128,6 +128,16 @@
 
 static struct map map;
 
+// FIXME Temporary solution for the storage and sound drivers
+unsigned long ps3_mem_total;
+EXPORT_SYMBOL_GPL(ps3_mem_total);
+unsigned long ps3_rm_limit;
+EXPORT_SYMBOL_GPL(ps3_rm_limit);
+unsigned long ps3_2nd_mem_base;
+EXPORT_SYMBOL_GPL(ps3_2nd_mem_base);
+unsigned long ps3_2nd_mem_size;
+EXPORT_SYMBOL_GPL(ps3_2nd_mem_size);
+
 /**
  * ps3_mm_phys_to_lpar - translate a linux physical address to lpar address
  * @phys_addr: linux physical address
@@ -810,12 +820,17 @@
 	BUG_ON(map.rm.base);
 	BUG_ON(!map.rm.size);
 
-	lmb_add(map.rm.base, map.rm.size);
-	lmb_analyze();
+#warning FIXME - need to check if map.rm.size is same as value in DT.
 
 	/* arrange to do this in ps3_mm_add_memory */
 	ps3_mm_region_create(&map.r1, map.total - map.rm.size);
 
+	// FIXME Temporary solution for the storage and sound drivers
+	ps3_mem_total = map.rm.size + map.r1.size;
+	ps3_rm_limit = map.rm.size;
+	ps3_2nd_mem_base = map.r1.base;
+	ps3_2nd_mem_size = map.r1.size;
+
 	DBG(" <- %s:%d\n", __func__, __LINE__);
 }
 
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/ps3/platform.h linux-2.6.22-ps3/arch/powerpc/platforms/ps3/platform.h
--- linux-2.6.22-org/arch/powerpc/platforms/ps3/platform.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/ps3/platform.h	2007-08-22 07:57:31.000000000 +0200
@@ -134,6 +134,8 @@
 	struct ps3_device_id did;
 };
 
+int ps3_repository_find_bus(enum ps3_bus_type bus_type, unsigned int from,
+	unsigned int *bus_index);
 int ps3_repository_find_device(enum ps3_bus_type bus_type,
 	enum ps3_dev_type dev_type,
 	const struct ps3_repository_device *start_dev,
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/ps3/repository.c linux-2.6.22-ps3/arch/powerpc/platforms/ps3/repository.c
--- linux-2.6.22-org/arch/powerpc/platforms/ps3/repository.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/ps3/repository.c	2007-08-22 07:57:31.000000000 +0200
@@ -182,6 +182,7 @@
 	*bus_id = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_bus_id);
 
 int ps3_repository_read_bus_type(unsigned int bus_index,
 	enum ps3_bus_type *bus_type)
@@ -197,6 +198,7 @@
 	*bus_type = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_bus_type);
 
 int ps3_repository_read_bus_num_dev(unsigned int bus_index,
 	unsigned int *num_dev)
@@ -212,6 +214,7 @@
 	*num_dev = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_bus_num_dev);
 
 int ps3_repository_read_dev_str(unsigned int bus_index,
 	unsigned int dev_index, const char *dev_str, u64 *value)
@@ -239,6 +242,7 @@
 	*dev_id = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_dev_id);
 
 int ps3_repository_read_dev_type(unsigned int bus_index,
 	unsigned int dev_index, enum ps3_dev_type *dev_type)
@@ -255,6 +259,7 @@
 	*dev_type = v1;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_dev_type);
 
 int ps3_repository_read_dev_intr(unsigned int bus_index,
 	unsigned int dev_index, unsigned int intr_index,
@@ -274,6 +279,7 @@
 	*interrupt_id = v2;
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_dev_intr);
 
 int ps3_repository_read_dev_reg_type(unsigned int bus_index,
 	unsigned int dev_index, unsigned int reg_index,
@@ -513,6 +519,31 @@
 }
 #endif /* defined(DEBUG) */
 
+int ps3_repository_find_bus(enum ps3_bus_type bus_type, unsigned int from,
+	unsigned int *bus_index)
+{
+	unsigned int i;
+	enum ps3_bus_type type;
+	int error;
+
+	for (i = from; i < 10; i++) {
+		error = ps3_repository_read_bus_type(i, &type);
+		if (error) {
+			pr_debug("%s:%d read_bus_type failed\n",
+				__func__, __LINE__);
+			*bus_index = UINT_MAX;
+			return error;
+		}
+		if (type == bus_type) {
+			*bus_index = i;
+			return 0;
+		}
+	}
+	*bus_index = UINT_MAX;
+	return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(ps3_repository_find_bus);
+
 static int find_device(unsigned int bus_index, unsigned int num_dev,
 	unsigned int start_dev_index, enum ps3_dev_type dev_type,
 	struct ps3_repository_device *dev)
@@ -541,7 +572,7 @@
 	}
 
 	if (dev_index == num_dev)
-		return -1;
+		return -ENODEV;
 
 	pr_debug("%s:%d: found dev_type %u at dev_index %u\n",
 		__func__, __LINE__, dev_type, dev_index);
@@ -577,25 +608,14 @@
 
 	BUG_ON(start_dev && start_dev->bus_index > 10);
 
-	for (bus_index = start_dev ? start_dev->bus_index : 0; bus_index < 10;
-		bus_index++) {
-		enum ps3_bus_type x;
-
-		result = ps3_repository_read_bus_type(bus_index, &x);
-
-		if (result) {
-			pr_debug("%s:%d read_bus_type failed\n",
-				__func__, __LINE__);
-			dev->bus_index = UINT_MAX;
-			return result;
-		}
-		if (x == bus_type)
-			break;
+	result = ps3_repository_find_bus(bus_type,
+					 start_dev ? start_dev->bus_index : 0,
+					 &bus_index);
+	if (result) {
+		dev->bus_index = UINT_MAX;
+		return result;
 	}
 
-	if (bus_index >= 10)
-		return -ENODEV;
-
 	pr_debug("%s:%d: found bus_type %u at bus_index %u\n",
 		__func__, __LINE__, bus_type, bus_index);
 
@@ -630,6 +650,7 @@
 
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_find_device);
 
 int ps3_repository_find_interrupt(const struct ps3_repository_device *dev,
 	enum ps3_interrupt_type intr_type, unsigned int *interrupt_id)
@@ -668,6 +689,7 @@
 
 	return result;
 }
+EXPORT_SYMBOL_GPL(ps3_repository_find_interrupt);
 
 int ps3_repository_find_reg(const struct ps3_repository_device *dev,
 	enum ps3_reg_type reg_type, u64 *bus_addr, u64 *len)
@@ -949,6 +971,7 @@
 		0,
 		address, 0);
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_stor_dev_info);
 
 int ps3_repository_read_boot_dat_size(unsigned int *size)
 {
@@ -1015,6 +1038,7 @@
 		0,
 		tb_freq, 0);
 }
+EXPORT_SYMBOL_GPL(ps3_repository_read_stor_dev_region);
 
 int ps3_repository_read_be_tb_freq(unsigned int be_index, u64 *tb_freq)
 {
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/ps3/setup.c linux-2.6.22-ps3/arch/powerpc/platforms/ps3/setup.c
--- linux-2.6.22-org/arch/powerpc/platforms/ps3/setup.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/ps3/setup.c	2007-08-23 16:16:02.000000000 +0200
@@ -117,9 +117,9 @@
 }
 
 struct ps3_prealloc ps3fb_videomemory = {
-    .name = "ps3fb videomemory",
-    .size = CONFIG_FB_PS3_DEFAULT_SIZE_M*1024*1024,
-    .align = 1024*1024			/* the GPU requires 1 MiB alignment */
+	.name = "ps3fb videomemory",
+	.size = CONFIG_FB_PS3_DEFAULT_SIZE_M*1024*1024,
+	.align = 1024*1024		/* the GPU requires 1 MiB alignment */
 };
 #define prealloc_ps3fb_videomemory()	prealloc(&ps3fb_videomemory)
 
@@ -137,6 +137,18 @@
 #define prealloc_ps3fb_videomemory()	do { } while (0)
 #endif
 
+#if defined(CONFIG_PS3_STORAGE) || defined(CONFIG_PS3_STORAGE_MODULE)
+struct ps3_prealloc ps3_stor_bounce_buffer = {
+ 	.name = "ps3_stor bounce buffer",
+ 	.size = 256*1024,
+ 	.align = 256*1024
+};
+EXPORT_SYMBOL_GPL(ps3_stor_bounce_buffer);
+#define prealloc_ps3_stor_bounce_buffer()	prealloc(&ps3_stor_bounce_buffer)
+#else
+#define prealloc_ps3_stor_bounce_buffer()	do { } while (0)
+#endif
+ 
 static int ps3_set_dabr(u64 dabr)
 {
 	enum {DABR_USER = 1, DABR_KERNEL = 2,};
@@ -166,6 +178,8 @@
 #endif
 
 	prealloc_ps3fb_videomemory();
+	prealloc_ps3_stor_bounce_buffer();
+
 	ppc_md.power_save = ps3_power_save;
 
 	DBG(" <- %s:%d\n", __func__, __LINE__);
@@ -231,24 +245,29 @@
 }
 #endif
 
+static int ps3_check_legacy_ioport(unsigned int baseport)
+{
+        return -ENODEV;
+}
+
 define_machine(ps3) {
-	.name				= "PS3",
-	.probe				= ps3_probe,
-	.setup_arch			= ps3_setup_arch,
-	.init_IRQ			= ps3_init_IRQ,
-	.panic				= ps3_panic,
+	.name				    = "PS3",
+	.probe				    = ps3_probe,
+	.setup_arch			    = ps3_setup_arch,
+	.init_IRQ			    = ps3_init_IRQ,
+	.panic				    = ps3_panic,
 	.get_boot_time			= ps3_get_boot_time,
 	.set_rtc_time			= ps3_set_rtc_time,
 	.get_rtc_time			= ps3_get_rtc_time,
-	.set_dabr			= ps3_set_dabr,
+	.set_dabr			    = ps3_set_dabr,
 	.calibrate_decr			= ps3_calibrate_decr,
-	.progress			= ps3_progress,
-	.restart			= ps3_restart,
-	.power_off			= ps3_power_off,
+	.progress			    = ps3_progress,
+	.restart			    = ps3_restart,
+	.power_off			    = ps3_power_off,
 #if defined(CONFIG_KEXEC)
 	.kexec_cpu_down			= ps3_kexec_cpu_down,
 	.machine_kexec			= ps3_machine_kexec,
-	.machine_kexec_prepare		= default_machine_kexec_prepare,
-	.machine_crash_shutdown		= default_machine_crash_shutdown,
+	.machine_kexec_prepare	= default_machine_kexec_prepare,
+	.machine_crash_shutdown	= default_machine_crash_shutdown,
 #endif
 };
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/ps3/spu.c linux-2.6.22-ps3/arch/powerpc/platforms/ps3/spu.c
--- linux-2.6.22-org/arch/powerpc/platforms/ps3/spu.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/ps3/spu.c	2007-08-22 07:57:31.000000000 +0200
@@ -28,6 +28,7 @@
 #include <asm/spu_priv1.h>
 #include <asm/lv1call.h>
 
+#include "../cell/spufs/spufs.h"
 #include "platform.h"
 
 /* spu_management_ops */
@@ -400,17 +401,32 @@
 		}
 	}
 
-	if (result)
+	if (result) {
 		printk(KERN_WARNING "%s:%d: Error initializing spus\n",
 			__func__, __LINE__);
+		return result;
+	}
 
-	return result;
+	return num_resource_id;
+}
+
+static int ps3_enable_spu(struct spu_context *ctx)
+{
+	return -ENOSYS;
+}
+
+static int ps3_disable_spu(struct spu_context *ctx)
+{
+	ctx->ops->runcntl_stop(ctx);
+	return -ENOSYS;
 }
 
 const struct spu_management_ops spu_management_ps3_ops = {
 	.enumerate_spus = ps3_enumerate_spus,
 	.create_spu = ps3_create_spu,
 	.destroy_spu = ps3_destroy_spu,
+	.enable_spu = ps3_enable_spu,
+	.disable_spu = ps3_disable_spu,
 };
 
 /* spu_priv1_ops */
diff -Naur linux-2.6.22-org/arch/powerpc/platforms/ps3/system-bus.c linux-2.6.22-ps3/arch/powerpc/platforms/ps3/system-bus.c
--- linux-2.6.22-org/arch/powerpc/platforms/ps3/system-bus.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/arch/powerpc/platforms/ps3/system-bus.c	2007-08-22 07:57:31.000000000 +0200
@@ -18,6 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/module.h>
@@ -30,6 +32,10 @@
 
 #include "platform.h"
 
+static struct device ps3_system_bus = {
+        .bus_id         = "ps3_system",
+};
+
 #define dump_mmio_region(_a) _dump_mmio_region(_a, __func__, __LINE__)
 static void _dump_mmio_region(const struct ps3_mmio_region* r,
 	const char* func, int line)
@@ -99,9 +105,10 @@
 
 	result = lv1_open_device(dev->did.bus_id, dev->did.dev_id, 0);
 
-	if (result) {
-		pr_debug("%s:%d: lv1_open_device failed (%d)\n",
-			__func__, __LINE__, result);
+	if (result && (result != LV1_BUSY || (dev->match_id != PS3_MATCH_ID_EHCI
+		&& dev->match_id != PS3_MATCH_ID_OHCI))) {
+		pr_debug("%s:%d: lv1_open_device failed: %s\n",
+			__func__, __LINE__, ps3_result(result));
 		result = -EACCES;
 		goto clean_none;
 	}
@@ -160,11 +167,42 @@
 	return 0;
 }
 
+static int ps3_system_bus_uevent(struct device *_dev, char **envp,
+				 int num_envp, char *buffer, int buffer_size)
+{
+	struct ps3_system_bus_device *dev = to_ps3_system_bus_device(_dev);
+	int i=0, length = 0;
+
+	if (add_uevent_var(envp, num_envp, &i, buffer, buffer_size,
+			   &length, "MODALIAS=ps3:%d",
+			   dev->match_id))
+		return -ENOMEM;
+
+	envp[i] = NULL;
+	return 0;
+}
+
+static ssize_t modalias_show(struct device *_dev, struct device_attribute *a,
+			     char *buf)
+{
+	struct ps3_system_bus_device *dev = to_ps3_system_bus_device(_dev);
+        int len = snprintf(buf, PAGE_SIZE, "ps3:%d\n", dev->match_id);
+
+        return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+
+static struct device_attribute ps3_system_bus_dev_attrs[] = {
+        __ATTR_RO(modalias),
+        __ATTR_NULL,
+};
+
 struct bus_type ps3_system_bus_type = {
 	.name = "ps3_system_bus",
 	.match = ps3_system_bus_match,
 	.probe = ps3_system_bus_probe,
 	.remove = ps3_system_bus_remove,
+	.uevent = ps3_system_bus_uevent,
+	.dev_attrs = ps3_system_bus_dev_attrs,
 };
 
 int __init ps3_system_bus_init(void)
@@ -173,7 +211,8 @@
 
 	if (!firmware_has_feature(FW_FEATURE_PS3_LV1))
 		return -ENODEV;
-
+	result = device_register(&ps3_system_bus);
+	BUG_ON(result);
 	result = bus_register(&ps3_system_bus_type);
 	BUG_ON(result);
 	return result;
@@ -353,6 +392,9 @@
 	dev->core.archdata.dma_ops = &ps3_dma_ops;
 	dev->core.archdata.numa_node = 0;
 
+	if (!dev->core.parent)
+		dev->core.parent = &ps3_system_bus;
+
 	snprintf(dev->core.bus_id, sizeof(dev->core.bus_id), "sb_%02x",
 		dev_count++);
 
diff -Naur linux-2.6.22-org/drivers/block/Kconfig linux-2.6.22-ps3/drivers/block/Kconfig
--- linux-2.6.22-org/drivers/block/Kconfig	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/drivers/block/Kconfig	2007-08-22 07:57:31.000000000 +0200
@@ -453,6 +453,34 @@
 
 source "drivers/s390/block/Kconfig"
 
+config PS3_STORAGE
+       tristate "Support PS3 internal HDD/CDROM drives"
+       depends on PPC_PS3 && BLK_DEV_SD && BLK_DEV_SR
+       help
+       This driver provides support for internal HDD/CD-ROM drives
+       controlled under PS3 hypervisor storage system.
+
+config PS3_STORAGE_EXPECTED_NUM_DRIVES
+       int "Number of expected storage drives"
+       depends on PS3_STORAGE
+       default "3"
+       help
+         This specifies number of expected numbers of internal
+         storage drives.  The PS3 storage driver waits for
+         this number of drives are reported ready by the
+         hypervisor.
+
+config PS3_STORAGE_MAX_SPINUP_WAIT_TIME
+       int "Maximum time of wait time"
+       depends on PS3_STORAGE
+       default "10"
+       help
+         This specifies maximum time to wait for storage
+         drive readiness.  If only less drives than
+         PS3_STORAGE_EXPECTED_NUM_DRIVES become ready
+         until this time expired,  the PS3 storage driver
+         stop to wait and continue to run with available
+         drives.
 endmenu
 
 endif
diff -Naur linux-2.6.22-org/drivers/block/Makefile linux-2.6.22-ps3/drivers/block/Makefile
--- linux-2.6.22-org/drivers/block/Makefile	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/drivers/block/Makefile	2007-08-22 07:57:31.000000000 +0200
@@ -28,4 +28,5 @@
 obj-$(CONFIG_VIODASD)		+= viodasd.o
 obj-$(CONFIG_BLK_DEV_SX8)	+= sx8.o
 obj-$(CONFIG_BLK_DEV_UB)	+= ub.o
+obj-$(CONFIG_PS3_STORAGE)	+= ps3_storage.o
 
diff -Naur linux-2.6.22-org/drivers/block/ps3_storage.c linux-2.6.22-ps3/drivers/block/ps3_storage.c
--- linux-2.6.22-org/drivers/block/ps3_storage.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/drivers/block/ps3_storage.c	2007-08-22 07:57:31.000000000 +0200
@@ -0,0 +1,2741 @@
+/*
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * Copyright 2006, 2007 Sony Corporation
+ * storage support for PS3
+ *
+ * based on scsi_debug.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <linux/list.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/blkdev.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/rwsem.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <linux/cdrom.h>
+#include <asm/lv1call.h>
+#include <asm/abs_addr.h>
+#include <asm/ps3.h>
+#include "ps3_storage.h"
+
+#undef _DEBUG
+#if defined(_DEBUG)
+#define DPRINTK(x...) printk(x)
+#else
+#define DPRINTK(x...) do {} while(0)
+#endif
+
+#undef _DEBUG_CALLTREE
+#if defined(_DEBUG_CALLTREE)
+static int func_level;
+#define FUNC_START     printk(KERN_ERR "%s:%d start\n", __FUNCTION__, func_level++)
+#define FUNC_STEP_C(x) printk(KERN_ERR "%s:%d step %s\n", __FUNCTION__, func_level, x)
+#define FUNC_END       printk(KERN_ERR "%s:%d end\n", __FUNCTION__, --func_level)
+#define FUNC_END_C(x)  printk(KERN_ERR "%s:%d end %s\n", __FUNCTION__, --func_level, x)
+#else
+#define FUNC_START     do {} while(0)
+#define FUNC_END       FUNC_START
+#define FUNC_STEP_C(x) FUNC_START
+#define FUNC_END_C(x)  FUNC_START
+#endif
+
+#define FLASH_ALIGN    (0x00040000) /* flash safe write size (256KB); should be powers of 2 */
+
+static int ps3_stor_add_host = 2;
+static int ps3_stor_wait_time = CONFIG_PS3_STORAGE_MAX_SPINUP_WAIT_TIME;
+static int ps3_stor_wait_num_storages = CONFIG_PS3_STORAGE_EXPECTED_NUM_DRIVES + 1;
+
+#define CEIL_ALIGN_16M(mem)  ((((mem - 1) >> 24) + 1 ) << 24) /* 2^24=16M */
+#define CEIL_ALIGN_1M(mem)   ((((mem - 1) >> 20) + 1 ) << 20) /* 2^20=1M */
+#define CEIL_ALIGN_64K(mem)  ((((mem - 1) >> 16) + 1 ) << 16) /* 2^16=64K */
+#define CEIL_ALIGN_4K(mem)   ((((mem - 1) >> 12) + 1 ) << 12) /* 2^12=4K */
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PS3 storage driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(PS3_STOR_VERSION);
+
+module_param_named(wait_num_storages, ps3_stor_wait_num_storages, int, 0);
+module_param_named(wait_time, ps3_stor_wait_time, int, 0);
+MODULE_PARM_DESC(wait_num_storages, "Number of expected (wanted) drives to wait spin up (default=3 drives)");
+MODULE_PARM_DESC(wait_time, "Maximum time to wait spinup (default=10sec)");
+
+static struct ps3_stor_lv1_bus_info ps3_stor_lv1_bus_info_array[PS3_STORAGE_NUM_OF_BUS_TYPES];
+
+static struct ps3_stor_lv1_dev_info * ps3_stor_lv1_dev_info_array;
+static int ps3_stor_lv1_devnum ; /* number of configured(used) lv1 devices */
+
+static LIST_HEAD(ps3_stor_host_list);
+static DEFINE_SPINLOCK(ps3_stor_host_list_lock);
+
+static u64 ps3_stor_virtual_to_lpar(struct ps3_stor_dev_info *dev_info,
+				    void *va);
+
+/*
+ * fill buf with MODE SENSE page 8 (caching parameter)
+ * changable: 0 fills current value, otherwise fills 0
+ * returns length of this page
+ */
+const static unsigned char page_data_6[] =
+{
+	0x06,    2, /* page 6, length =2                         */
+	0x01,       /* 0: write cache disabled                   */
+	0x00        /* reserved                                  */
+};
+const static unsigned char page_data_8[] =
+{
+	0x08,   10, /* page 8, length =10                        */
+	0x04,       /* 0:read cache, 1:mult factor, 2:write cache*/
+	0x00,       /* 0..3:write retantion, 4..7:read retantion */
+	0xff, 0xff, /* disable prefech block length              */
+	0x00, 0x00, /* minimum prefech                           */
+	0xff, 0xff, /* maximum prefech                           */
+	0xff, 0xff  /* maximum prefech ceiling                   */
+};
+
+/*
+ * returns 0: decoded
+ *        -1: not sense info, issue REQUEST_SENSE needed
+ */
+static int decode_lv1_status(u64 status, unsigned char * sense_key,
+			     unsigned char * asc, unsigned char * ascq)
+{
+	if (((status >> 24) & 0xff) != 0x02)
+		return -1;
+
+	*sense_key = (status >> 16) & 0xff;
+	*asc       = (status >>  8) & 0xff;
+	*ascq      =  status        & 0xff;
+	return 0;
+}
+
+
+static void ps3_stor_srb_done(struct ps3_stor_dev_info * dev_info)
+{
+	struct scsi_cmnd * srb = dev_info->srb;
+	unsigned long flags;
+
+	spin_lock_irqsave(&(dev_info->srb_lock), flags);
+	{
+		dev_info->srb = NULL;
+		srb->scsi_done(srb);
+	}
+	spin_unlock_irqrestore(&(dev_info->srb_lock), flags);
+}
+
+static void ps3_stor_process_srb(struct scsi_cmnd * srb)
+{
+	struct ps3_stor_dev_info * dev_info;
+	int (*command_handler)(struct ps3_stor_dev_info *, struct scsi_cmnd *);
+
+	dev_info = (struct ps3_stor_dev_info*) srb->device->hostdata;
+	command_handler = dev_info->handler_info[srb->cmnd[0]].cmnd_handler;
+
+	if (command_handler) {
+		(*command_handler)(dev_info, srb);
+	} else {
+		srb->result = (DID_ERROR << 16);
+		memset(srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		srb->sense_buffer[0] = 0x70;
+		srb->sense_buffer[2] = ILLEGAL_REQUEST;
+		ps3_stor_srb_done(dev_info);
+	}
+}
+
+/*
+ * main thread to process srb.
+ * thread is created per device basis.
+ * srb are often passed in interrupt context (softirq), so
+ * we can't sleep at queuecommand().  just receive it
+ * at queucommand(), then passed it to other thread
+ * to process it under non-interrupt context.
+ */
+static int ps3_stor_main_thread(void * parm)
+{
+	struct ps3_stor_dev_info * dev_info = (struct ps3_stor_dev_info *)parm;
+	int reason = 0;
+
+	current->flags |= PF_NOFREEZE; /* jugemu jugemu */
+
+	while (!reason) {
+		down_interruptible(&(dev_info->thread_sema));
+		switch (dev_info->thread_wakeup_reason) {
+		case SRB_QUEUED:
+			ps3_stor_process_srb(dev_info->srb);
+			break;
+		case THREAD_TERMINATE:
+			reason =  THREAD_TERMINATE;
+			break;
+		default:
+			printk(KERN_ERR "%s: unknown wakeup reason %d\n", __FUNCTION__,
+			       dev_info->thread_wakeup_reason);
+			break;
+		}
+	}
+
+	complete_and_exit(&(dev_info->thread_terminated), reason);
+}
+
+/*
+ * copy data from device into scatter/gather buffer
+ */
+static int fill_from_dev_buffer(struct scsi_cmnd * srb,
+				const unsigned char * arr,
+				int arr_len)
+{
+	int k, req_len, act_len, len, active;
+	void * kaddr;
+	void * kaddr_off;
+	struct scatterlist * sgpnt;
+
+	if (0 == srb->request_bufflen)
+		return 0;
+	if (NULL == srb->request_buffer)
+		return (DID_ERROR << 16);
+	if (! ((srb->sc_data_direction == DMA_BIDIRECTIONAL) ||
+	      (srb->sc_data_direction == DMA_FROM_DEVICE)))
+		return (DID_ERROR << 16);
+	if (0 == srb->use_sg) {
+		req_len = srb->request_bufflen;
+		act_len = (req_len < arr_len) ? req_len : arr_len;
+		memcpy(srb->request_buffer, arr, act_len);
+		srb->resid = req_len - act_len;
+		return 0;
+	}
+	sgpnt = (struct scatterlist *)srb->request_buffer;
+	active = 1;
+	for (k = 0, req_len = 0, act_len = 0; k < srb->use_sg; ++k, ++sgpnt) {
+		if (active) {
+			kaddr = kmap_atomic(sgpnt->page, KM_USER0);
+			if (NULL == kaddr)
+				return (DID_ERROR << 16);
+			kaddr_off = kaddr + sgpnt->offset;
+			len = sgpnt->length;
+			if ((req_len + len) > arr_len) {
+				active = 0;
+				len = arr_len - req_len;
+			}
+			memcpy(kaddr_off, arr + req_len, len);
+			kunmap_atomic(kaddr, KM_USER0);
+			act_len += len;
+		}
+		req_len += sgpnt->length;
+	}
+	srb->resid = req_len - act_len;
+	return 0;
+}
+
+/*
+ * copy data from scatter/gather into device's buffer
+ */
+static int fetch_to_dev_buffer(struct scsi_cmnd * srb,
+			       unsigned char * arr,
+			       int max_arr_len)
+{
+	int k, req_len, len, fin;
+	void * kaddr;
+	void * kaddr_off;
+	struct scatterlist * sgpnt;
+
+	if (0 == srb->request_bufflen)
+		return 0;
+	if (NULL == srb->request_buffer)
+		return -1;
+	if (! ((srb->sc_data_direction == DMA_BIDIRECTIONAL) ||
+	      (srb->sc_data_direction == DMA_TO_DEVICE)))
+		return -1;
+	if (0 == srb->use_sg) {
+		req_len = srb->request_bufflen;
+		len = (req_len < max_arr_len) ? req_len : max_arr_len;
+		memcpy(arr, srb->request_buffer, len);
+		return len;
+	}
+
+	sgpnt = (struct scatterlist *)srb->request_buffer;
+	for (k = 0, req_len = 0, fin = 0; k < srb->use_sg; ++k, ++sgpnt) {
+		kaddr = kmap_atomic(sgpnt->page, KM_USER0);
+		if (NULL == kaddr)
+			return -1;
+		kaddr_off = kaddr + sgpnt->offset;
+		len = sgpnt->length;
+		if ((req_len + len) > max_arr_len) {
+			len = max_arr_len - req_len;
+			fin = 1;
+		}
+		memcpy(arr + req_len, kaddr_off, len);
+		kunmap_atomic(kaddr, KM_USER0);
+		if (fin)
+			return req_len + len;
+		req_len += sgpnt->length;
+	}
+	return req_len;
+}
+
+/*
+ * copy data into device buffer to write.
+ * byte offset 'from' until byte offset 'to'
+ * data always copied into 'arr'
+ */
+static off_t fetch_to_dev_buffer_abs(struct scsi_cmnd * srb,
+				     unsigned char * arr,
+				     off_t from,
+				     off_t to)
+{
+	int i, fin;
+	void * kaddr;
+	void * kaddr_off;
+	off_t cur_pos, end_pos, start_pos, len;
+	struct scatterlist * sg;
+
+	if (0 == srb->request_bufflen)
+		return 0;
+	if (NULL == srb->request_buffer)
+		return -1;
+	if (! ((srb->sc_data_direction == DMA_BIDIRECTIONAL) ||
+	      (srb->sc_data_direction == DMA_TO_DEVICE)))
+		return -1;
+	if (to < from)
+		return -1;
+
+	DPRINTK(KERN_ERR "%s: from=%#lx(%ld) to=%#lx(%ld) sg=%d\n", __FUNCTION__,
+		from, from , to, to, srb->use_sg);
+
+	if (0 == srb->use_sg) {
+		len = (srb->request_bufflen < to) ? (srb->request_bufflen - from) : (to - from);
+		memcpy(arr, srb->request_buffer + from, len);
+		return len;
+	}
+
+
+	len = 0;
+	sg = (struct scatterlist *)srb->request_buffer;
+	for (i = 0, cur_pos = 0, fin = 0;
+	     (i < srb->use_sg) && !fin;
+	     cur_pos += sg->length, i++, sg++) {
+		kaddr = kmap_atomic(sg->page, KM_USER0);
+		kaddr_off = kaddr + sg->offset;
+
+		//DPRINTK(KERN_ERR "%s: cur_pos=%ld, sglen=%d kadoff=%p\n", __FUNCTION__,
+		//cur_pos, sg->length, kaddr_off);
+		if (NULL == kaddr)
+			return -1;
+
+		if (from <= cur_pos) {
+			start_pos = cur_pos;
+		}  else {
+			if (from < (cur_pos + sg->length)) {
+				/* copy start with middle of this segment */
+				start_pos = from;
+				kaddr_off += from - start_pos;
+			} else {
+				/* this segment does not have any desired data */
+				kunmap_atomic(kaddr, KM_USER0);
+				continue;
+			}
+		}
+
+		if (to < (cur_pos + sg->length)) {
+			/* copy end with middle of this segment */
+			end_pos = to;
+			fin = 1;
+		} else {
+			end_pos = cur_pos + sg->length;
+		}
+
+		if (start_pos < end_pos) {
+			//DPRINTK(KERN_ERR "%s: COPY start=%ld end=%ld kaddoff=%p\n", __FUNCTION__,
+			//start_pos, end_pos, kaddr_off);
+			memcpy(arr + len, kaddr_off, end_pos - start_pos);
+			len += end_pos - start_pos;
+		}
+		kunmap_atomic(kaddr, KM_USER0);
+
+	}
+	DPRINTK(KERN_ERR "%s: return ren=%ld\n", __FUNCTION__, len);
+	return len;
+}
+
+
+/*
+ * issue PACKET command according to passed SRB
+ * caller will block until the command completed.
+ * returns 0 if command sucessfully done,
+ * otherwise error detected.
+ * if auto_sense is on, request_sense is automatically issued and
+ * return the sense data into srb->sensebuffer[SCSI_SENSE_BUFFERSIZE]
+ * srb->result will be set.
+ * caller should call done(srb) to inform mid layer the command completed.
+ */
+static int issue_atapi_by_srb(struct ps3_stor_dev_info * dev_info,
+			      int auto_sense)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	struct lv1_atapi_cmnd_block atapi_cmnd;
+	const struct scsi_command_handler_info * handler_info;
+	unsigned char * cmnd = dev_info->srb->cmnd;
+	int bounce_len = 0;
+	int error;
+	unsigned char keys[4];
+
+	handler_info = &(dev_info->handler_info[cmnd[0]]);
+
+	/* check buffer size */
+	switch (handler_info->buflen) {
+	case USE_SRB_6:
+		bounce_len = cmnd[4];
+		break;
+	case USE_SRB_10:
+ 		bounce_len = (cmnd[7] << 8) | cmnd[8];
+		break;
+	case USE_CDDA_FRAME_RAW:
+		bounce_len = ((cmnd[6] << 16) |
+		       (cmnd[7] <<  8) |
+		       (cmnd[8] <<  0)) * CD_FRAMESIZE_RAW;
+		break;
+	default:
+		bounce_len = handler_info->buflen;
+	}
+
+	if (dev_info->dedicated_bounce_size < bounce_len ) {
+		static int printed;
+		if (!printed++)
+			printk(KERN_ERR "%s: data size too large %#x<%#x\n",
+			       __FUNCTION__,
+			       dev_info->dedicated_bounce_size,
+			       bounce_len);
+		dev_info->srb->result = DID_ERROR << 16;
+		memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+		dev_info->srb->sense_buffer[0] = 0x70;
+		dev_info->srb->sense_buffer[2] = ILLEGAL_REQUEST;
+		return -1;
+	}
+
+	memset(&atapi_cmnd, 0, sizeof(struct lv1_atapi_cmnd_block));
+	memcpy(&(atapi_cmnd.pkt), cmnd, 12);
+	atapi_cmnd.pktlen = 12;
+	atapi_cmnd.proto = handler_info->proto;
+	if (handler_info->in_out != DIR_NA)
+		atapi_cmnd.in_out = handler_info->in_out;
+
+	if (atapi_cmnd.in_out == DIR_WRITE)
+		fetch_to_dev_buffer(dev_info->srb, dev_info->bounce_buf, bounce_len);
+
+	atapi_cmnd.block_size = 1; /* transfer size is block_size * blocks */
+
+	atapi_cmnd.blocks = atapi_cmnd.arglen = bounce_len;
+	atapi_cmnd.buffer = ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf);
+
+	/* issue command */
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_send_device_command(lv1_dev_info->repo.did.dev_id,
+						LV1_STORAGE_SEND_ATAPI_COMMAND,
+						ps3_mm_phys_to_lpar(__pa(&atapi_cmnd)),
+						sizeof(struct lv1_atapi_cmnd_block),
+						atapi_cmnd.buffer,
+						atapi_cmnd.arglen,
+						&lv1_dev_info->current_tag);
+	if (error) {
+		printk(KERN_ERR "%s: send_device failed lv1dev=%u ret=%d\n",
+		       __FUNCTION__, lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: is better other error code ? */
+		return -1;
+	}
+
+	/* wait interrupt */
+	wait_for_completion(&(dev_info->irq_done));
+
+	/* check error */
+	if (!dev_info->lv1_status) {
+		/* OK, completed */
+		if (atapi_cmnd.in_out == DIR_READ)
+			fill_from_dev_buffer(dev_info->srb, dev_info->bounce_buf, bounce_len);
+		dev_info->srb->result = DID_OK << 16;
+		return 0;
+	}
+
+	/* error */
+	if (!auto_sense) {
+		dev_info->srb->result = (DID_ERROR << 16) | (CHECK_CONDITION << 1);
+		printk(KERN_ERR "%s: end error withtout autosense\n", __FUNCTION__);
+		return 1;
+	}
+
+	if (!decode_lv1_status(dev_info->lv1_status,
+			       &(keys[0]), &(keys[1]), &(keys[2]))) {
+		/* lv1 may have issued autosense ... */
+		dev_info->srb->sense_buffer[0]  = 0x70;
+		dev_info->srb->sense_buffer[2]  = keys[0];
+		dev_info->srb->sense_buffer[7]  = 16 - 6;
+		dev_info->srb->sense_buffer[12] = keys[1];
+		dev_info->srb->sense_buffer[13] = keys[2];
+		dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+	} else {
+		/* do auto sense by our selves*/
+		memset(&atapi_cmnd, 0, sizeof(struct lv1_atapi_cmnd_block));
+		atapi_cmnd.pkt[0] = REQUEST_SENSE;
+		atapi_cmnd.pkt[4] = 18;
+		atapi_cmnd.pktlen = 12;
+		atapi_cmnd.arglen = atapi_cmnd.blocks = atapi_cmnd.pkt[4];
+		atapi_cmnd.block_size = 1;
+		atapi_cmnd.proto = DMA_PROTO;
+		atapi_cmnd.in_out = DIR_READ;
+		atapi_cmnd.buffer = ps3_stor_virtual_to_lpar(dev_info,dev_info->bounce_buf);
+
+		/* issue REQUEST_SENSE command */
+		init_completion(&(dev_info->irq_done));
+		error = lv1_storage_send_device_command(lv1_dev_info->repo.did.dev_id,
+							LV1_STORAGE_SEND_ATAPI_COMMAND,
+							ps3_mm_phys_to_lpar(__pa(&atapi_cmnd)),
+							sizeof(struct lv1_atapi_cmnd_block),
+							atapi_cmnd.buffer,
+							atapi_cmnd.arglen,
+							&lv1_dev_info->current_tag);
+		if (error) {
+			printk(KERN_ERR "%s: send_device for request sense failed lv1dev=%u ret=%d\n", __FUNCTION__,
+			       lv1_dev_info->repo.did.dev_id, error);
+			dev_info->srb->result = DID_ERROR << 16; /* FIXME: is better other error code ? */
+			return -1;
+		}
+
+		/* wait interrupt */
+		wait_for_completion(&(dev_info->irq_done));
+
+		/* scsi spec says request sense should never get error */
+		if (dev_info->lv1_status) {
+			decode_lv1_status(dev_info->lv1_status,
+					  &(keys[0]), &(keys[1]), &(keys[2]));
+			printk(KERN_ERR "%s: auto REQUEST_SENSE error %#x %#x %#x\n", __FUNCTION__,
+			       keys[0], keys[1], keys[2]);
+		}
+
+		memcpy(dev_info->srb->sense_buffer, dev_info->bounce_buf,
+		       min((int)atapi_cmnd.pkt[4], SCSI_SENSE_BUFFERSIZE));
+		dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+	}
+
+	return 1;
+}
+
+/*
+ * just send command with auto REQUEST_SENSE
+ */
+static int ps3_stor_atapi_handle_simple(struct ps3_stor_dev_info * dev_info,
+				        struct scsi_cmnd * srb)
+{
+	int ret;
+
+	ret = issue_atapi_by_srb(dev_info, 1);
+	ps3_stor_srb_done(dev_info);
+	return ret;
+}
+
+/*
+ * just send command WITHOUT auto REQUEST_SENSE
+ */
+static int ps3_stor_atapi_handle_request_sense(struct ps3_stor_dev_info * dev_info, struct scsi_cmnd * srb)
+{
+	int ret;
+
+	ret = issue_atapi_by_srb(dev_info, 0);
+	ps3_stor_srb_done(dev_info);
+	return ret;
+}
+
+/******************************************************
+ * handlers for HDD
+ */
+
+static int ps3_stor_hdd_handle_inquiry(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	unsigned char inquiry_reply[PS3_STOR_MAX_INQUIRY_DATA_SIZE];
+	unsigned char *cmd = srb->cmnd;
+	const char * msg;
+	int alloc_len;
+	int ret;
+
+	FUNC_START;
+	alloc_len = (cmd[3] << 8) + cmd[4];
+	memset(inquiry_reply, 0, PS3_STOR_MAX_INQUIRY_DATA_SIZE);
+	inquiry_reply[0] = lv1_dev_info->device_type;
+	inquiry_reply[1] = 0;  /* Removable flag */
+	inquiry_reply[2] = 2;  /* ANSI version */
+	inquiry_reply[3] = 2;  /* response_data_format==2 */
+	inquiry_reply[4] = PS3_STOR_INQUIRY_DATA_SIZE - 5;
+
+	sprintf(&inquiry_reply[8], "%-8s", "SCEI");
+	if (lv1_dev_info->device_type == PS3_DEV_TYPE_STOR_DISK) {
+		switch (lv1_dev_info->attached_port) {
+		case 0:
+			msg = "Pri:Master";
+			break;
+		case 1:
+			msg = "Pri:Slave";
+			break;
+		case 2:
+			msg = "Sec:Master";
+			break;
+		case 3:
+			msg = "Sec:Slave";
+			break;
+		default:
+			msg = "Unknown";
+			break;
+
+		}
+	} else {
+		msg = "Flash";
+	}
+
+	/* SCSI spec requires model name left aligned, spece padded */
+	ret = sprintf(&inquiry_reply[16], "%s-%d", msg,
+		      lv1_dev_info->region_info_array[srb->cmnd[1]>>5].region_index);
+	if (ret < 16)
+		memset(&(inquiry_reply[16 + ret]), ' ', 16 - ret);
+
+	sprintf(&inquiry_reply[32], "%-4d", 4989);
+
+	inquiry_reply[58] = 0x0; inquiry_reply[59] = 0x40; /* SAM-2 */
+	inquiry_reply[60] = 0x3; inquiry_reply[61] = 0x0;  /* SPC-3 */
+	inquiry_reply[62] = 0x1; inquiry_reply[63] = 0x80; /* SBC */
+
+	ret = fill_from_dev_buffer(dev_info->srb, inquiry_reply, min(alloc_len, PS3_STOR_INQUIRY_DATA_SIZE));
+
+	srb->result = DID_OK << 16;
+	ps3_stor_srb_done(dev_info);
+	FUNC_END;
+	return ret;
+}
+
+
+static int ps3_stor_hdd_handle_request_sense(struct ps3_stor_dev_info * dev_info, struct scsi_cmnd * srb)
+{
+	unsigned char sense_data[PS3_STOR_SENSE_LEN];
+	int len = 18;
+
+	memset(sense_data, 0, PS3_STOR_SENSE_LEN);
+
+	if (dev_info->lv1_status) {
+		if (!decode_lv1_status(dev_info->lv1_status,
+				       &(sense_data[2]),
+				       &(sense_data[12]),
+				       &(sense_data[13]))) {
+		} else {
+			/* unknown error */
+			printk(KERN_ERR "%s: FIXME issue real RS %#lx %d\n",
+			       __FUNCTION__, dev_info->lv1_status,
+			       dev_info->lv1_retval);
+			sense_data[2] = HARDWARE_ERROR;
+			dev_info->srb->result = DID_OK << 16;
+		}
+		sense_data[0] = 0x70;
+	} else {
+		/* no sense */
+		sense_data[0] = 0x70;
+		dev_info->srb->result = DID_OK << 16;
+	}
+
+	fill_from_dev_buffer(dev_info->srb, sense_data, len);
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+static int ps3_stor_hdd_handle_just_ok(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	dev_info->srb->result = DID_OK << 16;
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+static int ps3_stor_hdd_handle_sync_cache(struct ps3_stor_dev_info * dev_info,
+					  struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	unsigned char keys[4];
+	int error;
+
+	/* issue command */
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_send_device_command(lv1_dev_info->repo.did.dev_id,
+						LV1_STORAGE_ATA_HDDOUT,
+						0,
+						0,
+						0,
+						0,
+						&lv1_dev_info->current_tag);
+	if (error) {
+		/* error */
+		printk(KERN_ERR "%s: send_device failed. lv1dev=%u ret=%d\n",
+		       __FUNCTION__, lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: is better other error code? */
+	} else {
+		/* wait interrupt */
+		wait_for_completion(&(dev_info->irq_done));
+
+		/* check error */
+		if (!dev_info->lv1_status) {
+			dev_info->srb->result = DID_OK << 16;
+		} else {
+			decode_lv1_status(dev_info->lv1_status,
+					  &(keys[0]), &(keys[1]), &(keys[2]));
+			dev_info->srb->sense_buffer[0]  = 0x70;
+			dev_info->srb->sense_buffer[2]  = keys[0];
+			dev_info->srb->sense_buffer[7]  = 16 - 6;
+			dev_info->srb->sense_buffer[12] = keys[1];
+			dev_info->srb->sense_buffer[13] = keys[2];
+			dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+		}
+	}
+
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+static int ps3_stor_hdd_handle_read_capacity(struct ps3_stor_dev_info * dev_info, struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	unsigned char data[PS3_STOR_READCAP_DATA_SIZE];
+	u64 len;
+	int ret;
+
+	FUNC_START;
+	memset(data, 0, sizeof(data));
+	len = lv1_dev_info->region_info_array[srb->cmnd[1] >> 5].region_size - 1;
+	data[0] = (len >> 24) & 0xff;
+	data[1] = (len >> 16) & 0xff;
+	data[2] = (len >> 8)  & 0xff;
+	data[3] =  len        & 0xff;
+
+	len = lv1_dev_info->sector_size;
+	data[4] = (len >> 24) & 0xff;
+	data[5] = (len >> 16) & 0xff;
+	data[6] = (len >> 8)  & 0xff;
+	data[7] =  len        & 0xff;
+
+	ret = fill_from_dev_buffer(dev_info->srb, data, PS3_STOR_READCAP_DATA_SIZE);
+	dev_info->srb->result = DID_OK << 16;
+	ps3_stor_srb_done(dev_info);
+	FUNC_END;
+	return ret;
+}
+
+
+static int copy_page_data(unsigned char * buf, const unsigned char * data,
+			   int length, int changable)
+{
+	if (changable) {
+		/* reports no parameters are changable */
+		memcpy(buf, data, 2);
+		memset(buf + 2, 0, length - 2);
+	} else {
+		memcpy(buf, data, length);
+	}
+	return length;
+}
+
+static int fill_mode_page(struct ps3_stor_dev_info * dev_info,
+			  unsigned char *buf, int page, int changable)
+{
+	int length;
+
+	switch (page){
+	case 8:
+		/* TYPE_DISK; see sd_read_cache_type():sd.c */
+		length = copy_page_data(buf, page_data_8, sizeof(page_data_8), changable);
+		break;
+	case 6:
+		/* TYPE_RBC */
+		length = copy_page_data(buf, page_data_6, sizeof(page_data_6), changable);
+		break;
+	case 0x3f: /* ALL PAGES, but sd.c checks only parameter header to see WriteProtect */
+		length  = copy_page_data(buf, page_data_6, sizeof(page_data_6), changable);
+		length += copy_page_data(buf + length, page_data_8, sizeof(page_data_8), changable);
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown page=%#x\n", __FUNCTION__, page);
+		return 0;
+	}
+
+	return length;
+}
+
+/*
+ * scsi disk driver asks only PAGE= 0x3f, 6(RBC), 8(SCSI disk)
+ */
+static int ps3_stor_hdd_handle_mode_sense(struct ps3_stor_dev_info * dev_info,
+					  struct scsi_cmnd * srb)
+{
+	unsigned char sense_data[128];
+	int offset = 0;
+
+	/*
+	 * NOTE: support MODE_SENSE_10 only
+	 * see slave_cofigure()
+	 */
+	memset(sense_data, 0, sizeof(sense_data));
+	/* parameter header */
+	sense_data[2] = dev_info->lv1_dev_info->device_type;
+	sense_data[3] = 0;      /* mid layer wants to see here     */
+	/* bit 7=1 means WriteProtected    */
+	offset = fill_mode_page(dev_info,
+				&(sense_data[8]),
+				dev_info->srb->cmnd[2] & 0x3f,
+				dev_info->srb->cmnd[2] & 0xc0);
+	sense_data[1] = offset + 8;        /* parameter length */
+	sense_data[0] = (offset + 8) >> 8;
+
+	fill_from_dev_buffer(dev_info->srb, sense_data, offset + 8);
+	ps3_stor_srb_done(dev_info);
+	return 0;
+}
+
+
+/*
+ * convert kernel virtal address to lpar address for storage IO
+ * NOTE: va should be within allocated special buffer
+ *       if DEDICATED_SPECIAL bounce type
+ */
+static u64 ps3_stor_virtual_to_lpar(struct ps3_stor_dev_info *dev_info,
+				    void *va)
+{
+	if (unlikely(dev_info->bounce_type == DEDICATED_SPECIAL)) {
+		return dev_info->separate_bounce_lpar + (va - dev_info->bounce_buf);
+	} else {
+		return ps3_mm_phys_to_lpar(__pa(va));
+	}
+}
+
+
+static int ps3_stor_common_handle_read(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	int error;
+	u64 lpar_addr;
+	unsigned int region_id;
+	u32 sectors = 0;
+	u32 start_sector = 0;
+	unsigned char *cmnd = dev_info->srb->cmnd;
+	int ret = 0;
+
+	/* check transfer length */
+	switch (cmnd[0]) {
+	case READ_10:
+		start_sector = (cmnd[2] << 24) +
+			(cmnd[3] << 16) +
+			(cmnd[4] <<  8) +
+			cmnd[5];
+		sectors = (cmnd[7] << 8) +
+			cmnd[8];
+		break;
+	case READ_6:
+		start_sector = (cmnd[1] << 16) +
+			(cmnd[2] <<  8) +
+			cmnd[3];
+		sectors = cmnd[4];
+		break;
+
+	}
+
+	/* issue read */
+	down_read(&dev_info->bounce_sem);
+	lpar_addr = ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf);
+	region_id = lv1_dev_info->region_info_array[(cmnd[1] >> 5)].region_id;
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+				 region_id,
+				 start_sector,
+				 sectors,
+				 0, /* flags */
+				 lpar_addr,
+				 &lv1_dev_info->current_tag);
+	if (error) {
+		/* error */
+		printk(KERN_ERR "%s: error lv1dev =%u ret=%d\n", __FUNCTION__,
+		       lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+		ret = -1;
+	} else {
+		/* wait irq */
+		wait_for_completion(&(dev_info->irq_done));
+		if (dev_info->lv1_status) {
+			/* error */
+			memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+			decode_lv1_status(dev_info->lv1_status,
+					  &(dev_info->srb->sense_buffer[2]),
+					  &(dev_info->srb->sense_buffer[12]),
+					  &(dev_info->srb->sense_buffer[13]));
+			dev_info->srb->sense_buffer[7] = 16 - 6;
+			dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+			ret =  1;
+		} else {
+			/* OK */
+			fill_from_dev_buffer(dev_info->srb,
+					     dev_info->bounce_buf,
+					     sectors * dev_info->sector_size);
+
+			dev_info->srb->result = DID_OK << 16;
+			ret =  0;
+		}
+	}
+
+	ps3_stor_srb_done(dev_info);
+	up_read(&dev_info->bounce_sem);
+	return ret;
+}
+
+static int ps3_stor_common_handle_write(struct ps3_stor_dev_info * dev_info,
+					struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	int ret;
+	int error;
+	u64 lpar_addr;
+	unsigned int region_id;
+	u32 start_sector = 0;
+	u32 sectors = 0;
+	unsigned char * cmnd = dev_info->srb->cmnd;
+
+	/* check transfer length */
+	switch (cmnd[0]) {
+	case WRITE_10:
+		start_sector = (cmnd[2] << 24) +
+			(cmnd[3] << 16) +
+			(cmnd[4] <<  8) +
+			cmnd[5];
+		sectors = (cmnd[7] << 8) +
+			cmnd[8];
+		break;
+	case WRITE_6:
+		start_sector = (cmnd[1] << 16) +
+			(cmnd[2] <<  8) +
+			cmnd[3];
+		sectors = cmnd[4];
+		break;
+	}
+
+	down_read(&dev_info->bounce_sem);
+	ret = fetch_to_dev_buffer(dev_info->srb,
+				  dev_info->bounce_buf,
+				  sectors * dev_info->sector_size);
+
+	lpar_addr = ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf);
+	region_id = lv1_dev_info->region_info_array[(cmnd[1] >> 5)].region_id;
+	init_completion(&(dev_info->irq_done));
+	error = lv1_storage_write(lv1_dev_info->repo.did.dev_id,
+				  region_id, /* region id */
+				  start_sector,
+				  sectors,
+				  0, /* flags */
+				  lpar_addr/*srb->request_buffer*/, /* assume non SG! */
+				  &lv1_dev_info->current_tag);
+	if (error) {
+		/* error */
+		printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n", __FUNCTION__,
+		       lv1_dev_info->repo.did.dev_id, error);
+		dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+		ret = -1;
+	} else {
+
+		/* wait irq */
+		wait_for_completion(&(dev_info->irq_done));
+
+		if (dev_info->lv1_status) {
+			/* error */
+			memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+			decode_lv1_status(dev_info->lv1_status,
+					  &(dev_info->srb->sense_buffer[2]),
+					  &(dev_info->srb->sense_buffer[12]),
+					  &(dev_info->srb->sense_buffer[13]));
+			dev_info->srb->sense_buffer[7] = 16 - 6;
+			dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+			ret = 1;
+		} else {
+			/* OK */
+			dev_info->srb->result = DID_OK << 16;
+			ret = 0;
+		}
+
+	}
+	ps3_stor_srb_done(dev_info);
+	up_read(&dev_info->bounce_sem);
+	return ret;
+}
+
+static int is_aligned_flash(u32 sector, int sector_size)
+{
+	u32 flash_align_sector = FLASH_ALIGN / sector_size;
+
+	return (sector % flash_align_sector)? 0 : 1;
+}
+
+static u32 floor_align_flash(u32 sector, int sector_size)
+{
+	u32 flash_align_sector = FLASH_ALIGN / sector_size;
+
+	return sector & ~(flash_align_sector - 1);
+}
+
+static u32 ceil_align_flash(u32 sector, int sector_size)
+{
+	u32 flash_align_sector = FLASH_ALIGN / sector_size;
+
+	return (sector + (flash_align_sector - 1)) & ~(flash_align_sector - 1);
+}
+
+/*
+ * special handling for flash drive; do safer way to write in order to reduce
+ * the risk of flash corruption by sudden power off.
+ */
+static int ps3_stor_handle_write_flash(struct ps3_stor_dev_info * dev_info,
+				       struct scsi_cmnd * srb)
+{
+	struct ps3_stor_lv1_dev_info *lv1_dev_info = dev_info->lv1_dev_info;
+	int ret = 0;
+	int error;
+	u64 sector_size;
+	u64 lpar_addr;
+	unsigned int region_id;
+	u64 start_sector = 0;
+	u64 start_sector_aligned = 0;
+	u64 sectors = 0;
+	u64 sectors_aligned = 0;
+	u64 current_sector;
+	u64 aligned_sector_count;
+	unsigned char * cmnd = dev_info->srb->cmnd;
+	void * current_buffer;
+	struct ps3_stor_lv1_region_info * region_info;
+
+	static int align_warned;
+
+	DPRINTK(KERN_ERR "%s: start\n", __FUNCTION__);
+
+	/* check transfer length */
+	switch (cmnd[0]) {
+	case WRITE_10:
+		start_sector = (cmnd[2] << 24) +
+			(cmnd[3] << 16) +
+			(cmnd[4] <<  8) +
+			cmnd[5];
+		sectors = (cmnd[7] << 8) +
+			cmnd[8];
+		break;
+	case WRITE_6:
+		start_sector = (cmnd[1] << 16) +
+			(cmnd[2] <<  8) +
+			cmnd[3];
+		sectors = cmnd[4];
+		break;
+	}
+
+
+        /*
+         *    start_sector_aligned
+         *   /          start_sector
+         *  /          /
+         * +----------+--------------------+---+
+         *            |<-    sectors     ->|   |
+         *            |<-   sectors_aligned  ->|
+         *
+         * ^-----------------------------------^ 256K align
+         */
+	sector_size = dev_info->sector_size;
+	aligned_sector_count = FLASH_ALIGN / sector_size;
+
+	start_sector_aligned = floor_align_flash(start_sector, sector_size);
+	sectors_aligned = ceil_align_flash(start_sector + sectors, sector_size) - start_sector;
+
+	/* check aligned border exceed region */
+	region_info = &lv1_dev_info->region_info_array[cmnd[1] >> 5];
+	if (!is_aligned_flash(region_info->region_start, sector_size) ||
+	    (region_info->region_size < (start_sector_aligned + sectors_aligned))) {
+		if (!align_warned) {
+			printk(KERN_ERR "%s: region alignment is not 256k, continue to work with norman method\n",
+			       __FUNCTION__);
+			align_warned = 1;
+		}
+		return ps3_stor_common_handle_write(dev_info, srb);
+	};
+
+	down_read(&dev_info->bounce_sem);
+	region_id = region_info->region_id;
+
+
+	DPRINTK(KERN_ERR "%s: start=%#lx(%ld) start_a=%#lx(%ld) sec=%#lx(%ld) sec_a=%#lx(%ld)\n", __FUNCTION__,
+		start_sector, start_sector,
+		start_sector_aligned, start_sector_aligned,
+		sectors, sectors,
+		sectors_aligned, sectors_aligned);
+
+	/*
+	 * loop in the case that the requested write sectors across
+	 * 245Kb alignment.  Since we have set max_sectors as 256kb,
+	 * loop count is up to 2.
+	 */
+	for (current_sector = start_sector_aligned, ret = 0;
+	     (current_sector < (start_sector + sectors_aligned)) && !ret;
+	     current_sector += aligned_sector_count) {
+
+		DPRINTK(KERN_ERR "%s: LOOP current=%#lx\n", __FUNCTION__, current_sector);
+
+		current_buffer = dev_info->bounce_buf;
+
+		/* read from (start_sector_aligned) to (start_sector) */
+		if (current_sector < start_sector) {
+			DPRINTK(KERN_ERR "%s: head read \n", __FUNCTION__);
+			lpar_addr = ps3_stor_virtual_to_lpar(dev_info,
+							     current_buffer);
+			init_completion(&(dev_info->irq_done));
+			error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+						 region_id,
+						 current_sector,
+						 start_sector - current_sector,
+						 0,
+						 lpar_addr,
+						 &lv1_dev_info->current_tag);
+			DPRINTK(KERN_ERR "HEAD start=%#lx, len=%#lx\n",
+				start_sector_aligned, (start_sector - start_sector_aligned));
+			if (error) {
+				/* error */
+				printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n",
+				       __FUNCTION__,
+				       lv1_dev_info->repo.did.dev_id, error);
+				dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+				ret = -1;
+				goto done;
+			} else {
+				/* wait irq */
+				wait_for_completion(&(dev_info->irq_done));
+			}
+			if (dev_info->lv1_status) {
+				/* error */
+				memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+				decode_lv1_status(dev_info->lv1_status,
+						  &(dev_info->srb->sense_buffer[2]),
+						  &(dev_info->srb->sense_buffer[12]),
+						  &(dev_info->srb->sense_buffer[13]));
+				dev_info->srb->sense_buffer[7] = 16 - 6;
+				dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+				ret = 1;
+				goto done;
+			} else {
+				/* OK */
+				ret = 0;
+				current_buffer += (start_sector - start_sector_aligned) * sector_size;
+			}
+		} /* head remainder */
+
+
+		if ((start_sector + sectors) < (current_sector + aligned_sector_count)) {
+			void * buf = dev_info->bounce_buf;
+			DPRINTK(KERN_ERR "%s: tail read\n", __FUNCTION__);
+			buf += (start_sector + sectors - current_sector) * sector_size;
+			lpar_addr = ps3_stor_virtual_to_lpar(dev_info, buf);
+			init_completion(&(dev_info->irq_done));
+			error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+						 region_id,
+						 start_sector + sectors,
+						 sectors_aligned - sectors,
+						 0,
+						 lpar_addr,
+						 &lv1_dev_info->current_tag);
+			DPRINTK(KERN_ERR "TAIL start=%#lx, len=%#lx\n",
+				start_sector + sectors, sectors_aligned - sectors);
+			if (error) {
+				/* error */
+				printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n",
+				       __FUNCTION__,
+				       lv1_dev_info->repo.did.dev_id, error);
+				dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+				ret = -1;
+				goto done;
+			} else {
+				/* wait irq */
+				wait_for_completion(&(dev_info->irq_done));
+			}
+			if (dev_info->lv1_status) {
+				/* error */
+				memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+				decode_lv1_status(dev_info->lv1_status,
+						  &(dev_info->srb->sense_buffer[2]),
+						  &(dev_info->srb->sense_buffer[12]),
+						  &(dev_info->srb->sense_buffer[13]));
+				dev_info->srb->sense_buffer[7] = 16 - 6;
+				dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+				ret = 1;
+				goto done;
+			} else {
+				/* OK */
+				ret = 0;
+			}
+		} /* tail remainder */
+
+		{
+			u64 copy_sectors_from, copy_sectors_to;
+
+			/* start_sector is within this iteration */
+			if ((current_sector < start_sector)  &&
+			    (start_sector < (current_sector + aligned_sector_count))) {
+				copy_sectors_from = start_sector;
+			}
+			else {
+				copy_sectors_from = current_sector;
+			}
+
+			/* start_sector+sectors is within this iteration */
+			if ((current_sector < (start_sector + sectors))  &&
+			    ((start_sector + sectors) < (current_sector + aligned_sector_count))) {
+				copy_sectors_to = start_sector + sectors;
+			}
+			else {
+				copy_sectors_to = current_sector + aligned_sector_count;
+			}
+
+			DPRINTK(KERN_ERR "%s: copy to current=%p\n", __FUNCTION__, current_buffer);
+			ret = fetch_to_dev_buffer_abs(dev_info->srb,
+						      current_buffer,
+						      (copy_sectors_from - start_sector) * sector_size,
+						      (copy_sectors_to - start_sector) * sector_size);
+		} /* write data */
+
+		/* write 256K */
+		DPRINTK(KERN_ERR "%s: WRITE sector=%#lx\n", __FUNCTION__, current_sector);
+		lpar_addr = ps3_stor_virtual_to_lpar(dev_info,
+						     dev_info->bounce_buf);
+		init_completion(&(dev_info->irq_done));
+		error = lv1_storage_write(lv1_dev_info->repo.did.dev_id,
+					  region_id,
+					  current_sector,
+					  aligned_sector_count,
+					  0,
+					  lpar_addr,
+					  &lv1_dev_info->current_tag);
+		if (error) {
+			/* error */
+			printk(KERN_ERR "%s: error lv1dev=%u ret=%d\n",
+			       __FUNCTION__, lv1_dev_info->repo.did.dev_id,
+			       error);
+			dev_info->srb->result = DID_ERROR << 16; /* FIXME: other error code? */
+			ret = -1;
+		} else {
+
+			/* wait irq */
+			wait_for_completion(&(dev_info->irq_done));
+
+			if (dev_info->lv1_status) {
+				/* error */
+				memset(dev_info->srb->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
+				decode_lv1_status(dev_info->lv1_status,
+						  &(dev_info->srb->sense_buffer[2]),
+						  &(dev_info->srb->sense_buffer[12]),
+						  &(dev_info->srb->sense_buffer[13]));
+				dev_info->srb->sense_buffer[7] = 16 - 6;
+				dev_info->srb->result = SAM_STAT_CHECK_CONDITION;
+				ret = 1;
+			} else {
+				/* OK */
+				dev_info->srb->result = DID_OK << 16;
+				ret = 0;
+			}
+
+		}
+	} /* for */
+ done:
+	ps3_stor_srb_done(dev_info);
+	up_read(&dev_info->bounce_sem);
+	DPRINTK(KERN_ERR "%s: end\n", __FUNCTION__);
+	return ret;
+}
+
+/*
+ * NOTE: If return 1, all buffers communicate with the device
+ *       should be in dedicated buffer area.
+ *       Currently common_handle_read, common_handle_write know this
+ *       restriction.
+ *       And should implement remap function in ps3_stor_set_max_sectors()
+ */
+static int need_dedicated_dma_region(enum ps3_dev_type device_type)
+{
+	int ret = 0;
+	switch (device_type) {
+	case PS3_DEV_TYPE_STOR_FLASH:
+		ret = 1; /* should be 1 */
+		break;
+	case PS3_DEV_TYPE_STOR_ROM:
+		ret = 0;
+		break;
+	case PS3_DEV_TYPE_STOR_DISK:
+		ret = 0;
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown type =%u\n", __FUNCTION__,
+		       device_type);
+		ret =  0;
+		break;
+	}
+	return ret;
+}
+/*
+ * allocate static(dedicated) bounce buffer
+ */
+static int get_dedicated_buffer_type(enum ps3_dev_type device_type)
+{
+	int ret = 0;
+	switch (device_type) {
+	case PS3_DEV_TYPE_STOR_FLASH:
+		ret = DEDICATED_SPECIAL;
+		break;
+	case PS3_DEV_TYPE_STOR_ROM:
+		ret = DEDICATED_KMALLOC;
+		break;
+	case PS3_DEV_TYPE_STOR_DISK:
+		ret = DEDICATED_KMALLOC;
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown type =%u\n", __FUNCTION__,
+		       device_type);
+		ret =  0;
+		break;
+	}
+	return ret;
+}
+
+
+extern unsigned long ps3_mem_total;
+extern unsigned long ps3_rm_limit;
+extern unsigned long ps3_2nd_mem_base;
+extern unsigned long ps3_2nd_mem_size;
+
+#define PS3_PCI_DMA_SIZE(mem) ((((mem -1) >> 27) + 1 ) << 27) /* 2^27=128M */
+#define PS3_PCI_IO_PAGESIZE      24
+
+static u64 ps3_allocate_dma_region(const struct ps3_device_id *did)
+{
+	u64 size, io_size, io_pagesize;
+	u64 dma, flg = 0;
+	int error;
+
+	io_size = PS3_PCI_DMA_SIZE(ps3_mem_total);
+	io_pagesize = PS3_PCI_IO_PAGESIZE;
+	error = lv1_allocate_device_dma_region(did->bus_id, did->dev_id,
+					       io_size, io_pagesize, flg,
+					       &dma);
+	if (error) {
+		printk("lv1_allocate_device_dma_region faild, error=%d\n",
+			error);
+		return 0;
+	}
+
+	size = ps3_rm_limit;
+	error = lv1_map_device_dma_region(did->bus_id, did->dev_id,
+					  0, /* lpar addr */
+					  dma, /* I/O addr */
+					  size,
+					  0xf800000000000000UL  /* flags */);
+	if (error) {
+		printk("lv1_map_device_dma_region faild, error=%d\n", error);
+		return 0;
+	}
+
+	size = ps3_2nd_mem_size;
+	error = lv1_map_device_dma_region(did->bus_id, did->dev_id,
+					  ps3_2nd_mem_base,   /* lpar addr */
+					  ps3_rm_limit + dma, /* I/O addr */
+					  size,
+					  0xf800000000000000UL  /* flags */);
+
+	if (error) {
+		printk("lv1_map_device_dma_region faild, error=%d\n", error);
+		return 0;
+	}
+	return dma;
+}
+
+static u64 ps3_free_dma_region(const struct ps3_device_id *did, u64 dma)
+{
+	u64 size, io_size, io_pagesize;
+	int error;
+
+	io_size = PS3_PCI_DMA_SIZE(ps3_mem_total);
+	io_pagesize = PS3_PCI_IO_PAGESIZE;
+
+	if (dma == 0)
+		return 0;
+
+	/* unmap dma_region */
+	size = ps3_rm_limit;
+	error = lv1_unmap_device_dma_region(did->bus_id, did->dev_id,
+					    dma, /* I/O addr */
+					    size);
+	if (error)
+		printk("lv1_unmap_device_dma_region faild, error=%d\n", error);
+	size = ps3_2nd_mem_size;
+	error = lv1_unmap_device_dma_region(did->bus_id, did->dev_id,
+					    ps3_rm_limit +  dma, /* I/O addr */
+					    size);
+
+	if (error)
+		printk("lv1_unmap_device_dma_region faild, error=%d\n", error);
+
+	/* free dma region */
+	error = lv1_free_device_dma_region(did->bus_id, did->dev_id, dma);
+	if (error)
+		printk("lv1_free_device_dma_region faild, error=%d\n", error);
+	return 0;
+}
+
+
+static void *ps3_stor_alloc_separate_memory(int alloc_size, u64 *lpar_addr)
+{
+	void * va;
+	BUG_ON(alloc_size != ps3_stor_bounce_buffer.size);
+	va = ps3_stor_bounce_buffer.address;
+	*lpar_addr = ps3_mm_phys_to_lpar(__pa(va));
+	return va;
+}
+
+static int ps3_stor_release_separate_memory(void *va, u64 lpar)
+{
+	/* Nothing to release anymore */
+	return 0;
+}
+
+
+static int get_default_max_sector(struct ps3_stor_lv1_dev_info * lv1_dev_info)
+{
+	int ret = 0;
+	switch (lv1_dev_info->device_type) {
+	case PS3_DEV_TYPE_STOR_FLASH:
+		ret = FLASH_ALIGN / lv1_dev_info->sector_size;
+		break;
+	case PS3_DEV_TYPE_STOR_ROM:
+		ret = 32;
+		break;
+	case PS3_DEV_TYPE_STOR_DISK:
+		ret =  128;
+		break;
+	default:
+		printk(KERN_ERR "%s: unknown type =%u\n", __FUNCTION__,
+		       lv1_dev_info->device_type);
+		ret =  0;
+		break;
+	}
+	return ret;
+}
+
+
+static irqreturn_t ps3_stor_hdd_irq_handler(int irq, void * context)
+{
+	struct ps3_stor_lv1_dev_info * lv1_dev_info = context;
+	struct ps3_stor_dev_info * dev_info = lv1_dev_info->dev_info;
+	int ret_val = IRQ_HANDLED;
+	u64 tag;
+
+	if (dev_info) {
+		dev_info->lv1_retval = lv1_storage_get_async_status(lv1_dev_info->repo.did.dev_id,
+								    &tag,
+								    (u64 *)&dev_info->lv1_status);
+		/*
+		 * lv1_status = -1 may mean that ATAPI transport completed OK, but ATAPI command
+		 * itself resulted CHECK CONDITION
+		 * so, upper layer should issue REQUEST_SENSE to check the sense data
+		 */
+		if (tag != lv1_dev_info->current_tag)
+			printk("%s: tag=%#lx ctag=%#lx\n", __FUNCTION__,
+			       tag, lv1_dev_info->current_tag);
+		if (dev_info->lv1_retval) {
+			printk("%s: ret=%d status=%#lx\n", __FUNCTION__,
+			       dev_info->lv1_retval, dev_info->lv1_status);
+			//if (dev_info->lv1_retval == LV1_NO_ENTRY)
+			//ret_val = IRQ_NONE;
+		} else {
+			complete(&(dev_info->irq_done));
+		}
+	}
+	return ret_val;
+}
+
+
+/*
+ * return 1 specified region is accessible from linux
+ */
+static irqreturn_t ps3_stor_temporary_irq_handler(int irq, void * context)
+{
+	struct ps3_stor_quirk_probe_info * info = context;
+
+	info->lv1_retval = lv1_storage_get_async_status(info->device_id,
+							&info->lv1_ret_tag,
+							&info->lv1_status);
+	complete(&(info->irq_done));
+
+	return IRQ_HANDLED;
+}
+
+static int is_region_accessible(struct ps3_stor_lv1_dev_info * lv1_dev_info,
+				unsigned int region_id)
+{
+	int accessible = 0;
+	unsigned int irq_plug_id, dma_region;
+	void * buf;
+	struct ps3_stor_quirk_probe_info info;
+	int error;
+
+	/*
+	 * special case
+	 * cd-rom is assumed always accessible
+	 */
+	if (lv1_dev_info->device_type == PS3_DEV_TYPE_STOR_ROM)
+		return 1;
+
+	/*
+	 * 1. open the device
+	 * 2. register irq for the device
+	 * 3. connect irq
+	 * 4. map dma region
+	 * 5. do read
+	 * 6. umap dma region
+	 * 7. disconnect irq
+	 * 8. unregister irq
+	 * 9. close the device
+	 */
+	memset(&info, 0, sizeof(info));
+
+	error = lv1_open_device(lv1_dev_info->repo.did.bus_id,
+				lv1_dev_info->repo.did.dev_id, 0);
+	if (error)
+		return 0;
+
+	error = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+				      &lv1_dev_info->repo.did,
+				      lv1_dev_info->interrupt_id,
+				      &irq_plug_id);
+	if (error) {
+		printk("%s:%u: ps3_sb_event_receive_port_setup failed (%d)\n",
+		       __func__, __LINE__, error);
+		goto fail_close_device;
+	}
+
+	error = request_irq(irq_plug_id, ps3_stor_temporary_irq_handler,
+			    IRQF_DISABLED, "PS3 quirk", &info);
+	if (error) {
+		printk("%s:%d: request_irq failed (%d)\n", __func__, __LINE__,
+		       error);
+		goto fail_event_receive_port_destroy;
+	}
+
+	dma_region = ps3_allocate_dma_region(&lv1_dev_info->repo.did);
+	if (!dma_region)
+		goto fail_free_irq;
+
+	/* 4k buffer is for fail safe of large sector devices */
+	buf = kmalloc(4096, GFP_KERNEL);
+	if (!buf) {
+		printk(KERN_ERR "%s: no memory while probing dev=%u",
+		       __FUNCTION__, lv1_dev_info->repo.did.dev_id);
+		goto fail_free_dma_region;
+	};
+
+	init_completion(&(info.irq_done));
+	info.device_id = lv1_dev_info->repo.did.dev_id;
+	error = lv1_storage_read(lv1_dev_info->repo.did.dev_id,
+				 region_id,
+				 0, /* start sector */
+				 1, /* sector count */
+				 0, /* flags */
+				 ps3_mm_phys_to_lpar(__pa(buf)), /* no need special convert */
+				 &info.lv1_tag);
+	if (error)
+		goto fail_free_buf;
+
+	wait_for_completion(&(info.irq_done));
+
+	if (!info.lv1_retval && !info.lv1_status) {
+		if (info.lv1_tag != info.lv1_ret_tag) {
+			printk(KERN_ERR "%s: tag mismached dev=%u\n",
+			       __FUNCTION__, lv1_dev_info->repo.did.dev_id);
+		} else
+			accessible = 1;
+	}
+
+fail_free_buf:
+	kfree(buf);
+fail_free_dma_region:
+	ps3_free_dma_region(&lv1_dev_info->repo.did, dma_region);
+fail_free_irq:
+	free_irq(irq_plug_id, &info);
+fail_event_receive_port_destroy:
+	ps3_sb_event_receive_port_destroy(&lv1_dev_info->repo.did,
+					  lv1_dev_info->interrupt_id,
+					  irq_plug_id);
+fail_close_device:
+	lv1_close_device(lv1_dev_info->repo.did.bus_id,
+			 lv1_dev_info->repo.did.dev_id);
+
+	return accessible;
+}
+
+static unsigned int ps3_stor_enum_storage_type(enum ps3_dev_type device_type)
+{
+	struct ps3_repository_device repo, *prev = NULL;
+	unsigned int devices = 0;
+	int error;
+	unsigned int interrupt_id, regions, region_id;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info;
+	u64 port, blksize, blocks, region_size, region_start;
+	unsigned int i, j, accessible_regions;
+
+	while (!(error = ps3_repository_find_device(PS3_BUS_TYPE_STORAGE,
+						    device_type, prev,
+						    &repo))) {
+		prev = &repo;
+		error = ps3_repository_find_interrupt(&repo,
+				PS3_INTERRUPT_TYPE_EVENT_PORT, &interrupt_id);
+		if (error) {
+			printk(KERN_ERR "%s: find_interrupt failed (%d)\n",
+			       __FUNCTION__, error);
+			continue;
+		}
+
+		error = ps3_repository_read_stor_dev_info(repo.bus_index,
+							  repo.dev_index,
+							  &port, &blksize,
+							  &blocks, &regions);
+		if (error) {
+			printk(KERN_ERR "%s: read_stor_dev_info failed\n",
+			       __FUNCTION__);
+			continue;
+		}
+
+		/* LUN limitation */
+		if (regions > 8) {
+			printk(KERN_ERR "%s: region count exceeded (%u).  the rest are ignored\n",
+			       __FUNCTION__, regions);
+			regions = 8;
+		}
+
+		lv1_dev_info = &(ps3_stor_lv1_dev_info_array[ps3_stor_lv1_devnum]);
+		INIT_LIST_HEAD(&(lv1_dev_info->bus_dev_list));
+
+		lv1_dev_info->repo = repo;
+		lv1_dev_info->device_type = device_type;
+		lv1_dev_info->interrupt_id = interrupt_id;
+		lv1_dev_info->sector_size = blksize;
+		lv1_dev_info->attached_port = port;
+		lv1_dev_info->regions = regions;
+
+		/* check how many regions are accessible */
+		accessible_regions = 0;
+		for (i = 0; i < regions; i++) {
+			if (is_region_accessible(lv1_dev_info, i)) {
+				set_bit(i, &(lv1_dev_info->accessible_region_flag));
+				accessible_regions ++;
+			}
+		}
+		if (!accessible_regions) {
+		    printk(KERN_WARNING "No accessible regions found\n");
+		    continue;
+		}
+
+		lv1_dev_info->region_info_array = kzalloc(sizeof(struct ps3_stor_lv1_region_info) * accessible_regions,
+							  GFP_KERNEL);
+		if (!lv1_dev_info->region_info_array) {
+			printk(KERN_ERR "%s: kzalloc failed for info array\n",
+			       __FUNCTION__);
+			continue;
+		}
+
+		lv1_dev_info->accessible_regions = accessible_regions;
+		for (i = j = 0; i < regions; i++) {
+			if (!test_bit(i, &lv1_dev_info->accessible_region_flag))
+				continue;
+
+			if (ps3_repository_read_stor_dev_region(repo.bus_index,
+							        repo.dev_index,
+								i, &region_id,
+							        &region_start,
+							        &region_size)) {
+				printk(KERN_ERR "%s: read_stor_dev_region failed\n",
+				       __FUNCTION__);
+				continue;
+			}
+			printk(KERN_INFO "Region %u: id %u start %lu size %lu\n",
+			       i, region_id, region_start, region_size);
+			lv1_dev_info->region_info_array[j].region_index = i;
+			lv1_dev_info->region_info_array[j].region_id = region_id;
+			lv1_dev_info->region_info_array[j].region_start = region_start;
+			lv1_dev_info->region_info_array[j].region_size = region_size;
+			j++;
+		}
+		printk(KERN_INFO "ps3_stor: dev=%u type=%u port=%lu regions=%u accessible=%u\n",
+		       repo.did.dev_id, device_type, port, regions,
+		       accessible_regions);
+		ps3_stor_lv1_devnum++;
+
+		devices++;
+	}
+	if (error != -ENODEV)
+		printk(KERN_ERR "%s: find_device failed: %d\n", __FUNCTION__,
+		       error);
+	return devices;
+}
+
+/*
+ * returns current number of found HDDs
+ * and collect device info
+ */
+static unsigned int ps3_stor_enum_storage_drives(void)
+{
+	unsigned int devices = 0;
+
+	printk("Looking for disk devices...\n");
+	devices += ps3_stor_enum_storage_type(PS3_DEV_TYPE_STOR_DISK);
+	printk("Looking for ROM devices...\n");
+	devices += ps3_stor_enum_storage_type(PS3_DEV_TYPE_STOR_ROM);
+	printk("Looking for FLASH devices...\n");
+	devices += ps3_stor_enum_storage_type(PS3_DEV_TYPE_STOR_FLASH);
+
+	return devices;
+}
+
+
+static void ps3_stor_device_release(struct device * device)
+{
+	FUNC_START;
+	// place holder
+	FUNC_END;
+}
+
+const static struct platform_device ps3_stor_platform_device = {
+	.name           = "ps3_storage",
+	.dev            = {
+		.release        = ps3_stor_device_release
+	}
+};
+
+
+/*
+  construct a host structure
+  and associated structures for
+  its devices.
+  register the host thru device_register()
+*/
+static int ps3_stor_add_adapter(struct ps3_stor_lv1_bus_info * lv1_bus_info)
+{
+	int k;
+        int error = 0;
+        struct ps3_stor_host_info *host_info;
+        struct ps3_stor_dev_info *dev_info;
+        struct list_head *lh, *lh_sf;
+
+        host_info = kzalloc(sizeof(struct ps3_stor_host_info), GFP_KERNEL);
+
+        if (NULL == host_info) {
+                printk(KERN_ERR "%s: out of memory \n", __FUNCTION__);
+                return -ENOMEM;
+        }
+        INIT_LIST_HEAD(&host_info->dev_info_list);
+	host_info->lv1_bus_info = lv1_bus_info;
+
+	/* create structures for child devices of this adapter */
+        for (k = 0; k < lv1_bus_info->devices; k++) {
+                dev_info = kzalloc(sizeof(struct ps3_stor_dev_info),
+				   GFP_KERNEL);
+                if (NULL == dev_info) {
+                        printk(KERN_ERR "%s: out of memory \n", __FUNCTION__);
+                        error = -ENOMEM;
+			goto clean;
+                }
+                dev_info->host_info = host_info;
+		INIT_LIST_HEAD(&dev_info->dev_list);
+		spin_lock_init(&dev_info->srb_lock);
+		init_rwsem(&dev_info->bounce_sem);
+                list_add_tail(&dev_info->dev_list, &host_info->dev_info_list);
+        }
+
+        spin_lock(&ps3_stor_host_list_lock);
+        list_add_tail(&host_info->host_list, &ps3_stor_host_list);
+        spin_unlock(&ps3_stor_host_list_lock);
+
+	/* copy struct platform_device */
+        host_info->dev =  ps3_stor_platform_device;
+        host_info->dev.id = ps3_stor_add_host;
+
+        error = platform_device_register(&host_info->dev);
+
+        if (error)
+		goto clean;
+
+	/* bump up registerd buses */
+	++ps3_stor_add_host;
+
+        return error;
+
+clean:
+	list_for_each_safe(lh, lh_sf, &host_info->dev_info_list) {
+		dev_info = list_entry(lh, struct ps3_stor_dev_info, dev_list);
+		list_del(&dev_info->dev_list);
+		kfree(dev_info);
+	}
+
+	kfree(host_info);
+        return error;
+}
+
+static void ps3_stor_remove_adapter(void)
+{
+        struct ps3_stor_host_info * host_info = NULL;
+
+        spin_lock(&ps3_stor_host_list_lock);
+        if (!list_empty(&ps3_stor_host_list)) {
+                host_info = list_entry(ps3_stor_host_list.prev,
+                                       struct ps3_stor_host_info, host_list);
+		list_del(&host_info->host_list);
+	}
+        spin_unlock(&ps3_stor_host_list_lock);
+
+	if (!host_info)
+		return;
+
+        platform_device_unregister(&host_info->dev);
+	kfree(host_info);
+        --ps3_stor_add_host;
+}
+
+static int ps3_stor_wait_device_ready(void)
+{
+	unsigned int bus_index, bus_id, num_of_dev;
+	int error;
+	u64 tag, status;
+	int retries;
+	int ret = 0;
+	int i;
+	u64 * buf;
+	int region_ready = 0;
+	int region_expected = 0;
+	struct device_probe_info * info_array;
+
+	/* find the storage bus */
+	error = ps3_repository_find_bus(PS3_BUS_TYPE_STORAGE, 0, &bus_index);
+	if (error) {
+		printk(KERN_ERR "%s: Cannot find storage bus (%d)\n",
+		       __FUNCTION__, error);
+		return 0;
+	}
+
+	error = ps3_repository_read_bus_id(bus_index, &bus_id);
+	if (error) {
+		printk(KERN_ERR "%s: read_bus_id failed (%d)\n", __FUNCTION__,
+		       error);
+		return 0;
+	}
+
+	error = ps3_repository_read_bus_num_dev(bus_index, &num_of_dev);
+	if (error) {
+		printk(KERN_ERR "%s: read_bus_num_dev failed (%d)\n",
+		       __FUNCTION__, error);
+		return 0;
+	}
+
+	/* 1) wait for expected devices becomes in repositry */
+	retries = 0;
+	while (retries++ < ps3_stor_wait_time)
+	{
+		if (ps3_repository_read_bus_num_dev(bus_index, &num_of_dev)) {
+			continue;
+		}
+		if (ps3_stor_wait_num_storages + 1 <= num_of_dev)
+			break;
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ);
+		printk(".");
+	}
+	printk("\n");
+
+	buf = kzalloc(512, GFP_KERNEL);
+	if (!buf)
+		return 0;
+
+	info_array = kzalloc(sizeof(struct device_probe_info) * num_of_dev, GFP_KERNEL);
+	if (!info_array) {
+		ret = -1;
+		goto cleanup_0;
+	}
+
+	/* 2) store the device info */
+	for (i = 0; i < num_of_dev; i++) {
+		if (ps3_repository_read_dev_id(bus_index, i,
+					       &info_array[i].device_id)) {
+			BUG();
+		}
+		ps3_repository_read_dev_type(bus_index, i,
+					     &info_array[i].device_type);
+		info_array[i].found = 1;
+
+		switch (info_array[i].device_type) {
+		case PS3_DEV_TYPE_STOR_DISK:
+		case PS3_DEV_TYPE_STOR_FLASH:
+			info_array[i].region_expected = 1;
+			region_expected ++;
+			ret ++;
+			break;
+		case PS3_DEV_TYPE_STOR_ROM:
+			ret ++;
+		default:
+			break;
+		}
+	} /* for */
+
+
+	/* 2-1) open special event device */
+	error = lv1_open_device(bus_id, NOTIFICATION_DEVID, 0);
+	if (error) {
+		printk(KERN_ERR "%s: open failed notification dev %d\n",
+		       __FUNCTION__, error);
+		ret = 0;
+		goto cleanup_1;
+	}
+
+	/* 2-2) write info to request notify */
+	buf[0] = 0;
+	buf[1] = (1 << 1); /* region update info only */
+	error = lv1_storage_write(NOTIFICATION_DEVID,
+				  0, /* region */
+				  0, /* lba */
+				  1, /* sectors to write */
+				  0, /* flags */
+				  ps3_mm_phys_to_lpar(__pa(buf)), /* no need special convert */
+				  &tag);
+	if (error) {
+		printk(KERN_ERR "%s: notify request write failed %d\n",
+		       __FUNCTION__, error);
+		ret = 0;
+		goto cleanup_2;
+	}
+
+	/* wait for completion in one sec */
+	retries = 0;
+	while ((error = lv1_storage_check_async_status(NOTIFICATION_DEVID, tag,
+						       &status)) &&
+	       (retries++ < 1000)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+	if (error) {
+		/* write not completed */
+		printk(KERN_ERR "%s: write not completed %d\n", __FUNCTION__,
+		       error);
+		ret = 0;
+		goto cleanup_2;
+	}
+
+	/* 2-3) read to wait region notification for each device */
+	while (region_ready < region_expected) {
+		memset(buf, 0, 512);
+		error = lv1_storage_read(NOTIFICATION_DEVID,
+					 0, /* region */
+					 0, /* lba */
+					 1, /* sectors to read */
+					 0, /* flags */
+					 ps3_mm_phys_to_lpar(__pa(buf)), /* no need special convert */
+					 &tag);
+		retries = 0;
+		while ((error = lv1_storage_check_async_status(NOTIFICATION_DEVID, tag, &status)) &&
+		       (retries++ < 1000)) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(1);
+		}
+		if (error) {
+			/* read not completed */
+			printk(KERN_ERR "%s: read not complated %d\n",
+			       __FUNCTION__, error);
+			break;
+		}
+
+		/* 2-4) verify the notification */
+		if (buf[0] != 1) {
+			/* other info notified */
+			printk(KERN_ERR "%s: notification info %ld dev=%lx type=%lx\n", __FUNCTION__,
+			       buf[0], buf[2], buf[3]);
+		}
+
+		for (i = 0; i < num_of_dev; i++) {
+			if (info_array[i].found && info_array[i].device_id == buf[2]) {
+				info_array[i].region_ready = 1;
+				region_ready ++;
+				break;
+			}
+		} /* for */
+	} /* while */
+
+ cleanup_2:
+	lv1_close_device(bus_id, NOTIFICATION_DEVID);
+
+ cleanup_1:
+	kfree(info_array);
+ cleanup_0:
+	kfree(buf);
+	return ret;
+}
+
+
+static const struct scsi_command_handler_info scsi_cmnd_info_table_hdd[256] =
+{
+	[INQUIRY]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_inquiry},
+	[REQUEST_SENSE]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_request_sense},
+	[TEST_UNIT_READY]         = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_just_ok},
+	[READ_CAPACITY]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_read_capacity},
+	[MODE_SENSE_10]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_mode_sense},
+	[SYNCHRONIZE_CACHE]       = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_sync_cache},
+	[READ_10]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[READ_6]                  = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[WRITE_10]                = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write},
+	[WRITE_6]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write}
+};
+
+static const struct scsi_command_handler_info scsi_cmnd_info_table_flash[256] =
+{
+	[INQUIRY]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_inquiry},
+	[REQUEST_SENSE]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_request_sense},
+	[TEST_UNIT_READY]         = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_just_ok},
+	[READ_CAPACITY]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_read_capacity},
+	[MODE_SENSE_10]           = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_mode_sense},
+	[SYNCHRONIZE_CACHE]       = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_hdd_handle_sync_cache},
+	[READ_10]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[READ_6]                  = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[WRITE_10]                = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_handle_write_flash},
+	[WRITE_6]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_handle_write_flash}
+};
+
+static const struct scsi_command_handler_info scsi_cmnd_info_table_atapi[256] =
+{
+	[INQUIRY]                 = {USE_SRB_6, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[REQUEST_SENSE]           = {USE_SRB_6, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_request_sense},
+	[START_STOP]              = {0, NON_DATA_PROTO, DIR_NA,
+				     ps3_stor_atapi_handle_simple},
+	[ALLOW_MEDIUM_REMOVAL]    = {0, NON_DATA_PROTO, DIR_NA,
+				     ps3_stor_atapi_handle_simple},
+	[TEST_UNIT_READY]         = {0, NON_DATA_PROTO, DIR_NA,
+				     ps3_stor_atapi_handle_simple},
+	[READ_CAPACITY]           = {8, PIO_DATA_IN_PROTO,  DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[MODE_SENSE_10]           = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[READ_TOC]                = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[GPCMD_GET_CONFIGURATION] = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[GPCMD_READ_DISC_INFO]    = {USE_SRB_10, PIO_DATA_IN_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple},
+	[READ_10]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[READ_6]                  = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_read},
+	[WRITE_10]                = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write},
+	[WRITE_6]                 = {NOT_AVAIL, NA_PROTO, DIR_NA,
+				     ps3_stor_common_handle_write},
+	[GPCMD_READ_CD]           = {USE_CDDA_FRAME_RAW, DMA_PROTO, DIR_READ,
+				     ps3_stor_atapi_handle_simple}
+};
+
+
+/*
+ * called from scsi mid layer when it want to probe a
+ * device.
+ * Prepare so that mid can issue SCSI commands later (slave_configure)
+ */
+static int ps3_stor_slave_alloc(struct scsi_device * scsi_dev)
+{
+        int error = 0;
+        struct ps3_stor_host_info * host_info = NULL;
+	struct ps3_stor_dev_info * dev_info = NULL;
+        struct Scsi_Host *scsi_host;
+	struct ps3_stor_lv1_bus_info * lv1_bus_info;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info = NULL;
+	struct list_head * pos;
+	int found;
+	char thread_name[64];
+
+	FUNC_START;
+
+	scsi_host = scsi_dev->host;
+	host_info = *(struct ps3_stor_host_info **)(scsi_host->hostdata);
+	lv1_bus_info = host_info->lv1_bus_info;
+	/*
+	 * connect lv1_dev_info with scsi_device
+	 * assume SCSI mid layer started scsi id with ZERO '0'
+	 */
+	found = 0;
+	list_for_each(pos, &(lv1_bus_info->dev_list)) {
+		lv1_dev_info = list_entry(pos, struct ps3_stor_lv1_dev_info,
+					  bus_dev_list);
+
+		if ((lv1_dev_info->bus_device_index == scsi_dev->id) &&
+		    (scsi_dev->lun < lv1_dev_info->accessible_regions)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		error = -ENXIO;
+		goto out;
+	}
+
+	/*
+	 * connect scsi_dev with dev_info
+	 */
+	found = 0;
+	list_for_each(pos, &(host_info->dev_info_list)) {
+		dev_info = list_entry(pos, struct ps3_stor_dev_info, dev_list);
+		if (!dev_info->used) {
+			dev_info->used = 1;
+			dev_info->target = scsi_dev->id;
+			dev_info->lv1_dev_info = lv1_dev_info;
+			switch (lv1_dev_info->device_type)
+			{
+			case PS3_DEV_TYPE_STOR_DISK:
+				dev_info->handler_info = scsi_cmnd_info_table_hdd;
+				break;
+			case PS3_DEV_TYPE_STOR_FLASH:
+				dev_info->handler_info = scsi_cmnd_info_table_flash;
+				break;
+			case PS3_DEV_TYPE_STOR_ROM:
+				dev_info->handler_info = scsi_cmnd_info_table_atapi;
+				break;
+			default:
+				break;
+			}
+			/* reverse link */
+			lv1_dev_info->dev_info = dev_info;
+			scsi_dev->hostdata = dev_info;
+			/* copy sector length and capacity */
+			dev_info->sector_size = lv1_dev_info->sector_size;
+			found = 1;
+			break;
+		} else {
+			if (dev_info->target == scsi_dev->id) {
+				/* another lun ? */
+				if (scsi_dev->lun < lv1_dev_info->accessible_regions) {
+					/* ok, support this lun */
+					scsi_dev->hostdata = dev_info;
+					goto skip_per_device_configure;
+				}
+			}
+		}
+	}
+
+	if (!found) {
+		printk(KERN_ERR "%s: no empty dev_info for device id=%d lun=%d \n", __FUNCTION__,
+		       scsi_dev->id, scsi_dev->lun);
+		error = -ENODEV;
+		goto out;
+	}
+	FUNC_STEP_C("1");
+
+	/* open lv1 device */
+	error = lv1_open_device(lv1_dev_info->repo.did.bus_id,
+			        lv1_dev_info->repo.did.dev_id, 0);
+	if (error) {
+		printk(KERN_ERR "%s:open failed %d\n", __FUNCTION__, error);
+		error = -ENODEV;
+		goto out;
+	}
+
+	error = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+						&lv1_dev_info->repo.did /* host_info->dev.did */,
+						lv1_dev_info->interrupt_id,
+						&lv1_dev_info->irq_plug_id);
+	if (error) {
+		printk("%s:%u: ps3_sb_event_receive_port_setup failed (%d)\n",
+		       __func__, __LINE__, error);
+		error = -EPERM;
+		goto fail_close_device;
+	}
+
+	FUNC_STEP_C("2");
+
+	error = request_irq(lv1_dev_info->irq_plug_id,
+			    ps3_stor_hdd_irq_handler, IRQF_DISABLED,
+			    "PS3 stor", lv1_dev_info);
+	if (error) {
+		printk("%s:%d: request_irq failed (%d)\n", __func__, __LINE__,
+		       error);
+		goto fail_event_receive_port_destroy;
+	}
+
+	FUNC_STEP_C("3");
+
+	/* prepare dma regions for the device */
+	down_write(&dev_info->bounce_sem);
+	switch (get_dedicated_buffer_type(lv1_dev_info->device_type)) {
+	case DEDICATED_KMALLOC:
+		/*
+		 * adjust max_sector count.
+		 * mid layer already set default value from host template
+		 */
+		blk_queue_max_sectors(scsi_dev->request_queue, get_default_max_sector(lv1_dev_info));
+		/* create its own static bouce buffer */
+		dev_info->dedicated_bounce_size = get_default_max_sector(lv1_dev_info) * lv1_dev_info->sector_size;
+		dev_info->bounce_buf = kmalloc(dev_info->dedicated_bounce_size, GFP_KERNEL | __GFP_DMA);
+		up_write(&dev_info->bounce_sem);
+		if (!dev_info->bounce_buf) {
+			printk(KERN_ERR "%s:kmalloc for static bounce buffer failed %#x\n", __FUNCTION__,
+			       dev_info->dedicated_bounce_size);
+			error = -ENOMEM;
+			goto fail_free_irq;
+		}
+		dev_info->bounce_type = DEDICATED_KMALLOC;
+		break;
+	case DEDICATED_SPECIAL:
+		blk_queue_max_sectors(scsi_dev->request_queue, get_default_max_sector(lv1_dev_info));
+		/* use static buffer, kmalloc can not allocate 256K */
+		dev_info->dedicated_bounce_size = FLASH_ALIGN;
+		dev_info->bounce_buf = ps3_stor_alloc_separate_memory(FLASH_ALIGN,
+								      &dev_info->separate_bounce_lpar);
+		if (!dev_info->bounce_buf) {
+			error = -ENOMEM;
+			goto fail_free_irq;
+		}
+		up_write(&dev_info->bounce_sem);
+		dev_info->bounce_type = DEDICATED_SPECIAL;
+		break;
+	}
+	/* allocate dma region */
+	if (need_dedicated_dma_region(lv1_dev_info->device_type)) {
+		error = lv1_allocate_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						       lv1_dev_info->repo.did.dev_id,
+						       CEIL_ALIGN_4K(dev_info->dedicated_bounce_size),
+						       12 /* 4K */,
+						       0,
+						       &lv1_dev_info->dma_region);
+		if (error || !lv1_dev_info->dma_region) {
+			printk(KERN_ERR "%s:allocate dma region failed %d\n",
+			       __FUNCTION__, error);
+			error = -ENOMEM;
+			goto fail_free_irq;
+		}
+		error = lv1_map_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						  lv1_dev_info->repo.did.dev_id,
+						  ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf),
+						  lv1_dev_info->dma_region,
+						  CEIL_ALIGN_4K(dev_info->dedicated_bounce_size),
+						  0xf800000000000000UL);
+		DPRINTK(KERN_ERR "%s:map bounce buffer %d va=%p lp=%#lx pa=%#lx size=%#x dma=%#lx\n",
+			__FUNCTION__, error, dev_info->bounce_buf,
+			ps3_stor_virtual_to_lpar(dev_info, dev_info->bounce_buf),
+		       __pa(dev_info->bounce_buf),
+		       dev_info->dedicated_bounce_size,
+		       lv1_dev_info->dma_region);
+		if (error) {
+			lv1_free_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						   lv1_dev_info->repo.did.dev_id,
+						   lv1_dev_info->dma_region);
+
+			error = -ENODEV;
+			goto fail_free_irq;
+		}
+		dev_info->dedicated_dma_region = 1;
+
+	} else {
+		lv1_dev_info->dma_region =
+			ps3_allocate_dma_region(&lv1_dev_info->repo.did);
+		if (!lv1_dev_info->dma_region) {
+			printk(KERN_ERR "%s:create dma region failed\n",
+			       __FUNCTION__);
+			error = -ENODEV;
+			goto fail_free_irq;
+		}
+	}
+	FUNC_STEP_C("4");
+
+	/* create receive thread */
+	sprintf(thread_name, "ps3stor-%d-%d",
+		scsi_host->host_no, scsi_dev->id);
+	dev_info->thread_struct = kthread_create(ps3_stor_main_thread,
+						 dev_info, thread_name);
+	if (IS_ERR(dev_info->thread_struct)) {
+		error = -ENOMEM;
+		dev_info->thread_struct = NULL;
+		goto fail_free_irq;
+	}
+	init_MUTEX_LOCKED(&(dev_info->thread_sema));
+	wake_up_process(dev_info->thread_struct);
+
+skip_per_device_configure:
+	FUNC_END;
+        return 0;
+
+fail_free_irq:
+	FUNC_STEP_C("5");
+	free_irq(lv1_dev_info->irq_plug_id, lv1_dev_info);
+fail_event_receive_port_destroy:
+	FUNC_STEP_C("6");
+	ps3_sb_event_receive_port_destroy(&lv1_dev_info->repo.did,
+					  lv1_dev_info->interrupt_id,
+					  lv1_dev_info->irq_plug_id);
+fail_close_device:
+	FUNC_STEP_C("7");
+	lv1_close_device(lv1_dev_info->repo.did.bus_id, lv1_dev_info->repo.did.dev_id);
+out:
+	FUNC_END_C("error");
+	return error;/* say failed to alloc */
+}
+
+static int ps3_stor_slave_configure(struct scsi_device * scsi_dev)
+{
+
+	if (scsi_dev->host->max_cmd_len != PS3_STOR_MAX_CMD_LEN)
+		scsi_dev->host->max_cmd_len = PS3_STOR_MAX_CMD_LEN;
+
+	if (scsi_dev->host->cmd_per_lun)
+		scsi_adjust_queue_depth(scsi_dev, 0, scsi_dev->host->cmd_per_lun);
+	/*
+	 * ATAPI SFF8020 devices use MODE_SENSE_10,
+	 * so we can prohibit MODE_SENSE_6
+	 */
+	scsi_dev->use_10_for_ms = 1;
+
+	return 0;
+}
+
+static void ps3_stor_slave_destroy(struct scsi_device * scsi_dev)
+{
+	int error;
+	struct ps3_stor_dev_info * dev_info =
+				(struct ps3_stor_dev_info *)scsi_dev->hostdata;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info = dev_info->lv1_dev_info;
+
+	/* only LUN=0 should do */
+	if (scsi_dev->lun != 0) {
+		printk(KERN_ERR "%s: id=%d lun=%d skipped\n", __FUNCTION__,
+		       scsi_dev->id, scsi_dev->lun);
+		return;
+	}
+
+	/* terminate main thread */
+	dev_info->thread_wakeup_reason = THREAD_TERMINATE;
+	init_completion(&(dev_info->thread_terminated));
+	up(&(dev_info)->thread_sema);
+	wait_for_completion(&(dev_info->thread_terminated));
+
+
+	/* free resources */
+	switch (dev_info->bounce_type) {
+	case DEDICATED_SPECIAL:
+		ps3_stor_release_separate_memory(dev_info->bounce_buf,
+						 dev_info->separate_bounce_lpar);
+		dev_info->bounce_buf = NULL;
+		break;
+	case DEDICATED_KMALLOC:
+		kfree(dev_info->bounce_buf);
+		dev_info->bounce_buf = NULL;
+		break;
+	}
+
+	if (dev_info->dedicated_dma_region) {
+		error = lv1_unmap_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						    lv1_dev_info->repo.did.dev_id,
+						    lv1_dev_info->dma_region,
+						    CEIL_ALIGN_4K(dev_info->dedicated_bounce_size));
+		if (error) {
+			printk(KERN_ERR "%s: unmap dma region failed %d\n",
+			       __FUNCTION__, error);
+		}
+		error = lv1_free_device_dma_region(lv1_dev_info->repo.did.bus_id,
+						   lv1_dev_info->repo.did.dev_id,
+						   lv1_dev_info->dma_region);
+		if (error) {
+			printk(KERN_ERR "%s: unmap dma region failed %d\n",
+			       __FUNCTION__, error);
+		}
+		dev_info->dedicated_dma_region = 0;
+	} else {
+		error = ps3_free_dma_region(&lv1_dev_info->repo.did,
+					    lv1_dev_info->dma_region);
+		if (error) {
+			printk(KERN_ERR "%s: free dma region failed %d\n",
+			       __FUNCTION__, error);
+		}
+	}
+
+	free_irq(lv1_dev_info->irq_plug_id, lv1_dev_info);
+
+	ps3_sb_event_receive_port_destroy(&lv1_dev_info->repo.did,
+					  lv1_dev_info->interrupt_id,
+					  lv1_dev_info->irq_plug_id);
+	if (error)
+		printk(KERN_ERR "%s: disconnect event irq %d\n", __FUNCTION__,
+		       error);
+
+	error = lv1_close_device(lv1_dev_info->repo.did.bus_id,
+				 lv1_dev_info->repo.did.dev_id);
+	if (error)
+		printk(KERN_ERR "%s: close device %d\n", __FUNCTION__, error);
+
+	if (dev_info) {
+		/* make this slot avaliable for re-use */
+		dev_info->used = 0;
+		scsi_dev->hostdata = NULL;
+	}
+
+}
+
+static int ps3_stor_queuecommand(struct scsi_cmnd * srb,
+				 void (*done)(struct scsi_cmnd *))
+{
+	struct ps3_stor_dev_info * dev_info;
+	unsigned long flags;
+	int ret = 0;
+	dev_info = (struct ps3_stor_dev_info *)srb->device->hostdata;
+
+	spin_lock_irqsave(&dev_info->srb_lock, flags);
+	{
+		if (dev_info->srb) {
+			/* no more than one can be processed */
+			printk(KERN_ERR "%s: more than 1 SRB queued %d %d\n", __FUNCTION__,
+			       srb->device->host->host_no, srb->device->id);
+			ret = SCSI_MLQUEUE_HOST_BUSY;
+		} else {
+			srb->scsi_done = done;
+			dev_info->srb = srb;
+
+			dev_info->thread_wakeup_reason = SRB_QUEUED;
+			up(&(dev_info->thread_sema));
+			ret = 0;
+		};
+	}
+	spin_unlock_irqrestore(&(dev_info->srb_lock), flags);
+	return ret;
+}
+
+static int ps3_stor_host_reset(struct scsi_cmnd * srb)
+{
+	return FAILED;
+}
+
+
+static ssize_t ps3_stor_get_max_sectors(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct scsi_device *scsi_dev = from_dev_to_scsi_device(dev);
+	struct ps3_stor_dev_info * dev_info =
+		(struct ps3_stor_dev_info *)scsi_dev->hostdata;
+	ssize_t ret;
+
+	down_read(&dev_info->bounce_sem);
+	ret = sprintf(buf, "%u\n", scsi_dev->request_queue->max_sectors);
+	up_read(&dev_info->bounce_sem);
+	return ret;
+}
+
+static ssize_t ps3_stor_set_max_sectors(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct scsi_device *scsi_dev = from_dev_to_scsi_device(dev);
+	struct ps3_stor_dev_info * dev_info;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info;
+	unsigned short max_sectors;
+	void * bounce_buf;
+
+	if (sscanf(buf, "%hu", &max_sectors) > 0 && max_sectors <= SCSI_DEFAULT_MAX_SECTORS) {
+		dev_info = (struct ps3_stor_dev_info *)scsi_dev->hostdata;
+		lv1_dev_info = dev_info->lv1_dev_info;
+		/* if dedicated dma region, refuse to reset buffer */
+		if (need_dedicated_dma_region(lv1_dev_info->device_type)) {
+			/* FIXME: need remap dma region !!! */
+			return -EINVAL;
+		}
+		down_write(&dev_info->bounce_sem);
+		if (dev_info->bounce_type == DEDICATED_KMALLOC) {
+			/* try to allocate new bounce buffer */
+			bounce_buf = kmalloc(max_sectors * lv1_dev_info->sector_size, GFP_NOIO | __GFP_DMA | __GFP_NOWARN);
+			if (!bounce_buf) {
+				up_write(&dev_info->bounce_sem);
+				return -ENOMEM;
+			}
+			kfree(dev_info->bounce_buf);
+			dev_info->bounce_buf = bounce_buf;
+			dev_info->dedicated_bounce_size = max_sectors * lv1_dev_info->sector_size;
+		}
+		blk_queue_max_sectors(scsi_dev->request_queue, max_sectors);
+		up_write(&dev_info->bounce_sem);
+		return strlen(buf);
+	}
+	return -EINVAL;
+}
+
+
+static DEVICE_ATTR(max_sectors, S_IRUGO | S_IWUSR, ps3_stor_get_max_sectors,
+		   ps3_stor_set_max_sectors);
+
+static struct device_attribute *ps3_stor_sysfs_device_attr_list[] = {
+	&dev_attr_max_sectors,
+	NULL,
+};
+
+static struct scsi_host_template ps3_stor_driver_template = {
+	.name =			"ps3_stor",
+	.slave_alloc =		ps3_stor_slave_alloc,
+	.slave_configure =	ps3_stor_slave_configure,
+	.slave_destroy =	ps3_stor_slave_destroy,
+	.queuecommand =		ps3_stor_queuecommand,
+	.eh_host_reset_handler = ps3_stor_host_reset,
+	.can_queue =		PS3_STOR_CANQUEUE,
+	.this_id =		7,
+	.sg_tablesize =		SG_ALL,
+	.cmd_per_lun =		1,
+	.emulated =             1,   /* only sg driver uses this       */
+	.max_sectors =		128, /* multiple of pagesize, reset later */
+	.unchecked_isa_dma =	0,
+	.use_clustering =	ENABLE_CLUSTERING,
+	.sdev_attrs =           ps3_stor_sysfs_device_attr_list,
+	.module =		THIS_MODULE,
+};
+
+
+static int ps3_stor_driver_probe(struct platform_device * dev)
+{
+        int error = 0;
+        struct ps3_stor_host_info *host_info;
+        struct ps3_stor_lv1_bus_info *lv1_bus_info;
+        struct Scsi_Host *scsi_host;
+
+	host_info = from_dev_to_ps3_stor_host(dev);
+	lv1_bus_info = host_info->lv1_bus_info;
+
+        scsi_host = scsi_host_alloc(&ps3_stor_driver_template,
+				    sizeof(struct ps3_stor_host_info*));
+        if (NULL == scsi_host) {
+                printk(KERN_ERR "%s: scsi_register failed\n", __FUNCTION__);
+                error = -ENODEV;
+		return error;
+        }
+
+        host_info->scsi_host = scsi_host;
+	*((struct ps3_stor_host_info **)scsi_host->hostdata) = host_info;
+
+	/*
+	 * set maximum id as same as number of child devices
+	 */
+	scsi_host->max_id = lv1_bus_info->devices;
+	scsi_host->max_lun = 8;
+
+        error = scsi_add_host(scsi_host, &host_info->dev.dev);
+
+        if (error) {
+                printk(KERN_ERR "%s: scsi_add_host failed\n", __FUNCTION__);
+                error = -ENODEV;
+		scsi_host_put(scsi_host);
+        } else {
+		scsi_scan_host(scsi_host);
+	}
+
+
+        return error;
+}
+
+static int ps3_stor_driver_remove(struct platform_device * dev)
+{
+        struct list_head *lh, *lh_sf;
+        struct ps3_stor_host_info *host_info;
+        struct ps3_stor_dev_info *dev_info;
+
+	host_info = from_dev_to_ps3_stor_host(dev);
+
+	if (!host_info) {
+		printk(KERN_ERR "%s: Unable to locate host info\n",
+		       __FUNCTION__);
+		return -ENODEV;
+	}
+
+        scsi_remove_host(host_info->scsi_host);
+
+        list_for_each_safe(lh, lh_sf, &host_info->dev_info_list) {
+                dev_info = list_entry(lh, struct ps3_stor_dev_info, dev_list);
+                list_del(&dev_info->dev_list);
+                kfree(dev_info);
+        }
+
+        scsi_host_put(host_info->scsi_host);
+
+        return 0;
+}
+
+static void ps3_stor_driver_shutdown(struct platform_device * dev)
+{
+	ps3_stor_driver_remove(dev);
+}
+
+
+static struct platform_driver ps3_stor_platform_driver = {
+	.driver = {
+		.name = "ps3_storage"
+	},
+	.probe          = ps3_stor_driver_probe,
+	.remove         = ps3_stor_driver_remove,
+	.shutdown       = ps3_stor_driver_shutdown
+};
+
+static int __init ps3_stor_init(void)
+{
+	int host_to_add;
+	unsigned int devices, index;
+
+	FUNC_START;
+
+	/* register this driver thru devfs */
+	platform_driver_register(&ps3_stor_platform_driver);
+
+	/* wait until expected number of devices becomes ready */
+	devices = ps3_stor_wait_device_ready();
+	if (devices <= 0)
+		return -ENODEV;
+
+	/* init lv1_bus_info */
+	for (index = 0; index < PS3_STORAGE_NUM_OF_BUS_TYPES; index++) {
+		ps3_stor_lv1_bus_info_array[index].bus_type = index;
+		INIT_LIST_HEAD(&(ps3_stor_lv1_bus_info_array[index].dev_list));
+	}
+
+	/* alloc lv1_dev_info for devices */
+	ps3_stor_lv1_dev_info_array =
+		kzalloc(sizeof(struct ps3_stor_lv1_dev_info) * devices,
+			GFP_KERNEL);
+
+	if (!ps3_stor_lv1_dev_info_array) {
+		printk("init failed\n");
+		goto clean;
+	}
+	for (index = 0; index < devices; index++) {
+		INIT_LIST_HEAD(&(ps3_stor_lv1_dev_info_array[index].bus_dev_list));
+	}
+
+	/* calc how many HBA to add */
+	ps3_stor_lv1_devnum = 0;
+	devices = ps3_stor_enum_storage_drives();
+
+	for (index = 0; index < devices; index++) {
+		struct ps3_stor_lv1_dev_info *dev_info =
+			&ps3_stor_lv1_dev_info_array[index];
+		if (dev_info->device_type == PS3_DEV_TYPE_STOR_DISK ||
+		    dev_info->device_type == PS3_DEV_TYPE_STOR_ROM) {
+			if (dev_info->attached_port & (1 << 1)) {
+				dev_info->bus_device_index =
+					ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_1].devices ++;
+				list_add_tail(&(dev_info->bus_dev_list),
+					      &(ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_1].dev_list));
+			} else {
+				dev_info->bus_device_index =
+					ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_0].devices ++;
+				list_add_tail(&(dev_info->bus_dev_list),
+					      &(ps3_stor_lv1_bus_info_array[PS3_STORAGE_PATA_0].dev_list));
+			}
+
+		}
+
+		if (dev_info->device_type == PS3_DEV_TYPE_STOR_FLASH) {
+			dev_info->bus_device_index =
+				ps3_stor_lv1_bus_info_array[PS3_STORAGE_FLASH].devices ++;
+			list_add_tail(&(dev_info->bus_dev_list),
+				      &(ps3_stor_lv1_bus_info_array[PS3_STORAGE_FLASH].dev_list));
+		}
+
+	}
+
+	host_to_add = 0;
+	for (index = 0; index < PS3_STORAGE_NUM_OF_BUS_TYPES; index++) {
+		if (ps3_stor_lv1_bus_info_array[index].devices)
+			host_to_add ++;
+	}
+
+
+        /* add HBAs */
+	ps3_stor_add_host = 0;
+	for (index = 0; index < PS3_STORAGE_NUM_OF_BUS_TYPES; index++) {
+		if (ps3_stor_lv1_bus_info_array[index].devices) {
+			if (ps3_stor_add_adapter(&(ps3_stor_lv1_bus_info_array[index]))) {
+				printk(KERN_ERR "ps3_stor_init: ps3_stor_add_adapter failed\n");
+				break;
+			} else
+				host_to_add --;
+		}
+	}
+
+	FUNC_END;
+	return 0;
+
+ clean:
+	platform_driver_unregister(&ps3_stor_platform_driver);
+	return -ENOMEM;
+}
+
+static void __exit ps3_stor_exit(void)
+{
+	int k;
+
+	for (k = ps3_stor_add_host; k; k--)
+		ps3_stor_remove_adapter();
+	platform_driver_unregister(&ps3_stor_platform_driver);
+
+	for (k = 0; k < ps3_stor_lv1_devnum; k++) {
+		if (ps3_stor_lv1_dev_info_array[k].region_info_array) {
+			kfree(ps3_stor_lv1_dev_info_array[k].region_info_array);
+		}
+	}
+	kfree(ps3_stor_lv1_dev_info_array);
+}
+
+
+device_initcall(ps3_stor_init);
+module_exit(ps3_stor_exit);
diff -Naur linux-2.6.22-org/drivers/block/ps3_storage.h linux-2.6.22-ps3/drivers/block/ps3_storage.h
--- linux-2.6.22-org/drivers/block/ps3_storage.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/drivers/block/ps3_storage.h	2007-08-22 07:57:31.000000000 +0200
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * Copyright 2006, 2007 Sony Corporation
+ * storage support for PS3
+ *
+ * based on scsi_debug.h
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef _PS3_STOR_H
+#define _PS3_STOR_H
+
+#include <linux/types.h>
+#include <../arch/powerpc/platforms/ps3/platform.h>
+
+#define LV1_STORAGE_SEND_ATAPI_COMMAND	(1)
+#define LV1_STORAGE_ATA_HDDOUT		(0x23)
+
+#define PS3_STOR_MAX_INQUIRY_DATA_SIZE	(128)
+#define PS3_STOR_INQUIRY_DATA_SIZE	(86)
+#define PS3_STOR_READCAP_DATA_SIZE	(8)
+#define PS3_STOR_SENSE_LEN		(32)
+#define PS3_STOR_VERSION		"1.00"
+#define PS3_STOR_CANQUEUE		(1)
+#define PS3_STOR_MAX_CMD_LEN		(16)
+
+struct lv1_atapi_cmnd_block {
+	u8	pkt[32];	/* packet command block           */
+	u32	pktlen;		/* should be 12 for ATAPI 8020    */
+	u32	blocks;
+	u32	block_size;
+	u32	proto;		/* transfer mode                  */
+	u32	in_out;		/* transfer direction             */
+	u64	buffer;		/* parameter except command block */
+	u32	arglen;		/* length above                   */
+};
+
+enum lv1_atapi_proto {
+	NA_PROTO = -1,
+	NON_DATA_PROTO     = 0,
+	PIO_DATA_IN_PROTO  = 1,
+	PIO_DATA_OUT_PROTO = 2,
+	DMA_PROTO = 3
+};
+
+enum lv1_atapi_in_out {
+	DIR_NA = -1,
+	DIR_WRITE = 0, /* memory -> device */
+	DIR_READ = 1 /* device -> memory */
+};
+
+/*
+ * describe protocol of an ATAPI command
+ */
+struct ps3_stor_dev_info;
+
+struct scsi_command_handler_info {
+	int buflen;
+	int proto;
+	int in_out;
+	int (*cmnd_handler)(struct ps3_stor_dev_info *, struct scsi_cmnd *);
+};
+
+/*
+ * to position parameter
+ */
+enum {
+	NOT_AVAIL          = -1,
+	USE_SRB_10         = -2,
+	USE_SRB_6          = -3,
+	USE_CDDA_FRAME_RAW = -4
+};
+/*
+ * for LV1 maintainance
+ */
+enum  {
+	PS3_STORAGE_PATA_0, /* primary   PATA bus */
+	PS3_STORAGE_PATA_1, /* secondary PATA bus */
+	PS3_STORAGE_FLASH,
+	PS3_STORAGE_NUM_OF_BUS_TYPES /* terminator */
+};
+
+/*
+ * LV1 per physical bus info:
+ * PATA0, PATA1, FLASH
+ */
+struct ps3_stor_lv1_bus_info {
+	int bus_type;           /* PATA0, PATA1, FLASH */
+	int devices;            /* number of devices on the bus */
+	struct list_head dev_list;
+};
+
+/*
+ * LV1 per region info
+ */
+struct ps3_stor_lv1_region_info {
+	int region_index;	/* index of this region       */
+	unsigned int region_id;	/* id of this region          */
+	u64 region_size;	/* region size in sector      */
+	u64 region_start;	/* start sector */
+};
+
+/*
+ * LV1 per device info
+ */
+struct ps3_stor_lv1_dev_info {
+	struct list_head bus_dev_list; /* device list of devices          */
+				       /* which share same physical bus   */
+	struct ps3_stor_dev_info * dev_info;
+	/* repository values */
+	struct ps3_repository_device repo;
+	enum ps3_dev_type device_type;	/* bus#X.dev#Y.type     */
+	u64 attached_port;		/* bus#x.dev#Y.port     */
+	u64 sector_size;		/* bus#X.dev#Y.blk_size */
+
+	/* house keeping */
+	int bus_type;			/* PATA0,1 or FLASH */
+	unsigned int irq_plug_id;
+	unsigned int interrupt_id;
+	u64 dma_region;
+	u64 current_tag;
+	int bus_device_index;		/*
+					 * device index of same lv1 phy bus.
+					 * 0 for first device, 1 for second.
+					 * should be same as SCSI id
+					 */
+	/* regions */
+	unsigned int regions;	/* number of regions reported thru repository */
+	unsigned long accessible_region_flag; /* flag of accessible regions */
+	unsigned int accessible_regions; /* number of accessible regions of this dev.
+				 * currently, this includes region #0
+				 * NOTE: maximum is 8, if exceed, the rest of
+				 * regions are ignored
+				 */
+	struct ps3_stor_lv1_region_info * region_info_array;
+};
+
+enum read_or_write {
+	SCSIDEBUG_READ,
+	SCSIDEBUG_WRITE
+};
+
+
+enum thread_wakeup_reason {
+	SRB_QUEUED,
+	THREAD_TERMINATE
+};
+
+enum bounce_buffer_type {
+	DEDICATED_KMALLOC,
+	DEDICATED_SPECIAL,
+};
+
+struct ps3_stor_dev_info {
+	struct list_head dev_list;
+	struct ps3_stor_lv1_dev_info * lv1_dev_info;
+	struct ps3_stor_host_info *host_info;
+	const struct scsi_command_handler_info * handler_info;
+	unsigned int target;
+
+	u64 sector_size;	/* copied from lv1 repository at initialize */
+	/* devices may change these value */
+	struct rw_semaphore bounce_sem;	/* protect the following members:
+					* bounce_buf (pointer itself, not buffer),
+					* dedicated_bounce_size
+					* max_sectors in scsi_dev->request_queue
+					*/
+	int  dedicated_bounce;	/* set nonzero if the bounce buffer is dedicated */
+	int  dedicated_bounce_size;
+	int  dedicated_dma_region; /* set if partial dma region allocated */
+	enum bounce_buffer_type bounce_type;	/* bounce buffer type */
+	void * bounce_buf;
+	u64 separate_bounce_lpar; /* lpar address for separated buffer  */
+
+	char used;
+
+	/* main thread communication */
+	struct task_struct * thread_struct;
+	spinlock_t srb_lock;
+	struct scsi_cmnd * srb;              /* queued srb; just one srb allowd             */
+	struct semaphore thread_sema;        /* device main thread wakeup                   */
+	struct completion thread_terminated; /* notify thread temination to slave_destory() */
+	int thread_wakeup_reason;
+
+	/* interrupt handler communication */
+	struct completion irq_done;
+	volatile u64 lv1_status;	/* result of get_async_status() */
+	volatile int lv1_retval;	/* return value of get_async_status() */
+
+};
+
+struct ps3_stor_host_info {
+	struct list_head host_list;
+	struct Scsi_Host *scsi_host;
+	struct platform_device dev;
+	struct list_head dev_info_list;
+	struct ps3_stor_lv1_bus_info * lv1_bus_info;
+};
+
+#define from_dev_to_ps3_stor_host(p) \
+	container_of(p, struct ps3_stor_host_info, dev)
+#define from_dev_to_scsi_device(p) \
+	container_of(p, struct scsi_device, sdev_gendev)
+
+
+struct ps3_stor_quirk_probe_info {
+	struct completion irq_done;
+	unsigned int device_id;
+	int lv1_retval;
+	u64 lv1_status;
+	u64 lv1_tag;
+	u64 lv1_ret_tag;
+};
+
+
+#define NOTIFICATION_DEVID ((u64)(-1L))
+
+struct device_probe_info {
+	unsigned int device_id;
+	enum ps3_dev_type device_type;
+	int      found;
+	int      region_expected;
+	int      region_ready;
+};
+
+#endif
diff -Naur linux-2.6.22-org/drivers/net/Kconfig linux-2.6.22-ps3/drivers/net/Kconfig
--- linux-2.6.22-org/drivers/net/Kconfig	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/drivers/net/Kconfig	2007-08-22 07:57:31.000000000 +0200
@@ -2264,6 +2264,16 @@
 	     To compile this driver as a module, choose M here: the module
 	     will be called tsi108_eth.
 
+config GELIC_NET
+	tristate "PS3 Gigabit Ethernet driver"
+	depends on PPC_PS3
+	help
+	  This driver supports the Gigabit Ethernet device on the
+	  PS3 game console.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gelic_net.
+
 config GIANFAR
 	tristate "Gianfar Ethernet"
 	depends on 85xx || 83xx || PPC_86xx
diff -Naur linux-2.6.22-org/drivers/net/Makefile linux-2.6.22-ps3/drivers/net/Makefile
--- linux-2.6.22-org/drivers/net/Makefile	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/drivers/net/Makefile	2007-08-22 07:57:31.000000000 +0200
@@ -60,6 +60,7 @@
 obj-$(CONFIG_BNX2) += bnx2.o
 spidernet-y += spider_net.o spider_net_ethtool.o
 obj-$(CONFIG_SPIDER_NET) += spidernet.o sungem_phy.o
+obj-$(CONFIG_GELIC_NET) += gelic_net.o
 obj-$(CONFIG_TC35815) += tc35815.o
 obj-$(CONFIG_SKGE) += skge.o
 obj-$(CONFIG_SKY2) += sky2.o
diff -Naur linux-2.6.22-org/drivers/net/gelic_net.c linux-2.6.22-ps3/drivers/net/gelic_net.c
--- linux-2.6.22-org/drivers/net/gelic_net.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/drivers/net/gelic_net.c	2007-08-21 16:52:52.000000000 +0200
@@ -0,0 +1,1883 @@
+/*
+ *  PS3 Platfom gelic network driver.
+ *
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ *
+ *  this file is based on: spider_net.c
+ *
+ * Network device driver for Cell Processor-Based Blade
+ *
+ * (C) Copyright IBM Corp. 2005
+ *
+ * Authors : Utz Bacher <utz.bacher@de.ibm.com>
+ *           Jens Osterkamp <Jens.Osterkamp@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define DEBUG 1
+
+#include <linux/compiler.h>
+#include <linux/crc32.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/firmware.h>
+#include <linux/if_vlan.h>
+#include <linux/in.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/mii.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/device.h>
+#include <linux/pci.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <asm/bitops.h>
+#include <asm/pci-bridge.h>
+#include <net/checksum.h>
+#include <asm/io.h>
+#include <asm/firmware.h>
+#include <asm/ps3.h>
+#include <asm/lv1call.h>
+
+#define GELIC_NET_DRV_NAME "Gelic Network Driver"
+#define GELIC_NET_DRV_VERSION "1.0"
+
+#define GELIC_NET_DEBUG
+
+#ifdef GELIC_NET_DEBUG
+#define DPRINTK(fmt,arg...)   printk(KERN_ERR fmt ,##arg)
+#define DPRINTKK(fmt,arg...)  printk(KERN_ERR fmt ,##arg)
+#else
+#define DPRINTK(fmt,arg...)
+#define DPRINTKK(fmt,arg...)
+#endif
+
+#define GELIC_NET_ETHTOOL               /* use ethtool */
+
+/* ioctl */
+#define GELIC_NET_GET_MODE              (SIOCDEVPRIVATE + 0)
+#define GELIC_NET_SET_MODE              (SIOCDEVPRIVATE + 1)
+
+/* descriptors */
+#define GELIC_NET_RX_DESCRIPTORS        128 /* num of descriptors */
+#define GELIC_NET_TX_DESCRIPTORS        128 /* num of descriptors */
+
+#define GELIC_NET_MAX_MTU               2308
+#define GELIC_NET_MIN_MTU               64
+#define GELIC_NET_RXBUF_ALIGN           128
+#define GELIC_NET_RX_CSUM_DEFAULT       1 /* hw chksum */
+#define GELIC_NET_WATCHDOG_TIMEOUT      5*HZ
+#define GELIC_NET_NAPI_WEIGHT           64
+#define GELIC_NET_BROADCAST_ADDR        0xffffffffffff
+#define GELIC_NET_VLAN_POS              (VLAN_ETH_ALEN * 2)
+#define GELIC_NET_VLAN_MAX              4
+#define GELIC_NET_MC_COUNT_MAX          32 /* multicast address list */
+
+enum gelic_net_int0_status {
+	GELIC_NET_GDTDCEINT  = 24,
+	GELIC_NET_GRFANMINT  = 28,
+};
+
+/* GHIINT1STS bits */
+enum gelic_net_int1_status {
+	GELIC_NET_GDADCEINT = 14,
+};
+
+/* interrupt mask */
+#define GELIC_NET_TXINT                   (1L << (GELIC_NET_GDTDCEINT + 32))
+
+#define GELIC_NET_RXINT0                  (1L << (GELIC_NET_GRFANMINT + 32))
+#define GELIC_NET_RXINT1                  (1L << GELIC_NET_GDADCEINT)
+#define GELIC_NET_RXINT                   (GELIC_NET_RXINT0 | GELIC_NET_RXINT1)
+
+ /* descriptor data_status bits */
+#define GELIC_NET_RXIPCHK                 29
+#define GELIC_NET_TCPUDPIPCHK             28
+#define GELIC_NET_DATA_STATUS_CHK_MASK    (1 << GELIC_NET_RXIPCHK | \
+                                           1 << GELIC_NET_TCPUDPIPCHK)
+
+/* descriptor data_error bits */
+#define GELIC_NET_RXIPCHKERR              27
+#define GELIC_NET_RXTCPCHKERR             26
+#define GELIC_NET_DATA_ERROR_CHK_MASK     (1 << GELIC_NET_RXIPCHKERR | \
+                                           1 << GELIC_NET_RXTCPCHKERR)
+
+#define GELIC_NET_DMAC_CMDSTAT_NOCS       0xa0080000 /* middle of frame */
+#define GELIC_NET_DMAC_CMDSTAT_TCPCS      0xa00a0000
+#define GELIC_NET_DMAC_CMDSTAT_UDPCS      0xa00b0000
+#define GELIC_NET_DMAC_CMDSTAT_END_FRAME  0x00040000 /* end of frame */
+
+#define GELIC_NET_DMAC_CMDSTAT_CHAIN_END  0x00000002 /* RXDCEIS:DMA stopped */
+
+#define GELIC_NET_DESCR_IND_PROC_SHIFT    28
+#define GELIC_NET_DESCR_IND_PROC_MASKO    0x0fffffff
+
+/* ignore ipsec ans multicast */
+#define GELIC_NET_DATA_ERROR_MASK         0xfdefbfff
+/* ignore unmatched sp on sp, drop_packet, multicast address frame*/
+#define GELIC_NET_DATA_ERROR_FLG          0x7def8000
+
+enum gelic_net_descr_status {
+	GELIC_NET_DESCR_COMPLETE            = 0x00, /* used in rx and tx */
+	GELIC_NET_DESCR_RESPONSE_ERROR      = 0x01, /* used in rx and tx */
+	GELIC_NET_DESCR_PROTECTION_ERROR    = 0x02, /* used in rx and tx */
+	GELIC_NET_DESCR_FRAME_END           = 0x04, /* used in rx */
+	GELIC_NET_DESCR_FORCE_END           = 0x05, /* used in rx and tx */
+	GELIC_NET_DESCR_CARDOWNED           = 0x0a, /* used in rx and tx */
+	GELIC_NET_DESCR_NOT_IN_USE                  /* any other value */
+};
+#define GELIC_NET_DMAC_CMDSTAT_NOT_IN_USE 0xb0000000
+
+#define GELIC_NET_DESCR_SIZE              32
+struct gelic_net_descr {
+	/* as defined by the hardware */
+	uint32_t buf_addr;
+	uint32_t buf_size;
+	uint32_t next_descr_addr;
+	uint32_t dmac_cmd_status;
+	uint32_t result_size;
+	uint32_t valid_size;	/* all zeroes for tx */
+	uint32_t data_status;
+	uint32_t data_error;	/* all zeroes for tx */
+
+	/* used in the driver */
+	struct sk_buff *skb;
+	dma_addr_t bus_addr;
+	struct gelic_net_descr *next;
+	struct gelic_net_descr *prev;
+	struct vlan_ethhdr vlan;
+} __attribute__((aligned(32)));
+
+struct gelic_net_descr_chain {
+	/* we walk from tail to head */
+	struct gelic_net_descr *head;
+	struct gelic_net_descr *tail;
+	spinlock_t lock;
+};
+
+struct gelic_net_card {
+	struct net_device *netdev;
+	uint64_t ghiintmask;
+	struct ps3_system_bus_device *dev;
+	uint32_t vlan_id[GELIC_NET_VLAN_MAX];
+	int vlan_index;
+
+	struct gelic_net_descr_chain tx_chain;
+	struct gelic_net_descr_chain rx_chain;
+	spinlock_t chain_lock;
+
+	struct net_device_stats netdev_stats;
+	int rx_csum;
+	spinlock_t intmask_lock;
+
+	struct work_struct tx_timeout_task;
+	atomic_t tx_timeout_task_counter;
+	wait_queue_head_t waitq;
+
+	struct gelic_net_descr *tx_top, *rx_top;
+
+	struct gelic_net_descr descr[0];
+};
+
+static int ps3_gelic_param = 1; /* vlan desc support */
+#ifdef CONFIG_GELIC_NET_MODULE
+module_param(ps3_gelic_param, int, S_IRUGO);
+#endif
+
+struct gelic_net_card *gcard;
+static uint64_t gelic_irq_status;
+
+static int dmac_status = 0;
+
+/* for lv1_net_control */
+#define GELIC_NET_GET_MAC_ADDRESS               0x0000000000000001
+#define GELIC_NET_GET_ETH_PORT_STATUS           0x0000000000000002
+#define GELIC_NET_SET_NEGOTIATION_MODE          0x0000000000000003
+#define GELIC_NET_GET_VLAN_ID                   0x0000000000000004
+
+#define GELIC_NET_LINK_UP                       0x0000000000000001
+#define GELIC_NET_FULL_DUPLEX                   0x0000000000000002
+#define GELIC_NET_AUTO_NEG                      0x0000000000000004
+#define GELIC_NET_SPEED_10                      0x0000000000000010
+#define GELIC_NET_SPEED_100                     0x0000000000000020
+#define GELIC_NET_SPEED_1000                    0x0000000000000040
+
+#define GELIC_NET_VLAN_ALL                      0x0000000000000001
+#define GELIC_NET_VLAN_WIRED                    0x0000000000000002
+#define GELIC_NET_VLAN_WIRELESS                 0x0000000000000003
+#define GELIC_NET_VLAN_PSP                      0x0000000000000004
+#define GELIC_NET_VLAN_PORT0                    0x0000000000000010
+#define GELIC_NET_VLAN_PORT1                    0x0000000000000011
+#define GELIC_NET_VLAN_PORT2                    0x0000000000000012
+#define GELIC_NET_VLAN_DAEMON_CLIENT_BSS        0x0000000000000013
+#define GELIC_NET_VLAN_LIBERO_CLIENT_BSS        0x0000000000000014
+#define GELIC_NET_VLAN_NO_ENTRY                 -6
+
+#define GELIC_NET_PORT                          2 /* for port status */
+
+
+MODULE_AUTHOR("SCE Inc.");
+MODULE_DESCRIPTION("Gelic Network driver");
+MODULE_LICENSE("GPL");
+
+static int rx_descriptors = GELIC_NET_RX_DESCRIPTORS;
+static int tx_descriptors = GELIC_NET_TX_DESCRIPTORS;
+
+
+/* set irq_mask */
+static int
+gelic_net_set_irq_mask(struct gelic_net_card *card, uint64_t mask)
+{
+	uint64_t status = 0;
+
+	status = lv1_net_set_interrupt_mask(card->dev->did.bus_id,
+		card->dev->did.dev_id, mask, 0);
+	if (status) {
+		printk("lv1_net_set_interrupt_mask failed, status=%ld\n",
+			status);
+	}
+	return status;
+}
+
+/**
+ * gelic_net_get_descr_status -- returns the status of a descriptor
+ * @descr: descriptor to look at
+ *
+ * returns the status as in the dmac_cmd_status field of the descriptor
+ */
+enum gelic_net_descr_status
+gelic_net_get_descr_status(struct gelic_net_descr *descr)
+{
+	uint32_t cmd_status;
+
+	rmb();
+	cmd_status = descr->dmac_cmd_status;
+	rmb();
+	cmd_status >>= GELIC_NET_DESCR_IND_PROC_SHIFT;
+	return cmd_status;
+}
+
+/**
+ * gelic_net_set_descr_status -- sets the status of a descriptor
+ * @descr: descriptor to change
+ * @status: status to set in the descriptor
+ *
+ * changes the status to the specified value. Doesn't change other bits
+ * in the status
+ */
+static void
+gelic_net_set_descr_status(struct gelic_net_descr *descr,
+			    enum gelic_net_descr_status status)
+{
+	uint32_t cmd_status;
+
+	/* read the status */
+	mb();
+	cmd_status = descr->dmac_cmd_status;
+	/* clean the upper 4 bits */
+	cmd_status &= GELIC_NET_DESCR_IND_PROC_MASKO;
+	/* add the status to it */
+	cmd_status |= ((uint32_t)status)<<GELIC_NET_DESCR_IND_PROC_SHIFT;
+	/* and write it back */
+	descr->dmac_cmd_status = cmd_status;
+	wmb();
+}
+
+/**
+ * gelic_net_free_chain - free descriptor chain
+ * @card: card structure
+ * @descr_in: address of desc
+ */
+static void
+gelic_net_free_chain(struct gelic_net_card *card,
+		      struct gelic_net_descr *descr_in)
+{
+	struct gelic_net_descr *descr;
+
+	for (descr = descr_in; descr && !descr->bus_addr; descr = descr->next) {
+		dma_unmap_single(&card->dev->core, descr->bus_addr,
+				 GELIC_NET_DESCR_SIZE, PCI_DMA_BIDIRECTIONAL);
+		descr->bus_addr = 0;
+	}
+}
+
+/**
+ * gelic_net_init_chain - links descriptor chain
+ * @card: card structure
+ * @chain: address of chain
+ * @start_descr: address of descriptor array
+ * @no: number of descriptors
+ *
+ * we manage a circular list that mirrors the hardware structure,
+ * except that the hardware uses bus addresses.
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int
+gelic_net_init_chain(struct gelic_net_card *card,
+		       struct gelic_net_descr_chain *chain,
+		       struct gelic_net_descr *start_descr, int no)
+{
+	int i;
+	struct gelic_net_descr *descr;
+
+	spin_lock_init(&chain->lock);
+	descr = start_descr;
+	memset(descr, 0, sizeof(*descr) * no);
+
+	/* set up the hardware pointers in each descriptor */
+	for (i=0; i<no; i++, descr++) {
+		gelic_net_set_descr_status(descr, GELIC_NET_DESCR_NOT_IN_USE);
+		descr->bus_addr =
+			dma_map_single(&card->dev->core, descr,
+				       GELIC_NET_DESCR_SIZE,
+				       PCI_DMA_BIDIRECTIONAL);
+
+		if (descr->bus_addr == DMA_ERROR_CODE)
+			goto iommu_error;
+
+		descr->next = descr + 1;
+		descr->prev = descr - 1;
+	}
+	/* do actual chain list */
+	(descr-1)->next = start_descr;
+	start_descr->prev = (descr-1);
+
+	descr = start_descr;
+	for (i=0; i < no; i++, descr++) {
+		if (descr->next) {
+			descr->next_descr_addr = descr->next->bus_addr;
+		} else {
+			descr->next_descr_addr = 0;
+		}
+	}
+
+	chain->head = start_descr;
+	chain->tail = start_descr;
+	(descr-1)->next_descr_addr = 0; /* last descr */
+	return 0;
+
+iommu_error:
+	descr = start_descr;
+	for (i=0; i < no; i++, descr++)
+		if (descr->bus_addr)
+			dma_unmap_single(&card->dev->core, descr->bus_addr,
+					 GELIC_NET_DESCR_SIZE,
+					 PCI_DMA_BIDIRECTIONAL);
+	return -ENOMEM;
+}
+
+/**
+ * gelic_net_prepare_rx_descr - reinitializes a rx descriptor
+ * @card: card structure
+ * @descr: descriptor to re-init
+ *
+ * return 0 on succes, <0 on failure
+ *
+ * allocates a new rx skb, iommu-maps it and attaches it to the descriptor.
+ * Activate the descriptor state-wise
+ */
+static int
+gelic_net_prepare_rx_descr(struct gelic_net_card *card,
+			    struct gelic_net_descr *descr)
+{
+	dma_addr_t buf;
+	int error = 0;
+	int offset;
+	int bufsize;
+
+	if( gelic_net_get_descr_status(descr) !=  GELIC_NET_DESCR_NOT_IN_USE) {
+		printk("%s: ERROR status \n", __FUNCTION__);
+	}
+	/* we need to round up the buffer size to a multiple of 128 */
+	bufsize = (GELIC_NET_MAX_MTU + GELIC_NET_RXBUF_ALIGN - 1) &
+		(~(GELIC_NET_RXBUF_ALIGN - 1));
+
+	/* and we need to have it 128 byte aligned, therefore we allocate a
+	 * bit more */
+	/* allocate an skb */
+	descr->skb = dev_alloc_skb(bufsize + GELIC_NET_RXBUF_ALIGN - 1);
+	if (!descr->skb) {
+		if (net_ratelimit())
+			printk("Not enough memory to allocate rx buffer\n");
+		return -ENOMEM;
+	}
+	descr->buf_size = bufsize;
+	descr->dmac_cmd_status = 0;
+	descr->result_size = 0;
+	descr->valid_size = 0;
+	descr->data_error = 0;
+
+	offset = ((unsigned long)descr->skb->data) &
+		(GELIC_NET_RXBUF_ALIGN - 1);
+	if (offset)
+		skb_reserve(descr->skb, GELIC_NET_RXBUF_ALIGN - offset);
+	/* io-mmu-map the skb */
+	buf = dma_map_single(&card->dev->core, descr->skb->data,
+					GELIC_NET_MAX_MTU,
+					PCI_DMA_BIDIRECTIONAL);
+	descr->buf_addr = buf;
+	if (buf == DMA_ERROR_CODE) {
+		dev_kfree_skb_any(descr->skb);
+		printk("Could not iommu-map rx buffer\n");
+		gelic_net_set_descr_status(descr, GELIC_NET_DESCR_NOT_IN_USE);
+	} else {
+		gelic_net_set_descr_status(descr, GELIC_NET_DESCR_CARDOWNED);
+	}
+
+	return error;
+}
+
+/**
+ * gelic_net_release_rx_chain - free all rx descr
+ * @card: card structure
+ *
+ */
+static void
+gelic_net_release_rx_chain(struct gelic_net_card *card)
+{
+	struct gelic_net_descr_chain *chain = &card->rx_chain;
+
+	while(chain->tail != chain->head) {
+		if (chain->tail->skb) {
+			dma_unmap_single(&card->dev->core,
+						chain->tail->buf_addr,
+						chain->tail->skb->len,
+						PCI_DMA_BIDIRECTIONAL);
+			chain->tail->buf_addr = 0;
+			dev_kfree_skb_any(chain->tail->skb);
+			chain->tail->skb = NULL;
+			chain->tail->dmac_cmd_status =
+						GELIC_NET_DESCR_NOT_IN_USE;
+			chain->tail = chain->tail->next;
+		}
+	}
+}
+
+/**
+ * gelic_net_enable_rxdmac - enables a receive DMA controller
+ * @card: card structure
+ *
+ * gelic_net_enable_rxdmac enables the DMA controller by setting RX_DMA_EN
+ * in the GDADMACCNTR register
+ */
+static void
+gelic_net_enable_rxdmac(struct gelic_net_card *card)
+{
+	uint64_t status;
+
+	status = lv1_net_start_rx_dma(card->dev->did.bus_id,
+				card->dev->did.dev_id,
+				(uint64_t)card->rx_chain.tail->bus_addr, 0);
+	if (status) {
+		printk("lv1_net_start_rx_dma failed, status=%ld\n", status);
+	}
+}
+
+/**
+ * gelic_net_refill_rx_chain - refills descriptors/skbs in the rx chains
+ * @card: card structure
+ *
+ * refills descriptors in all chains (last used chain first): allocates skbs
+ * and iommu-maps them.
+ */
+static void
+gelic_net_refill_rx_chain(struct gelic_net_card *card)
+{
+	struct gelic_net_descr_chain *chain;
+	int count = 0;
+
+	chain = &card->rx_chain;
+	while (chain->head && gelic_net_get_descr_status(chain->head) ==
+		GELIC_NET_DESCR_NOT_IN_USE) {
+		if (gelic_net_prepare_rx_descr(card, chain->head))
+			break;
+		count++;
+		chain->head = chain->head->next;
+	}
+}
+
+/**
+ * gelic_net_alloc_rx_skbs - allocates rx skbs in rx descriptor chains
+ * @card: card structure
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int
+gelic_net_alloc_rx_skbs(struct gelic_net_card *card)
+{
+	struct gelic_net_descr_chain *chain;
+
+	chain = &card->rx_chain;
+	gelic_net_refill_rx_chain(card);
+	chain->head = card->rx_top->prev; /* point to the last */
+	return 0;
+}
+
+/**
+ * gelic_net_release_tx_descr - processes a used tx descriptor
+ * @card: card structure
+ * @descr: descriptor to release
+ *
+ * releases a used tx descriptor (unmapping, freeing of skb)
+ */
+static void
+gelic_net_release_tx_descr(struct gelic_net_card *card,
+			    struct gelic_net_descr *descr)
+{
+	struct sk_buff *skb;
+
+  if (!ps3_gelic_param) {
+	/* unmap the skb */
+	skb = descr->skb;
+	dma_unmap_single(&card->dev->core, descr->buf_addr, skb->len,
+			 PCI_DMA_BIDIRECTIONAL);
+
+	dev_kfree_skb_any(skb);
+  } else {
+	if ((descr->data_status & 0x00000001) == 1) { /* end of frame */
+		skb = descr->skb;
+		dma_unmap_single(&card->dev->core, descr->buf_addr, skb->len,
+			 PCI_DMA_BIDIRECTIONAL);
+		dev_kfree_skb_any(skb);
+	} else {
+		dma_unmap_single(&card->dev->core, descr->buf_addr,
+			descr->buf_size, PCI_DMA_BIDIRECTIONAL);
+	}
+  }
+	descr->buf_addr = 0;
+	descr->buf_size = 0;
+	descr->next_descr_addr = 0;
+	descr->result_size = 0;
+	descr->valid_size = 0;
+	descr->data_status = 0;
+	descr->data_error = 0;
+	descr->skb = NULL;
+	card->tx_chain.tail = card->tx_chain.tail->next;
+
+	/* set descr status */
+	descr->dmac_cmd_status = GELIC_NET_DMAC_CMDSTAT_NOT_IN_USE;
+}
+
+/**
+ * gelic_net_release_tx_chain - processes sent tx descriptors
+ * @card: adapter structure
+ * @stop: net_stop sequence
+ *
+ * releases the tx descriptors that gelic has finished with
+ */
+static void
+gelic_net_release_tx_chain(struct gelic_net_card *card, int stop)
+{
+	struct gelic_net_descr_chain *tx_chain = &card->tx_chain;
+	enum gelic_net_descr_status status;
+	int release = 0;
+
+	for (;tx_chain->head != tx_chain->tail && tx_chain->tail;) {
+		status = gelic_net_get_descr_status(tx_chain->tail);
+		switch (status) {
+		case GELIC_NET_DESCR_RESPONSE_ERROR:
+		case GELIC_NET_DESCR_PROTECTION_ERROR:
+		case GELIC_NET_DESCR_FORCE_END:
+			printk("%s: forcing end of tx descriptor "
+			       "with status x%02x\n",
+			       card->netdev->name, status);
+			card->netdev_stats.tx_dropped++;
+			break;
+
+		case GELIC_NET_DESCR_COMPLETE:
+			card->netdev_stats.tx_packets++;
+			card->netdev_stats.tx_bytes +=
+				tx_chain->tail->skb->len;
+			break;
+
+		case GELIC_NET_DESCR_CARDOWNED:
+		default: /* any other value (== GELIC_NET_DESCR_NOT_IN_USE) */
+			goto out;
+		}
+		gelic_net_release_tx_descr(card, tx_chain->tail);
+		release = 1;
+	}
+out:
+	/* status NOT_IN_USE or chain end */
+	if (!tx_chain->tail) {
+		/* release all chains */
+		if(card->tx_chain.head) printk("ERROR tx_chain.head is NULL\n");
+		card->tx_chain.tail = card->tx_top;
+		card->tx_chain.head = card->tx_top;
+	}
+	if (!stop && release && netif_queue_stopped(card->netdev)) {
+		netif_wake_queue(card->netdev);
+	}
+}
+
+/**
+ * gelic_net_set_multi - sets multicast addresses and promisc flags
+ * @netdev: interface device structure
+ *
+ * gelic_net_set_multi configures multicast addresses as needed for the
+ * netdev interface. It also sets up multicast, allmulti and promisc
+ * flags appropriately
+ */
+static void
+gelic_net_set_multi(struct net_device *netdev)
+{
+	int i;
+	uint8_t *p;
+	uint64_t addr, status;
+	struct dev_mc_list *mc;
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	/* clear all multicast address */
+	status = lv1_net_remove_multicast_address(card->dev->did.bus_id,
+				card->dev->did.dev_id, 0, 1);
+	if (status) {
+		printk("lv1_net_remove_multicast_address failed, status=%ld\n",\
+			status);
+	}
+	/* set broadcast address */
+	status = lv1_net_add_multicast_address(card->dev->did.bus_id,
+			card->dev->did.dev_id, GELIC_NET_BROADCAST_ADDR, 0);
+	if (status) {
+		printk("lv1_net_add_multicast_address failed, status=%ld\n",\
+			status);
+	}
+
+	if (netdev->flags & IFF_ALLMULTI
+		|| netdev->mc_count > GELIC_NET_MC_COUNT_MAX) { /* list max */
+		status = lv1_net_add_multicast_address(card->dev->did.bus_id,
+				card->dev->did.dev_id,
+				0, 1);
+		if (status) {
+			printk("lv1_net_add_multicast_address failed, status=%ld\n",\
+				status);
+		}
+		return ;
+	}
+
+	/* set multicalst address */
+	for ( mc = netdev->mc_list; mc; mc = mc->next) {
+		addr = 0;
+		p = mc->dmi_addr;
+		for (i = 0; i < ETH_ALEN; i++) {
+			addr <<= 8;
+			addr |= *p++;
+		}
+		status = lv1_net_add_multicast_address(card->dev->did.bus_id,
+				card->dev->did.dev_id,
+				addr, 0);
+		if (status) {
+			printk("lv1_net_add_multicast_address failed, status=%ld\n",\
+				status);
+		}
+	}
+}
+
+/**
+ * gelic_net_disable_rxdmac - disables the receive DMA controller
+ * @card: card structure
+ *
+ * gelic_net_disable_rxdmac terminates processing on the DMA controller by
+ * turing off DMA and issueing a force end
+ */
+static void
+gelic_net_disable_rxdmac(struct gelic_net_card *card)
+{
+	uint64_t status;
+
+	status = lv1_net_stop_rx_dma(card->dev->did.bus_id,
+		card->dev->did.dev_id, 0);
+	if (status) {
+		printk("lv1_net_stop_rx_dma faild, status=%ld\n", status);
+	}
+}
+
+/**
+ * gelic_net_disable_txdmac - disables the transmit DMA controller
+ * @card: card structure
+ *
+ * gelic_net_disable_txdmac terminates processing on the DMA controller by
+ * turing off DMA and issueing a force end
+ */
+static void
+gelic_net_disable_txdmac(struct gelic_net_card *card)
+{
+	uint64_t status;
+
+	status = lv1_net_stop_tx_dma(card->dev->did.bus_id,
+		card->dev->did.dev_id, 0);
+	if (status) {
+		printk("lv1_net_stop_tx_dma faild, status=%ld\n", status);
+	}
+}
+
+/**
+ * gelic_net_stop - called upon ifconfig down
+ * @netdev: interface device structure
+ *
+ * always returns 0
+ */
+int
+gelic_net_stop(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	netif_poll_disable(netdev);
+	netif_stop_queue(netdev);
+
+	/* turn off DMA, force end */
+	gelic_net_disable_rxdmac(card);
+	gelic_net_disable_txdmac(card);
+
+	gelic_net_set_irq_mask(card, 0);
+
+	/* disconnect event port */
+	free_irq(card->netdev->irq, card->netdev);
+	ps3_sb_event_receive_port_destroy(&card->dev->did,
+		card->dev->interrupt_id, card->netdev->irq);
+	card->netdev->irq = NO_IRQ;
+
+	netif_carrier_off(netdev);
+
+	/* release chains */
+	gelic_net_release_tx_chain(card, 1);
+	gelic_net_release_rx_chain(card);
+
+	gelic_net_free_chain(card, card->tx_top);
+	gelic_net_free_chain(card, card->rx_top);
+
+	return 0;
+}
+
+/**
+ * gelic_net_get_next_tx_descr - returns the next available tx descriptor
+ * @card: device structure to get descriptor from
+ *
+ * returns the address of the next descriptor, or NULL if not available.
+ */
+static struct gelic_net_descr *
+gelic_net_get_next_tx_descr(struct gelic_net_card *card)
+{
+	if (card->tx_chain.head == NULL) return NULL;
+	/* check, if head points to not-in-use descr */
+  if (!ps3_gelic_param) {
+	if ( card->tx_chain.tail != card->tx_chain.head->next
+		&& gelic_net_get_descr_status(card->tx_chain.head) ==
+		     GELIC_NET_DESCR_NOT_IN_USE ) {
+		return card->tx_chain.head;
+	} else {
+		return NULL;
+	}
+  } else {
+	if ( card->tx_chain.tail != card->tx_chain.head->next
+		&& card->tx_chain.tail != card->tx_chain.head->next->next
+		&& gelic_net_get_descr_status(card->tx_chain.head) ==
+		     GELIC_NET_DESCR_NOT_IN_USE
+		&& gelic_net_get_descr_status(card->tx_chain.head->next) ==
+		     GELIC_NET_DESCR_NOT_IN_USE ) {
+		return card->tx_chain.head;
+	} else {
+		return NULL;
+	}
+  }
+}
+
+/**
+ * gelic_net_set_txdescr_cmdstat - sets the tx descriptor command field
+ * @descr: descriptor structure to fill out
+ * @skb: packet to consider
+ * @middle: middle of frame
+ *
+ * fills out the command and status field of the descriptor structure,
+ * depending on hardware checksum settings. This function assumes a wmb()
+ * has executed before.
+ */
+static void
+gelic_net_set_txdescr_cmdstat(struct gelic_net_descr *descr,
+			       struct sk_buff *skb, int middle)
+{
+	uint32_t nocs, tcpcs, udpcs;
+    struct   iphdr *iph;
+
+	if (middle) {
+		nocs =  GELIC_NET_DMAC_CMDSTAT_NOCS;
+		tcpcs = GELIC_NET_DMAC_CMDSTAT_TCPCS;
+		udpcs = GELIC_NET_DMAC_CMDSTAT_UDPCS;
+	}else {
+		nocs =  GELIC_NET_DMAC_CMDSTAT_NOCS
+			| GELIC_NET_DMAC_CMDSTAT_END_FRAME;
+		tcpcs = GELIC_NET_DMAC_CMDSTAT_TCPCS
+			| GELIC_NET_DMAC_CMDSTAT_END_FRAME;
+		udpcs = GELIC_NET_DMAC_CMDSTAT_UDPCS
+			| GELIC_NET_DMAC_CMDSTAT_END_FRAME;
+	}
+
+	if (skb->ip_summed != CHECKSUM_PARTIAL) {
+		descr->dmac_cmd_status = nocs;
+	} else {
+		/* is packet ip?
+		 * if yes: tcp? udp? */
+		if (skb->protocol == htons(ETH_P_IP)) 
+        {
+		    iph=(struct   iphdr *)skb_network_header(skb);
+        	if (iph->protocol == IPPROTO_TCP) {
+				descr->dmac_cmd_status = tcpcs;
+			} else if (iph->protocol == IPPROTO_UDP) {
+				descr->dmac_cmd_status = udpcs;
+			} else { /* the stack should checksum non-tcp and non-udp
+				    packets on his own: NETIF_F_IP_CSUM */
+				descr->dmac_cmd_status = nocs;
+			}
+		}
+	}
+}
+
+/**
+ * gelic_net_prepare_tx_descr - get dma address of skb_data
+ * @card: card structure
+ * @descr: descriptor structure
+ * @skb: packet to use
+ *
+ * returns 0 on success, <0 on failure.
+ *
+ */
+static int
+gelic_net_prepare_tx_descr_v(struct gelic_net_card *card,
+			    struct gelic_net_descr *descr,
+			    struct sk_buff *skb)
+{
+	dma_addr_t buf;
+	uint8_t *hdr;
+	struct vlan_ethhdr *v_hdr;
+	int vlan_len;
+
+	if (skb->len < GELIC_NET_VLAN_POS) {
+		printk("error: skb->len:%d\n", skb->len);
+		return -EINVAL;
+	}
+	hdr = skb->data;
+	v_hdr = (struct vlan_ethhdr *)skb->data;
+	memcpy(&descr->vlan, v_hdr, GELIC_NET_VLAN_POS);
+	if (card->vlan_index != -1) {
+		descr->vlan.h_vlan_proto = htons(ETH_P_8021Q); /* vlan 0x8100*/
+		descr->vlan.h_vlan_TCI = htons(card->vlan_id[card->vlan_index]);
+		vlan_len = GELIC_NET_VLAN_POS + VLAN_HLEN; /* VLAN_HLEN=4 */
+	} else {
+		vlan_len = GELIC_NET_VLAN_POS; /* no vlan tag */
+	}
+
+	/* first descr */
+	buf = dma_map_single(&card->dev->core, &descr->vlan,
+					 vlan_len, PCI_DMA_BIDIRECTIONAL);
+
+	if (buf == DMA_ERROR_CODE) {
+		printk("could not iommu-map packet (%p, %i). "
+			  "Dropping packet\n", v_hdr, vlan_len);
+		return -ENOMEM;
+	}
+
+	descr->buf_addr = buf;
+	descr->buf_size = vlan_len;
+	descr->skb = skb; /* not used */
+	descr->data_status = 0;
+	gelic_net_set_txdescr_cmdstat(descr, skb, 1); /* not the frame end */
+
+	/* second descr */
+	card->tx_chain.head = card->tx_chain.head->next;
+	descr->next_descr_addr = descr->next->bus_addr;
+	descr = descr->next;
+	if (gelic_net_get_descr_status(descr) !=
+			GELIC_NET_DESCR_NOT_IN_USE) {
+		printk("ERROR descr()\n"); /* XXX will be removed */
+	}
+	buf = dma_map_single(&card->dev->core, hdr + GELIC_NET_VLAN_POS,
+				skb->len - GELIC_NET_VLAN_POS,
+				PCI_DMA_BIDIRECTIONAL);
+
+	if (buf == DMA_ERROR_CODE) {
+		printk("could not iommu-map packet (%p, %i). "
+			  "Dropping packet\n", hdr + GELIC_NET_VLAN_POS,
+			  skb->len - GELIC_NET_VLAN_POS);
+		return -ENOMEM;
+	}
+
+	descr->buf_addr = buf;
+	descr->buf_size = skb->len - GELIC_NET_VLAN_POS;
+	descr->skb = skb;
+	descr->data_status = 0;
+	descr->next_descr_addr= 0;
+	gelic_net_set_txdescr_cmdstat(descr,skb, 0);
+
+	return 0;
+}
+
+static int
+gelic_net_prepare_tx_descr(struct gelic_net_card *card,
+			    struct gelic_net_descr *descr,
+			    struct sk_buff *skb)
+{
+	dma_addr_t buf = dma_map_single(&card->dev->core, skb->data,
+					 skb->len, PCI_DMA_BIDIRECTIONAL);
+
+	if (buf == DMA_ERROR_CODE) {
+		printk("could not iommu-map packet (%p, %i). "
+			  "Dropping packet\n", skb->data, skb->len);
+		return -ENOMEM;
+	}
+
+	descr->buf_addr = buf;
+	descr->buf_size = skb->len;
+	descr->skb = skb;
+	descr->data_status = 0;
+
+	return 0;
+}
+
+static void
+gelic_net_set_frame_end(struct gelic_net_card *card,
+		struct gelic_net_descr *descr, struct sk_buff *skb)
+{
+	descr->next_descr_addr= 0;
+	gelic_net_set_txdescr_cmdstat(descr,skb, 0);
+	wmb();
+	if (descr->prev) {
+		descr->prev->next_descr_addr = descr->bus_addr;
+	}
+}
+
+/**
+ * gelic_net_kick_txdma - enables TX DMA processing
+ * @card: card structure
+ * @descr: descriptor address to enable TX processing at
+ *
+ */
+static void
+gelic_net_kick_txdma(struct gelic_net_card *card,
+		       struct gelic_net_descr *descr)
+{
+	uint64_t status = -1;
+	int count = 10;
+
+	if (dmac_status) {
+		return ;
+	}
+
+	if (gelic_net_get_descr_status(descr) == GELIC_NET_DESCR_CARDOWNED) {
+		/* kick */
+		dmac_status = 1;
+
+		while(count--) {
+			status = lv1_net_start_tx_dma(card->dev->did.bus_id,
+					card->dev->did.dev_id,
+					(uint64_t)descr->bus_addr, 0);
+			if (!status) {
+				break;
+			}
+		}
+		if (!count) {
+			printk("lv1_net_start_txdma failed, status=%ld %016lx\n",\
+				status, gelic_irq_status);
+		}
+	}
+}
+
+/**
+ * gelic_net_xmit - transmits a frame over the device
+ * @skb: packet to send out
+ * @netdev: interface device structure
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int
+gelic_net_xmit(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	struct gelic_net_descr *descr = NULL;
+	int result;
+	unsigned long flags;
+
+	spin_lock_irqsave(&card->intmask_lock, flags);
+
+	gelic_net_release_tx_chain(card, 0);
+	if (skb == NULL){
+		goto kick;
+	}
+	descr = gelic_net_get_next_tx_descr(card); /* get tx_chain.head */
+	if (!descr) {
+		netif_stop_queue(netdev);
+		spin_unlock_irqrestore(&card->intmask_lock, flags);
+		return 1;
+	}
+  if (!ps3_gelic_param) {
+	result = gelic_net_prepare_tx_descr(card, descr, skb);
+  } else {
+	result = gelic_net_prepare_tx_descr_v(card, descr, skb);
+  }
+	if (result)
+		goto error;
+
+	card->tx_chain.head = card->tx_chain.head->next;
+  if (!ps3_gelic_param) {
+	gelic_net_set_frame_end(card, descr, skb);
+  } else {
+	if (descr->prev) {
+		descr->prev->next_descr_addr = descr->bus_addr;
+	}
+  }
+kick:
+	wmb();
+	gelic_net_kick_txdma(card, card->tx_chain.tail);
+
+	netdev->trans_start = jiffies;
+	spin_unlock_irqrestore(&card->intmask_lock, flags);
+	return NETDEV_TX_OK;
+
+error:
+	card->netdev_stats.tx_dropped++;
+	spin_unlock_irqrestore(&card->intmask_lock, flags);
+	return NETDEV_TX_LOCKED;
+}
+
+/**
+ * gelic_net_pass_skb_up - takes an skb from a descriptor and passes it on
+ * @descr: descriptor to process
+ * @card: card structure
+ *
+ * returns 1 on success, 0 if no packet was passed to the stack
+ *
+ * iommu-unmaps the skb, fills out skb structure and passes the data to the
+ * stack. The descriptor state is not changed.
+ */
+static int
+gelic_net_pass_skb_up(struct gelic_net_descr *descr,
+		       struct gelic_net_card *card)
+{
+	struct sk_buff *skb;
+	struct net_device *netdev;
+	uint32_t data_status, data_error;
+
+	data_status = descr->data_status;
+	data_error = descr->data_error;
+
+	netdev = card->netdev;
+	/* check for errors in the data_error flag */
+	if ((data_error & GELIC_NET_DATA_ERROR_MASK))
+		DPRINTK("error in received descriptor found, "
+		       "data_status=x%08x, data_error=x%08x\n",
+		       data_status, data_error);
+	/* prepare skb, unmap descriptor */
+	skb = descr->skb;
+	dma_unmap_single(&card->dev->core, descr->buf_addr, GELIC_NET_MAX_MTU,
+			 PCI_DMA_BIDIRECTIONAL);
+
+	/* the cases we'll throw away the packet immediately */
+	if (data_error & GELIC_NET_DATA_ERROR_FLG) {
+		DPRINTK("ERROR DESTROY:%x\n", data_error);
+		return 0;
+	}
+
+	skb->dev = netdev;
+	skb_put(skb, descr->valid_size);
+	descr->skb = NULL;
+	/* the card seems to add 2 bytes of junk in front
+	 * of the ethernet frame */
+#define GELIC_NET_MISALIGN		2
+	skb_pull(skb, GELIC_NET_MISALIGN);
+	skb->protocol = eth_type_trans(skb, netdev);
+
+	/* checksum offload */
+	if (card->rx_csum) {
+		if ( (data_status & GELIC_NET_DATA_STATUS_CHK_MASK) &&
+		     (!(data_error & GELIC_NET_DATA_ERROR_CHK_MASK)) )
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+		else
+			skb->ip_summed = CHECKSUM_NONE;
+	} else {
+		skb->ip_summed = CHECKSUM_NONE;
+	}
+
+	/* pass skb up to stack */
+	netif_receive_skb(skb);
+
+	/* update netdevice statistics */
+	card->netdev_stats.rx_packets++;
+	card->netdev_stats.rx_bytes += skb->len;
+
+	return 1;
+}
+
+/**
+ * gelic_net_decode_descr - processes an rx descriptor
+ * @card: card structure
+ *
+ * returns 1 if a packet has been sent to the stack, otherwise 0
+ *
+ * processes an rx descriptor by iommu-unmapping the data buffer and passing
+ * the packet up to the stack
+ */
+static int
+gelic_net_decode_one_descr(struct gelic_net_card *card)
+{
+	enum gelic_net_descr_status status;
+	struct gelic_net_descr *descr;
+	struct gelic_net_descr_chain *chain = &card->rx_chain;
+	int result = 0;
+	int kick = 0;
+	uint32_t cmd_status;
+
+	descr = chain->tail;
+	cmd_status = chain->tail->dmac_cmd_status;
+	rmb();
+	status = cmd_status >> GELIC_NET_DESCR_IND_PROC_SHIFT;
+	if (status == GELIC_NET_DESCR_CARDOWNED) {
+		goto no_decode;
+	}
+	if (status == GELIC_NET_DESCR_NOT_IN_USE) {
+		printk("err: decode_one_descr\n");
+		goto no_decode;
+	}
+
+	if ( (status == GELIC_NET_DESCR_RESPONSE_ERROR) ||
+	     (status == GELIC_NET_DESCR_PROTECTION_ERROR) ||
+	     (status == GELIC_NET_DESCR_FORCE_END) ) {
+		printk("%s: dropping RX descriptor with state %d\n",
+		       card->netdev->name, status);
+		card->netdev_stats.rx_dropped++;
+		goto refill;
+	}
+
+	if ( (status != GELIC_NET_DESCR_COMPLETE) &&
+	     (status != GELIC_NET_DESCR_FRAME_END) ) {
+		printk("%s: RX descriptor with state %d\n",
+		       card->netdev->name, status);
+		goto refill;
+	}
+
+	/* ok, we've got a packet in descr */
+	result = gelic_net_pass_skb_up(descr, card); /* 1: skb_up sccess */
+	if (cmd_status & GELIC_NET_DMAC_CMDSTAT_CHAIN_END) {
+		kick = 1;
+	}
+refill:
+	descr->next_descr_addr = 0; /* unlink the descr */
+	wmb();
+	gelic_net_set_descr_status(descr, GELIC_NET_DESCR_NOT_IN_USE);
+	/* change the descriptor state: */
+	gelic_net_prepare_rx_descr(card, descr); /* refill one desc */
+	chain->head = descr;
+	chain->tail = descr->next;
+	descr->prev->next_descr_addr = descr->bus_addr;
+	if(kick) {
+		wmb();
+		gelic_net_enable_rxdmac(card);
+	}
+	return result;
+
+no_decode:
+	return 0;
+}
+
+/**
+ * gelic_net_poll - NAPI poll function called by the stack to return packets
+ * @netdev: interface device structure
+ * @budget: number of packets we can pass to the stack at most
+ *
+ * returns 0 if no more packets available to the driver/stack. Returns 1,
+ * if the quota is exceeded, but the driver has still packets.
+ *
+ */
+static int
+gelic_net_poll(struct net_device *netdev, int *budget)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	int packets_to_do, packets_done = 0;
+	int no_more_packets = 0;
+
+	packets_to_do = min(*budget, netdev->quota);
+
+	while (packets_to_do) {
+		if (gelic_net_decode_one_descr(card)) {
+			packets_done++;
+			packets_to_do--;
+		} else {
+			/* no more packets for the stack */
+			no_more_packets = 1;
+			break;
+		}
+	}
+	netdev->quota -= packets_done;
+	*budget -= packets_done;
+	if (no_more_packets == 1) {
+		netif_rx_complete(netdev);
+
+		/* one more check */
+		while (1) {
+			if (!gelic_net_decode_one_descr(card) ) break;
+		};
+
+		return 0;
+	}else {
+		return 1;
+	}
+}
+
+/**
+ * gelic_net_get_stats - get interface statistics
+ * @netdev: interface device structure
+ *
+ * returns the interface statistics residing in the gelic_net_card struct
+ */
+static struct net_device_stats *
+gelic_net_get_stats(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	struct net_device_stats *stats = &card->netdev_stats;
+
+	return stats;
+}
+
+/**
+ * gelic_net_change_mtu - changes the MTU of an interface
+ * @netdev: interface device structure
+ * @new_mtu: new MTU value
+ *
+ * returns 0 on success, <0 on failure
+ */
+static int
+gelic_net_change_mtu(struct net_device *netdev, int new_mtu)
+{
+	/* no need to re-alloc skbs or so -- the max mtu is about 2.3k
+	 * and mtu is outbound only anyway */
+	if ( (new_mtu < GELIC_NET_MIN_MTU ) ||
+		(new_mtu > GELIC_NET_MAX_MTU) ) {
+		return -EINVAL;
+	}
+	netdev->mtu = new_mtu;
+	return 0;
+}
+
+/**
+ * gelic_net_interrupt - event handler for gelic_net
+ */
+static irqreturn_t
+gelic_net_interrupt(int irq, void *ptr)
+{
+	struct net_device *netdev = ptr;
+	struct gelic_net_card *card = netdev_priv(netdev);
+	uint32_t status0, status1, status2;
+	unsigned long flags;
+	uint64_t status;
+
+	status = gelic_irq_status;
+	rmb();
+	status0 = (uint32_t)(status >> 32);
+	status1 = (uint32_t)(status & 0xffffffff);
+	status2 = 0;
+
+	if (!status0 && !status1 && !status2) {
+		return IRQ_NONE;
+	}
+
+	if(status1 & (1 << GELIC_NET_GDADCEINT) )  {
+		netif_rx_schedule(netdev);
+	}else
+	if (status0 & (1 << GELIC_NET_GRFANMINT) ) {
+		netif_rx_schedule(netdev);
+	}
+
+	if (status0 & (1 << GELIC_NET_GDTDCEINT) ) {
+		spin_lock_irqsave(&card->intmask_lock, flags);
+		dmac_status = 0;
+		spin_unlock_irqrestore(&card->intmask_lock, flags);
+		gelic_net_xmit(NULL, netdev);
+	}
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/**
+ * gelic_net_poll_controller - artificial interrupt for netconsole etc.
+ * @netdev: interface device structure
+ *
+ * see Documentation/networking/netconsole.txt
+ */
+static void
+gelic_net_poll_controller(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	gelic_net_set_irq_mask(card, 0);
+	gelic_net_interrupt(netdev->irq, netdev);
+	gelic_net_set_irq_mask(card, card->ghiintmask);
+}
+#endif /* CONFIG_NET_POLL_CONTROLLER */
+
+/**
+ * gelic_net_open_device - open device and map dma region
+ * @card: card structure
+ */
+static int
+gelic_net_open_device(struct gelic_net_card *card)
+{
+	unsigned long result;
+	int ret;
+
+	result = ps3_sb_event_receive_port_setup(PS3_BINDING_CPU_ANY,
+		&card->dev->did, card->dev->interrupt_id, &card->netdev->irq);
+
+	if (result) {
+		printk("%s:%d: gelic_net_open_device failed (%ld)\n",
+			__func__, __LINE__, result);
+		ret = -EPERM;
+		goto fail_alloc_irq;
+	}
+
+	ret = request_irq(card->netdev->irq, gelic_net_interrupt, IRQF_DISABLED,
+		"gelic network", card->netdev);
+
+	if (ret) {
+		printk("%s:%d: request_irq failed (%ld)\n",
+			__func__, __LINE__, result);
+		goto fail_request_irq;
+	}
+
+	return 0;
+
+fail_request_irq:
+	ps3_sb_event_receive_port_destroy(&card->dev->did,
+		card->dev->interrupt_id, card->netdev->irq);
+	card->netdev->irq = NO_IRQ;
+fail_alloc_irq:
+	return ret;
+}
+
+
+/**
+ * gelic_net_open - called upon ifonfig up
+ * @netdev: interface device structure
+ *
+ * returns 0 on success, <0 on failure
+ *
+ * gelic_net_open allocates all the descriptors and memory needed for
+ * operation, sets up multicast list and enables interrupts
+ */
+int
+gelic_net_open(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	printk(" -> %s:%d\n", __func__, __LINE__);
+
+	gelic_net_open_device(card);
+
+	if (gelic_net_init_chain(card, &card->tx_chain,
+			card->descr, tx_descriptors))
+		goto alloc_tx_failed;
+	if (gelic_net_init_chain(card, &card->rx_chain,
+			card->descr + tx_descriptors, rx_descriptors))
+		goto alloc_rx_failed;
+
+	/* head of chain */
+	card->tx_top = card->tx_chain.head;
+	card->rx_top = card->rx_chain.head;
+
+	/* allocate rx skbs */
+	if (gelic_net_alloc_rx_skbs(card))
+		goto alloc_skbs_failed;
+
+	dmac_status = 0;
+	card->ghiintmask = GELIC_NET_RXINT | GELIC_NET_TXINT;
+	gelic_net_set_irq_mask(card, card->ghiintmask);
+	gelic_net_enable_rxdmac(card);
+
+	netif_start_queue(netdev);
+	netif_carrier_on(netdev);
+	netif_poll_enable(netdev);
+
+	return 0;
+
+alloc_skbs_failed:
+	gelic_net_free_chain(card, card->rx_top);
+alloc_rx_failed:
+	gelic_net_free_chain(card, card->tx_top);
+alloc_tx_failed:
+	return -ENOMEM;
+}
+
+#ifdef GELIC_NET_ETHTOOL
+static void
+gelic_net_get_drvinfo (struct net_device *netdev, struct ethtool_drvinfo *info)
+{
+	strncpy(info->driver, GELIC_NET_DRV_NAME, sizeof(info->driver) - 1);
+	strncpy(info->version, GELIC_NET_DRV_VERSION, sizeof(info->version) - 1);
+}
+
+static int
+gelic_net_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	uint64_t status, v1, v2;
+	int speed, duplex;
+
+	speed = duplex = -1;
+	status = lv1_net_control(card->dev->did.bus_id, card->dev->did.dev_id,
+			GELIC_NET_GET_ETH_PORT_STATUS, GELIC_NET_PORT, 0, 0,
+			&v1, &v2);
+	if (status) {
+		/* link down */
+	} else {
+		if (v1 & GELIC_NET_FULL_DUPLEX) {
+			duplex = DUPLEX_FULL;
+		} else {
+			duplex = DUPLEX_HALF;
+		}
+
+		if (v1 & GELIC_NET_SPEED_10 ) {
+			speed = SPEED_10;
+		} else if (v1 & GELIC_NET_SPEED_100) {
+			speed = SPEED_100;
+		} else if (v1 & GELIC_NET_SPEED_1000) {
+			speed = SPEED_1000;
+		}
+	}
+	cmd->supported = SUPPORTED_TP | SUPPORTED_Autoneg |
+			SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+			SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+			SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full;
+	cmd->advertising = cmd->supported;
+	cmd->speed = speed;
+	cmd->duplex = duplex;
+	cmd->autoneg = AUTONEG_ENABLE; /* always enabled */
+	cmd->port = PORT_TP;
+
+	return 0;
+}
+
+static uint32_t
+gelic_net_get_link(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	uint64_t status, v1, v2;
+	int link;
+
+	status = lv1_net_control(card->dev->did.bus_id, card->dev->did.dev_id,
+			GELIC_NET_GET_ETH_PORT_STATUS, GELIC_NET_PORT, 0, 0,
+			&v1, &v2);
+	if (status) {
+		return 0; /* link down */
+	}
+	if (v1 & GELIC_NET_LINK_UP)
+		link = 1;
+	else
+		link = 0;
+	return link;
+}
+
+static int
+gelic_net_nway_reset(struct net_device *netdev)
+{
+	if (netif_running(netdev)) {
+		gelic_net_stop(netdev);
+		gelic_net_open(netdev);
+	}
+	return 0;
+}
+
+static uint32_t
+gelic_net_get_tx_csum(struct net_device *netdev)
+{
+	return (netdev->features & NETIF_F_IP_CSUM) != 0;
+}
+
+static int
+gelic_net_set_tx_csum(struct net_device *netdev, uint32_t data)
+{
+	if (data)
+		netdev->features |= NETIF_F_IP_CSUM;
+	else
+		netdev->features &= ~NETIF_F_IP_CSUM;
+
+	return 0;
+}
+
+static uint32_t
+gelic_net_get_rx_csum(struct net_device *netdev)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	return card->rx_csum;
+}
+
+static int
+gelic_net_set_rx_csum(struct net_device *netdev, uint32_t data)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+
+	card->rx_csum = data;
+	return 0;
+}
+
+static struct ethtool_ops gelic_net_ethtool_ops = {
+	.get_drvinfo	= gelic_net_get_drvinfo,
+	.get_settings	= gelic_net_get_settings,
+	.get_link	= gelic_net_get_link,
+	.nway_reset	= gelic_net_nway_reset,
+	.get_tx_csum	= gelic_net_get_tx_csum,
+	.set_tx_csum	= gelic_net_set_tx_csum,
+	.get_rx_csum	= gelic_net_get_rx_csum,
+	.set_rx_csum	= gelic_net_set_rx_csum,
+};
+#endif
+
+static int
+gelic_net_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+	struct gelic_net_card *card = netdev_priv(netdev);
+	void __user *addr = (void __user *) ifr->ifr_ifru.ifru_data;
+	int mode, res = 0;
+
+	switch(cmd) {
+	case GELIC_NET_GET_MODE:
+		DPRINTK("GELIC_NET_GET_MODE:\n");
+		mode = card->vlan_index;
+		if (copy_to_user(addr, &mode, sizeof(mode)) ) {
+			printk("error copy_to_user\n");
+		}
+		res = 0;
+		break;
+	case GELIC_NET_SET_MODE:
+		if (card->vlan_index == -1) {
+			res = -EOPNOTSUPP; /* vlan mode only */
+			break;
+		}
+		if (copy_from_user(&mode, addr, sizeof(mode)) ) {
+			printk("error copy_from_user\n");
+		}
+		DPRINTK("GELIC_NET_SET_MODE:%x --> %x \n",
+				card->vlan_index, mode);
+		if (mode > GELIC_NET_VLAN_MAX -1 || mode < -1)
+			mode = GELIC_NET_VLAN_WIRED - 1;
+
+		if (card->vlan_index != mode) {
+			card->vlan_index = mode;
+			if (netif_running(netdev)) {
+				gelic_net_stop(netdev);
+				gelic_net_open(netdev);
+			}
+		}
+		res = 0;
+		break;
+	default:
+		res = -EOPNOTSUPP;
+		break;
+	}
+
+	return res;
+}
+
+/**
+ * gelic_net_tx_timeout_task - task scheduled by the watchdog timeout
+ * function (to be called not under interrupt status)
+ * @data: data, is interface device structure
+ *
+ * called as task when tx hangs, resets interface (if interface is up)
+ */
+static void
+gelic_net_tx_timeout_task(struct work_struct *work)
+{
+	struct gelic_net_card *card =
+		container_of(work, struct gelic_net_card, tx_timeout_task);
+	struct net_device *netdev = card->netdev;
+
+	printk("Timed out. Restarting... \n");
+
+	if (!(netdev->flags & IFF_UP))
+		goto out;
+
+	netif_device_detach(netdev);
+	gelic_net_stop(netdev);
+
+	gelic_net_open(netdev);
+	netif_device_attach(netdev);
+
+out:
+	atomic_dec(&card->tx_timeout_task_counter);
+}
+
+/**
+ * gelic_net_tx_timeout - called when the tx timeout watchdog kicks in.
+ * @netdev: interface device structure
+ *
+ * called, if tx hangs. Schedules a task that resets the interface
+ */
+static void
+gelic_net_tx_timeout(struct net_device *netdev)
+{
+	struct gelic_net_card *card;
+
+	card = netdev_priv(netdev);
+	atomic_inc(&card->tx_timeout_task_counter);
+	if (netdev->flags & IFF_UP)
+		schedule_work(&card->tx_timeout_task);
+	else
+		atomic_dec(&card->tx_timeout_task_counter);
+}
+
+/**
+ * gelic_net_setup_netdev_ops - initialization of net_device operations
+ * @netdev: net_device structure
+ *
+ * fills out function pointers in the net_device structure
+ */
+static void
+gelic_net_setup_netdev_ops(struct net_device *netdev)
+{
+	netdev->open = &gelic_net_open;
+	netdev->stop = &gelic_net_stop;
+	netdev->hard_start_xmit = &gelic_net_xmit;
+	netdev->get_stats = &gelic_net_get_stats;
+	netdev->set_multicast_list = &gelic_net_set_multi;
+	netdev->change_mtu = &gelic_net_change_mtu;
+	/* tx watchdog */
+	netdev->tx_timeout = &gelic_net_tx_timeout;
+	netdev->watchdog_timeo = GELIC_NET_WATCHDOG_TIMEOUT;
+	/* NAPI */
+	netdev->poll = &gelic_net_poll;
+	netdev->weight = GELIC_NET_NAPI_WEIGHT;
+#ifdef GELIC_NET_ETHTOOL
+	netdev->ethtool_ops = &gelic_net_ethtool_ops;
+#endif
+	netdev->do_ioctl = &gelic_net_ioctl;
+}
+
+/**
+ * gelic_net_setup_netdev - initialization of net_device
+ * @card: card structure
+ *
+ * Returns 0 on success or <0 on failure
+ *
+ * gelic_net_setup_netdev initializes the net_device structure
+ **/
+static int
+gelic_net_setup_netdev(struct gelic_net_card *card)
+{
+	int i, result;
+	struct net_device *netdev = card->netdev;
+	struct sockaddr addr;
+	uint8_t *mac;
+	uint64_t status, v1, v2;
+
+	SET_MODULE_OWNER(netdev);
+	spin_lock_init(&card->intmask_lock);
+
+	card->rx_csum = GELIC_NET_RX_CSUM_DEFAULT;
+
+	gelic_net_setup_netdev_ops(netdev);
+
+	netdev->features = NETIF_F_IP_CSUM;
+
+	status = lv1_net_control(card->dev->did.bus_id, card->dev->did.dev_id,
+				GELIC_NET_GET_MAC_ADDRESS,
+				0, 0, 0, &v1, &v2);
+	if (status || !v1) {
+		printk("lv1_net_control GET_MAC_ADDR not supported, status=%ld\n",
+			status);
+		return -EINVAL;
+	}
+	v1 <<= 16;
+	mac = (uint8_t *)&v1;
+	memcpy(addr.sa_data, mac, ETH_ALEN);
+	memcpy(netdev->dev_addr, addr.sa_data, ETH_ALEN);
+
+	result = register_netdev(netdev);
+	if (result) {
+			printk("Couldn't register net_device: %i\n", result);
+		return result;
+	}
+
+	printk("%s: %s\n", netdev->name, GELIC_NET_DRV_NAME);
+	printk("%s: Ethernet Address: %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X\n",
+		netdev->name,
+		netdev->dev_addr[0], netdev->dev_addr[1], netdev->dev_addr[2],
+		netdev->dev_addr[3], netdev->dev_addr[4], netdev->dev_addr[5]);
+
+	card->vlan_index = -1;	/* no vlan */
+	for (i = 0; i < GELIC_NET_VLAN_MAX ;i++) {
+		status = lv1_net_control(card->dev->did.bus_id,
+					card->dev->did.dev_id,
+					GELIC_NET_GET_VLAN_ID,
+					i + 1, /* GELIC_NET_VLAN_X */
+					0, 0, &v1, &v2);
+		if (status == GELIC_NET_VLAN_NO_ENTRY) {
+			DPRINTK("GELIC_VLAN_ID no entry:%ld, VLAN disabled\n",
+				status);
+			card->vlan_id[i] = 0;
+		} else if (status) {
+			printk("GELIC_NET_VLAN_ID faild, status=%ld\n", status);
+			card->vlan_id[i] = 0;
+		} else {
+			card->vlan_id[i] = (uint32_t)v1;
+			DPRINTK("vlan_id:%d, %lx\n", i, v1);
+		}
+	}
+	if (card->vlan_id[GELIC_NET_VLAN_WIRED - 1]) {
+		card->vlan_index = GELIC_NET_VLAN_WIRED - 1;
+	}
+	return 0;
+}
+
+/**
+ * gelic_net_alloc_card - allocates net_device and card structure
+ *
+ * returns the card structure or NULL in case of errors
+ *
+ * the card and net_device structures are linked to each other
+ */
+static struct gelic_net_card *
+gelic_net_alloc_card(void)
+{
+	struct net_device *netdev;
+	struct gelic_net_card *card;
+	size_t alloc_size;
+
+	alloc_size = sizeof (*card) +
+		sizeof (struct gelic_net_descr) * rx_descriptors +
+		sizeof (struct gelic_net_descr) * tx_descriptors;
+	netdev = alloc_etherdev(alloc_size);
+	if (!netdev)
+		return NULL;
+
+	card = netdev_priv(netdev);
+	card->netdev = netdev;
+	INIT_WORK(&card->tx_timeout_task, gelic_net_tx_timeout_task);
+	init_waitqueue_head(&card->waitq);
+	atomic_set(&card->tx_timeout_task_counter, 0);
+
+	return card;
+}
+
+/**
+ * ps3_gelic_driver_probe - add a device to the control of this driver
+ */
+static int ps3_gelic_driver_probe (struct ps3_system_bus_device *dev)
+{
+	struct gelic_net_card *card;
+	int error = -EIO;
+	uint64_t status;
+	uint64_t lpar;
+
+	card = gelic_net_alloc_card();
+	if (!card) {
+		printk("Couldn't allocate net_device structure, aborting.\n");
+		return -ENOMEM;
+	}
+	gcard = card;
+	card->dev = dev;
+
+	/* setup status indicator */
+	lpar = ps3_mm_phys_to_lpar(__pa(&gelic_irq_status));
+	status = lv1_net_set_interrupt_status_indicator(
+						card->dev->did.bus_id,
+						card->dev->did.dev_id,
+						lpar, 0);
+	if (status) {
+		printk("lv1_net_set_interrupt_status_indicator failed, status=%ld\n",
+			status);
+		goto error;
+	}
+
+	error = gelic_net_setup_netdev(card);
+	if (error) {
+		printk("gelic_net_setup_netdev() failed: error = %d\n", error);
+		goto error;
+	}
+	return 0;
+
+error:
+	free_netdev(card->netdev);
+	return error;
+}
+
+/**
+ * ps3_gelic_driver_remove - remove a device from the control of this driver
+ */
+
+static int
+ps3_gelic_driver_remove (struct ps3_system_bus_device *dev)
+{
+	struct net_device *netdev;
+	struct gelic_net_card *card;
+
+	card = gcard;
+	netdev = card->netdev;
+
+	wait_event(card->waitq,
+		   atomic_read(&card->tx_timeout_task_counter) == 0);
+
+	unregister_netdev(netdev);
+	free_netdev(netdev);
+
+	return 0;
+}
+
+static struct ps3_system_bus_driver ps3_gelic_driver = {
+	.match_id = PS3_MATCH_ID_GELIC,
+	.probe = ps3_gelic_driver_probe,
+	.remove = ps3_gelic_driver_remove,
+	.core = {
+		.name = "ps3_gelic_driver",
+	},
+};
+
+static int __init
+ps3_gelic_driver_init (void)
+{
+	return firmware_has_feature(FW_FEATURE_PS3_LV1)
+		? ps3_system_bus_driver_register(&ps3_gelic_driver)
+		: -ENODEV;
+}
+
+static void __exit
+ps3_gelic_driver_exit (void)
+{
+	ps3_system_bus_driver_unregister(&ps3_gelic_driver);
+}
+
+module_init (ps3_gelic_driver_init);
+module_exit (ps3_gelic_driver_exit);
+
+#ifdef CONFIG_GELIC_NET
+static int __init early_param_gelic_net(char *p)
+{
+	if (strstr(p, "n")) {
+		ps3_gelic_param = 0;	/* gelic_vlan off */
+		printk("ps3_gelic_param:vlan off\n");
+	} else {
+		ps3_gelic_param = 1;	/* gelic_vlan on */
+	}
+	return 0;
+
+}
+early_param("gelic_vlan", early_param_gelic_net);
+#endif
diff -Naur linux-2.6.22-org/drivers/usb/host/ehci-sched.c linux-2.6.22-ps3/drivers/usb/host/ehci-sched.c
--- linux-2.6.22-org/drivers/usb/host/ehci-sched.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/drivers/usb/host/ehci-sched.c	2007-08-22 07:57:31.000000000 +0200
@@ -1168,8 +1168,21 @@
 		if (likely (!list_empty(&stream->free_list))) {
 			itd = list_entry (stream->free_list.prev,
 					 struct ehci_itd, itd_list);
-			list_del (&itd->itd_list);
-			itd_dma = itd->itd_dma;
+#if defined(CONFIG_PPC_PS3)
+			/* Fix for Cell SCC ISO transfer (PS3 Bluetooth). */
+			if (firmware_has_feature(FW_FEATURE_PS3_LV1)
+				&& itd->frame == ((ehci_readl(ehci,
+				&ehci->regs->frame_index) >> 3)
+				% ehci->periodic_size))
+				itd = NULL;
+			else {
+				list_del (&itd->itd_list);
+				itd_dma = itd->itd_dma;
+			}
+#else
+                       list_del (&itd->itd_list);
+                       itd_dma = itd->itd_dma;
+#endif
 		} else
 			itd = NULL;
 
@@ -1784,8 +1797,21 @@
 		if (!list_empty(&stream->free_list)) {
 			sitd = list_entry (stream->free_list.prev,
 					 struct ehci_sitd, sitd_list);
-			list_del (&sitd->sitd_list);
-			sitd_dma = sitd->sitd_dma;
+#if defined(CONFIG_PPC_PS3)
+			/* Fix for Cell SCC ISO transfer (PS3 Bluetooth). */
+			if (firmware_has_feature(FW_FEATURE_PS3_LV1)
+				&& sitd->frame == ((ehci_readl(ehci,
+				&ehci->regs->frame_index) >> 3)
+				% ehci->periodic_size))
+				sitd = NULL;
+			else {
+				list_del (&sitd->sitd_list);
+				sitd_dma = sitd->sitd_dma;
+			}
+#else
+                       list_del (&sitd->sitd_list);
+                       sitd_dma = sitd->sitd_dma;
+#endif
 		} else
 			sitd = NULL;
 
diff -Naur linux-2.6.22-org/drivers/video/fbmem.c linux-2.6.22-ps3/drivers/video/fbmem.c
--- linux-2.6.22-org/drivers/video/fbmem.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/drivers/video/fbmem.c	2007-08-24 11:36:13.000000000 +0200
@@ -318,6 +318,13 @@
 	const struct linux_logo *logo;
 } fb_logo __read_mostly;
 
+#define FB_LOGO_EX_NUM_MAX 10
+static struct logo_data_extra {
+	const struct linux_logo *logo;
+	unsigned int n;
+} fb_logo_ex[FB_LOGO_EX_NUM_MAX];
+static unsigned int fb_logo_ex_num = 0;
+
 static void fb_rotate_logo_ud(const u8 *in, u8 *out, u32 width, u32 height)
 {
 	u32 size = width * height, i;
@@ -411,6 +418,16 @@
 	}
 }
 
+void fb_append_extra_logo(const struct linux_logo *logo, unsigned int n)
+{
+ 	if (!n || fb_logo_ex_num == FB_LOGO_EX_NUM_MAX)
+ 		return;
+ 
+ 	fb_logo_ex[fb_logo_ex_num].logo = logo;
+ 	fb_logo_ex[fb_logo_ex_num].n = n;
+ 	fb_logo_ex_num++;
+}
+
 int fb_prepare_logo(struct fb_info *info, int rotate)
 {
 	int depth = fb_get_color_depth(&info->var, &info->fix);
@@ -501,7 +518,7 @@
 			return 0;
 
 		if (fb_logo.needs_truepalette)
-			fb_set_logo_truepalette(info, fb_logo.logo, palette);
+            fb_set_logo_truepalette(info, fb_logo.logo, palette);
 		else
 			fb_set_logo_directpalette(info, fb_logo.logo, palette);
 
@@ -510,8 +527,7 @@
 	}
 
 	if (fb_logo.depth <= 4) {
-		logo_new = kmalloc(fb_logo.logo->width * fb_logo.logo->height, 
-				   GFP_KERNEL);
+		logo_new = kmalloc(fb_logo.logo->width * fb_logo.logo->height, GFP_KERNEL);
 		if (logo_new == NULL) {
 			kfree(palette);
 			if (saved_pseudo_palette)
@@ -1458,6 +1474,7 @@
 		printk(KERN_WARNING "Unable to create fb class; errno = %ld\n", PTR_ERR(fb_class));
 		fb_class = NULL;
 	}
+
 	return 0;
 }
 
diff -Naur linux-2.6.22-org/drivers/video/logo/logo.c linux-2.6.22-ps3/drivers/video/logo/logo.c
--- linux-2.6.22-org/drivers/video/logo/logo.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/drivers/video/logo/logo.c	2007-08-22 07:57:32.000000000 +0200
@@ -21,19 +21,6 @@
 #include <asm/bootinfo.h>
 #endif
 
-extern const struct linux_logo logo_linux_mono;
-extern const struct linux_logo logo_linux_vga16;
-extern const struct linux_logo logo_linux_clut224;
-extern const struct linux_logo logo_dec_clut224;
-extern const struct linux_logo logo_mac_clut224;
-extern const struct linux_logo logo_parisc_clut224;
-extern const struct linux_logo logo_sgi_clut224;
-extern const struct linux_logo logo_sun_clut224;
-extern const struct linux_logo logo_superh_mono;
-extern const struct linux_logo logo_superh_vga16;
-extern const struct linux_logo logo_superh_clut224;
-extern const struct linux_logo logo_m32r_clut224;
-
 
 const struct linux_logo *fb_find_logo(int depth)
 {
diff -Naur linux-2.6.22-org/include/asm-powerpc/lv1call.h linux-2.6.22-ps3/include/asm-powerpc/lv1call.h
--- linux-2.6.22-org/include/asm-powerpc/lv1call.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/include/asm-powerpc/lv1call.h	2007-08-22 07:57:32.000000000 +0200
@@ -238,6 +238,7 @@
 LV1_CALL(configure_irq_state_bitmap,                    3, 0,  11 )
 LV1_CALL(connect_irq_plug_ext,                          5, 0,  12 )
 LV1_CALL(release_memory,                                1, 0,  13 )
+LV1_CALL(put_iopte,                                     5, 0,  15 )
 LV1_CALL(disconnect_irq_plug_ext,                       3, 0,  17 )
 LV1_CALL(construct_event_receive_port,                  0, 1,  18 )
 LV1_CALL(destruct_event_receive_port,                   1, 0,  19 )
@@ -268,6 +269,8 @@
 LV1_CALL(read_htab_entries,                             2, 5,  95 )
 LV1_CALL(set_dabr,                                      2, 0,  96 )
 LV1_CALL(get_total_execution_time,                      2, 1, 103 )
+LV1_CALL(allocate_io_segment,                           3, 1, 116 )
+LV1_CALL(release_io_segment,                            2, 0, 117 )
 LV1_CALL(construct_io_irq_outlet,                       1, 1, 120 )
 LV1_CALL(destruct_io_irq_outlet,                        1, 0, 121 )
 LV1_CALL(map_htab,                                      1, 1, 122 )
diff -Naur linux-2.6.22-org/include/asm-powerpc/ps3.h linux-2.6.22-ps3/include/asm-powerpc/ps3.h
--- linux-2.6.22-org/include/asm-powerpc/ps3.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/include/asm-powerpc/ps3.h	2007-08-22 07:57:32.000000000 +0200
@@ -393,5 +393,6 @@
 };
 
 extern struct ps3_prealloc ps3fb_videomemory;
+extern struct ps3_prealloc ps3_stor_bounce_buffer;
 
 #endif
diff -Naur linux-2.6.22-org/include/asm-powerpc/spu.h linux-2.6.22-ps3/include/asm-powerpc/spu.h
--- linux-2.6.22-org/include/asm-powerpc/spu.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/include/asm-powerpc/spu.h	2007-08-22 07:57:32.000000000 +0200
@@ -122,6 +122,7 @@
 	u64 flags;
 	u64 dar;
 	u64 dsisr;
+	u64 class_0_pending;
 	size_t ls_size;
 	unsigned int slb_replace;
 	struct mm_struct *mm;
@@ -129,7 +130,6 @@
 	struct spu_runqueue *rq;
 	unsigned long long timestamp;
 	pid_t pid;
-	int class_0_pending;
 	spinlock_t register_lock;
 
 	void (* wbox_callback)(struct spu *spu);
diff -Naur linux-2.6.22-org/include/asm-powerpc/spu_priv1.h linux-2.6.22-ps3/include/asm-powerpc/spu_priv1.h
--- linux-2.6.22-org/include/asm-powerpc/spu_priv1.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/include/asm-powerpc/spu_priv1.h	2007-08-22 07:57:32.000000000 +0200
@@ -178,6 +178,8 @@
 	int (*enumerate_spus)(int (*fn)(void *data));
 	int (*create_spu)(struct spu *spu, void *data);
 	int (*destroy_spu)(struct spu *spu);
+	int (*enable_spu)(struct spu_context *ctx);
+	int (*disable_spu)(struct spu_context *ctx);
 };
 
 extern const struct spu_management_ops* spu_management_ops;
@@ -200,6 +202,18 @@
 	return spu_management_ops->destroy_spu(spu);
 }
 
+static inline int
+spu_enable_spu (struct spu_context *ctx)
+{
+	return spu_management_ops->enable_spu(ctx);
+}
+
+static inline int
+spu_disable_spu (struct spu_context *ctx)
+{
+	return spu_management_ops->disable_spu(ctx);
+}
+
 /*
  * The declarations folowing are put here for convenience
  * and only intended to be used by the platform setup code.
diff -Naur linux-2.6.22-org/include/linux/linux_logo.h linux-2.6.22-ps3/include/linux/linux_logo.h
--- linux-2.6.22-org/include/linux/linux_logo.h	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/include/linux/linux_logo.h	2007-08-22 07:57:32.000000000 +0200
@@ -32,6 +32,28 @@
 	const unsigned char *data;
 };
 
+extern const struct linux_logo logo_linux_mono;
+extern const struct linux_logo logo_linux_vga16;
+extern const struct linux_logo logo_linux_clut224;
+extern const struct linux_logo logo_dec_clut224;
+extern const struct linux_logo logo_mac_clut224;
+extern const struct linux_logo logo_parisc_clut224;
+extern const struct linux_logo logo_sgi_clut224;
+extern const struct linux_logo logo_sun_clut224;
+extern const struct linux_logo logo_superh_mono;
+extern const struct linux_logo logo_superh_vga16;
+extern const struct linux_logo logo_superh_clut224;
+extern const struct linux_logo logo_m32r_clut224;
+extern const struct linux_logo logo_spe_clut224;
+
 extern const struct linux_logo *fb_find_logo(int depth);
+#ifdef CONFIG_LOGO
+extern void fb_append_extra_logo(const struct linux_logo *logo,
+				 unsigned int n);
+#else
+static inline void fb_append_extra_logo(const struct linux_logo *logo,
+					unsigned int n)
+{}
+#endif
 
 #endif /* _LINUX_LINUX_LOGO_H */
diff -Naur linux-2.6.22-org/scripts/pnmtologo.c linux-2.6.22-ps3/scripts/pnmtologo.c
--- linux-2.6.22-org/scripts/pnmtologo.c	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/scripts/pnmtologo.c	2007-08-22 07:57:32.000000000 +0200
@@ -244,7 +244,7 @@
 static void write_footer(void)
 {
     fputs("\n};\n\n", out);
-    fprintf(out, "struct linux_logo %s __initdata = {\n", logoname);
+    fprintf(out, "const struct linux_logo %s __initdata = {\n", logoname);
     fprintf(out, "    .type\t= %s,\n", logo_types[logo_type]);
     fprintf(out, "    .width\t= %d,\n", logo_width);
     fprintf(out, "    .height\t= %d,\n", logo_height);
diff -Naur linux-2.6.22-org/sound/ppc/Kconfig linux-2.6.22-ps3/sound/ppc/Kconfig
--- linux-2.6.22-org/sound/ppc/Kconfig	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/sound/ppc/Kconfig	2007-08-22 07:57:32.000000000 +0200
@@ -33,3 +33,23 @@
 	  option.
 
 endmenu
+
+menu "ALSA PowerPC devices"
+	depends on SND!=n && ( PPC64 || PPC32 )
+
+config SND_PS3
+	tristate "PS3 Audio support"
+	depends on SND && PS3_PS3AV
+	select SND_PCM
+	default m
+	help
+	  Say Y here to include support for audio on the PS3
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called snd_ps3.
+
+config SND_PS3_DEFAULT_START_DELAY
+	int "Startup delay time in ms"
+	depends on SND_PS3
+	default "2000"
+endmenu
diff -Naur linux-2.6.22-org/sound/ppc/Makefile linux-2.6.22-ps3/sound/ppc/Makefile
--- linux-2.6.22-org/sound/ppc/Makefile	2007-07-09 01:32:17.000000000 +0200
+++ linux-2.6.22-ps3/sound/ppc/Makefile	2007-08-22 07:57:32.000000000 +0200
@@ -6,4 +6,5 @@
 snd-powermac-objs := powermac.o pmac.o awacs.o burgundy.o daca.o tumbler.o keywest.o beep.o
 
 # Toplevel Module Dependency
-obj-$(CONFIG_SND_POWERMAC) += snd-powermac.o
+obj-$(CONFIG_SND_POWERMAC)	+= snd-powermac.o
+obj-$(CONFIG_SND_PS3)		+= snd_ps3.o
diff -Naur linux-2.6.22-org/sound/ppc/snd_ps3.c linux-2.6.22-ps3/sound/ppc/snd_ps3.c
--- linux-2.6.22-org/sound/ppc/snd_ps3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/sound/ppc/snd_ps3.c	2007-08-22 07:57:32.000000000 +0200
@@ -0,0 +1,1536 @@
+/*
+ * Audio support for PS3
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * All rights reserved.
+ * Copyright 2006, 2007 Sony Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2 of the Licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/asound.h>
+#include <sound/memalloc.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <linux/dmapool.h>
+#include <linux/dma-mapping.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/lv1call.h>
+#include <asm/ps3.h>
+#include <asm/ps3av.h>
+
+#include "snd_ps3_reg.h"
+#include "snd_ps3.h"
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("PS3 sound driver");
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+
+static int index = SNDRV_DEFAULT_IDX1;
+static char *id = SNDRV_DEFAULT_STR1;
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for PS3 soundchip.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for PS3 soundchip.");
+
+module_init(snd_ps3_init);
+module_exit(snd_ps3_exit);
+
+static DEVICE_ATTR(start_delay,
+		   S_IRUGO | S_IWUSR,
+		   snd_ps3_get_start_delay,
+		   snd_ps3_set_start_delay);
+
+/* system memory info */
+extern unsigned long ps3_rm_limit, ps3_2nd_mem_base;
+extern unsigned long ps3_2nd_mem_size, ps3_mem_total;
+
+/*
+ * global
+ */
+struct snd_ps3_card_info the_card;
+
+static struct ioif_map_info * ioif_map_info_array;
+static int ioif_map_info_count;
+static int snd_ps3_start_delay = CONFIG_SND_PS3_DEFAULT_START_DELAY;
+
+module_param_named(start_delay, snd_ps3_start_delay, int, 0444);
+MODULE_PARM_DESC(start_delay, "time to insert silent data in milisec");
+
+/*
+ * PS3 audio register access macros
+ */
+
+/*
+ * chip: pointer to snd_ps3_card_info
+ * name: register offset value; PS3_AUDIO_XXXX
+ */
+#define AUDIOREGPTR(chip, name) (volatile uint32_t *)(chip->mapped_vaddr + name)
+
+#define AUDIOREG(chip, name) *(AUDIOREGPTR(chip, name))
+
+/*
+ * ALSA defs
+ */
+const static struct snd_pcm_hardware snd_ps3_pcm_hw = {
+        .info = (SNDRV_PCM_INFO_MMAP |
+                 SNDRV_PCM_INFO_NONINTERLEAVED |
+                 SNDRV_PCM_INFO_MMAP_VALID),
+        .formats = (SNDRV_PCM_FMTBIT_S16_BE |
+		    SNDRV_PCM_FMTBIT_S24_BE),
+        .rates = (SNDRV_PCM_RATE_44100 |
+		  SNDRV_PCM_RATE_48000 |
+		  SNDRV_PCM_RATE_88200 |
+		  SNDRV_PCM_RATE_96000),
+        .rate_min = 44100,
+        .rate_max = 96000,
+
+        .channels_min = 2, /* stereo only */
+        .channels_max = 2,
+
+        .buffer_bytes_max = PS3_AUDIO_FIFO_SIZE * 64,
+
+	/* interrupt by four stages */
+        .period_bytes_min = PS3_AUDIO_FIFO_STAGE_SIZE * 4,
+        .period_bytes_max = PS3_AUDIO_FIFO_STAGE_SIZE * 4,
+
+        .periods_min = 16,
+	.periods_max = 32, /* buffer_size_max/ period_bytes_max */
+
+	.fifo_size = PS3_AUDIO_FIFO_SIZE
+};
+
+static struct snd_pcm_ops snd_ps3_pcm_spdif_ops =
+{
+	.open = snd_ps3_pcm_open,
+	.close = snd_ps3_pcm_close,
+	.prepare = snd_ps3_pcm_prepare,
+	.ioctl = snd_pcm_lib_ioctl,
+	.trigger = snd_ps3_pcm_trigger,
+	.pointer = snd_ps3_pcm_pointer,
+	.hw_params = snd_ps3_pcm_hw_params,
+	.hw_free = snd_ps3_pcm_hw_free
+};
+
+static struct snd_kcontrol_new snd_ps3_vol_control =
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "PCM Playback Volume",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value = SND_PS3_MAX_VOL,/* not used */
+	.info = snd_ps3_info_vol_control,
+	.put = snd_ps3_put_vol_control,
+	.get = snd_ps3_get_vol_control
+};
+
+/*
+ * PCM operators
+ */
+static int snd_ps3_pcm_open(struct snd_pcm_substream * substream)
+{
+	struct snd_pcm_runtime * runtime = substream->runtime;
+	struct snd_ps3_card_info * card = snd_pcm_substream_chip(substream);
+	int pcm_index;
+
+	_SF;
+	pcm_index = substream->pcm->device;
+	/* to retrieve substream/runtime in interrupt handler */
+	card->substream = substream;
+
+	runtime->hw = snd_ps3_pcm_hw;
+
+	/* mute off */
+	snd_ps3_mute(substream, 0); // this function sleep
+
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+				   PS3_AUDIO_FIFO_STAGE_SIZE * 4 * 2);
+	_EF;
+	return 0;
+};
+
+static int snd_ps3_pcm_hw_params(struct snd_pcm_substream * substream,
+				 struct snd_pcm_hw_params * hw_params)
+{
+	size_t size;
+
+	_SF;
+	/* alloc transport buffer */
+	size = params_buffer_bytes(hw_params);
+	snd_pcm_lib_malloc_pages(substream, size);
+	_EF;
+	return 0;
+};
+
+static int snd_ps3_delay_to_bytes(struct snd_pcm_substream * substream,
+				  unsigned int delay_ms)
+{
+	int ret;
+	int rate ;
+
+	rate = substream->runtime->rate;
+	ret = snd_pcm_format_size(substream->runtime->format,
+				  rate * delay_ms / 1000)
+		* substream->runtime->channels;
+#if defined(_SND_PS3_DEBUG)
+	printk(KERN_ERR "%s: time=%d rate=%d bytes=%ld, frames=%d, ret=%d\n",
+	       __FUNCTION__,
+	       delay_ms,
+	       rate,
+	       snd_pcm_format_size(substream->runtime->format, rate),
+	       rate * delay_ms / 1000,
+	       ret);
+#endif
+	return ret;
+};
+
+static int snd_ps3_pcm_prepare(struct snd_pcm_substream * substream)
+{
+	struct snd_pcm_runtime * runtime = substream->runtime;
+	struct snd_ps3_card_info * card = snd_pcm_substream_chip(substream);
+	unsigned long irqsave;
+	_SF;
+
+	if (!snd_ps3_set_avsetting(substream)) {
+		/* some parameter changed */
+		AUDIOREG(card, PS3_AUDIO_AX_IE) = (PS3_AUDIO_AX_IE_ASOBEIE(0) |
+						   PS3_AUDIO_AX_IE_ASOBUIE(0));
+		/*
+		 * let SPDIF device re-lock with SPDIF signal,
+		 * start with some silence
+		 */
+		read_lock(&card->start_delay_lock);
+		card->silent = snd_ps3_delay_to_bytes(substream,
+						      card->start_delay) /
+			(PS3_AUDIO_FIFO_STAGE_SIZE * 4); /* every 4 times */
+		read_unlock(&card->start_delay_lock);
+	}
+
+	/* restart ring buffer pointer */
+	write_lock_irqsave(&card->dma_lock, irqsave);
+	{
+		card->dma_last_transfer_vaddr[SND_PS3_CH_L] =
+			card->dma_next_transfer_vaddr[SND_PS3_CH_L] =
+			card->dma_start_vaddr[SND_PS3_CH_L] = runtime->dma_area;
+
+		card->dma_buffer_size = runtime->dma_bytes;
+
+		card->dma_last_transfer_vaddr[SND_PS3_CH_R] =
+			card->dma_next_transfer_vaddr[SND_PS3_CH_R] =
+			card->dma_start_vaddr[SND_PS3_CH_R] =
+			runtime->dma_area + (runtime->dma_bytes / 2);
+	}
+	write_unlock_irqrestore(&card->dma_lock, irqsave);
+
+	mb();
+
+	_EF;
+	return 0;
+};
+
+/*
+ * atomic
+ */
+static int snd_ps3_pcm_trigger(struct snd_pcm_substream * substream,
+			       int cmd)
+{
+	struct snd_ps3_card_info * card = snd_pcm_substream_chip(substream);
+	int ret = 0;
+	unsigned long irqsave;
+
+	_SF;
+	switch (cmd)
+	{
+	case SNDRV_PCM_TRIGGER_START:
+		/* clear outstanding interrupts  */
+		AUDIOREG(card, PS3_AUDIO_AX_IS) = -1;
+
+		write_lock_irqsave(&card->dma_lock, irqsave);
+		{
+			card->running = 1;
+		}
+		write_unlock_irqrestore(&card->dma_lock, irqsave);
+
+		snd_ps3_program_dma(card,
+				    SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);
+		snd_ps3_kick_dma(card);
+		while (AUDIOREG(card, PS3_AUDIO_KICK(7)) &
+		       PS3_AUDIO_KICK_STATUS_MASK) {
+			udelay(1);
+		}
+		snd_ps3_program_dma(card, SND_PS3_DMA_FILLTYPE_SILENT_RUNNING);
+		snd_ps3_kick_dma(card);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		write_lock_irqsave(&card->dma_lock, irqsave);
+		{
+			card->running = 0;
+		}
+		write_unlock_irqrestore(&card->dma_lock, irqsave);
+		snd_ps3_wait_for_dma_stop(card);
+		break;
+	default:
+		break;
+
+	}
+
+	_EF;
+	return ret;
+};
+
+/*
+ * report current pointer
+ */
+static snd_pcm_uframes_t snd_ps3_pcm_pointer(
+	struct snd_pcm_substream * substream)
+{
+	struct snd_ps3_card_info * card = snd_pcm_substream_chip(substream);
+	unsigned long irqsave;
+	size_t bytes;
+	snd_pcm_uframes_t ret;
+
+	_SF;
+
+ 	read_lock_irqsave(&card->dma_lock, irqsave);
+	{
+		bytes = (size_t)(card->dma_last_transfer_vaddr[SND_PS3_CH_L] -
+				 card->dma_start_vaddr[SND_PS3_CH_L]);
+	}
+ 	read_unlock_irqrestore(&card->dma_lock, irqsave);
+
+	ret = bytes_to_frames(substream->runtime, bytes * 2);
+	_EF;
+	return ret;
+};
+
+static int snd_ps3_pcm_hw_free(struct snd_pcm_substream * substream)
+{
+	int ret;
+	_SF;
+	ret = snd_pcm_lib_free_pages(substream);
+	_EF;
+	return ret;
+};
+
+static int snd_ps3_pcm_close(struct snd_pcm_substream * substream)
+{
+	_SF;
+	/* mute on */
+	snd_ps3_mute(substream, 1); // this function sleep
+	_EF;
+	return 0;
+};
+
+static void snd_ps3_audio_fixup(struct snd_ps3_card_info * card)
+{
+	/*
+	 * avsetting driver seems to never change the followings
+	 * so, init them here once
+	 */
+
+	/* no dma interrupt needed */
+	AUDIOREG(card, PS3_AUDIO_INTR_EN_0) = 0;
+
+	/* use every 4 buffer empty interrupt */
+	AUDIOREG(card, PS3_AUDIO_AX_IC) = ((AUDIOREG(card, PS3_AUDIO_AX_IC) &
+					    PS3_AUDIO_AX_IC_AASOIMD_MASK) |
+					   PS3_AUDIO_AX_IC_AASOIMD_EVERY4);
+
+	/* enable 3wire clocks */
+	AUDIOREG(card, PS3_AUDIO_AO_3WMCTRL) &=
+		~(PS3_AUDIO_AO_3WMCTRL_ASOBCLKD_DISABLED |
+		  PS3_AUDIO_AO_3WMCTRL_ASOLRCKD_DISABLED);
+	AUDIOREG(card, PS3_AUDIO_AO_3WMCTRL) |=
+		PS3_AUDIO_AO_3WMCTRL_ASOPLRCK_DEFAULT;
+}
+
+/*
+ * av setting
+ * NOTE: calling this function may generate audio interrupt.
+ */
+static int snd_ps3_change_avsetting(struct snd_ps3_card_info * card)
+{
+	int ret, retries, i;
+	_SF;
+
+	ret = ps3av_set_audio_mode(card->avs.avs_audio_ch,
+				  card->avs.avs_audio_rate,
+				  card->avs.avs_audio_width,
+				  card->avs.avs_audio_format,
+				  card->avs.avs_audio_source);
+	/*
+	 * Reset the following unwanted settings:
+	 */
+
+	/* disable all 3wire buffers */
+	AUDIOREG(card, PS3_AUDIO_AO_3WMCTRL) &=
+		~(PS3_AUDIO_AO_3WMCTRL_ASOEN(0) |
+		  PS3_AUDIO_AO_3WMCTRL_ASOEN(1) |
+		  PS3_AUDIO_AO_3WMCTRL_ASOEN(2) |
+		  PS3_AUDIO_AO_3WMCTRL_ASOEN(3));
+	mb();
+	/* wait for actually stopped */
+	retries = 1000;
+	while ((AUDIOREG(card, PS3_AUDIO_AO_3WMCTRL) &
+		(PS3_AUDIO_AO_3WMCTRL_ASORUN(0) |
+		 PS3_AUDIO_AO_3WMCTRL_ASORUN(1) |
+		 PS3_AUDIO_AO_3WMCTRL_ASORUN(2) |
+		 PS3_AUDIO_AO_3WMCTRL_ASORUN(3))) &&
+	       --retries) {
+		udelay(1);
+	}
+	mb();
+	/* reset buffer pointer */
+	for (i = 0; i < 4; i++) {
+		AUDIOREG(card, PS3_AUDIO_AO_3WCTRL(i)) |=
+			PS3_AUDIO_AO_3WCTRL_ASOBRST_RESET;
+		udelay(10);
+	}
+	mb();
+
+	/* enable 3wire#0 buffer */
+	AUDIOREG(card, PS3_AUDIO_AO_3WMCTRL) |= PS3_AUDIO_AO_3WMCTRL_ASOEN(0);
+	mb();
+
+	/* In 24bit mode,ALSA inserts a zero byte at first byte of per sample */
+	AUDIOREG(card, PS3_AUDIO_AO_3WCTRL(0)) =
+		((AUDIOREG(card, PS3_AUDIO_AO_3WCTRL(0)) &
+		  ~PS3_AUDIO_AO_3WCTRL_ASODF) |
+		 PS3_AUDIO_AO_3WCTRL_ASODF_LSB);
+	AUDIOREG(card, PS3_AUDIO_AO_SPDCTRL(0)) =
+		((AUDIOREG(card, PS3_AUDIO_AO_SPDCTRL(0)) &
+		  ~PS3_AUDIO_AO_SPDCTRL_SPODF) |
+		 PS3_AUDIO_AO_SPDCTRL_SPODF_LSB);
+	mb();
+	/* avsetting driver altered AX_IE, caller must reset it if you want */
+	_EF;
+	return ret;
+}
+
+static int snd_ps3_init_avsetting(struct snd_ps3_card_info * card)
+{
+	int ret;
+
+	_SF;
+	card->avs.avs_audio_ch = PS3AV_CMD_AUDIO_NUM_OF_CH_2;
+	card->avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_48K;
+	card->avs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_16;
+	card->avs.avs_audio_format = PS3AV_CMD_AUDIO_FORMAT_PCM;
+	card->avs.avs_audio_source = PS3AV_CMD_AUDIO_SOURCE_SERIAL;
+
+	ret = snd_ps3_change_avsetting(card);
+
+	snd_ps3_audio_fixup(card);
+
+	/* to start to generate SPDIF signal, fill data */
+	snd_ps3_program_dma(card, SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);
+	snd_ps3_kick_dma(card);
+	_EF;
+	return ret;
+}
+
+/*
+ *  set sampling rate according to the substream
+ */
+static int snd_ps3_set_avsetting(struct snd_pcm_substream * substream)
+{
+	struct snd_ps3_card_info * card = snd_pcm_substream_chip(substream);
+	struct snd_ps3_avsetting_info avs;
+
+	avs = card->avs;
+
+#if defined(_SND_PS3_DEBUG)
+	printk(KERN_ERR "%s: called freq=%d width=%d\n", __FUNCTION__,
+	       substream->runtime->rate,
+	       snd_pcm_format_width(substream->runtime->format));
+
+	printk(KERN_ERR "%s: before freq=%d width=%d\n", __FUNCTION__,
+	       card->avs.avs_audio_rate, card->avs.avs_audio_width);
+
+#endif
+	/* sample rate */
+	switch (substream->runtime->rate)
+	{
+	case 44100:
+		avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_44K;
+		break;
+	case 48000:
+		avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_48K;
+		break;
+	case 88200:
+		avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_88K;
+		break;
+	case 96000:
+		avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_96K;
+		break;
+	default:
+		printk(KERN_ERR "%s: invalid rate %d\n", __FUNCTION__,
+		       substream->runtime->rate);
+		return 1;
+	}
+
+	/* width */
+	switch (snd_pcm_format_width(substream->runtime->format))
+	{
+	case 16:
+		avs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_16;
+		break;
+	case 24:
+		avs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_24;
+		break;
+	default:
+		printk(KERN_ERR "%s: invalid width %d\n", __FUNCTION__,
+		       snd_pcm_format_width(substream->runtime->format));
+		return 1;
+	}
+
+	if ((card->avs.avs_audio_width != avs.avs_audio_width) ||
+	    (card->avs.avs_audio_rate != avs.avs_audio_rate)) {
+		card->avs = avs;
+		snd_ps3_change_avsetting(card);
+#if defined(_SND_PS3_DEBUG)
+		printk(KERN_ERR "%s: after freq=%d width=%d\n", __FUNCTION__,
+		       card->avs.avs_audio_rate, card->avs.avs_audio_width);
+#endif
+		return 0;
+	} else
+		return 1;
+}
+
+/*
+ * audio mute on/off
+ * mute_on : 0 output enabled
+ *           1 mute
+ */
+static int snd_ps3_mute(struct snd_pcm_substream * substream, int mute_on)
+{
+	(void) substream;
+
+	return ps3av_audio_mute(mute_on);
+}
+
+static int snd_ps3_kick_dma(struct snd_ps3_card_info * card)
+{
+
+	/* kick dma */
+	AUDIOREG(card, PS3_AUDIO_KICK(0)) |= PS3_AUDIO_KICK_REQUEST;
+	mb();
+
+	return 0;
+}
+
+static int snd_ps3_verify_dma_stop(struct snd_ps3_card_info * card,
+				   int count, int force_stop)
+{
+	int dma_ch, done, retries, stop_forced = 0;
+	uint32_t status;
+
+	for (dma_ch = 0; dma_ch < 8; dma_ch ++) {
+		retries = count;
+		do {
+			status = AUDIOREG(card, PS3_AUDIO_KICK(dma_ch)) &
+				PS3_AUDIO_KICK_STATUS_MASK;
+			switch (status) {
+			case PS3_AUDIO_KICK_STATUS_DONE:
+			case PS3_AUDIO_KICK_STATUS_NOTIFY:
+			case PS3_AUDIO_KICK_STATUS_CLEAR:
+			case PS3_AUDIO_KICK_STATUS_ERROR:
+				done = 1;
+				break;
+			default:
+				done = 0;
+				udelay(10);
+			}
+		} while (!done && --retries);
+		if (!retries && force_stop) {
+			printk(KERN_ERR "%s: DMA ch %d is not stopped.",
+			       __FUNCTION__, dma_ch);
+			/* last resort. force to stop dma.
+			 *  NOTE: this cause DMA done interrupts
+			 */
+			AUDIOREG(card, PS3_AUDIO_CONFIG) |=
+				PS3_AUDIO_CONFIG_CLEAR;
+			stop_forced = 1;
+		}
+	}
+	return stop_forced;
+}
+
+/*
+ * wait for all dma is done.
+ * NOTE: caller should reset card->running before call.
+ *       If not, the interrupt handler will re-start DMA,
+ *       then DMA is never stopped.
+ */
+static void snd_ps3_wait_for_dma_stop(struct snd_ps3_card_info * card)
+{
+	int stop_forced;
+	_SF;
+	/*
+	 * wait for the last dma is done
+	 */
+
+	/*
+	 * expected maximum DMA done time is 5.7ms + something (DMA itself).
+	 * 5.7ms is from 16bit/sample 2ch 44.1Khz; the time next
+	 * DMA kick event would occur.
+	 */
+	stop_forced = snd_ps3_verify_dma_stop(card, 700, 1);
+
+	/*
+	 * clear outstanding interrupts.
+	 */
+	AUDIOREG(card, PS3_AUDIO_INTR_0) = -1;
+	AUDIOREG(card, PS3_AUDIO_AX_IS) = -1;
+
+	/*
+	 *revert CLEAR bit since it will not reset automatically after DMA stop
+	 */
+	if (stop_forced) {
+		AUDIOREG(card, PS3_AUDIO_CONFIG) &= ~PS3_AUDIO_CONFIG_CLEAR;
+	}
+	mb();
+	_EF;
+}
+
+/*
+ * increment ring buffer pointer.
+ * NOTE: caller must hold write spinlock
+ */
+static void snd_ps3_bump_buffer(struct snd_ps3_card_info * card,
+				enum snd_ps3_ch ch, size_t byte_count,
+				int stage)
+{
+	if (!stage)
+		card->dma_last_transfer_vaddr[ch] =
+			card->dma_next_transfer_vaddr[ch];
+	card->dma_next_transfer_vaddr[ch] += byte_count;
+	if ((card->dma_start_vaddr[ch] + (card->dma_buffer_size / 2)) <=
+	    card->dma_next_transfer_vaddr[ch]) {
+		card->dma_next_transfer_vaddr[ch] = card->dma_start_vaddr[ch];
+	}
+}
+
+/*
+ * setup dmac to send data to audio and attenuate samples on the ring buffer
+ */
+static int snd_ps3_program_dma(struct snd_ps3_card_info * card,
+			       enum snd_ps3_dma_filltype filltype)
+{
+	uint32_t dma_addr;
+	int fill_stages, dma_ch, stage;
+	enum snd_ps3_ch ch;
+	uint32_t ch0_kick_event = 0; /* initialize to mute gcc */
+	void * start_vaddr;
+	unsigned long irqsave;
+	int silent = 0;
+
+	switch (filltype) {
+	case SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL:
+		silent = 1;
+		/* intentionally fall thru */
+	case SND_PS3_DMA_FILLTYPE_FIRSTFILL:
+		ch0_kick_event = PS3_AUDIO_KICK_EVENT_ALWAYS;
+		break;
+
+	case SND_PS3_DMA_FILLTYPE_SILENT_RUNNING:
+		silent = 1;
+		/* intentionally fall thru */
+	case SND_PS3_DMA_FILLTYPE_RUNNING:
+		ch0_kick_event = PS3_AUDIO_KICK_EVENT_SERIALOUT0_EMPTY;
+		break;
+	}
+
+	snd_ps3_verify_dma_stop(card, 700, 0);
+	fill_stages = 4;
+ 	write_lock_irqsave(&card->dma_lock, irqsave);
+	if (likely(!silent))
+		snd_ps3_soft_attenuate(card,
+				       card->dma_next_transfer_vaddr[0],
+				       card->dma_next_transfer_vaddr[1],
+				       PS3_AUDIO_DMAC_BLOCK_SIZE * 4);
+	for (ch = 0; ch < 2; ch++) {
+		start_vaddr = card->dma_next_transfer_vaddr[0];
+		for (stage = 0; stage < fill_stages; stage ++) {
+			//dma_ch = fill_stages * ch + stage;
+			dma_ch = stage * 2 + ch;
+			if (silent) {
+				dma_addr =
+				p_to_dma(__pa(card->null_buffer_start_vaddr));
+			}
+			else {
+				dma_addr =
+				p_to_dma(__pa(card->dma_next_transfer_vaddr[ch]));
+			}
+
+			AUDIOREG(card, PS3_AUDIO_SOURCE(dma_ch)) =
+				(PS3_AUDIO_SOURCE_TARGET_SYSTEM_MEMORY |
+				 dma_addr);
+
+			/* dst: fixed to 3wire#0 */
+			if (ch == 0)
+				AUDIOREG(card, PS3_AUDIO_DEST(dma_ch)) =
+					(PS3_AUDIO_DEST_TARGET_AUDIOFIFO |
+					 PS3_AUDIO_AO_3W_LDATA(0));
+			else
+				AUDIOREG(card, PS3_AUDIO_DEST(dma_ch)) =
+					(PS3_AUDIO_DEST_TARGET_AUDIOFIFO |
+					 PS3_AUDIO_AO_3W_RDATA(0));
+
+			/* count always 1 DMA block (1/2 stage = 128 bytes) */
+			AUDIOREG(card, PS3_AUDIO_DMASIZE(dma_ch)) = 0;
+			/* bump pointer if needed */
+			if (!silent)
+				snd_ps3_bump_buffer(card, ch,
+						    PS3_AUDIO_DMAC_BLOCK_SIZE,
+						    stage);
+
+			/* kick event  */
+			if (dma_ch == 0) {
+				AUDIOREG(card, PS3_AUDIO_KICK(dma_ch)) =
+					ch0_kick_event;
+			} else {
+				AUDIOREG(card, PS3_AUDIO_KICK(dma_ch)) =
+					(PS3_AUDIO_KICK_EVENT_AUDIO_DMA(dma_ch -
+									1) |
+					 PS3_AUDIO_KICK_REQUEST);
+			}
+		}
+	}
+	mb();
+	write_unlock_irqrestore(&card->dma_lock, irqsave);
+
+	mb();
+	return 0;
+}
+
+/****************************************************************************
+ *
+ * real initializer. called once
+ *
+ */
+static int __init snd_ps3_driver_probe(struct platform_device * device)
+{
+	int ret;
+	_SF;
+
+	memset(&the_card, 0, sizeof(the_card));
+	rwlock_init(&the_card.dma_lock);
+	rwlock_init(&the_card.start_delay_lock);
+
+	/* CONFIG_SND_PS3_DEFAULT_START_DELAY */
+	the_card.start_delay = snd_ps3_start_delay;
+	the_card.platform_device = device;
+
+	/* map audio register, etc */
+	if ((ret = snd_ps3_init_audio())) {
+		return -ENOMEM;
+	}
+
+	/* create card instance */
+	the_card.card = snd_card_new(index, id, THIS_MODULE, 0);
+	if (!the_card.card) {
+		goto error0;
+	}
+	strcpy(the_card.card->driver, "snd_ps3");
+	strcpy(the_card.card->shortname, "PS3");
+	strcpy(the_card.card->longname, "PS3 sound");
+	/* create PCM devices instance */
+	/* NOTE:this driver works assuming pcm:substream = 1:1 */
+	ret = snd_pcm_new(the_card.card,
+			  "SPDIF",
+			  0, /* instance index, will be stored pcm.device*/
+			  1, /* output substream */
+			  0, /* input substream */
+			  &(the_card.pcm));
+	if (ret)
+		goto error1;
+
+	the_card.pcm->private_data = &the_card;
+	strcpy(the_card.pcm->name, "SPDIF");
+
+	/* set pcm ops */
+	snd_pcm_set_ops(the_card.pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_ps3_pcm_spdif_ops);
+
+	the_card.pcm->info_flags = SNDRV_PCM_INFO_NONINTERLEAVED;
+	/* pre-alloc buffer */
+	ret = snd_pcm_lib_preallocate_pages_for_all(the_card.pcm,
+					SNDRV_DMA_TYPE_CONTINUOUS,
+					snd_dma_continuous_data(GFP_KERNEL),
+					PS3_AUDIO_DMAC_BLOCK_SIZE *
+					PS3_AUDIO_DMAC_MAX_BLOCKS * 4,
+					PS3_AUDIO_DMAC_BLOCK_SIZE *
+					PS3_AUDIO_DMAC_MAX_BLOCKS * 4);
+
+	if (ret < 0) {
+		printk(KERN_ERR "%s: prealloc failed\n", __FUNCTION__);
+		goto error1;
+	}
+
+	/*
+	 * allocate null buffer
+	 * its size should be lager than PS3_AUDIO_FIFO_STAGE_SIZE * 2
+	 */
+	if (!(the_card.null_buffer_start_vaddr = get_zeroed_page(GFP_KERNEL))) {
+		printk(KERN_ERR "%s: nullbuffer alloc failed\n", __FUNCTION__);
+		goto error2;
+	}
+	/* set default sample rate/word width */
+	snd_ps3_init_avsetting(&the_card);
+
+	/* add volume control */
+	the_card.vol_control = snd_ctl_new1(&snd_ps3_vol_control, &the_card);
+	if ((ret = snd_ctl_add(the_card.card, the_card.vol_control)) < 0) {
+		goto error3;
+	}
+	/* register the card */
+	ret = snd_card_register(the_card.card);
+	if (ret < 0)
+		goto error4;
+
+	platform_set_drvdata(device, &the_card);
+
+	printk("%s started. start_delay=%dms\n",
+	       the_card.card->longname, the_card.start_delay);
+	_EF;
+	return 0;
+
+ error4:
+	/* no need call to snd_control_free_one() here*/
+	snd_ctl_remove(the_card.card, the_card.vol_control);
+ error3:
+	free_page(the_card.null_buffer_start_vaddr);
+ error2:
+	snd_pcm_lib_preallocate_free_for_all(the_card.pcm);
+ error1:
+	snd_card_free(the_card.card);
+ error0:
+	snd_ps3_free_audio();
+	/*
+	 * there is no destructor function to pcm.
+	 * midlayer automatically releases if the card removed
+	 */
+	_EF1("error");
+	return ret;
+}; /* snd_ps3_probe */
+
+/* called when system shutdown */
+static void snd_ps3_driver_shutdown(struct platform_device * device)
+{
+	_SF;
+	snd_ps3_driver_remove(device);
+	_EF;
+}
+
+/* called when module removal */
+static int snd_ps3_driver_remove(struct platform_device * device)
+{
+	_SF;
+
+	platform_set_drvdata(device, NULL);
+	snd_ctl_remove(the_card.card, the_card.vol_control);
+	snd_pcm_lib_preallocate_free_for_all(the_card.pcm);
+	snd_card_free(the_card.card);
+	free_page(the_card.null_buffer_start_vaddr);
+	snd_ps3_free_audio();
+
+	_EF;
+	return 0;
+} /* snd_ps3_remove */
+
+static struct platform_driver snd_ps3_platform_driver =
+{
+	.probe = snd_ps3_driver_probe,
+	.remove = snd_ps3_driver_remove,
+	.shutdown = snd_ps3_driver_shutdown,
+	.driver = {
+		.name = SND_PS3_DRIVER_NAME
+	}
+};
+
+static struct platform_device * the_platform_device;
+
+/*
+ * module initialize/terminate
+ */
+static int __init snd_ps3_init(void)
+{
+	int ret;
+
+	ret = ps3av_dev_open();
+
+	if (ret) {
+		printk(KERN_ERR "%s: open failed %d\n", __FUNCTION__, ret);
+		return ret;
+	}
+
+	ret = platform_driver_register(&snd_ps3_platform_driver);
+	if (ret < 0)
+		return ret;
+
+	the_platform_device =
+		platform_device_register_simple(SND_PS3_DRIVER_NAME,
+						0, NULL, 0);
+	if (IS_ERR(the_platform_device)) {
+		ret = PTR_ERR(the_platform_device);
+		goto error0;
+	}
+
+	ret = device_create_file(&(the_platform_device->dev),
+				 &dev_attr_start_delay);
+
+	return ret;
+ error0:
+	platform_driver_unregister(&snd_ps3_platform_driver);
+	return ret;
+}
+
+static void __exit snd_ps3_exit(void)
+{
+	device_remove_file(&(the_platform_device->dev), &dev_attr_start_delay);
+	platform_device_unregister(the_platform_device);
+	platform_driver_unregister(&snd_ps3_platform_driver);
+}
+
+
+/*
+ * create iosegment and iopte for DMA area
+ * map audio audio registers
+ * allocate irq
+ */
+
+static int snd_ps3_init_audio(void)
+{
+	int ret, map;
+
+	if ((ret = snd_ps3_create_iopt()))
+		return ret;
+
+ 	/* map registers and irq info */
+	map = 1;
+	ret = lv1_gpu_device_map(map, &the_card.audio_lpar_addr,
+				 &the_card.audio_lpar_size);
+	if (ret) {
+		printk(KERN_ERR "%s: device map 1 failed %d\n", __FUNCTION__,
+		       ret);
+		ret = -ENXIO;
+		goto cleanup;
+	}
+
+	the_card.mapped_vaddr = ioremap(the_card.audio_lpar_addr,
+					the_card.audio_lpar_size);
+
+	if (!the_card.mapped_vaddr) {
+		printk(KERN_ERR "%s: ioremap 1 failed \n", __FUNCTION__);
+		ret = -ENXIO;
+		goto cleanup_1;
+	}
+
+
+	the_card.audio_irq_outlet = *(uint64_t*)the_card.mapped_vaddr;
+
+	/* no more needed */
+	iounmap(the_card.mapped_vaddr);
+	lv1_gpu_device_unmap(map);
+
+	map = 2;
+	ret = lv1_gpu_device_map(map, &the_card.audio_lpar_addr,
+				 &the_card.audio_lpar_size);
+	if (ret) {
+		printk(KERN_ERR "%s: device map 2 failed %d\n", __FUNCTION__,
+		       ret);
+		ret = -ENXIO;
+		goto cleanup;
+	}
+
+	the_card.mapped_vaddr = ioremap(the_card.audio_lpar_addr,
+					the_card.audio_lpar_size);
+
+	if (!the_card.mapped_vaddr) {
+		printk(KERN_ERR "%s: ioremap 0 failed \n", __FUNCTION__);
+		ret = -ENXIO;
+		goto cleanup_1;
+	}
+
+	/* irq */
+	ret = ps3_irq_plug_setup(PS3_BINDING_CPU_ANY, the_card.audio_irq_outlet,
+				 &the_card.irq_no);
+	if (ret) {
+		printk("%s:%u: ps3_alloc_irq failed (%d)\n", __FUNCTION__,
+		       __LINE__, ret);
+		goto cleanup_2;
+	}
+
+	ret = request_irq(the_card.irq_no, snd_ps3_interrupt, IRQF_DISABLED,
+			  SND_PS3_DRIVER_NAME, &the_card);
+	if (ret) {
+		printk("%s:%u: request_irq failed (%d)\n", __FUNCTION__,
+		       __LINE__, ret);
+		goto cleanup_3;
+	}
+
+	/*
+	 * OK, PPU side setup done,
+	 * tell io address for DMA to audio controller
+	 */
+	snd_ps3_audio_set_base_addr(ioif_map_info_array[0].ioif_addr);
+
+	_EF;
+
+	return 0;
+ cleanup_3:
+	ps3_irq_plug_destroy(the_card.irq_no);
+ cleanup_2:
+	iounmap(the_card.mapped_vaddr);
+
+ cleanup_1:
+	lv1_gpu_device_unmap(map);
+
+ cleanup:
+
+	return ret;
+};
+
+
+static void snd_ps3_free_audio(void)
+{
+	int ret;
+
+	_SF;
+	/* irq */
+	free_irq(the_card.irq_no, &the_card);
+	ps3_irq_plug_destroy(the_card.irq_no);
+
+	iounmap(the_card.mapped_vaddr);
+
+	/* unmap registers */
+	ret = lv1_gpu_device_unmap(2);
+	if (ret)
+		printk(KERN_ERR "%s: device unmap failed %d\n", __FUNCTION__,
+		       ret);
+
+	ps3av_dev_close();
+
+	/* iopte */
+	snd_ps3_destruct_iopt();
+	_EF;
+
+};
+
+
+
+/*
+ * request iopte for device dma
+ */
+static void snd_ps3_audio_set_base_addr(uint64_t ioaddr_start)
+{
+	uint64_t val;
+	int ret;
+
+	_SF;
+
+	val = (ioaddr_start & (0x0fUL << 32)) >> (32 - 20) |
+		(0x03UL << 24) |
+		(0x0fUL << 12) |
+		(1);
+
+	ret = lv1_gpu_attribute(0x100, 0x007, val, 0, 0);
+	if (ret)
+		printk(KERN_ERR "%s: gpu_attribute failed %d\n", __FUNCTION__,
+		       ret);
+	_EF;
+}
+
+#define PS3_AUDIO_IOID       (1UL)
+#define IO_PAGESIZE_4K_SHIFT   (12)
+#define IO_PAGESIZE_64K_SHIFT  (16)
+#define IO_PAGESIZE_1M_SHIFT   (20)
+#define IO_PAGESIZE_16M_SHIFT  (24)
+#define IO_PAGESIZE_SHIFT      IO_PAGESIZE_16M_SHIFT
+#define IO_PAGESIZE            (1UL << IO_PAGESIZE_SHIFT)
+#define IO_SEGMENTSIZE_SHIFT   (28)
+#define IO_SEGMENTSIZE         (1UL << IO_SEGMENTSIZE_SHIFT)
+#define IOPTE_READONLY         (1UL << 62)
+#define IOPTE_READWRITE        (3UL << 62)
+#define IOPTE_INVALID          (0UL << 62)
+
+#define IOPTE_COHERENT         (1UL << 61)
+#define IOPTE_STRICT_ORDER     (3UL << 59)
+#define IOPTE_HINT             (1UL << 11)
+/*
+ * convert physical addr to ioif bus addr.
+ * Since we mapped physical addr 0 as seg[0].ioif_addr
+ * no need to convert to lpar address here.
+ * NOTE: no boudary check performed
+ */
+static uint64_t p_to_dma(uint64_t paddr)
+{
+	int seg;
+#if defined(CONFIG_PS3_USE_LPAR_ADDR)
+	if (ps3_rm_limit <= paddr)
+		paddr = paddr - ps3_2nd_mem_base + ps3_rm_limit;
+#endif
+	seg = paddr >> IO_SEGMENTSIZE_SHIFT;
+
+
+	return ioif_map_info_array[seg].ioif_addr + (paddr & ~IO_SEGMENTSIZE);
+};
+
+static uint64_t inc_paddr(uint64_t curpos, uint64_t offset)
+{
+	uint64_t ret = curpos + offset;
+
+#if defined(CONFIG_PS3_USE_LPAR_ADDR)
+	if ((ps3_rm_limit <= ret) && (ret < ps3_2nd_mem_base))
+		ret = ps3_2nd_mem_base;
+#endif
+	return ret;
+}
+/*
+ * create io segments for DMA and iopte
+ * and also AUDIO ioif setup
+ * Note: segments cover whole mememory area Linux uses.
+ *       See ps3_get_memsize for LPAR memory layout.
+ * we assume the followings:
+ *   o total system memory size is multiple of 16MB
+ *   o hvc allocates all io address under 4G
+ */
+static int snd_ps3_create_iopt(void)
+{
+	int ret, pages_remain, current_segment, current_page;
+	uint64_t current_paddr;
+	_SF;
+	/*
+	 * since we allocated memory from hvc as pagesize 16MB,
+	 * total allocated size should be multiple of 16MB
+	 */
+	if (ps3_mem_total % IO_PAGESIZE) {
+		printk(KERN_ERR "%s: pagesize differ %lx!!\n", __FUNCTION__,
+		       ps3_mem_total);
+		panic("!");
+	}
+	/*
+	 * calc how many segment needed
+	 * assumed 1 or 2 for current ps3 memory size
+	 */
+	ioif_map_info_count = (ps3_mem_total >> IO_SEGMENTSIZE_SHIFT) + 1;
+
+	if (!(ioif_map_info_array =
+	      kzalloc(sizeof(struct ioif_map_info) * ioif_map_info_count,
+		      GFP_KERNEL))) {
+		printk(KERN_ERR "%s: no memory\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	pages_remain = ps3_mem_total >> IO_PAGESIZE_SHIFT;
+	/* physical address start from 0 */
+	current_paddr = 0;
+	for (current_segment = 0;
+	     current_segment < ioif_map_info_count;
+	     current_segment++) {
+
+		ioif_map_info_array[current_segment].start_paddr =
+			current_paddr;
+		ioif_map_info_array[current_segment].start_lpar_addr =
+			ps3_mm_phys_to_lpar(current_paddr);
+		ioif_map_info_array[current_segment].area_size = IO_SEGMENTSIZE;
+
+		ret = lv1_allocate_io_segment(0, /* io space */
+			IO_SEGMENTSIZE, /* segment size */
+			IO_PAGESIZE_SHIFT, /* io page size */
+			&(ioif_map_info_array[current_segment].ioif_addr));
+
+		if (ret) {
+			printk(KERN_ERR "%s: alloc_io_seg %d failed %d\n",
+			       __FUNCTION__, current_segment, ret);
+			goto cleanup0;
+		}
+
+		if (ioif_map_info_array[current_segment].ioif_addr >> 32) {
+			printk(KERN_CRIT "%s: io addr is alloc above 4G! %lx\n",
+			       __FUNCTION__,
+			       ioif_map_info_array[current_segment].ioif_addr);
+			panic("!");
+		}
+		/* create iopte for this segment */
+		for (current_page = 0;
+		     current_page < (IO_SEGMENTSIZE / IO_PAGESIZE) &&
+			     pages_remain;
+		     current_page ++, current_paddr =
+			     inc_paddr(current_paddr, IO_PAGESIZE)) {
+			ret = lv1_put_iopte(0, /* io address space id */
+				ioif_map_info_array[current_segment].ioif_addr +
+				current_page * IO_PAGESIZE, /* ioif addr */
+				ps3_mm_phys_to_lpar(current_paddr),
+				PS3_AUDIO_IOID,
+				IOPTE_READONLY | IOPTE_COHERENT |
+					    IOPTE_STRICT_ORDER);
+			if (ret) {
+				printk(KERN_ERR "%s: put_iopte failed (%d) " \
+				       "seg=%d paddr=%#lx lpar=%#lx page=%d\n",
+				       __FUNCTION__, ret, current_segment,
+				       current_paddr,
+				       ps3_mm_phys_to_lpar(current_paddr),
+				       current_page);
+				printk(KERN_ERR "%s: rm_limit=%#lx " \
+				       "2nd_base=%#lx 2nd_size=%#lx "\
+				       "total=%#lx\n",
+				       __FUNCTION__,
+				       ps3_rm_limit, ps3_2nd_mem_base,
+				       ps3_2nd_mem_size, ps3_mem_total);
+				current_segment ++;
+				goto cleanup0;
+			}
+			pages_remain --;
+		}
+	}
+
+	if (0 < pages_remain) {
+		panic("unmaped page remain\n");
+	}
+
+	_EF;
+	return 0;
+
+ cleanup0:
+	snd_ps3_destruct_iopt_helper();
+	return -ENOMEM;
+}
+
+/*
+ * invalidate all iopte and free io segment
+ */
+static void snd_ps3_destruct_iopt_helper(void)
+{
+	int ret, pages_remain, current_segment, current_page;
+	uint64_t current_paddr;
+
+	_SF;
+
+	pages_remain = ps3_mem_total >> IO_PAGESIZE_SHIFT;
+	/* physical address start from 0 */
+	current_paddr = 0;
+
+	/*
+	 * invalidate iopte first , then release io segment
+	 */
+	for (current_segment = 0;
+	     current_segment < ioif_map_info_count; current_segment++) {
+		/* create iopte for this segment */
+		for (current_page = 0;
+		     current_page < (IO_SEGMENTSIZE / IO_PAGESIZE) &&
+			     pages_remain;
+		     current_page ++, current_paddr =
+			     inc_paddr(current_paddr,IO_PAGESIZE)) {
+			ret = lv1_put_iopte(0, /* io address space id */
+				ioif_map_info_array[current_segment].ioif_addr +
+					    current_page *
+					    IO_PAGESIZE, /* ioif addr */
+				ps3_mm_phys_to_lpar(current_paddr),
+				PS3_AUDIO_IOID, IOPTE_INVALID);
+			if (ret) {
+				printk(KERN_ERR "%s: put_iopte failed (%d) "\
+				       "seg=%d paddr=%#lx lpar=%#lx page=%d\n",
+				       __FUNCTION__, ret, current_segment,
+				       current_paddr,
+				       ps3_mm_phys_to_lpar(current_paddr),
+				       current_page);
+				printk(KERN_ERR "%s: rm_limit=%#lx "\
+				       "2nd_base=%#lx 2nd_size=%#lx "\
+				       "total=%#lx\n", __FUNCTION__,
+				       ps3_rm_limit, ps3_2nd_mem_base,
+				       ps3_2nd_mem_size, ps3_mem_total);
+				current_segment ++;
+			}
+			pages_remain --;
+		}
+
+		ret = lv1_release_io_segment(0, /* io space */
+			     ioif_map_info_array[current_segment].ioif_addr);
+
+		if (ret)
+			printk(KERN_ERR "%s: release_io_seg %d failed %d\n",
+			       __FUNCTION__, current_segment, ret);
+	}
+
+	kfree(ioif_map_info_array);
+	ioif_map_info_array = 0;
+	_EF;
+}
+
+static void snd_ps3_destruct_iopt(void)
+{
+	snd_ps3_destruct_iopt_helper();
+}
+
+/*
+ * Interrupt handler
+ */
+static irqreturn_t snd_ps3_interrupt(int irq, void * dev_id)
+{
+
+	uint32_t port_intr;
+	int underflow_occured = 0;
+	struct snd_ps3_card_info * card = dev_id;
+
+
+
+	if (!card->running) {
+		AUDIOREG(card, PS3_AUDIO_AX_IS) = -1;
+		AUDIOREG(card, PS3_AUDIO_INTR_0) = -1;
+		return IRQ_HANDLED;
+	}
+
+	port_intr = AUDIOREG(card, PS3_AUDIO_AX_IS);
+	/*
+	 *serial buffer empty detected (every 4 times),
+	 *program next dma and kick it
+	 */
+	if (port_intr & PS3_AUDIO_AX_IE_ASOBEIE(0)) {
+		AUDIOREG(card, PS3_AUDIO_AX_IS) = PS3_AUDIO_AX_IE_ASOBEIE(0);
+		if (port_intr & PS3_AUDIO_AX_IE_ASOBUIE(0)) {
+			AUDIOREG(card, PS3_AUDIO_AX_IS) = port_intr;
+			underflow_occured = 1;
+		}
+		if (card->silent) {
+			/* we are still in silent time */
+			snd_ps3_program_dma(card,
+				(underflow_occured) ?
+				SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL :
+				SND_PS3_DMA_FILLTYPE_SILENT_RUNNING);
+			snd_ps3_kick_dma(card);
+			card->silent --;
+		} else {
+			snd_ps3_program_dma(card,
+				(underflow_occured) ?
+				SND_PS3_DMA_FILLTYPE_FIRSTFILL :
+				SND_PS3_DMA_FILLTYPE_RUNNING);
+			snd_ps3_kick_dma(card);
+			snd_pcm_period_elapsed(card->substream);
+		}
+	} else if (port_intr & PS3_AUDIO_AX_IE_ASOBUIE(0)) {
+		AUDIOREG(card, PS3_AUDIO_AX_IS) = PS3_AUDIO_AX_IE_ASOBUIE(0);
+                /*
+		 * serial out underflow, but buffer empty not detected.
+		 * in this case, fill fifo with 0 to recover.  After
+		 * filling dummy data, serial automatically start to
+		 * consume them and then will generate normal buffer
+		 * empty interrupts.
+		 * If both buffer underflow and buffer empty are occured,
+		 * it is better to do nomal data transfer than empty one
+		 */
+		snd_ps3_program_dma(card,
+				    SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);
+		snd_ps3_kick_dma(card);
+		snd_ps3_program_dma(card,
+				    SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);
+		snd_ps3_kick_dma(card);
+	}
+	/* clear interrupt cause */
+	return IRQ_HANDLED;
+};
+
+/*
+ * sysfs
+ */
+static ssize_t snd_ps3_get_start_delay(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct platform_device * plat_dev =
+		container_of(dev, struct platform_device, dev);
+	struct snd_ps3_card_info * card = platform_get_drvdata(plat_dev);
+	ssize_t ret;
+
+	read_lock(&card->start_delay_lock);
+	ret = sprintf(buf, "%u\n", card->start_delay);
+	read_unlock(&card->start_delay_lock);
+	return ret;
+}
+
+static ssize_t snd_ps3_set_start_delay(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf,
+				       size_t count)
+{
+	unsigned int start_delay;
+	struct platform_device * plat_dev =
+		container_of(dev, struct platform_device, dev);
+	struct snd_ps3_card_info * card = platform_get_drvdata(plat_dev);
+
+	if (sscanf(buf, "%u", &start_delay) > 0) {
+ 		write_lock(&card->start_delay_lock);
+		card->start_delay = start_delay;
+		write_unlock(&card->start_delay_lock);
+		return strlen(buf);
+	}
+	return -EINVAL;
+}
+
+
+static int snd_ps3_info_vol_control(struct snd_kcontrol * kcontrol,
+				    struct snd_ctl_elem_info * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = SND_PS3_CH_MAX; /* stereo */
+	uinfo->value.integer.min = SND_PS3_MIN_VOL;
+	uinfo->value.integer.max = SND_PS3_MAX_VOL;
+	return 0;
+};
+
+static int snd_ps3_get_vol_control(struct snd_kcontrol * kcontrol,
+				   struct snd_ctl_elem_value * ucontrol)
+{
+	struct snd_ps3_card_info * card = snd_kcontrol_chip(kcontrol);
+	int i;
+	for (i = 0; i < SND_PS3_CH_MAX; i++)
+		ucontrol->value.integer.value[i] =
+			SND_PS3_MAX_VOL - card->attenuater[i];
+	return 0;
+};
+
+static int snd_ps3_put_vol_control(struct snd_kcontrol * kcontrol,
+				   struct snd_ctl_elem_value * ucontrol)
+{
+	struct snd_ps3_card_info * card = snd_kcontrol_chip(kcontrol);
+	int i;
+	int changed = 0;
+
+	for (i = 0; i < SND_PS3_CH_MAX; i++)
+		if ((ucontrol->value.integer.value[i] < SND_PS3_MIN_VOL) ||
+		    (SND_PS3_MAX_VOL < ucontrol->value.integer.value[i]))
+			return -EINVAL;
+
+	for (i = 0; i < SND_PS3_CH_MAX; i++)
+		if ((SND_PS3_MAX_VOL - card->attenuater[i]) !=
+		    ucontrol->value.integer.value[i]) {
+			card->attenuater[i] = SND_PS3_MAX_VOL -
+				ucontrol->value.integer.value[i];
+			changed = 1;
+		}
+	return changed;
+};
+
+typedef struct
+{
+	unsigned char numerator;
+	unsigned char denominator;
+} attenuater_divisor;
+
+static const attenuater_divisor
+attenuater_divisor_array[SND_PS3_MAX_VOL - SND_PS3_MIN_VOL + 1] =
+{
+	[ 0] = {   1,   1}, /* 0db; not used */
+	[ 1] = { 177, 250}, /*  -1.5 db 0.708 */
+	[ 2] = {   1,   2}, /*  -3.0 db 0.501 */
+	[ 3] = {  71, 200}, /*  -4.5 db 0.355 */
+	[ 4] = {   1,   4}, /*  -6.0 db 0.251 */
+	[ 5] = {  45, 250}, /*  -7.5 db 0.178 */
+	[ 6] = {   1,   8}, /*  -9.0 db 0.126 */
+	[ 7] = {  22, 250}, /* -10.5 db 89.1m */
+	[ 8] = {   1,  16}, /* -12.0 db 63.1m */
+	[ 9] = {  11, 250}, /* -13.5 db 44.7m */
+	[10] = {   1,  32}, /* -15.0 db 31.6m */
+	[11] = {   5, 250}, /* -16.5 db 22.4m */
+	[12] = {   1,  64}, /* -18.0 db 15.8m */
+	[13] = {   2, 178}, /* -19.5 db 11.2m */
+	[14] = {   1, 128}, /* -21.0 db  7.94m*/
+	[15] = {   0,   1} /* mute; not used */
+};
+
+/*
+ * software volume control
+ */
+static void snd_ps3_do_attenuate_16(int attenuate, signed short int * start,
+				    int samples)
+{
+	int i;
+
+	if (unlikely(attenuate == SND_PS3_MIN_ATT)) {
+		return;
+	} else if (attenuate == SND_PS3_MAX_ATT) {
+		memset(start, 0, sizeof(short int) * samples);
+		return;
+	} else {
+		for (i = 0; i < samples; i++) {
+			start[i] = start[i] *
+				attenuater_divisor_array[attenuate].numerator /
+				attenuater_divisor_array[attenuate].denominator;
+		}
+	}
+}
+
+static void snd_ps3_do_attenuate_24(int attenuate, uint32_t * start,
+				    int samples)
+{
+	int i;
+	int32_t temp, temp2;
+
+	if (unlikely(attenuate == SND_PS3_MIN_ATT)) {
+		return;
+	} else if (attenuate == SND_PS3_MAX_ATT) {
+		memset(start, 0, sizeof(uint32_t) * samples);
+		return;
+	} else {
+		for (i = 0; i < samples; i++) {
+			/* 24bit -> 32bit */
+			temp = (int32_t)(start[i] << 8);
+			/* shift alithmetic */
+			temp2 = temp >> 8;
+			/*
+			 * Since upper 8 bits will be disposed of by the
+			 * hardware, leave it untouched.
+			 */
+			start[i] = temp2 *
+				attenuater_divisor_array[attenuate].numerator /
+				attenuater_divisor_array[attenuate].denominator;
+		}
+	}
+}
+
+static int snd_ps3_soft_attenuate(struct snd_ps3_card_info *card,
+				  void * start_l, void * start_r, int bytes)
+{
+
+	switch(snd_pcm_format_width(card->substream->runtime->format)) {
+	case 16:
+		snd_ps3_do_attenuate_16(card->attenuater[SND_PS3_CH_L],
+					start_l, bytes / 2);
+		snd_ps3_do_attenuate_16(card->attenuater[SND_PS3_CH_R],
+					start_r, bytes / 2);
+		break;
+	case 24:
+		snd_ps3_do_attenuate_24(card->attenuater[SND_PS3_CH_L],
+					start_l, bytes / 4);
+		snd_ps3_do_attenuate_24(card->attenuater[SND_PS3_CH_R],
+					start_r, bytes / 4);
+		break;
+	default:
+		printk(KERN_ERR "%s: invalid width %d\n", __FUNCTION__,
+		       snd_pcm_format_width(card->substream->runtime->format));
+		return -EINVAL;
+	}
+	return 0;
+}
diff -Naur linux-2.6.22-org/sound/ppc/snd_ps3.h linux-2.6.22-ps3/sound/ppc/snd_ps3.h
--- linux-2.6.22-org/sound/ppc/snd_ps3.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/sound/ppc/snd_ps3.h	2007-08-22 07:57:32.000000000 +0200
@@ -0,0 +1,232 @@
+/*
+ * Audio support for PS3
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * All rights reserved.
+ * Copyright 2006, 2007 Sony Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2 of the Licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#if !defined(_SND_PS3_H_)
+#define _SND_PS3_H_
+
+#include <linux/irqreturn.h>
+
+
+/*
+ * enable the following for  dummy driver
+ */
+#define _SND_PS3_DUMMY
+
+/*
+ * enable the following for debug traces
+ */
+#undef _SND_PS3_DEBUG
+
+#undef _SND_PS3_TRACE
+#if defined(_SND_PS3_TRACE)
+#define _SF     printk(KERN_ERR "%s: start\n", __FUNCTION__)
+#define _STEPF(x) printk(KERN_ERR "%s: %s\n", __FUNCTION__, x)
+#define _EF     printk(KERN_ERR "%s: end\n", __FUNCTION__)
+#define _EF1(x) printk(KERN_ERR "%s: end %s\n", __FUNCTION__, x)
+#else
+#define _SF do {} while (0)
+#define _EF _SF
+#define _EF1(x) _SF
+#define _STEPF(x) _SF
+#endif
+
+#define SND_PS3_DRIVER_NAME "snd_ps3"
+
+enum snd_ps3_out_channel {
+	SND_PS3_OUT_SPDIF_0,
+	SND_PS3_OUT_SPDIF_1,
+	SND_PS3_OUT_SERIAL_0,
+	SND_PS3_OUT_DEVS
+};
+
+enum snd_ps3_dma_filltype {
+	SND_PS3_DMA_FILLTYPE_FIRSTFILL,
+	SND_PS3_DMA_FILLTYPE_RUNNING,
+	SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL,
+	SND_PS3_DMA_FILLTYPE_SILENT_RUNNING
+};
+
+enum snd_ps3_ch {
+	SND_PS3_CH_L = 0,
+	SND_PS3_CH_R = 1,
+	SND_PS3_CH_MAX = 2
+};
+
+struct snd_ps3_avsetting_info {
+	uint32_t avs_audio_ch;     /* fixed */
+	uint32_t avs_audio_rate;
+	uint32_t avs_audio_width;
+	uint32_t avs_audio_format; /* fixed */
+	uint32_t avs_audio_source; /* fixed */
+};
+/*
+ * PS3 audio 'card' instance
+ * there should be only ONE hardware.
+ */
+struct snd_ps3_card_info {
+	struct platform_device * platform_device;
+	struct snd_card * card;
+
+	struct snd_pcm * pcm;
+	struct snd_pcm_substream * substream;
+
+	/* hvc info */
+	uint64_t audio_lpar_addr;
+	uint64_t audio_lpar_size;
+
+	void *   mapped_vaddr; /* registers */
+
+	uint64_t audio_irq_outlet;
+
+	unsigned int irq_no;
+
+	/* remember avsetting */
+	struct snd_ps3_avsetting_info avs;
+
+	/* remember dmac setting */
+	uint32_t dmac_transfer_count;
+
+	/* dma buffer management */
+	rwlock_t dma_lock;
+	/* dma_lock start */
+		void * dma_start_vaddr[2]; /* 0 for L, 1 for R */
+		size_t dma_buffer_size;
+		void * dma_last_transfer_vaddr[2];
+		void * dma_next_transfer_vaddr[2];
+		int    silent;
+		int running;
+	/* dma_lock end */
+
+	unsigned long null_buffer_start_vaddr;
+
+	rwlock_t start_delay_lock;
+	/* start_delay_lock start */
+		unsigned int start_delay;
+	/* start_delay_lock end */
+
+	struct snd_kcontrol * vol_control;
+	int attenuater[2]; /* store by attenuation, not volume*/
+};
+
+
+/* module  entries */
+static int __init snd_ps3_init(void);
+static void __exit snd_ps3_exit(void);
+
+/* ALSA snd driver ops */
+static int snd_ps3_pcm_open(struct snd_pcm_substream * substream);
+static int snd_ps3_pcm_close(struct snd_pcm_substream * substream);
+static int snd_ps3_pcm_prepare(struct snd_pcm_substream * substream);
+static int snd_ps3_pcm_trigger(struct snd_pcm_substream * substream,
+				 int cmd);
+static snd_pcm_uframes_t snd_ps3_pcm_pointer(struct snd_pcm_substream *
+					     substream);
+static int snd_ps3_pcm_hw_params(struct snd_pcm_substream * substream,
+				 struct snd_pcm_hw_params * hw_params);
+static int snd_ps3_pcm_hw_free(struct snd_pcm_substream * substream);
+
+/* PS3 audio chip */
+static int snd_ps3_init_audio(void);
+
+static void snd_ps3_free_audio(void);
+
+/* platform driver entries */
+static int __init snd_ps3_driver_probe(struct platform_device * device);
+static void snd_ps3_driver_shutdown(struct platform_device * device);
+static int snd_ps3_driver_remove(struct platform_device * device);
+
+/* address setup */
+static int snd_ps3_create_iopt(void);
+static void snd_ps3_destruct_iopt_helper(void);
+static void snd_ps3_destruct_iopt(void);
+static void snd_ps3_audio_set_base_addr(uint64_t ioaddr_start);
+
+/* interrupt handler */
+static irqreturn_t snd_ps3_interrupt(int irq, void * dev_id);
+
+
+/* set sampling rate/format */
+static int snd_ps3_set_avsetting(struct snd_pcm_substream * substream);
+/* take effect parameter change */
+static int snd_ps3_change_avsetting(struct snd_ps3_card_info * card);
+/* initialize avsetting and take it effect */
+static int snd_ps3_init_avsetting(struct snd_ps3_card_info * card);
+/* setup dma */
+static int snd_ps3_program_dma(struct snd_ps3_card_info * card,
+			       enum snd_ps3_dma_filltype filltype);
+static int snd_ps3_kick_dma(struct snd_ps3_card_info * card);
+static void snd_ps3_wait_for_dma_stop(struct snd_ps3_card_info * card);
+
+static uint64_t p_to_dma(uint64_t paddr);
+/* mute control */
+static int snd_ps3_mute(struct snd_pcm_substream * substream, int mute_on);
+
+static ssize_t snd_ps3_get_start_delay(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf);
+static ssize_t snd_ps3_set_start_delay(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count);
+
+
+static int snd_ps3_info_vol_control(struct snd_kcontrol * kcontrol,
+				    struct snd_ctl_elem_info * uinfo);
+static int snd_ps3_get_vol_control(struct snd_kcontrol * kcontrol,
+				   struct snd_ctl_elem_value * ucontrol);
+static int snd_ps3_put_vol_control(struct snd_kcontrol * kcontrol,
+				   struct snd_ctl_elem_value * ucontrol);
+
+static int snd_ps3_soft_attenuate(struct snd_ps3_card_info * card,
+				  void * start_l, void * star_r, int bytes);
+/*
+ * iopte management
+ */
+struct ioif_map_info {
+	uint64_t ioif_addr;
+	uint64_t start_paddr;
+	uint64_t start_lpar_addr;
+	uint64_t area_size;
+};
+
+/* PS3 audio DMAC block size in bytes */
+#define PS3_AUDIO_DMAC_BLOCK_SIZE (128)
+/* one stage (stereo)  of audio FIFO in bytes */
+#define PS3_AUDIO_FIFO_STAGE_SIZE (256)
+/* how many stages the fifo have */
+#define PS3_AUDIO_FIFO_STAGE_COUNT (8)
+/* fifo size 128 bytes * 8 stages * stereo (2ch) */
+#define PS3_AUDIO_FIFO_SIZE \
+	(PS3_AUDIO_FIFO_STAGE_SIZE * PS3_AUDIO_FIFO_STAGE_COUNT)
+
+/* PS3 audio DMAC max block count in one dma shot = 128 (0x80) blocks*/
+#define PS3_AUDIO_DMAC_MAX_BLOCKS  (PS3_AUDIO_DMASIZE_BLOCKS_MASK + 1)
+
+#define PS3_AUDIO_NORMAL_DMA_START_CH (0)
+#define PS3_AUDIO_NORMAL_DMA_COUNT    (8)
+#define PS3_AUDIO_NULL_DMA_START_CH \
+	(PS3_AUDIO_NORMAL_DMA_START_CH + PS3_AUDIO_NORMAL_DMA_COUNT)
+#define PS3_AUDIO_NULL_DMA_COUNT      (2)
+
+#define SND_PS3_MAX_VOL (0x0F)
+#define SND_PS3_MIN_VOL (0x00)
+#define SND_PS3_MIN_ATT SND_PS3_MIN_VOL
+#define SND_PS3_MAX_ATT SND_PS3_MAX_VOL
+
+#endif /* _SND_PS3_H_ */
diff -Naur linux-2.6.22-org/sound/ppc/snd_ps3_reg.h linux-2.6.22-ps3/sound/ppc/snd_ps3_reg.h
--- linux-2.6.22-org/sound/ppc/snd_ps3_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.22-ps3/sound/ppc/snd_ps3_reg.h	2007-08-22 07:57:32.000000000 +0200
@@ -0,0 +1,856 @@
+/*
+ * Audio support for PS3
+ * Copyright (C) 2006 Sony Computer Entertainment Inc.
+ * Copyright 2006, 2007 Sony Corporation
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/*
+ * interrupt / configure registers
+ */
+
+#define PS3_AUDIO_INTR_0                 (0x00000100)
+#define PS3_AUDIO_INTR_EN_0              (0x00000140)
+#define PS3_AUDIO_CONFIG                 (0x00000200)
+
+/*
+ * DMAC registers
+ * n:0..9
+ */
+#define PS3_AUDIO_DMAC_REGBASE(x)         (0x0000210 + 0x20 * (x))
+
+#define PS3_AUDIO_KICK(n)                 (PS3_AUDIO_DMAC_REGBASE(n) + 0x00)
+#define PS3_AUDIO_SOURCE(n)               (PS3_AUDIO_DMAC_REGBASE(n) + 0x04)
+#define PS3_AUDIO_DEST(n)                 (PS3_AUDIO_DMAC_REGBASE(n) + 0x08)
+#define PS3_AUDIO_DMASIZE(n)              (PS3_AUDIO_DMAC_REGBASE(n) + 0x0C)
+
+/*
+ * mute control
+ */
+#define PS3_AUDIO_AX_MCTRL                (0x00004000)
+#define PS3_AUDIO_AX_ISBP                 (0x00004004)
+#define PS3_AUDIO_AX_AOBP                 (0x00004008)
+#define PS3_AUDIO_AX_IC                   (0x00004010)
+#define PS3_AUDIO_AX_IE                   (0x00004014)
+#define PS3_AUDIO_AX_IS                   (0x00004018)
+
+/*
+ * three wire serial
+ * n:0..3
+ */
+#define PS3_AUDIO_AO_MCTRL                (0x00006000)
+#define PS3_AUDIO_AO_3WMCTRL              (0x00006004)
+
+#define PS3_AUDIO_AO_3WCTRL(n)            (0x00006200 + 0x200 * (n))
+
+/*
+ * S/PDIF
+ * n:0..1
+ * x:0..11
+ * y:0..5
+ */
+#define PS3_AUDIO_AO_SPD_REGBASE(n)       (0x00007200 + 0x200 * (n))
+
+#define PS3_AUDIO_AO_SPDCTRL(n)           (PS3_AUDIO_AO_SPD_REGBASE(n) + 0x00)
+#define PS3_AUDIO_AO_SPDUB(n,x)           (PS3_AUDIO_AO_SPD_REGBASE(n) + 0x04 + 0x04 * (x))
+#define PS3_AUDIO_AO_SPDCS(n,y)           (PS3_AUDIO_AO_SPD_REGBASE(n) + 0x34 + 0x04 * (y))
+
+
+/*
+  PS3_AUDIO_INTR_0 register tells an interrupt handler which audio
+  DMA channel triggered the interrupt.  The interrupt status for a channel
+  can be cleared by writing a '1' to the corresponding bit.  A new interrupt
+  cannot be generated until the previous interrupt has been cleared.
+
+  Note that the status reported by PS3_AUDIO_INTR_0 is independent of the
+  value of PS3_AUDIO_INTR_EN_0.
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0 0 0 0 0 0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C| INTR_0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+#define PS3_AUDIO_INTR_0_CHAN(n)                    (1 << ((n) * 2))
+#define PS3_AUDIO_INTR_0_CHAN9                      PS3_AUDIO_INTR_0_CHAN(9)
+#define PS3_AUDIO_INTR_0_CHAN8                      PS3_AUDIO_INTR_0_CHAN(8)
+#define PS3_AUDIO_INTR_0_CHAN7                      PS3_AUDIO_INTR_0_CHAN(7)
+#define PS3_AUDIO_INTR_0_CHAN6                      PS3_AUDIO_INTR_0_CHAN(6)
+#define PS3_AUDIO_INTR_0_CHAN5                      PS3_AUDIO_INTR_0_CHAN(5)
+#define PS3_AUDIO_INTR_0_CHAN4                      PS3_AUDIO_INTR_0_CHAN(4)
+#define PS3_AUDIO_INTR_0_CHAN3                      PS3_AUDIO_INTR_0_CHAN(3)
+#define PS3_AUDIO_INTR_0_CHAN2                      PS3_AUDIO_INTR_0_CHAN(2)
+#define PS3_AUDIO_INTR_0_CHAN1                      PS3_AUDIO_INTR_0_CHAN(1)
+#define PS3_AUDIO_INTR_0_CHAN0                      PS3_AUDIO_INTR_0_CHAN(0)
+
+/*
+  The PS3_AUDIO_INTR_EN_0 register specifies which DMA channels can generate
+  an interrupt to the PU.  Each bit of PS3_AUDIO_INTR_EN_0 is ANDed with the
+  corresponding bit in PS3_AUDIO_INTR_0.  The resulting bits are OR'd together
+  to generate the Audio interrupt.
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0 0 0 0 0 0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C|0|C| INTR_EN_0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+  Bit assignments are same as PS3_AUDIO_INTR_0
+*/
+
+/*
+  PS3_AUDIO_CONFIG
+  31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 C|0 0 0 0 0 0 0 0| CONFIG
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+*/
+
+/* The CLEAR field cancels all pending transfers, and stops any running DMA
+   transfers.  Any interrupts associated with the canceled transfers
+   will occur as if the transfer had finished.
+   Since this bit is designed to recover from DMA related issues
+   which are caused by unpredictable situations, it is prefered to wait
+   for normal DMA transfer end without using this bit.
+*/
+#define PS3_AUDIO_CONFIG_CLEAR                           (1 << 8)  /* RWIVF */
+
+/*
+  PS3_AUDIO_AX_MCTRL: Audio Port Mute Control Register
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|A|A|A|0 0 0 0 0 0 0|S|S|A|A|A|A| AX_MCTRL
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+/* 3 Wire Audio Serial Output Channel Mutes (0..3)  */
+#define PS3_AUDIO_AX_MCTRL_ASOMT(n)                      (1 << (3 - (n)))  /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_ASO3MT                        (1 << 0)          /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_ASO2MT                        (1 << 1)          /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_ASO1MT                        (1 << 2)          /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_ASO0MT                        (1 << 3)          /* RWIVF */
+
+/* S/PDIF mutes (0,1)*/
+#define PS3_AUDIO_AX_MCTRL_SPOMT(n)                      (1 << (5 - (n)))  /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_SPO1MT                        (1 << 4)          /* RWIVF */
+#define PS3_AUDIO_AX_MCTRL_SPO0MT                        (1 << 5)          /* RWIVF */
+
+/* All 3 Wire Serial Outputs Mute */
+#define PS3_AUDIO_AX_MCTRL_AASOMT                        (1 << 13)         /* RWIVF */
+
+/* All S/PDIF Mute */
+#define PS3_AUDIO_AX_MCTRL_ASPOMT                        (1 << 14)         /* RWIVF */
+
+/* All Audio Outputs Mute */
+#define PS3_AUDIO_AX_MCTRL_AAOMT                         (1 << 15)         /* RWIVF */
+
+/*
+  S/PDIF Outputs Buffer Read/Write Pointer Register
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0|0|SPO0B|0|SPO1B|0 0 0 0 0 0 0 0|0|SPO0B|0|SPO1B| AX_ISBP
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+*/
+/*
+ S/PDIF Output Channel Read Buffer Numbers
+ Buffer number is  value of field.
+ Indicates current read access buffer ID from Audio Data
+ Transfer controller of S/PDIF Output
+*/
+
+#define PS3_AUDIO_AX_ISBP_SPOBRN_MASK(n)                 (0x7 << 4 * (1 - (n))) /* R-IUF */
+#define PS3_AUDIO_AX_ISBP_SPO1BRN_MASK                   (0x7 << 0) /* R-IUF */
+#define PS3_AUDIO_AX_ISBP_SPO0BRN_MASK                   (0x7 << 4) /* R-IUF */
+
+/*
+S/PDIF Output Channel Buffer Write Numbers
+Indicates current write access buffer ID from bus master.
+*/
+#define PS3_AUDIO_AX_ISBP_SPOBWN_MASK(n)                 (0x7 <<  4 * (5 - (n))) /* R-IUF */
+#define PS3_AUDIO_AX_ISBP_SPO1BWN_MASK                   (0x7 << 16) /* R-IUF */
+#define PS3_AUDIO_AX_ISBP_SPO0BWN_MASK                   (0x7 << 20) /* R-IUF */
+
+/*
+  3 Wire Audio Serial Outputs Buffer Read/Write
+  Pointer Register
+  Buffer number is  value of field
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0|ASO0B|0|ASO1B|0|ASO2B|0|ASO3B|0|ASO0B|0|ASO1B|0|ASO2B|0|ASO3B| AX_AOBP
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+/*
+3 Wire Audio Serial Output Channel Buffer Read Numbers
+Indicates current read access buffer Id from Audio Data Transfer
+Controller of 3 Wire Audio Serial Output Channels
+*/
+#define PS3_AUDIO_AX_AOBP_ASOBRN_MASK(n)                 (0x7 << 4 * (3 - (n))) /* R-IUF */
+
+#define PS3_AUDIO_AX_AOBP_ASO3BRN_MASK                   (0x7 << 0) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO2BRN_MASK                   (0x7 << 4) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO1BRN_MASK                   (0x7 << 8) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO0BRN_MASK                   (0x7 << 12) /* R-IUF */
+
+/*
+3 Wire Audio Serial Output Channel Buffer Write Numbers
+Indicates current write access buffer ID from bus master.
+*/
+#define PS3_AUDIO_AX_AOBP_ASOBWN_MASK(n)                 (0x7 << 4 * (7 - (n))) /* R-IUF */
+
+#define PS3_AUDIO_AX_AOBP_ASO3BWN_MASK                   (0x7 << 16) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO2BWN_MASK                   (0x7 << 20) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO1BWN_MASK                   (0x7 << 24) /* R-IUF */
+#define PS3_AUDIO_AX_AOBP_ASO0BWN_MASK                   (0x7 << 28) /* R-IUF */
+
+
+
+/*
+Audio Port Interrupt Condition Register
+For the fields in this register, the following values apply:
+0 = Interrupt is generated every interrupt event.
+1 = Interrupt is generated every 2 interrupt events.
+2 = Interrupt is generated every 4 interrupt events.
+3 = Reserved
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0|0 0|SPO|0 0|SPO|0 0|AAS|0 0 0 0 0 0 0 0 0 0 0 0| AX_IC
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+/*
+All 3-Wire Audio Serial Outputs Interrupt Mode
+Configures the Interrupt and Signal Notification
+condition of all 3-wire Audio Serial Outputs.
+*/
+#define PS3_AUDIO_AX_IC_AASOIMD_MASK                     (0x3 << 12) /* RWIVF */
+#define PS3_AUDIO_AX_IC_AASOIMD_EVERY1                   (0x0 << 12) /* RWI-V */
+#define PS3_AUDIO_AX_IC_AASOIMD_EVERY2                   (0x1 << 12) /* RW--V */
+#define PS3_AUDIO_AX_IC_AASOIMD_EVERY4                   (0x2 << 12) /* RW--V */
+
+/*
+S/PDIF Output Channel Interrupt Modes
+Configures the Interrupt and signal Notification
+conditions of S/PDIF output channels.
+*/
+#define PS3_AUDIO_AX_IC_SPO1IMD_MASK                     (0x3 << 16) /* RWIVF */
+#define PS3_AUDIO_AX_IC_SPO1IMD_EVERY1                   (0x0 << 16) /* RWI-V */
+#define PS3_AUDIO_AX_IC_SPO1IMD_EVERY2                   (0x1 << 16) /* RW--V */
+#define PS3_AUDIO_AX_IC_SPO1IMD_EVERY4                   (0x2 << 16) /* RW--V */
+
+#define PS3_AUDIO_AX_IC_SPO0IMD_MASK                     (0x3 << 20) /* RWIVF */
+#define PS3_AUDIO_AX_IC_SPO0IMD_EVERY1                   (0x0 << 20) /* RWI-V */
+#define PS3_AUDIO_AX_IC_SPO0IMD_EVERY2                   (0x1 << 20) /* RW--V */
+#define PS3_AUDIO_AX_IC_SPO0IMD_EVERY4                   (0x2 << 20) /* RW--V */
+
+/*
+Audio Port interrupt Enable Register
+Configures whether to enable or disable each Interrupt Generation.
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0|S|S|0 0|A|A|A|A|0 0 0 0|S|S|0 0|S|S|0 0|A|A|A|A| AX_IE
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+*/
+
+/*
+3 Wire Audio Serial Output Channel Buffer Underflow
+Interrupt Enables
+Select enable/disable of Buffer Underflow Interrupts for
+3-Wire Audio Serial Output Channels
+DISABLED=Interrupt generation disabled.
+*/
+#define PS3_AUDIO_AX_IE_ASOBUIE(n)                       (1 << (3 - (n))) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO3BUIE                         (1 << 0) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO2BUIE                         (1 << 1) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO1BUIE                         (1 << 2) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO0BUIE                         (1 << 3) /* RWIVF */
+
+/* S/PDIF Output Channel Buffer Underflow Interrupt Enables */
+
+#define PS3_AUDIO_AX_IE_SPOBUIE(n)                       (1 << (7 - (n))) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO1BUIE                         (1 << 6) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO0BUIE                         (1 << 7) /* RWIVF */
+
+/* S/PDIF Output Channel One Block Transfer Completion Interrupt Enables */
+
+#define PS3_AUDIO_AX_IE_SPOBTCIE(n)                      (1 << (11 - (n))) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO1BTCIE                        (1 << 10) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO0BTCIE                        (1 << 11) /* RWIVF */
+
+/* 3-Wire Audio Serial Output Channel Buffer Empty Interrupt Enables */
+
+#define PS3_AUDIO_AX_IE_ASOBEIE(n)                       (1 << (19 - (n))) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO3BEIE                         (1 << 16) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO2BEIE                         (1 << 17) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO1BEIE                         (1 << 18) /* RWIVF */
+#define PS3_AUDIO_AX_IE_ASO0BEIE                         (1 << 19) /* RWIVF */
+
+/* S/PDIF Output Channel Buffer Empty Interrupt Enables */
+
+#define PS3_AUDIO_AX_IE_SPOBEIE(n)                       (1 << (23 - (n))) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO1BEIE                         (1 << 22) /* RWIVF */
+#define PS3_AUDIO_AX_IE_SPO0BEIE                         (1 << 23) /* RWIVF */
+
+/*
+Audio Port Interrupt Status Register
+Indicates Interrupt status, which interrupt has occured, and can clear
+each interrupt in this register.
+Writing 1b to a field containing 1b clears field and de-asserts interrupt.
+Writing 0b to a field has no effect.
+Field vaules are the following:
+0 - Interrupt hasn't occured.
+1 - Interrupt has occured.
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0|S|S|0 0|A|A|A|A|0 0 0 0|S|S|0 0|S|S|0 0|A|A|A|A| AX_IS
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+ Bit assignment are same as AX_IE
+*/
+
+/*
+Audio Output Master Control Register
+Configures Master Clock and other master Audio Output Settings
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0|SCKSE|0|SCKSE|  MR0  |  MR1  |MCL|MCL|0 0 0 0|0 0 0 0 0 0 0 0| AO_MCTRL
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+/*
+MCLK Output Control
+Controls mclko[1] output.
+0 - Disable output (fixed at High)
+1 - Output clock produced by clock selected
+with scksel1 by mr1
+2 - Reserved
+3 - Reserved
+*/
+
+#define PS3_AUDIO_AO_MCTRL_MCLKC1_MASK                   (0x3 << 12) /* RWIVF */
+#define PS3_AUDIO_AO_MCTRL_MCLKC1_DISABLED               (0x0 << 12) /* RWI-V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC1_ENABLED                (0x1 << 12) /* RW--V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC1_RESVD2                 (0x2 << 12) /* RW--V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC1_RESVD3                 (0x3 << 12) /* RW--V */
+
+/*
+MCLK Output Control
+Controls mclko[0] output.
+0 - Disable output (fixed at High)
+1 - Output clock produced by clock selected
+with SCKSEL0 by MR0
+2 - Reserved
+3 - Reserved
+*/
+#define PS3_AUDIO_AO_MCTRL_MCLKC0_MASK                   (0x3 << 14) /* RWIVF */
+#define PS3_AUDIO_AO_MCTRL_MCLKC0_DISABLED               (0x0 << 14) /* RWI-V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC0_ENABLED                (0x1 << 14) /* RW--V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC0_RESVD2                 (0x2 << 14) /* RW--V */
+#define PS3_AUDIO_AO_MCTRL_MCLKC0_RESVD3                 (0x3 << 14) /* RW--V */
+/*
+Master Clock Rate 1
+Sets the divide ration of Master Clock1 (clock output from
+mclko[1] for the input clock selected by scksel1.
+*/
+#define PS3_AUDIO_AO_MCTRL_MR1_MASK                      (0xf << 16)
+#define PS3_AUDIO_AO_MCTRL_MR1_DEFAULT                   (0x0 << 16) /* RWI-V */
+/*
+Master Clock Rate 0
+Sets the divide ratio of Master Clock0 (clock output from
+mclko[0] for the input clock selected by scksel0).
+*/
+#define PS3_AUDIO_AO_MCTRL_MR0_MASK                      (0xf << 20) /* RWIVF */
+#define PS3_AUDIO_AO_MCTRL_MR0_DEFAULT                   (0x0 << 20) /* RWI-V */
+/*
+System Clock Select 0/1
+Selects the system clock to be used as Master Clock 0/1
+Input the system clock that is appropriate for the sampling
+rate.
+*/
+#define PS3_AUDIO_AO_MCTRL_SCKSEL1_MASK                  (0x7 << 24) /* RWIVF */
+#define PS3_AUDIO_AO_MCTRL_SCKSEL1_DEFAULT               (0x2 << 24) /* RWI-V */
+
+#define PS3_AUDIO_AO_MCTRL_SCKSEL0_MASK                  (0x7 << 28) /* RWIVF */
+#define PS3_AUDIO_AO_MCTRL_SCKSEL0_DEFAULT               (0x2 << 28) /* RWI-V */
+
+
+/*
+3-Wire Audio Output Master Control Register
+Configures clock, 3-Wire Audio Serial Output Enable, and
+other 3-Wire Audio Serial Output Master Settings
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |A|A|A|A|0 0 0|A| ASOSR |0 0 0 0|A|A|A|A|A|A|0|1|0 0 0 0 0 0 0 0| AO_3WMCTRL
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+
+/*
+LRCKO Polarity
+0 - Reserved
+1 - default
+*/
+#define PS3_AUDIO_AO_3WMCTRL_ASOPLRCK                    (1 << 8) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOPLRCK_DEFAULT            (1 << 8) /* RW--V */
+
+/* LRCK Output Disable */
+
+#define PS3_AUDIO_AO_3WMCTRL_ASOLRCKD                    (1 << 10) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOLRCKD_ENABLED            (0 << 10) /* RW--V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOLRCKD_DISABLED           (1 << 10) /* RWI-V */
+
+/* Bit Clock Output Disable */
+
+#define PS3_AUDIO_AO_3WMCTRL_ASOBCLKD                    (1 << 11) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOBCLKD_ENABLED            (0 << 11) /* RW--V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOBCLKD_DISABLED           (1 << 11) /* RWI-V */
+
+/*
+3-Wire Audio Serial Output Channel 0-3 Operational
+Status.  Each bit becomes 1 after each 3-Wire Audio
+Serial Output Channel N is in action by setting 1 to
+asoen.
+Each bit becomes 0 after each 3-Wire Audio Serial Output
+Channel N is out of action by setting 0 to asoen.
+*/
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN(n)                   (1 << (15 - (n))) /* R-IVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN_STOPPED(n)           (0 << (15 - (n))) /* R-I-V */
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN_RUNNING(n)           (1 << (15 - (n))) /* R---V */
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN0                     PS3_AUDIO_AO_3WMCTRL_ASORUN(0)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN0_STOPPED             PS3_AUDIO_AO_3WMCTRL_ASORUN_STOPPED(0)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN0_RUNNING             PS3_AUDIO_AO_3WMCTRL_ASORUN_RUNNING(0)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN1                     PS3_AUDIO_AO_3WMCTRL_ASORUN(1)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN1_STOPPED             PS3_AUDIO_AO_3WMCTRL_ASORUN_STOPPED(1)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN1_RUNNING             PS3_AUDIO_AO_3WMCTRL_ASORUN_RUNNING(1)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN2                     PS3_AUDIO_AO_3WMCTRL_ASORUN(2)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN2_STOPPED             PS3_AUDIO_AO_3WMCTRL_ASORUN_STOPPED(2)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN2_RUNNING             PS3_AUDIO_AO_3WMCTRL_ASORUN_RUNNING(2)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN3                     PS3_AUDIO_AO_3WMCTRL_ASORUN(3)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN3_STOPPED             PS3_AUDIO_AO_3WMCTRL_ASORUN_STOPPED(3)
+#define PS3_AUDIO_AO_3WMCTRL_ASORUN3_RUNNING             PS3_AUDIO_AO_3WMCTRL_ASORUN_RUNNING(3)
+
+/*
+Sampling Rate
+Specifies the divide ratio of the bit clock (clock output
+from bclko) used by the 3-wire Audio Output Clock, whcih
+is applied to the master clock selected by mcksel.
+Data output is synchronized with this clock.
+*/
+#define PS3_AUDIO_AO_3WMCTRL_ASOSR_MASK                  (0xf << 20) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOSR_DIV2                  (0x1 << 20) /* RWI-V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOSR_DIV4                  (0x2 << 20) /* RW--V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOSR_DIV8                  (0x4 << 20) /* RW--V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOSR_DIV12                 (0x6 << 20) /* RW--V */
+
+/*
+Master Clock Select
+0 - Master Clock 0
+1 - Master Clock 1
+*/
+#define PS3_AUDIO_AO_3WMCTRL_ASOMCKSEL                   (1 << 24) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOMCKSEL_CLK0              (0 << 24) /* RWI-V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOMCKSEL_CLK1              (1 << 24) /* RW--V */
+
+/*
+Enables and disables 4ch 3-Wire Audio Serial Output
+operation.  Each Bit from 0 to 3 corresponds to an
+output channel, which means that each output channel
+can be enabled or disabled individually.  When
+multiple channels are enabled at the same time, output
+operations are performed in synchronization.
+Bit 0 - Output Channel 0 (SDOUT[0])
+Bit 1 - Output Channel 1 (SDOUT[1])
+Bit 2 - Output Channel 2 (SDOUT[2])
+Bit 3 - Output Channel 3 (SDOUT[3])
+*/
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN(n)                    (1 << (31 - (n))) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN_DISABLED(n)           (0 << (31 - (n))) /* RWI-V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN_ENABLED(n)            (1 << (31 - (n))) /* RW--V */
+
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN0                      PS3_AUDIO_AO_3WMCTRL_ASOEN(0) /* RWIVF */
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN0_DISABLED             PS3_AUDIO_AO_3WMCTRL_ASOEN_DISABLED(0) /* RWI-V */
+#define PS3_AUDIO_AO_3WMCTRL_ASOEN0_ENABLED              PS3_AUDIO_AO_3WMCTRL_ASOEN_ENABLED(0) /* RW--V */
+#define PS3_AUDIO_A1_3WMCTRL_ASOEN0                      PS3_AUDIO_AO_3WMCTRL_ASOEN(1) /* RWIVF */
+#define PS3_AUDIO_A1_3WMCTRL_ASOEN0_DISABLED             PS3_AUDIO_AO_3WMCTRL_ASOEN_DISABLED(1) /* RWI-V */
+#define PS3_AUDIO_A1_3WMCTRL_ASOEN0_ENABLED              PS3_AUDIO_AO_3WMCTRL_ASOEN_ENABLED(1) /* RW--V */
+#define PS3_AUDIO_A2_3WMCTRL_ASOEN0                      PS3_AUDIO_AO_3WMCTRL_ASOEN(2) /* RWIVF */
+#define PS3_AUDIO_A2_3WMCTRL_ASOEN0_DISABLED             PS3_AUDIO_AO_3WMCTRL_ASOEN_DISABLED(2) /* RWI-V */
+#define PS3_AUDIO_A2_3WMCTRL_ASOEN0_ENABLED              PS3_AUDIO_AO_3WMCTRL_ASOEN_ENABLED(2) /* RW--V */
+#define PS3_AUDIO_A3_3WMCTRL_ASOEN0                      PS3_AUDIO_AO_3WMCTRL_ASOEN(3) /* RWIVF */
+#define PS3_AUDIO_A3_3WMCTRL_ASOEN0_DISABLED             PS3_AUDIO_AO_3WMCTRL_ASOEN_DISABLED(3) /* RWI-V */
+#define PS3_AUDIO_A3_3WMCTRL_ASOEN0_ENABLED              PS3_AUDIO_AO_3WMCTRL_ASOEN_ENABLED(3) /* RW--V */
+
+/*
+3-Wire Audio Serial output Channel 0-3 Control Register
+Configures settings for 3-Wire Serial Audio Output Channel 0-3
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|A|0 0 0 0|A|0|ASO|0 0 0|0|0|0|0|0| AO_3WCTRL
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+*/
+/*
+Data Bit Mode
+Specifies the number of data bits
+0 - 16 bits
+1 - reserved
+2 - 20 bits
+3 - 24 bits
+*/
+#define PS3_AUDIO_AO_3WCTRL_ASODB_MASK                   (0x3 << 8) /* RWIVF */
+#define PS3_AUDIO_AO_3WCTRL_ASODB_16BIT                  (0x0 << 8) /* RWI-V */
+#define PS3_AUDIO_AO_3WCTRL_ASODB_RESVD                  (0x1 << 8) /* RWI-V */
+#define PS3_AUDIO_AO_3WCTRL_ASODB_20BIT                  (0x2 << 8) /* RW--V */
+#define PS3_AUDIO_AO_3WCTRL_ASODB_24BIT                  (0x3 << 8) /* RW--V */
+/*
+Data Format Mode
+Specifies the data format where (LSB side or MSB) the data(in 20 bit
+or 24 bit resolution mode) is put in a 32 bit field.
+0 - Data put on LSB side
+1 - Data put on MSB side
+*/
+#define PS3_AUDIO_AO_3WCTRL_ASODF                        (1 << 11) /* RWIVF */
+#define PS3_AUDIO_AO_3WCTRL_ASODF_LSB                    (0 << 11) /* RWI-V */
+#define PS3_AUDIO_AO_3WCTRL_ASODF_MSB                    (1 << 11) /* RW--V */
+/*
+Buffer Reset
+Performs buffer reset.  Writing 1 to this bit initializes the
+corresponding 3-Wire Audio Output buffers(both L and R).
+*/
+#define PS3_AUDIO_AO_3WCTRL_ASOBRST                      (1 << 16) /* CWIVF */
+#define PS3_AUDIO_AO_3WCTRL_ASOBRST_IDLE                 (0 << 16) /* -WI-V */
+#define PS3_AUDIO_AO_3WCTRL_ASOBRST_RESET                (1 << 16) /* -W--T */
+
+/*
+S/PDIF Audio Output Channel 0/1 Control Register
+Configures settings for S/PDIF Audio Output Channel 0/1.
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |S|0 0 0|S|0 0|S| SPOSR |0 0|SPO|0 0 0 0|S|0|SPO|0 0 0 0 0 0 0|S| AO_SPDCTRL
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+/*
+Buffer reset.  Writing 1 to this bit initializes the
+corresponding S/PDIF output buffer pointer.
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPOBRST                     (1 << 0) /* CWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPOBRST_IDLE                (0 << 0) /* -WI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOBRST_RESET               (1 << 0) /* -W--T */
+
+/*
+Data Bit Mode
+Specifies number of data bits
+0 - 16 bits
+1 - Reserved
+2 - 20 bits
+3 - 24 bits
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPODB_MASK                  (0x3 << 8) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPODB_16BIT                 (0x0 << 8) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPODB_RESVD                 (0x1 << 8) /* RW--V */
+#define PS3_AUDIO_AO_SPDCTRL_SPODB_20BIT                 (0x2 << 8) /* RW--V */
+#define PS3_AUDIO_AO_SPDCTRL_SPODB_24BIT                 (0x3 << 8) /* RW--V */
+/*
+Data format Mode
+Specifies the data format, where (LSB side or MSB)
+the data(in 20 or 24 bit resolution) is put in the
+32 bit field.
+0 - LSB Side
+1 - MSB Side
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPODF                       (1 << 11) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPODF_LSB                   (0 << 11) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPODF_MSB                   (1 << 11) /* RW--V */
+/*
+Source Select
+Specifies the source of the S/PDIF output.  When 0, output
+operation is controlled by 3wen[0] of AO_3WMCTRL register.
+The SR must have the same setting as the a0_3wmctrl reg.
+0 - 3-Wire Audio OUT Ch0 Buffer
+1 - S/PDIF buffer
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPOSS_MASK                  (0x3 << 16) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSS_3WEN                  (0x0 << 16) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSS_SPDIF                 (0x1 << 16) /* RW--V */
+/*
+Sampling Rate
+Specifies the divide ratio of the bit clock (clock output
+from bclko) used by the S/PDIF Output Clock, which
+is applied to the master clock selected by mcksel.
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPOSR                       (0xf << 20) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSR_DIV2                  (0x1 << 20) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSR_DIV4                  (0x2 << 20) /* RW--V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSR_DIV8                  (0x4 << 20) /* RW--V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOSR_DIV12                 (0x6 << 20) /* RW--V */
+/*
+Master Clock Select
+0 - Master Clock 0
+1 - Master Clock 1
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPOMCKSEL                   (1 << 24) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPOMCKSEL_CLK0              (0 << 24) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOMCKSEL_CLK1              (1 << 24) /* RW--V */
+
+/*
+S/PDIF Output Channel Operational Status
+This bit becomes 1 after S/PDIF Output Channel is in
+action by setting 1 to spoen.  This bit becomes 0
+after S/PDIF Output Channel is out of action by setting
+0 to spoen.
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPORUN                      (1 << 27) /* R-IVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPORUN_STOPPED              (0 << 27) /* R-I-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPORUN_RUNNING              (1 << 27) /* R---V */
+
+/*
+S/PDIF Audio Output Channel Output Enable
+Enables and disables output operation.  This bit is used
+only when sposs = 1
+*/
+#define PS3_AUDIO_AO_SPDCTRL_SPOEN                       (1 << 31) /* RWIVF */
+#define PS3_AUDIO_AO_SPDCTRL_SPOEN_DISABLED              (0 << 31) /* RWI-V */
+#define PS3_AUDIO_AO_SPDCTRL_SPOEN_ENABLED               (1 << 31) /* RW--V */
+
+/*
+S/PDIF Audio Output Channel Channel Status
+Setting Registers.
+Configures channel status bit settings for each block
+(192 bits).
+Output is performed from the MSB(AO_SPDCS0 register bit 31).
+The same value is added for subframes within the same frame.
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |                             SPOCS                             | AO_SPDCS
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+
+S/PDIF Audio Output Channel User Bit Setting
+Configures user bit settings for each block (384 bits).
+Output is performed from the MSB(ao_spdub0 register bit 31).
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |                             SPOUB                             | AO_SPDUB
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+/*******************************************************************************
+ *
+ * DMAC register
+ *
+ *******************************************************************************/
+/*
+The PS3_AUDIO_KICK register is used to initiate a DMA transfer and monitor its status
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0|STATU|0 0 0|  EVENT  |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|R| KICK
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+/*
+The REQUEST field is written to ACTIVE to initiate a DMA request when EVENT occurs.
+It will return to the DONE state when the request is completed.
+The registers for a DMA channel should only be written if REQUEST is IDLE.
+*/
+
+#define PS3_AUDIO_KICK_REQUEST                           (1 << 0) /* RWIVF */
+#define PS3_AUDIO_KICK_REQUEST_IDLE                      (0 << 0) /* RWI-V */
+#define PS3_AUDIO_KICK_REQUEST_ACTIVE                    (1 << 0) /* -W--T */
+
+/* The EVENT field is used to set the event in which the DMA request becomes active. */
+#define PS3_AUDIO_KICK_EVENT_MASK                        (0x1f << 16) /* RWIVF */
+#define PS3_AUDIO_KICK_EVENT_ALWAYS                      (0x00 << 16) /* RWI-V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT0_EMPTY            (0x01 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT0_UNDERFLOW        (0x02 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT1_EMPTY            (0x03 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT1_UNDERFLOW        (0x04 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT2_EMPTY            (0x05 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT2_UNDERFLOW        (0x06 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT3_EMPTY            (0x07 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SERIALOUT3_UNDERFLOW        (0x08 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF0_BLOCKTRANSFERCOMPLETE (0x09 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF0_UNDERFLOW            (0x0A << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF0_EMPTY                (0x0B << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF1_BLOCKTRANSFERCOMPLETE (0x0C << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF1_UNDERFLOW            (0x0D << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_SPDIF1_EMPTY                (0x0E << 16) /* RW--V */
+
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA(n)                ((0x13 + (n)) << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA0                  (0x13 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA1                  (0x14 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA2                  (0x15 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA3                  (0x16 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA4                  (0x17 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA5                  (0x18 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA6                  (0x19 << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA7                  (0x1A << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA8                  (0x1B << 16) /* RW--V */
+#define PS3_AUDIO_KICK_EVENT_AUDIO_DMA9                  (0x1C << 16) /* RW--V */
+
+/*
+The STATUS field can be used to monitor the progress of a DMA request.
+DONE indicates the previous request has completed.
+EVENT indicates that the DMA engine is waiting for the EVENT to occur.
+PENDING indicates that the DMA engine has not started processing this
+request, but the EVENT has occured.
+DMA indicates that the data transfer is in progress.
+NOTIFY indicates that the notifier signalling end of transfer is being written.
+CLEAR indicated that the previous transfer was cleared.
+ERROR indicates the previous transfer requested an unsupported source/destination combination.
+*/
+
+#define PS3_AUDIO_KICK_STATUS_MASK                       (0x7 << 24) /* R-IVF */
+#define PS3_AUDIO_KICK_STATUS_DONE                       (0x0 << 24) /* R-I-V */
+#define PS3_AUDIO_KICK_STATUS_EVENT                      (0x1 << 24) /* R---V */
+#define PS3_AUDIO_KICK_STATUS_PENDING                    (0x2 << 24) /* R---V */
+#define PS3_AUDIO_KICK_STATUS_DMA                        (0x3 << 24) /* R---V */
+#define PS3_AUDIO_KICK_STATUS_NOTIFY                     (0x4 << 24) /* R---V */
+#define PS3_AUDIO_KICK_STATUS_CLEAR                      (0x5 << 24) /* R---V */
+#define PS3_AUDIO_KICK_STATUS_ERROR                      (0x6 << 24) /* R---V */
+
+/*
+The PS3_AUDIO_SOURCE register specifies the source address for transfers.
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |                      START                      |0 0 0 0 0|TAR| SOURCE
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+/*
+The Audio DMA engine uses 128-byte transfers, thus the address must be aligned
+to a 128 byte boundary.  The low seven bits are assumed to be 0.
+*/
+
+#define PS3_AUDIO_SOURCE_START_MASK                      (0x01FFFFFF << 7) /* RWIUF */
+
+/*
+The TARGET field specifies the memory space containing the source address.
+*/
+
+#define PS3_AUDIO_SOURCE_TARGET_MASK                     (3 << 0) /* RWIVF */
+#define PS3_AUDIO_SOURCE_TARGET_SYSTEM_MEMORY            (2 << 0) /* RW--V */
+
+/*
+The PS3_AUDIO_DEST register specifies the destination address for transfers.
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |                      START                      |0 0 0 0 0|TAR| DEST
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+/*
+The Audio DMA engine uses 128-byte transfers, thus the address must be aligned
+to a 128 byte boundary.  The low seven bits are assumed to be 0.
+*/
+
+#define PS3_AUDIO_DEST_START_MASK                       (0x01FFFFFF << 7) /* RWIUF */
+
+/*
+The TARGET field specifies the memory space containing the destination address
+AUDIOFIFO = Audio WriteData FIFO,
+*/
+
+#define PS3_AUDIO_DEST_TARGET_MASK                       (3 << 0) /* RWIVF */
+#define PS3_AUDIO_DEST_TARGET_AUDIOFIFO                  (1 << 0) /* RW--V */
+
+/*
+PS3_AUDIO_DMASIZE specifies the number of 128-byte blocks + 1 to transfer.
+So a value of 0 means 128-bytes will get transfered.
+
+
+ 31            24 23           16 15            8 7             0
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+ |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|   BLOCKS    | DMASIZE
+ +-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+
+*/
+
+
+#define PS3_AUDIO_DMASIZE_BLOCKS_MASK                    (0x7f << 0) /* RWIUF */
+
+/*
+ * source/destination address for internal fifos
+ */
+#define PS3_AUDIO_AO_3W_LDATA(n)                         (0x1000 + (0x100 * (n)))
+#define PS3_AUDIO_AO_3W_RDATA(n)                         (0x1080 + (0x100 * (n)))
+
+#define PS3_AUDIO_AO_SPD_DATA(n)                         (0x2000 + (0x400 * (n)))
+
+
+/************************************************************************
+ field attiribute
+
+	Read
+	  ' ' = Other Information
+	  '-' = Field is part of a write-only register
+	  'C' = Value read is always the same, constant value line follows (C)
+	  'R' = Value is read
+
+	Write
+	  ' ' = Other Information
+	  '-' = Must not be written (D), value ignored when written (R,A,F)
+	  'W' = Can be written
+
+	Internal State
+	  ' ' = Other Information
+	  '-' = No internal state
+	  'X' = Internal state, initial value is unknown
+	  'I' = Internal state, initial value is known and follows (I)
+
+	Declaration/Size
+	  ' ' = Other Information
+	  '-' = Does Not Apply
+	  'V' = Type is void
+	  'U' = Type is unsigned integer
+	  'S' = Type is signed integer
+	  'F' = Type is IEEE floating point
+	  '1' = Byte size (008)
+	  '2' = Short size (016)
+	  '3' = Three byte size (024)
+	  '4' = Word size (032)
+	  '8' = Double size (064)
+
+	Define Indicator
+	  ' ' = Other Information
+	  'D' = Device
+	  'M' = Memory
+	  'R' = Register
+	  'A' = Array of Registers
+	  'F' = Field
+	  'V' = Value
+          'T' = Task
+
+ **********************************************************************/
