diff -Naur linux-org/drivers/media/video/ecam32/auto_conf.h linux-ths/drivers/media/video/ecam32/auto_conf.h
--- linux-org/drivers/media/video/ecam32/auto_conf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/auto_conf.h	2011-12-21 12:36:18.000000000 +0100
@@ -0,0 +1,96 @@
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                              e_CAM32_OMAP_GSTIX
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_BOARD_e_CAM32_OMAP_GSTIX
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                                Memory related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+/*
+ * e_CAM50_OMAP_GSTIX
+ *
+ *
+ * Modified version:
+ * etc/rc5.d/S30gstti-init
+ *
+ * # Start Addr    Size    Description
+ * # -------------------------------------------
+ * # 0x80000000    93 MB   Linux
+ * # 0x85700000     6 MB   e-con camera
+ * # 0x86300000    16 MB   CMEM
+ * # 0x87300000    13 MB   CODEC SERVER
+ * # 0x88000000   128 MB   RAM starts if available is 256 MB ram
+ *
+ * Boot arguments used
+ * -------------------
+ * setenv mmcargs 'setenv bootargs console=${console} vram=${vram} mem=87M@0x80000000 mem=128M@0x88000000 omapfb.mode=dvi:${dvimode} omapfb.debug=y omapdss.def_disp=${defaultdisplay} root=/dev/mmcblk0p2 rw rootfstype=ext3 rootwait i2c_bus=3,100'
+ */
+
+#define CONFIG_RAM_SIZE_IN_MB			256
+#define CONFIG_CMEM_DRIVER_AVAILABLE
+#define CONFIG_ALLOW_DRIVER_PHY_MEMORY_OVERLAP
+
+#define PHY_MEM_HIGH_ALLOCATE_IN_MB		6	
+
+#if (CONFIG_RAM_SIZE_IN_MB == 128)
+
+	#if defined(CONFIG_CMEM_DRIVER_AVAILABLE)
+		#define PHY_MEM_END		0x862FFFFF	// start address is 0x8570_0000  @ 12M
+	#else
+		#define PHY_MEM_END		0x87FFFFFF
+	#endif
+	
+#elif (CONFIG_RAM_SIZE_IN_MB == 256)
+
+	#if defined(CONFIG_CMEM_DRIVER_AVAILABLE)
+		#define PHY_MEM_END		0x862FFFFF	// start address is 0x8570_0000  @ 12M
+	#else
+		#define PHY_MEM_END		0x8FFFFFFF
+	#endif
+
+#endif
+#define PHY_MEM_START				(PHY_MEM_END - ((PHY_MEM_HIGH_ALLOCATE_IN_MB * 1024 * 1024)-1))
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Driver related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define STILL_IMAGE_CAPTURE_FRAME_NUMBER	3
+#define CONFIG_USE_TI_RESIZER			DISABLE
+#define CONFIG_ISP_DATA_LINE_SHIFT		DISABLE
+#define CONFIG_ISP_SLV0_DISCARD_COUNT		0
+#define CONFIG_SENS_MCLK			0
+#undef CONFIG_CTRL_FRAME_RATE_FRM_SENSOR
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Sensor related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_USE_OV3640_SENSOR
+#define CONFIG_OV3640_DEFAULT_FLIP		DISABLE	
+#define CONFIG_OV3640_DEFAULT_MIRROR		DISABLE
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Flash related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_USE_LM3553_FLASH
+/*
+ * FIXME:
+ * 	When Flash lumination value is set more than 40 then board re-boots at snap mode.
+ */
+#define CONIFG_LM3553_FLASH_MAX_LUM_VALUE		40
+
+
+
diff -Naur linux-org/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/auto_conf.h linux-ths/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/auto_conf.h
--- linux-org/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/auto_conf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/auto_conf.h	2011-11-01 09:19:08.000000000 +0100
@@ -0,0 +1,96 @@
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                              e_CAM32_OMAP_GSTIX
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_BOARD_e_CAM32_OMAP_GSTIX
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                                Memory related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+/*
+ * e_CAM50_OMAP_GSTIX
+ *
+ *
+ * Modified version:
+ * etc/rc5.d/S30gstti-init
+ *
+ * # Start Addr    Size    Description
+ * # -------------------------------------------
+ * # 0x80000000    93 MB   Linux
+ * # 0x85700000     6 MB   e-con camera
+ * # 0x86300000    16 MB   CMEM
+ * # 0x87300000    13 MB   CODEC SERVER
+ * # 0x88000000   128 MB   RAM starts if available is 256 MB ram
+ *
+ * Boot arguments used
+ * -------------------
+ * setenv mmcargs 'setenv bootargs console=${console} vram=${vram} mem=87M@0x80000000 mem=128M@0x88000000 omapfb.mode=dvi:${dvimode} omapfb.debug=y omapdss.def_disp=${defaultdisplay} root=/dev/mmcblk0p2 rw rootfstype=ext3 rootwait i2c_bus=3,100'
+ */
+
+#define CONFIG_RAM_SIZE_IN_MB			256
+#define CONFIG_CMEM_DRIVER_AVAILABLE
+#define CONFIG_ALLOW_DRIVER_PHY_MEMORY_OVERLAP
+
+#define PHY_MEM_HIGH_ALLOCATE_IN_MB		6	
+
+#if (CONFIG_RAM_SIZE_IN_MB == 128)
+
+	#if defined(CONFIG_CMEM_DRIVER_AVAILABLE)
+		#define PHY_MEM_END		0x862FFFFF	// start address is 0x8570_0000  @ 12M
+	#else
+		#define PHY_MEM_END		0x87FFFFFF
+	#endif
+	
+#elif (CONFIG_RAM_SIZE_IN_MB == 256)
+
+	#if defined(CONFIG_CMEM_DRIVER_AVAILABLE)
+		#define PHY_MEM_END		0x862FFFFF	// start address is 0x8570_0000  @ 12M
+	#else
+		#define PHY_MEM_END		0x8FFFFFFF
+	#endif
+
+#endif
+#define PHY_MEM_START				(PHY_MEM_END - ((PHY_MEM_HIGH_ALLOCATE_IN_MB * 1024 * 1024)-1))
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Driver related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define STILL_IMAGE_CAPTURE_FRAME_NUMBER	3
+#define CONFIG_USE_TI_RESIZER			DISABLE
+#define CONFIG_ISP_DATA_LINE_SHIFT		DISABLE
+#define CONFIG_ISP_SLV0_DISCARD_COUNT		0
+#define CONFIG_SENS_MCLK			0
+#undef CONFIG_CTRL_FRAME_RATE_FRM_SENSOR
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Sensor related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_USE_OV3640_SENSOR
+#define CONFIG_OV3640_DEFAULT_FLIP		DISABLE	
+#define CONFIG_OV3640_DEFAULT_MIRROR		DISABLE
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Flash related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_USE_LM3553_FLASH
+/*
+ * FIXME:
+ * 	When Flash lumination value is set more than 40 then board re-boots at snap mode.
+ */
+#define CONIFG_LM3553_FLASH_MAX_LUM_VALUE		40
+
+
+
diff -Naur linux-org/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/Makefile linux-ths/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/Makefile
--- linux-org/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/Makefile	2011-07-30 15:02:20.000000000 +0200
@@ -0,0 +1,13 @@
+v4l2_driver-objs	:=	init_module.o isp.o omap_hwr_base.o 				\
+				ov3640/sens_ov3640.o  v4l2_driver_base.o                  \
+				omap_camera_interface.o omap_v4l2_fops_base.o  			\
+				isp.o omap_v4l2_ioctl_fops.o i2c.o				\
+				lm3553/lm3553_flash.o exit_module.o					\
+				resource/src/error.o resource/src/kernel/phy_mem.o
+
+obj-m			+=v4l2_driver.o
+
+omap:
+	make -C $(KERNEL_PATH) M=$(PWD) ARCH=arm CROSS_COMPILE=$(CROSS_COMPILE) modules
+clean:
+	make -C $(KERNEL_PATH) M=$(PWD) ARCH=arm CROSS_COMPILE=$(CROSS_COMPILE) clean
diff -Naur linux-org/drivers/media/video/ecam32/exit_module.c linux-ths/drivers/media/video/ecam32/exit_module.c
--- linux-org/drivers/media/video/ecam32/exit_module.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/exit_module.c	2011-10-20 15:50:52.000000000 +0200
@@ -0,0 +1,238 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * Include Header file
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	all_clk_disable	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT all_clk_disable(cam_data *cam)
+{
+	if(!(IS_ERR(cam->cam_mclk)))
+	{
+		clk_disable(cam->cam_mclk);
+	}
+
+	if(!(IS_ERR(cam->cam_ick)))
+	{
+		clk_disable(cam->cam_ick);
+	}
+
+	if(!(IS_ERR(cam->cam_dpll4)))
+	{
+		clk_disable(cam->cam_dpll4);
+	}
+	cam->clk_enable	= DISABLE;
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	all_clk_unregister
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT all_clk_unregister(cam_data *cam)
+{
+	if(!(IS_ERR(cam->cam_ick)))
+	{
+		clk_put(cam->cam_ick);
+	}
+
+	if(!(IS_ERR(cam->cam_mclk)))
+	{
+		clk_put(cam->cam_mclk);
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	free_all_irq
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT free_all_irq(cam_data *cam)
+{
+	free_irq(cam->irq,cam);
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	isp_remove
+ *  Parameter1	:	struct platform_device *pdev
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+INT32 isp_remove(struct platform_device *pdev)
+{
+
+	FNRESLT ret_val;
+	cam_data *cam;
+/*
+ * register the camera base pointer
+ */
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	if(cam->cam_sensor.exit)
+	{
+		ret_val	= cam->cam_sensor.exit(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+
+	if(cam->cam_flash.exit)
+	{
+		ret_val	= cam->cam_flash.exit(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+
+	ret_val	= disable_isp_irq0(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+		
+	}
+
+	ret_val	= free_all_irq(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+		
+	}
+
+	ret_val	= all_clk_disable(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= all_clk_unregister(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= exit_omap_hwr(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	video_unregister_device(cam->video_dev);
+//	video_device_release(cam->video_dev);
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE_00
+ *  Name	:	omap_v4l2_camera_driver_exit
+ *  Parameter1	:	INT0
+ *  Returns	:	INT0
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+static void __exit omap_v4l2_camera_driver_exit(void)
+{
+	FNRESLT ret_val;
+	cam_data *cam;
+
+/*
+ * TODO:
+ * 	Release the hardware resource properly
+ */
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to get the camera base address\n");
+		return ;		
+	}
+
+	platform_driver_unregister(&cam->omap3isp_driver);
+
+	printk(KERN_INFO MODULE_NAME ":unregistering v4l2 camera driver\n");
+
+	cam->video_dev	= NULL;
+	v4l2_base_struct(&cam,MAKE_ADDRESS_INVALID);
+
+	return ;
+}
+module_exit(omap_v4l2_camera_driver_exit);
diff -Naur linux-org/drivers/media/video/ecam32/fn_protype.h linux-ths/drivers/media/video/ecam32/fn_protype.h
--- linux-org/drivers/media/video/ecam32/fn_protype.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/fn_protype.h	2011-10-21 15:56:42.000000000 +0200
@@ -0,0 +1,151 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * init_moudle.c
+ */
+FNRESLT all_clk_enable(cam_data *cam);
+/*
+ * isp.c
+ */
+irqreturn_t omap34xx_isp_isr(INT32 irq,PINT0 _isp);
+FNRESLT init_cam_isp_ccdc(cam_data *cam);
+FNRESLT exit_cam_isp_ccdc(cam_data *cam);
+FNRESLT isp_set_xclk(cam_data *cam,UINT32 xclk, UINT8 xclksel, UPINT32 current_xclk);
+FNRESLT isp_reset(cam_data *cam);
+FNRESLT isp_configure(cam_data *cam);
+FNRESLT enable_ccdc(cam_data *cam);
+FNRESLT isp_prg_sdram_addr(cam_data *cam);
+FNRESLT program_dummy_isp_sdram_addr(cam_data *cam);
+FNRESLT disable_ccdc(cam_data *cam);
+
+FNRESLT enable_isp_irq0(cam_data *cam);
+FNRESLT disable_isp_irq0(cam_data *cam);
+
+
+
+/*
+ * v4l2_driver_base.c
+ */
+FNRESLT v4l2_base_struct(cam_data **cam,UINT8 option);
+FNRESLT init_v4l2_base_struct(cam_data *cam);
+
+/*
+ * sens_ov3640.c
+ */
+FNRESLT ov3640_exit(cam_data *cam);
+FNRESLT sensor_driver_init(cam_data *cam);
+FNRESLT ov3640_write_reg(UINT16 reg_address,UINT8 reg_data);
+FNRESLT ov3640_limit_pclk_max_limit(cam_data *cam);
+FNRESLT ov3640_read_reg(UINT16 reg_address,UPINT8 reg_data);
+
+/*
+ * sens_ov5642.c
+ */
+FNRESLT ov5642_write_reg(UINT16 reg_address,UINT8 reg_data);
+FNRESLT ov5642_read_reg(UINT16 reg_address,UPINT8 reg_data);
+FNRESLT ov5642_flip_mirror_logic(cam_data *cam,UINT32 logic);
+
+/*
+ * sens_ov10630.c
+ */
+FNRESLT ov10630_write_reg(UINT16 reg_address,UINT8 reg_data);
+FNRESLT ov10630_read_reg(UINT16 reg_address,UPINT8 reg_data);
+
+/*
+ * sens_ov10633.c
+ */
+FNRESLT ov10633_write_reg(UINT16 reg_address,UINT8 reg_data);
+FNRESLT ov10633_read_reg(UINT16 reg_address,UPINT8 reg_data);
+
+/*
+ * lm355 flash support.c
+ */
+FNRESLT lm3553_exit(cam_data *cam);
+
+/*
+ * omap_hwr_base.c
+ */
+FNRESLT init_omap_hwr(cam_data *cam);
+FNRESLT exit_omap_hwr(cam_data *cam);
+
+/*
+ * omap_camera_interface.c
+ */
+
+FNRESLT init_cam_interface(cam_data *cam);
+FNRESLT exit_cam_interface(cam_data *cam);
+
+/*
+ * omap_v4l2_fops_base.c
+ */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	INT32 omap_v4l2_open(struct file *file);
+	INT32 omap_v4l2_close(struct file *file);
+	LINT32 omap_v4l2_ioctl(struct file *file,UINT32 cmd,ULINT32 arg);
+	LINT32 omap_v4l2_do_ioctl(struct file *file,UINT32 ioctlnr,PINT0 arg);
+
+#else
+	INT32 omap_v4l2_open(struct inode *inode,struct file *file);
+	INT32 omap_v4l2_close(struct inode *inode,struct file *file);
+	LINT32 omap_v4l2_ioctl( struct inode *inode, struct file *file,UINT32 cmd,ULINT32 arg);
+	LINT32 omap_v4l2_do_ioctl(struct inode *inode, struct file *file,UINT32 ioctlnr,PINT0 arg);
+#endif
+INT32 omap_v4l2_read(struct file *file, INT8 *buf, size_t count, loff_t * ppos);
+INT32 omap_mmap(struct file *file, struct vm_area_struct *vma);
+
+/*
+ * gendral
+ */
+
+FNRESLT register_sensor_bus(cam_data *cam);
+
+/*
+ * omap_v4l2_ioctl_fops.c
+ */
+FNRESLT omap_v4l2_capability(cam_data *cam,struct v4l2_capability *cap);
+FNRESLT omap_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f);
+FNRESLT omap_v4l2_g_fmt(cam_data *cam, struct v4l2_format *f);
+FNRESLT omap_v4l2_ctrl(cam_data *cam);
+
+FNRESLT omap_v4l2_req_buf(cam_data *cam,struct v4l2_requestbuffers *req);
+FNRESLT omap_v4l2_query_buf(cam_data *cam,struct v4l2_buffer *buf);
+FNRESLT omap_v4l2_queue_buf(cam_data *cam,struct v4l2_buffer *buf);
+FNRESLT omap_v4l2_dqueue_buf(cam_data *cam,struct v4l2_buffer *buf);
+FNRESLT omap_v4l2_stream_on(cam_data *cam,INT32 *type);
+FNRESLT omap_v4l2_stream_off(cam_data *cam,INT32 *type);
+FNRESLT omap_v4l2_enum_fmt(cam_data *cam,struct v4l2_fmtdesc *fmt);
+
+/*
+ * exit_module.c
+ */
+INT32 isp_remove(struct platform_device *pdev);
+FNRESLT all_clk_disable(cam_data *cam);
diff -Naur linux-org/drivers/media/video/ecam32/i2c.c linux-ths/drivers/media/video/ecam32/i2c.c
--- linux-org/drivers/media/video/ecam32/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/i2c.c	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,32 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+
diff -Naur linux-org/drivers/media/video/ecam32/i2c.h linux-ths/drivers/media/video/ecam32/i2c.h
--- linux-org/drivers/media/video/ecam32/i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/i2c.h	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,33 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+#define	I2C_IDBR_MODE			0x01
+#define I2C_FLAG_READ			0x01
+
diff -Naur linux-org/drivers/media/video/ecam32/inc_header.h linux-ths/drivers/media/video/ecam32/inc_header.h
--- linux-org/drivers/media/video/ecam32/inc_header.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/inc_header.h	2012-07-09 16:45:09.000000000 +0200
@@ -0,0 +1,121 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :        VER 3.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.1   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ * 3.0       Flash support added  
+ *==========================================================================================================
+ */
+/*
+ * include configuration code for selecting sensor and flash driver code
+ */
+#include "auto_conf.h"
+
+
+/*
+ * Define the Include header file Macro
+ */
+#define MODULE_NAME	"V4l2 driver module"
+
+#define CONFIG_DRIVER
+#define USE_KERNEL_THREAD
+#define KERNEL_ARM_OMAP
+#define KERNEL_ARM_OMAP3530
+#define USE_KERNEL_MEMORY_MANAGE
+#define CONFIG_KERNEL_ERR_INCLUDED
+
+#include "resource/include/Headerfile.h"
+
+/*
+ * driver specific header files
+ */
+
+#include <media/v4l2-dev.h>
+#include <mach/gpio.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+
+#ifndef gpio_get_value
+#define gpio_get_value    __gpio_get_value
+#endif
+
+#ifndef gpio_set_value
+#define gpio_set_value  __gpio_set_value
+#endif
+
+#ifndef gpio_cansleep     
+#define gpio_cansleep     __gpio_cansleep
+#endif
+
+#endif
+
+#include <media/v4l2-ioctl.h>
+
+/*
+ * Include module specific code here
+ */
+#include "omap_camera_interface.h"
+#include "isp.h"
+#include "v4l2_driver_base.h"
+#include "omap_v4l2.h"
+#include "i2c.h"
+
+
+/*
+ * include the sensor file
+ */
+#if defined (CONFIG_USE_OV5642_SENSOR)
+	#include "ov5642/sens_ov5642.h"
+#elif defined (CONFIG_USE_OV3640_SENSOR)
+	#include "ov3640/sens_ov3640.h"
+#elif defined (CONFIG_USE_OV10630_SENSOR)
+	#include "ov10630/sens_ov10630.h"
+#elif defined (CONFIG_USE_OV10633_SENSOR)
+	#include "ov10633/sens_ov10633.h"
+#else
+	#warning "Sensor related driver file not selected"
+#endif
+
+/*
+ * include Flash related header file
+ */
+
+#if defined(CONFIG_USE_LM3553_FLASH)
+	#include "lm3553/lm3553_flash.h"
+#elif defined(CONFIG_USE_STCF03_FLASH)
+	#include "stcf03/stcf03_flash.h"
+#else
+	#warning "Flash related driver file not selected"
+#endif
+
+/*
+ * Tracking maintenance 
+ */
+#include "svn_revision.h"
+/*
+ * Include function protype here
+ */
+
+#include "fn_protype.h"
diff -Naur linux-org/drivers/media/video/ecam32/init_module.c linux-ths/drivers/media/video/ecam32/init_module.c
--- linux-org/drivers/media/video/ecam32/init_module.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/init_module.c	2011-10-24 13:48:42.000000000 +0200
@@ -0,0 +1,541 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/*
+ * Global variables
+ */
+
+static INT32 video_nr = -1;
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	init_plat_res
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_plat_res(cam_data *cam)
+{
+/*
+ * Allocate the memory region in the isp
+ */
+
+	if(cam->pdev == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+		
+	cam->mem = platform_get_resource(cam->pdev, IORESOURCE_MEM, 0);
+	if (!cam->mem)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * FIXME :
+ * 	Unable to request the memory region
+ */
+#if 0
+	if (!request_mem_region(cam->mem->start, MAP_ISP_REGION,cam->pdev->name))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+#endif
+	/* map the region */
+	cam->isp = (isp_reg_bit_access*)ioremap_nocache(cam->mem->start,MAP_ISP_REGION);
+	if (cam->isp	== NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	init_plat_irq
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_plat_irq(cam_data *cam)
+{
+#if (CONFIG_USE_TI_RESIZER == DISABLE)
+	cam->irq	= platform_get_irq(cam->pdev, 0);
+	if (cam->irq <= 0)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+#endif
+	cam->irq	= INT_34XX_CAM_IRQ;
+	if (request_irq(cam->irq, omap34xx_isp_isr, IRQF_SHARED,
+				"e-cam camera isp",cam))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	init_hwr_clock
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_hwr_clock(cam_data *cam)
+{
+	struct device_driver camera_drv =	\
+	{
+		.name = "camera"
+	};
+
+	struct device camera_dev = 		\
+	{
+		.driver = &camera_drv,
+	};
+	
+	cam->cam_ick = clk_get(&camera_dev, "cam_ick");
+	if (IS_ERR(cam->cam_ick))
+	{
+//		ret_err = PTR_ERR(isp_obj.cam_ick);
+		TRACE_ERR_AND_RET(FAIL);		
+
+	}
+	cam->cam_mclk = clk_get(&camera_dev, "cam_mclk");
+	if (IS_ERR(cam->cam_mclk))
+	{
+//		ret_err = PTR_ERR(cam->cam_mclk);
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	cam->cam_dpll4 = clk_get(&camera_dev, "dpll4_m4x2_ck");
+	if (IS_ERR(cam->cam_dpll4))
+	{
+//		ret_err = PTR_ERR(cam->cam_dpll4);
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	all_clk_enable
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT all_clk_enable(cam_data *cam)
+{
+	INT32 ret_err = DISABLE;
+
+	if(cam->clk_enable	== DISABLE)
+	{
+		cam->clk_enable	= ENABLE;
+	}else
+	{
+		return SUCCESS;
+	}
+	
+	ret_err = clk_enable(cam->cam_mclk);
+	if(ret_err)
+	{
+		goto err;
+	}
+
+	ret_err = clk_enable(cam->cam_ick);
+	if(ret_err)
+	{
+		clk_disable(cam->cam_mclk);
+		goto err;
+	}
+
+	ret_err = clk_enable(cam->cam_dpll4);
+	if(ret_err)
+	{
+		clk_disable(cam->cam_ick);
+		clk_disable(cam->cam_mclk);
+		goto err;
+	}
+	return SUCCESS;
+
+	err:
+	{
+		cam->clk_enable	= DISABLE;
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	init_cam_struct
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_cam_struct(cam_data *cam)
+{
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	
+	cam->capture.v2f.fmt.pix.width		= SENS_DEFAULT_WIDTH;
+	cam->capture.v2f.fmt.pix.height		= SENS_DEFAULT_HEIGHT;
+	cam->capture.v2f.type			= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	cam->capture.v2f.fmt.pix.pixelformat	= V4L2_PIX_FMT_UYVY;
+
+/*
+ * init S_PARM type
+ */
+	cam->capture.s_parm.type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+/*
+ * init the wait queue
+ */
+
+	init_waitqueue_head(&cam->still.dma_frame_complete_still);
+	init_waitqueue_head(&cam->capture.capture_frame_complete);	
+	
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	isp_probe_late_init
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT isp_probe_late_init(cam_data *cam)
+{
+	FNRESLT ret_val;
+	INT32 ret;
+
+/*
+ * initialize the camera structre
+ */
+
+	ret_val	= init_v4l2_base_struct(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to initialize camera device\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * Get the platform resource
+ */
+#if (CONFIG_USE_TI_RESIZER == DISABLE)
+	ret_val	= init_plat_res(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+#endif
+	ret_val	= init_plat_irq(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+/*
+ * TODO: initialize the hardware 
+ *
+ */
+/*
+ * initialize the camera structure
+ */
+	ret_val	= init_cam_struct(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+/*
+ * Configure the camera interface lines
+ */
+
+	ret_val	= init_hwr_clock(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	ret_val	= all_clk_enable(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	ret_val	= init_omap_hwr(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to initialize omap hardware device\n");
+		TRACE_ERR_AND_RET(ret_val);
+	}
+/*
+ * 	initialize the sensor 
+ */
+
+	ret_val	= register_sensor_bus(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	if(cam->cam_sensor.init)
+	{
+		ret_val	= cam->cam_sensor.init(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			return ret_val;
+		}
+	}
+
+/*
+ * register the flash driver
+ */
+	ret_val	= register_flash_driver(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+
+	if(cam->cam_flash.init)
+	{
+		ret_val	= cam->cam_flash.init(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			return ret_val;
+		}
+	}
+/*
+ * register the video device
+ */
+	ret	= video_register_device(cam->video_dev, VFL_TYPE_GRABBER, video_nr);
+	if (ret	== FAIL)
+	{
+		video_device_release(cam->video_dev);
+		cam->video_dev	= NULL;
+
+		v4l2_base_struct(&cam,MAKE_ADDRESS_INVALID);
+		printk(KERN_ERR "video_register_device failed\n");
+		TRACE_ERR_AND_RET(ret_val);
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	isp_probe
+ *  Parameter1	:	struct platform_device *pdev
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+static INT32 isp_probe(struct platform_device *pdev)
+{
+
+	FNRESLT ret_val;
+	cam_data *cam;
+/*
+ * register the camera base pointer
+ */
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	cam->pdev	= pdev;
+	
+/*
+ * register the driver content into platform
+ */
+	platform_set_drvdata(pdev, cam);
+
+/*
+ * Have a device structure copy in the driver
+ */
+	cam->dev = &pdev->dev;
+
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	cam_driver_init
+ *  Parameter1	:	INT0
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+static __init INT32 cam_driver_init(INT0)
+{
+#if (CONFIG_USE_TI_RESIZER == DISABLE)
+	INT32 plat_ret;
+#endif
+	FNRESLT ret_val;
+
+	cam_data *cam	= NULL;
+/*
+ * Print the Tracking information of application
+ */
+
+	printk(KERN_INFO "-------------------------------------------------\n");
+	printk(KERN_INFO "PRODUCT_NAME       : %s\n", PRODUCT_NAME);
+	printk(KERN_INFO "SVN_REVISION       : %s\n", SVN_REVISION);
+	printk(KERN_INFO "SVN_DATE           : %s\n", SVN_DATE);
+	printk(KERN_INFO "SVN_TIME           : %s\n", SVN_TIME);
+	printk(KERN_INFO "Driver Module info : "MODULE_NAME"\n");
+	printk(KERN_INFO "Build Time stamp   : "__TIMESTAMP__"\n");
+	printk(KERN_INFO "-------------------------------------------------\n");
+
+	if ((cam = kmalloc(sizeof(cam_data), GFP_KERNEL)) == NULL)
+	{
+		printk(KERN_ERR "Failed to allocate memory to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * Clear the memory 
+ */
+	memset(cam, 0, sizeof(cam_data));
+
+	ret_val	= v4l2_base_struct(&cam,SET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * init the reserved memory for camera 
+ */
+
+	ret_val	= init_phy_mem();
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+#if (CONFIG_USE_TI_RESIZER == DISABLE)
+	cam->omap3isp_driver.probe		= isp_probe;
+	cam->omap3isp_driver.remove		= isp_remove;
+	cam->omap3isp_driver.driver.name	= "omap3isp";
+
+	plat_ret = platform_driver_register(&cam->omap3isp_driver);
+	if (plat_ret)
+	{
+		TRACE_ERR_AND_RET(plat_ret);
+	}
+#endif
+	ret_val	= isp_probe_late_init(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+	return SUCCESS;
+
+	exit:
+	{
+		platform_driver_unregister(&cam->omap3isp_driver);
+		
+		ret_val	= v4l2_base_struct(&cam,MAKE_ADDRESS_INVALID);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			printk(KERN_ERR "Failed to register the camera device\n");
+			TRACE_ERR_AND_RET(FAIL);
+		}
+		TRACE_ERR_AND_RET(FAIL);
+	}
+}
+
+module_init(cam_driver_init);
+
+module_param(video_nr, int, 0444);
+MODULE_AUTHOR("e-consystems india pvt. lmt");
+MODULE_DESCRIPTION("V4L2 capture driver for omap based cameras");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("video");
diff -Naur linux-org/drivers/media/video/ecam32/isp.c linux-ths/drivers/media/video/ecam32/isp.c
--- linux-org/drivers/media/video/ecam32/isp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/isp.c	2011-10-24 13:48:42.000000000 +0200
@@ -0,0 +1,765 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+static UINT32 cam_mclk	= CONFIG_SENS_MCLK;
+module_param(cam_mclk,int, 0444);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	ISR ROUTINE				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	omap34xx_isp_isr	
+ *  Parameter1	:	INT32 irq
+ *  Parameter2	:	PINT0 _cam	- private data number
+ *  Returns	:	irq - handled information
+ *  Description	: 	interrupt service routine 
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+irqreturn_t omap34xx_isp_isr(INT32 irq,PINT0 _cam)
+{
+	cam_data *cam	= _cam;
+	FNRESLT ret_val;
+	static UINT32 using_dummy_buffer	= DISABLE;
+	static UINT32 fill_dummy_buf		= DISABLE;
+	union
+	{
+		UVINT32 ISP_IRQ0ENABLE;
+		struct isp_irq bit;
+	}isp_status;
+	isp_status.ISP_IRQ0ENABLE				= (cam->isp->isp_main.reg.isp_irq0status.ISP_IRQ0STATUS & CCDC_VD0);
+	cam->isp->isp_main.reg.isp_irq0status.ISP_IRQ0STATUS	= isp_status.ISP_IRQ0ENABLE;
+	cam->isp->isp_main.reg.isp_irq1status.ISP_IRQ1STATUS	= cam->isp->isp_main.reg.isp_irq1status.ISP_IRQ1STATUS;
+
+	if(isp_status.bit.ccdc_vd0_irq			== ENABLED)
+	{
+		if(cam->task.bit.still	== ENABLE)
+		{
+			cam->still.frame_count++;
+			if(cam->still.frame_count >= STILL_IMAGE_CAPTURE_FRAME_NUMBER)
+			{
+				wake_up_interruptible(&cam->still.dma_frame_complete_still);
+				cam->still.wait_queue_head_t_dma_frame_complete_still	= ENABLE;
+			}
+		}else if(cam->task.bit.capture	== ENABLE)
+		{
+
+#if (!defined(CONFIG_CTRL_FRAME_RATE_FRM_SENSOR))
+			static UINT32 frame_skip_count;
+			static UINT32 capture_frame_rate;
+			static UINT32 current_fps	= SENS_MAX_FPS;
+			static struct timeval timestamp_rec;
+			struct timeval timestamp;
+			static INT32 frame_rate_denominator = SENS_MAX_FPS;
+
+			if(frame_rate_denominator != cam->capture.s_parm.parm.capture.timeperframe.denominator)
+			{
+				frame_skip_count	= DISABLE;
+				frame_rate_denominator	= cam->capture.s_parm.parm.capture.timeperframe.denominator;
+			}
+
+			do_gettimeofday(&timestamp);
+
+			if(timestamp_rec.tv_sec	== DISABLE && timestamp_rec.tv_usec == DISABLE)
+			{
+				do_gettimeofday(&timestamp_rec);
+			}
+
+			if (timestamp.tv_sec > timestamp_rec.tv_sec)
+			{
+				current_fps		= capture_frame_rate;
+				capture_frame_rate	= DISABLE;
+				timestamp_rec		= timestamp;
+			}
+			capture_frame_rate++;
+#endif 
+
+ /*
+ * Process the completed buffer
+  */
+			if(using_dummy_buffer	== DISABLE)
+			{
+				if(cam->capture.processing)
+				{
+					__link_node(cam->capture.filled, cam->capture.processing);
+					do_gettimeofday(&cam->capture.processing->buffer.timestamp);
+					cam->capture.processing->buffer.flags	|= V4L2_BUF_FLAG_DONE;
+					cam->capture.valid_buf++;
+				}
+			}
+
+			if(fill_dummy_buf	== DISABLE)
+			{
+
+/*
+ * Process the next processing buffer
+ */
+				cam->capture.processing			= cam->capture.Need_to_be_filled;
+				if(cam->capture.processing)
+				{
+					__update_base(cam->capture.Need_to_be_filled);
+					using_dummy_buffer	= DISABLE;
+				}else
+				{
+					if((cam->capture.filled) && (cam->capture.filled->next))
+					{
+						cam->capture.processing		= cam->capture.filled;
+					}
+
+					if(cam->capture.processing)
+					{
+						__update_base(cam->capture.filled);
+						cam->capture.valid_buf--;
+						using_dummy_buffer	= DISABLE;
+					}else
+					{
+						cam->capture.processing	= &cam->capture.frame[cam->capture.available_buf-1];
+						using_dummy_buffer	= ENABLE;
+					}
+				}
+			}else
+			{
+				cam->capture.processing	= &cam->capture.frame[cam->capture.available_buf-1];
+				using_dummy_buffer	= ENABLE;
+			}
+
+			if(cam->capture.valid_buf)
+			{
+				wake_up_interruptible(&cam->capture.capture_frame_complete);
+			}
+
+			cam->capture.processing->next		= NULL;
+			ret_val	= isp_prg_sdram_addr(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				
+			}
+
+#ifndef CONFIG_CTRL_FRAME_RATE_FRM_SENSOR
+			frame_skip_count	+= ((1000000*cam->capture.s_parm.parm.capture.			\
+							timeperframe.denominator)/current_fps);
+			if(frame_skip_count > 1000000)
+			{
+				frame_skip_count -=1000000;
+				fill_dummy_buf	= DISABLE;
+			}else
+			{
+				fill_dummy_buf	= ENABLE;
+			}
+#endif
+		}
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	isp_set_xclk
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	xclk		- Needed mclk given to sensor
+ *  Parameter3	:	xclksel		- Needed xclk mode in the omap
+*  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	Sets the mclk provided to the sensor
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT isp_set_xclk(cam_data *cam,UINT32 xclk, UINT8 xclksel, UPINT32 current_xclk)
+{
+#define CM_CAM_MCLK_HZ			216000000
+#define ISPTCTRL_CTRL_DIV_BYPASS	0x1F
+
+	UINT32 divisor;
+	UINT32 currentxclk;
+
+	if (xclk >= CM_CAM_MCLK_HZ)
+	{
+		divisor = ISPTCTRL_CTRL_DIV_BYPASS;
+		currentxclk = CM_CAM_MCLK_HZ;
+	}else if (xclk >= 2)
+	{
+		divisor = CM_CAM_MCLK_HZ / xclk;
+		if (divisor >= ISPTCTRL_CTRL_DIV_BYPASS)
+			divisor = ISPTCTRL_CTRL_DIV_BYPASS - 1;
+		currentxclk = CM_CAM_MCLK_HZ / divisor;
+	}else
+	{
+		divisor = xclk;
+		currentxclk = 0;
+	}
+
+	switch (xclksel)
+	{
+		case 0:
+		{
+			cam->isp->isp_main.reg.tctrl_ctrl.bit.diva	= divisor;
+		}break;
+
+		case 1:
+		{
+			cam->isp->isp_main.reg.tctrl_ctrl.bit.divb	= divisor;
+		}break;
+
+		default:
+		{
+			return FAIL;
+		}
+	}
+
+	if(current_xclk)
+	{
+		*current_xclk	= currentxclk;
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	mclk_to_sensor
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	option		- command to perform 
+ *  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Function callback exposed to other layers.
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT mclk_to_sensor(cam_data *cam,UINT32 xclk,UPINT32 clk_set)
+{
+	FNRESLT ret_val;
+
+	ret_val	= isp_set_xclk(cam,xclk,0,clk_set);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	omap_isp_base_struct
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	option		- command to perform 
+ *  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	maintain the base pointer of pin configuration.
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT omap_isp_base_struct(cam_data *cam,UINT8 option)
+{
+
+/*
+ * SET_ADDRESS 
+ * GET_ADDRESS 
+ * MAKE_ADDRESS_INVALID
+ * CREATE_ADDRESS
+ */
+	static UINT32 g_cam_isp;
+
+	if(cam == NULL)
+	{
+		TRACE_ERROR(MEMORY_NOT_VALID);	
+		return MEMORY_NOT_VALID;
+	}
+	switch(option)
+	{
+		case SET_ADDRESS:
+		{
+			g_cam_isp =(UINT32)cam->isp;			
+		}break;
+		case GET_ADDRESS:
+		{
+			cam->isp	= (isp_reg_bit_access*)g_cam_isp;
+		}break;
+		case MAKE_ADDRESS_INVALID:
+		{
+			if(cam->isp	== NULL)
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+			iounmap(cam->isp);
+			cam->isp	= NULL;
+			g_cam_isp	= DISABLE;
+		}break;
+		case CREATE_ADDRESS:
+		{
+			cam->isp	= ioremap(BADDR_ISP,MAP_ISP_REGION);
+			if(cam->isp	== NULL)
+			{
+				printk(KERN_ERR "Unable to remap the isp registers\n");
+				TRACE_ERR_AND_RET(FAIL);
+			}			
+		}break;
+		default:
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	reset the isp and ccdc interface
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT isp_reset(cam_data *cam)
+{
+	UINT32 time_out	= 10;
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	
+/*
+ * Clear all the status register and irq registers
+ */
+	cam->isp->isp_main.reg.isp_irq0enable.ISP_IRQ0ENABLE	= DISABLE;
+	cam->isp->isp_main.reg.isp_irq0status.ISP_IRQ0STATUS	= cam->isp->isp_main.reg.isp_irq0status.ISP_IRQ0STATUS;
+
+	cam->isp->isp_main.reg.isp_irq1enable.ISP_IRQ1ENABLE	= DISABLE;
+	cam->isp->isp_main.reg.isp_irq1status.ISP_IRQ1STATUS	= cam->isp->isp_main.reg.isp_irq1status.ISP_IRQ1STATUS;
+
+/*
+ * Enable the soft reset
+ */
+	cam->isp->isp_main.reg.isp_sysconfig.bit.soft_reset	= ENABLE;
+
+/*
+ * Check the reset is done 
+ */
+	for(;time_out--;)
+	{
+		if(cam->isp->isp_main.reg.isp_sysstatus.bit.reset_done	== ENABLE)
+		{
+			break;
+		}
+		mdelay(100);
+	}
+
+	cam->isp->isp_main.reg.isp_sysconfig.bit.midle_mode	= ENABLE;
+	cam->isp->isp_main.reg.isp_sysconfig.bit.auto_idle	= DISABLE;
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	program the ccdc sdram address.
+ *  Comments	:  	In the programed sdram address the new frame from the sensor be filled.
+ ************************************************************************************************************/
+
+FNRESLT program_dummy_isp_sdram_addr(cam_data *cam)
+ {
+	if(cam->capture.available_buf	<= DISABLE)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	cam->isp->isp_ccdc.reg.CCDC_SDR_ADDR	= cam->capture.frame[cam->capture.available_buf].buffer.m.offset;
+ 	return SUCCESS;
+ }
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	program the ccdc sdram address.
+ *  Comments	:  	In the programed sdram address the new frame from the sensor be filled.
+ ************************************************************************************************************/
+FNRESLT isp_prg_sdram_addr(cam_data *cam)
+{
+	static struct timeval timestamp;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+	struct tm timecode;
+#endif
+
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * Take the current time stamp
+ */
+	do_gettimeofday(&timestamp);
+
+	if(cam->task.bit.still	== ENABLE)
+	{
+		cam->isp->isp_ccdc.reg.CCDC_SDR_ADDR	= cam->still.phy_addr;
+	}else if(cam->task.bit.capture == ENABLE)
+	{
+		cam->isp->isp_ccdc.reg.CCDC_SDR_ADDR			= cam->capture.processing->buffer.m.offset;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+		time_to_tm(cam->capture.processing->buffer.timestamp.tv_sec,DISABLE, &timecode);
+		cam->capture.processing->buffer.timecode.seconds	= timecode.tm_sec;
+		cam->capture.processing->buffer.timecode.minutes	= timecode.tm_min;
+		cam->capture.processing->buffer.timecode.hours		= timecode.tm_hour;
+#if (SENS_MAX_FPS <= 30)
+		cam->capture.processing->buffer.timecode.type		= V4L2_TC_TYPE_30FPS;
+#else
+		cam->capture.processing->buffer.timecode.type		= V4L2_TC_TYPE_60FPS;
+#endif
+		cam->capture.processing->buffer.timecode.flags		= V4L2_TC_FLAG_COLORFRAME;
+		cam->capture.processing->buffer.timecode.frames		= cam->capture.buffer_sequence;
+#endif
+		cam->capture.processing->buffer.sequence		= cam->capture.buffer_sequence;
+
+	}
+	
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	disable the irq0 interrupt
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT disable_isp_irq0(cam_data *cam)
+{
+	cam->isp->isp_main.reg.isp_irq0enable.ISP_IRQ0ENABLE	= DISABLE;
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Configure the isp side
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT isp_configure(cam_data *cam)
+{
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	cam->isp->isp_main.reg.isp_ctrl.ISP_CTRL		= DISABLE;
+	cam->isp->isp_main.reg.isp_ctrl.bit.ccdc_clk_en		= ENABLE;
+	cam->isp->isp_main.reg.isp_ctrl.bit.par_bridge		= ISPM_ISP_CTRL_MEM_ORDER_MSB_LSB;
+
+	cam->isp->isp_main.reg.isp_ctrl.bit.par_ser_clk_sel	= DISABLE;
+	cam->isp->isp_main.reg.isp_ctrl.bit.ccdc_ram_en		= ENABLE;
+	cam->isp->isp_main.reg.isp_ctrl.bit.sync_detect		= ISPM_ISP_CTRL_SYNC_DETECT_VS_FALL;
+#if (CONFIG_ISP_DATA_LINE_SHIFT == ENABLE)
+	cam->isp->isp_main.reg.isp_ctrl.bit.shift		= ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_0_CAM13_0;
+#elif (CONFIG_ISP_DATA_LINE_SHIFT == DISABLE)
+	cam->isp->isp_main.reg.isp_ctrl.bit.shift		= ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_2_CAM11_0;
+#endif
+
+//	cam->isp->isp_main.reg.isp_ctrl.bit.sbl_wr1_ram_en	= DISABLE;
+//	cam->isp->isp_main.reg.isp_ctrl.bit.sbl_rd_ram_en	= DISABLE;
+
+	/*
+	 * Pixel clock polority
+	 * 1. From camera side Falling edge the data will be put into the bus.
+	 *    In omap side at raising edge the data will be taken form sampling.
+	 */
+
+	cam->isp->isp_main.reg.isp_ctrl.bit.par_clk_pol		= DISABLE;	
+	cam->isp->isp_ccdc.reg.ccdc_hsize_off.bit.lnofst	= cam->capture.v2f.fmt.pix.bytesperline;
+
+	cam->isp->isp_ccdc.reg.ccdc_cfg.bit.vdlc		= ENABLE;
+
+	cam->isp->isp_ccdc.reg.ccdc_syn_mode.bit.vdhden		= ENABLE;
+	cam->isp->isp_ccdc.reg.ccdc_syn_mode.bit.datsiz		= 0x0;
+	cam->isp->isp_ccdc.reg.ccdc_syn_mode.bit.inpmod		= ISP_CCDC_CCDC_SYNC_MODE_IMPMOD_YUV_16BIT;
+	cam->isp->isp_ccdc.reg.ccdc_syn_mode.bit.wen		= ENABLE;
+	cam->isp->isp_ccdc.reg.ccdc_syn_mode.bit.exwen		= DISABLE;
+	cam->isp->isp_ccdc.reg.ccdc_horz_info.bit.nph		= cam->capture.v2f.fmt.pix.width -1;
+
+	cam->isp->isp_ccdc.reg.ccdc_vert_start.bit.slv0		= CONFIG_ISP_SLV0_DISCARD_COUNT;
+	cam->isp->isp_ccdc.reg.ccdc_vert_start.bit.slv1		= DISABLE;
+
+	switch(cam->cam_sensor.fmt.fmt.pix.pixelformat)	
+	{
+		case V4L2_PIX_FMT_YUV420:
+		{
+			cam->isp->isp_ccdc.reg.ccdc_vert_lines.bit.nlv	= (cam->capture.v2f.fmt.pix.height*3/4) -1;
+		}break;
+
+		default:
+		{
+			cam->isp->isp_ccdc.reg.ccdc_vert_lines.bit.nlv	= cam->capture.v2f.fmt.pix.height -1;
+		}break;
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	After configuration isp irq0 is enabled
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT enable_isp_irq0(cam_data *cam)
+{
+	cam->isp->isp_ccdc.reg.ccdc_vdint.bit.vdint0		= cam->capture.v2f.fmt.pix.height -1;
+	cam->isp->isp_main.reg.isp_irq0enable.ISP_IRQ0ENABLE	= DISABLE;
+	cam->isp->isp_main.reg.isp_irq0enable.bit.ccdc_vd0_irq	= ENABLE;
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	enable the ccdc unit.
+ *  Comments	:  	Once ccdc unit is enabled it will copy the frame into programmed sdram address.
+ ************************************************************************************************************/
+FNRESLT enable_ccdc(cam_data *cam)
+{
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	cam->isp->isp_ccdc.reg.ccdc_pcr.bit.enable		= ENABLE;
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	disable_ccdc
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	disable ccdc unit
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT disable_ccdc(cam_data *cam)
+{
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	cam->isp->isp_ccdc.reg.ccdc_pcr.bit.enable		= DISABLE;
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	init_cam_isp_ccdc
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+  *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	init routine of ccdc done here
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_cam_isp_ccdc(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * Validate the input
+ */
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+/*
+ * map the physical address of isp registers 
+ * to kernel virtual address
+ */
+#if (CONFIG_USE_TI_RESIZER == ENABLE)
+	ret_val	= omap_isp_base_struct(cam,CREATE_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to map the camera isp registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+#endif
+	ret_val	= omap_isp_base_struct(cam,SET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to map the camera isp registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	if(cam_mclk)
+	{
+		ret_val	= isp_set_xclk(cam,cam_mclk,0,NULL);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);		
+		}
+	}
+/*
+ * Call back function for changing the mclk is assinged here
+ */
+	cam->modify_mclk_to_sensor	= mclk_to_sensor;
+	
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	exit_cam_isp_ccdc
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Perform cleanup routine done here
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT exit_cam_isp_ccdc(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * Validate the input
+ */
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * unmap the kernel space and 
+ * Perform cleaning of structure
+ */
+
+	ret_val	= omap_isp_base_struct(cam,MAKE_ADDRESS_INVALID);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to unmap the camera isp registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/isp.h linux-ths/drivers/media/video/ecam32/isp.h
--- linux-org/drivers/media/video/ecam32/isp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/isp.h	2011-10-24 13:48:42.000000000 +0200
@@ -0,0 +1,716 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * Values for the isp structure members
+ */
+#define ISPM_ISP_CTRL_MEM_ORDER_MSB_LSB			3
+#define ISPM_ISP_CTRL_MEM_ORDER_LSB_MSB			2
+
+#define ISP_CCDC_CCDC_SYNC_MODE_IMPMOD_RAW_DATA		0
+#define ISP_CCDC_CCDC_SYNC_MODE_IMPMOD_YUV_16BIT	1
+
+#define ISPM_ISP_CTRL_SYNC_DETECT_HS_FALL		0
+#define ISPM_ISP_CTRL_SYNC_DETECT_HS_RISE		1
+#define ISPM_ISP_CTRL_SYNC_DETECT_VS_FALL		2
+#define ISPM_ISP_CTRL_SYNC_DETECT_VS_RISE		3
+
+#define ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_0_CAM13_0	0
+#define ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_2_CAM11_0	1
+#define ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_4_CAM9_0	2
+#define ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_6_CAM7_0	3
+
+/*
+ * structure definition
+ */
+
+#define MAP_ISP_REGION			0x2000	
+#define BADDR_ISP			0x480BC000
+#define BADDR_ISP_CBUFF			0x480BC100
+#define BADDR_ISP_CCDC			0x480BC600
+#define BADDR_ISP_HIST			0x480BCA00
+#define BADDR_ISP_H3A			0x480BCC00
+#define BADDR_ISP_PREVIEW		0x480BCE00
+#define BADDR_ISP_RESIZER		0x480BD000
+#define BADDR_ISP_SBL			0x480BD200
+#define BADDR_ISP_SBL_END		0x480BD300
+
+enum isp_irqevents
+{
+	CSIA = 0x01,
+	CSIB = 0x10,
+	CCDC_VD0 = 0x100,
+	CCDC_VD1 = 0x200,
+	CCDC_VD2 = 0x400,
+	CCDC_ERR = 0x800,
+	H3A_AWB_DONE = 0x2000,
+	H3A_AF_DONE = 0x1000,
+	HIST_DONE = 0x10000,
+	PREV_DONE = 0x100000,
+	LSC_DONE = 0x20000,
+	LSC_PRE_COMP = 0x40000,
+	LSC_PRE_ERR = 0x80000,
+	RESZ_DONE = 0x1000000,
+	SBL_OVF = 0x2000000,
+	MMU_ERR = 0x10000000,
+	OCP_ERR = 0x20000000,
+	HS_VS = 0x80000000
+};
+
+struct isp_irq
+{
+	UVINT32 reserved0				:8;
+	UVINT32 ccdc_vd0_irq				:1;
+	UVINT32 ccdc_vd1_irq				:1;
+	UVINT32 ccdc_vd2_irq				:1;
+	UVINT32 ccdc_err_irq				:1;
+	UVINT32 h3a_af_done_irq				:1;
+	UVINT32 h3a_awb_done_irq			:1;
+	UVINT32 reserved1				:2;
+	UVINT32 hist_done_irq				:1;
+	UVINT32 ccdc_lsc_done				:1;
+	UVINT32 ccdc_lsc_prefectch_completed		:1;
+	UVINT32 ccdc_lsc_prefectch_error		:1;
+	UVINT32 prv_done_irq				:1;
+	UVINT32 cbuff_irq				:1;
+	UVINT32 reserved2				:2;
+	UVINT32 rsz_done_irq				:1;
+	UVINT32 ovf_irq					:1;
+	UVINT32 reserved3				:2;
+	UVINT32 mmu_err_irq				:1;
+	UVINT32 ocp_err_irq				:1;
+	UVINT32 sec_err_irq				:1;
+	UVINT32 hs_vs_irq				:1;					
+};
+
+/*
+ * Module Name Base address (hex) Size
+ * ISP            0x480B C000          512 bytes
+ * ISP_CBUFF      0x480B C100          256 bytes
+ * ISP_CCDC       0x480B C600          512 bytes
+ * ISP_HIST       0x480B CA00          512 bytes
+ * ISP_H3A        0x480B CC00          512 bytes
+ * ISP_PREVIEW    0x480B CE00          512 bytes
+ * ISP_RESIZER    0x480B D000          512 bytes
+ * ISP_SBL        0x480B D200          512 bytes
+ */
+
+typedef struct __isp_reg_bit_access
+{
+	union
+	{
+/*
+ * 
+ * Register Name       Type Register   Address     Physical     Section
+ *                          Width      Offset     Address
+ *                          (Bits)
+ * ISP_SYSCONFIG        RW     32    0x0000 0004 0x480B C004 Section 1.6.2.1
+ * ISP_SYSSTATUS         R     32    0x0000 0008 0x480B C008 Section 1.6.2.2
+ * ISP_IRQ0ENABLE       RW     32    0x0000 000C 0x480B C00C Section 1.6.2.3
+ * ISP_IRQ0STATUS       RW     32    0x0000 0010 0x480B C010 Section 1.6.2.4
+ * ISP_IRQ1ENABLE       RW     32    0x0000 0014 0x480B C014 Section 1.6.2.5
+ * ISP_IRQ1STATUS       RW     32    0x0000 0018 0x480B C018 Section 1.6.2.6
+ * TCTRL_GRESET_LENGTH  RW     32    0x0000 0030 0x480B C030 Section 1.6.2.7
+ * TCTRL_PSTRB_REPLAY   RW     32    0x0000 0034 0x480B C034 Section 1.6.2.8
+ * ISP_CTRL             RW     32    0x0000 0040 0x480B C040 Section 1.6.2.9
+ * ISP_SECURE           RW     32    0x0000 0044 0x480B C044 Section 1.6.2.10
+ * TCTRL_CTRL           RW     32    0x0000 0050 0x480B C050 Section 1.6.2.11
+ * TCTRL_FRAME          RW     32    0x0000 0054 0x480B C054 Section 1.6.2.12
+ * TCTRL_PSTRB_DELAY    RW     32    0x0000 0058 0x480B C058 Section 1.6.2.13
+ * TCTRL_STRB_DELAY     RW     32    0x0000 005C 0x480B C05C Section 1.6.2.14
+ * TCTRL_SHUT_DELAY     RW     32    0x0000 0060 0x480B C060 Section 1.6.2.15
+ * TCTRL_PSTRB_LENGTH   RW     32    0x0000 0064 0x480B C064 Section 1.6.2.16
+ * TCTRL_STRB_LENGTH    RW     32    0x0000 0068 0x480B C068 Section 1.6.2.17
+ * TCTRL_SHUT_LENGTH    RW     32    0x0000 006C 0x480B C06C Section 1.6.2.18
+ */
+
+		UVINT32 ISP[((BADDR_ISP_CBUFF-BADDR_ISP)/4)];
+		struct
+		{	
+			UVINT32 ISP_VER;			// 0x0000 0000
+			union
+			{
+				UVINT32 ISP_SYSCONFIG;		// 0x0000 0004
+				struct
+				{
+					UVINT32 auto_idle		:1;
+					UVINT32 soft_reset		:1;
+					UVINT32 reserved1		:10;
+					UVINT32 midle_mode		:2;
+				}bit;
+			}isp_sysconfig;
+			
+			union
+			{
+				UVINT32 ISP_SYSSTATUS;		// 0x0000 0008
+				struct
+				{
+					UVINT32 reset_done		:1;
+				}bit;
+			}isp_sysstatus;
+			
+			union
+			{
+				UVINT32 ISP_IRQ0ENABLE;		// 0x0000 000C
+				struct isp_irq bit;
+			}isp_irq0enable;
+
+			union 
+			{
+				UVINT32 ISP_IRQ0STATUS;		// 0x0000 0010
+				struct isp_irq bit;
+
+			}isp_irq0status;
+
+			union
+			{
+				UVINT32 ISP_IRQ1ENABLE;		// 0x0000 0014
+				struct isp_irq bit;
+
+			}isp_irq1enable;
+
+			union
+			{
+				UVINT32 ISP_IRQ1STATUS;		// 0x0000 0018
+				struct isp_irq bit;
+			}isp_irq1status;
+
+			UVINT32 RESERVED0[5];
+			union
+			{
+				UVINT32 TCTRL_GRESET_LENGTH;	// 0x0000 0030
+				struct
+				{
+					UVINT32 length			:24;
+					UVINT32 reserved		:8;
+				}bit;
+			}tctrl_greset_length;
+			UVINT32 TCTRL_PSTRB_REPLAY;		// 0x0000 0034
+			UVINT32 RESERVED1[2];
+			
+			union
+			{
+				UVINT32 ISP_CTRL;		// 0x0000 0040
+				struct
+				{
+					UVINT32 par_ser_clk_sel		:2;
+					UVINT32 par_bridge		:2;
+					UVINT32 par_clk_pol		:1;
+					UVINT32 reserved0		:1;
+					UVINT32 shift			:2;
+					UVINT32 ccdc_clk_en		:1;
+					UVINT32 cbuff_autogating	:1;
+					UVINT32 h3a_clk_en		:1;
+					UVINT32 hist_clk_en		:1;
+					UVINT32 prv_clk_en		:1;
+					UVINT32 rsz_clk_en		:1;
+					UVINT32 sync_detect		:2;
+					UVINT32 ccdc_ram_en		:1;
+					UVINT32 prev_ram_en		:1;
+					UVINT32 sbl_rd_ram_en		:1;
+					UVINT32 sbl_wr1_ram_en		:1;
+					UVINT32 sbl_wr0_ram_en		:1;
+					UVINT32 sbl_autoidle		:1;
+					UVINT32 reserved1		:6;
+					UVINT32 sbl_shared_rportb	:1;
+					UVINT32 ccdc_wen_pol		:1;
+					UVINT32 jpeg_flush		:1;
+					UVINT32 flush			:1;
+				}bit;
+			}isp_ctrl;
+
+			UVINT32 ISP_SECURE;			// 0x0000 0044
+			UVINT32 RESERVED2[2];
+			union
+			{			
+				UVINT32 TCTRL_CTRL;		// 0x0000 0050
+				struct
+				{
+					UVINT32 diva			:5;
+					UVINT32 divb			:5;
+					UVINT32 divc			:9;
+					UVINT32 reserved0		:2;
+					UVINT32 shuten			:1;
+					UVINT32 pstrben			:1;
+					UVINT32 strben			:1;
+					UVINT32 shutpol			:1;
+					UVINT32 reserved1		:1;
+					UVINT32 strbpstrbpol		:1;
+					UVINT32 insel			:2;
+					UVINT32 greseten		:1;
+					UVINT32 gresetpol		:1;
+					UVINT32 gresetdir		:1;
+				}bit;
+			}tctrl_ctrl;
+			
+			UVINT32 TCTRL_FRAME;			// 0x0000 0054
+			UVINT32 TCTRL_PSTRB_DELAY;		// 0x0000 0058
+			UVINT32 TCTRL_STRB_DELAY;		// 0x0000 005C
+			UVINT32 TCTRL_SHUT_DELAY;		// 0x0000 0060
+			UVINT32 TCTRL_PSTRB_LENGTH;		// 0x0000 0064
+			UVINT32 TCTRL_STRB_LENGTH;		// 0x0000 0068
+			UVINT32 TCTRL_SHUT_LENGTH;		// 0x0000 006C
+		}reg;
+	}isp_main;
+
+	union
+	{
+/*
+ * CBUFF_SYSCONFIG       RW 32      0x0000 0010             0x480B C110             Section 1.6.3.1
+ * CBUFF_SYSSTATUS        R 32      0x0000 0014             0x480B C114             Section 1.6.3.2
+ * CBUFF_IRQSTATUS       RW 32      0x0000 0018             0x480B C118             Section 1.6.3.3
+ * CBUFF_IRQENABLE       RW 32      0x0000 001C             0x480B C11C             Section 1.6.3.4
+ * CBUFFx_CTRL (1)       RW 32      0x0000 0020 + (0x4 * x) 0x480B C120 + (0x4 * x) Section 1.6.3.5
+ * CBUFFx_STATUS (1)      R 32      0x0000 0030 + (0x4 * x) 0x480B C130 + (0x4 * x) Section 1.6.3.6
+ * CBUFFx_START (1)      RW 32      0x0000 0040 + (0x4 * x) 0x480B C140 + (0x4 * x) Section 1.6.3.7
+ * CBUFFx_END (1)        RW 32      0x0000 0050 + (0x4 * x) 0x480B C150 + (0x4 * x) Section 1.6.3.8
+ * CBUFFx_WINDOWSIZE (1) RW 32      0x0000 0060 + (0x4 * x) 0x480B C160 + (0x4 * x) Section 1.6.3.9
+ * CBUFFx_THRESHOLD (1)  RW 32      0x0000 0070 + (0x4 * x) 0x480B C170 + (0x4 * x) Section 1.6.3.10
+ */
+
+		UVINT32 ISP_CBUFF[((BADDR_ISP_CCDC-BADDR_ISP_CBUFF)/4)];
+	}isp_cbuff;
+	
+	union
+	{
+/*
+ * Register Name        Type Register        Address                 Physical            Section
+ *                          Width           Offset                 Address
+ *                          (Bits)
+ * CCDC_PID               R     32         0x0000 0000             0x480B C600        Section 1.6.4.1
+ * CCDC_PCR              RW     32         0x0000 0004             0x480B C604        Section 1.6.4.2
+ * CCDC_SYN_MODE         RW     32         0x0000 0008             0x480B C608        Section 1.6.4.3
+ * CCDC_HD_VD_WID        RW     32         0x0000 000C             0x480B C60C        Section 1.6.4.4
+ * CCDC_PIX_LINES        RW     32         0x0000 0010             0x480B C610        Section 1.6.4.5
+ * CCDC_HORZ_INFO        RW     32         0x0000 0014             0x480B C614        Section 1.6.4.6
+ * CCDC_VERT_START       RW     32         0x0000 0018             0x480B C618        Section 1.6.4.7
+ * CCDC_VERT_LINES       RW     32         0x0000 001C             0x480B C61C        Section 1.6.4.8
+ * CCDC_CULLING          RW     32         0x0000 0020             0x480B C620        Section 1.6.4.9
+ * CCDC_HSIZE_OFF        RW     32         0x0000 0024             0x480B C624        Section 1.6.4.10
+ * CCDC_SDOFST           RW     32         0x0000 0028             0x480B C628        Section 1.6.4.11
+ * CCDC_SDR_ADDR         RW     32         0x0000 002C             0x480B C62C        Section 1.6.4.12
+ * CCDC_CLAMP            RW     32         0x0000 0030             0x480B C630        Section 1.6.4.13
+ * CCDC_DCSUB            RW     32         0x0000 0034             0x480B C634        Section 1.6.4.14
+ * CCDC_COLPTN           RW     32         0x0000 0038             0x480B C638        Section 1.6.4.15
+ * CCDC_BLKCMP           RW     32         0x0000 003C             0x480B C63C        Section 1.6.4.16
+ * CCDC_FPC              RW     32         0x0000 0040             0x480B C640        Section 1.6.4.17
+ * CCDC_FPC_ADDR         RW     32         0x0000 0044             0x480B C644        Section 1.6.4.18
+ * CCDC_VDINT            RW     32         0x0000 0048             0x480B C648        Section 1.6.4.19
+ * CCDC_ALAW             RW     32         0x0000 004C             0x480B C64C        Section 1.6.4.20
+ * CCDC_REC656IF         RW     32         0x0000 0050             0x480B C650        Section 1.6.4.21
+ * CCDC_CFG              RW     32         0x0000 0054             0x480B C654        Section 1.6.4.22
+ * CCDC_FMTCFG           RW     32         0x0000 0058             0x480B C658        Section 1.6.4.23
+ * CCDC_FMT_HORZ         RW     32         0x0000 005C             0x480B C65C        Section 1.6.4.24
+ * CCDC_FMT_VERT         RW     32         0x0000 0060             0x480B C660        Section 1.6.4.25
+ * CCDC_FMT_ADDRx(1)     RW     32         0x0000 0064 + (0x4 * x) 0x480B C664 + (0x4 * x) Section 1.6.4.26
+ * CCDC_PRGEVEN0         RW     32         0x0000 0084             0x480B C684        Section 1.6.4.27
+ * CCDC_PRGEVEN1         RW     32         0x0000 0088             0x480B C688        Section 1.6.4.28
+ * CCDC_PRGODD0          RW     32         0x0000 008C             0x480B C68C        Section 1.6.4.29
+ * CCDC_PRGODD1          RW     32         0x0000 0090             0x480B C690        Section 1.6.4.30
+ * CCDC_VP_OUT           RW     32         0x0000 0094             0x480B C694        Section 1.6.4.31
+ * CCDC_LSC_CONFIG       RW     32         0x0000 0098             0x480B C698        Section 1.6.4.32
+ * CCDC_LSC_INITIAL      RW     32         0x0000 009C             0x480B C69C        Section 1.6.4.33
+ * CCDC_LSC_TABLE_BASE   RW     32         0x0000 00A0             0x480B C6A0        Section 1.6.4.34
+ * CCDC_LSC_TABLE_OFFSET RW     32         0x0000 00A4             0x480B C6A4        Section 1.6.4.35
+ */
+
+		UVINT32 ISP_CCDC[((BADDR_ISP_HIST-BADDR_ISP_CCDC)/4)];
+		struct
+		{
+			UVINT32 CCDC_PID;			// 0x0000 0000
+			union
+			{
+				UVINT32 CCDC_PCR;		// 0x0000 0004
+				struct
+				{
+					UVINT32 enable				:1;
+					UVINT32 busy				:1;
+				}bit;
+			}ccdc_pcr;
+
+			union
+			{
+				UVINT32 CCDC_SYN_MODE;		// 0x0000 0008
+				struct
+				{
+					UVINT32 vdhdout				:1;
+					UVINT32 fldout				:1;
+					UVINT32 vdpol				:1;
+					UVINT32 hdpol				:1;
+					UVINT32 fldpol				:1;
+					UVINT32 exwen				:1;
+					UVINT32 datapol				:1;
+					UVINT32 fldmode				:1;
+					UVINT32 datsiz				:3;
+					UVINT32 pack8				:1;
+					UVINT32 inpmod				:2;
+					UVINT32 lpf				:1;
+					UVINT32 fldstat				:1;
+					UVINT32 vdhden				:1;
+					UVINT32 wen				:1;
+					UVINT32 vp2str				:1;
+					UVINT32 sdr2rsz				:1;
+				}bit;
+			}ccdc_syn_mode;
+
+			UVINT32 CCDC_HD_VD_WID;			// 0x0000 000C
+			UVINT32 CCDC_PIX_LINES;			// 0x0000 0010
+
+			union
+			{
+				UVINT32 CCDC_HORZ_INFO;		// 0x0000 0014
+				struct
+				{
+					UVINT32 nph				:15;
+					UVINT32 reserved0			:1;
+					UVINT32 sph				:15;
+					UVINT32 reserved1			:1;
+				}bit;
+			}ccdc_horz_info;
+
+			union
+			{
+				UVINT32 CCDC_VERT_START;	// 0x0000 0018
+				struct
+				{
+					UVINT32 slv1				:15;
+					UVINT32 reserved0			:1;
+					UVINT32 slv0				:15;
+					UVINT32 reserved1			:1;
+				}bit;
+			}ccdc_vert_start;
+		
+			union
+			{
+				UVINT32 CCDC_VERT_LINES;	// 0x0000 001C
+				struct
+				{
+					UVINT32 nlv				:15;
+				}bit;
+			}ccdc_vert_lines;
+			UVINT32 CCDC_CULLING;			// 0x0000 0020
+
+			union
+			{
+				UVINT32 CCDC_HSIZE_OFF;		// 0x0000 0024
+				struct
+				{
+					UVINT32 lnofst				:16;
+				}bit;
+			}ccdc_hsize_off;
+
+			UVINT32 CCDC_SDOFST;			// 0x0000 0028
+			UVINT32 CCDC_SDR_ADDR;			// 0x0000 002C
+			UVINT32 CCDC_CLAMP;			// 0x0000 0030
+			UVINT32 CCDC_DCSUB;			// 0x0000 0034
+			UVINT32 CCDC_COLPTN;			// 0x0000 0038
+			UVINT32 CCDC_BLKCMP;			// 0x0000 003C
+			UVINT32 CCDC_FPC;			// 0x0000 0040
+			UVINT32 CCDC_FPC_ADDR;			// 0x0000 0044
+
+			union
+			{
+				UVINT32 CCDC_VDINT;		// 0x0000 0048
+				struct
+				{
+					UVINT32 vdint1				:15;
+					UVINT32 reserved0			:1;
+					UVINT32 vdint0				:15;
+				}bit;
+			}ccdc_vdint;
+
+			UVINT32 CCDC_ALAW;			// 0x0000 004C
+			UVINT32 CCDC_REC656IF;			// 0x0000 0050
+
+			union
+			{
+				UVINT32 CCDC_CFG;		// 0x0000 0054 
+				struct
+				{
+					UVINT32 reserved0			:5;
+					UVINT32 bw565				:1;
+					UVINT32 fidmd				:2;
+					UVINT32 wenlog				:1;
+					UVINT32 reserved1			:2;
+					UVINT32 y8pos				:1;
+					UVINT32 bswb				:1;
+					UVINT32 msbinvi				:1;
+					UVINT32 reserved2			:1;
+					UVINT32 vdlc				:1;
+				}bit;
+			}ccdc_cfg;
+
+			UVINT32 CCDC_FMTCFG;			// 0x0000 0058
+			UVINT32 CCDC_FMT_HORZ;			// 0x0000 005C
+			UVINT32 CCDC_FMT_VERT;			// 0x0000 0060
+			UVINT32 CCDC_FMT_ADDRx;			// 0x0000 0064
+			UVINT32 CCDC_PRGEVEN0;			// 0x0000 0084
+			UVINT32 CCDC_PRGEVEN1;			// 0x0000 0088
+			UVINT32 CCDC_PRGODD0;			// 0x0000 008C
+			UVINT32 CCDC_PRGODD1;			// 0x0000 0090
+			UVINT32 CCDC_VP_OUT;			// 0x0000 0094 
+			UVINT32 CCDC_LSC_CONFIG;		// 0x0000 0098
+			UVINT32 CCDC_LSC_INITIAL;		// 0x0000 009C
+			UVINT32 CCDC_LSC_TABLE_BASE;		// 0x0000 00A0
+			UVINT32 CCDC_LSC_TABLE_OFFSET;		// 0x0000 00A4 
+		}reg;
+	}isp_ccdc;
+	
+	union
+	{
+/*
+ * Register Name     Type Register        Address                 Physical            Section
+ *                        Width           Offset                 Address
+ *                       (Bits)
+ * HIST_PID            R     32         0x0000 0000             0x480B CA00        Section 1.6.5.1
+ * HIST_PCR           RW     32         0x0000 0004             0x480B CA04        Section 1.6.5.2
+ * HIST_CNT           RW     32         0x0000 0008             0x480B CA08        Section 1.6.5.3
+ * HIST_WB_GAIN       RW     32         0x0000 000C             0x480B CA0C         Section 1.6.5.4
+ * HIST_Rn_HORZ (1)   RW     32         0x0000 0010 + (0x8 * x) 0x480B CA10 + (0x8 * x) Section 1.6.5.5
+ * HIST_Rn_VERT (1)   RW     32         0x0000 0014 + (0x8 * x) 0x480B CA14 + (0x8 * x) Section 1.6.5.6
+ * HIST_ADDR          RW     32         0x0000 0030             0x480B CA30        Section 1.6.5.7
+ * HIST_DATA          RW     32         0x0000 0034             0x480B CA34        Section 1.6.5.8
+ * HIST_RADD          RW     32         0x0000 0038             0x480B CA38        Section 1.6.5.9
+ * HIST_RADD_OFF      RW     32         0x0000 003C             0x480B CA3C         Section 1.6.5.10
+ * HIST_H_V_INFO      RW     32         0x0000 0040             0x480B CA40        Section 1.6.5.11
+ */
+
+		UVINT32 ISP_HIST[((BADDR_ISP_H3A-BADDR_ISP_HIST)/4)];
+		
+	}isp_hist;
+
+	union
+	{
+/*
+ * Register Name  Type Register   Address     Physical     Section
+ *                    Width      Offset     Address
+ *                   (Bits)
+ * H3A_PID          R     32    0x0000 0000 0x480B CC00 Section 1.6.6.1
+ * H3A_PCR         RW     32    0x0000 0004 0x480B CC04 Section 1.6.6.2
+ * H3A_AFPAX1      RW     32    0x0000 0008 0x480B CC08 Section 1.6.6.3
+ * H3A_AFPAX2      RW     32    0x0000 000C 0x480B CC0C Section 1.6.6.4
+ * H3A_AFPAXSTART  RW     32    0x0000 0010 0x480B CC10 Section 1.6.6.5
+ * H3A_AFIIRSH     RW     32    0x0000 0014 0x480B CC14 Section 1.6.6.6
+ * H3A_AFBUFST     RW     32    0x0000 0018 0x480B CC18 Section 1.6.6.7
+ * H3A_AFCOEF010   RW     32    0x0000 001C 0x480B CC1C Section 1.6.6.8
+ * H3A_AFCOEF032   RW     32    0x0000 0020 0x480B CC20 Section 1.6.6.9
+ * H3A_AFCOEF054   RW     32    0x0000 0024 0x480B CC24 Section 1.6.6.10
+ * H3A_AFCOEF076   RW     32    0x0000 0028 0x480B CC28 Section 1.6.6.11
+ * H3A_AFCOEF098   RW     32    0x0000 002C 0x480B CC2C Section 1.6.6.12
+ * H3A_AFCOEF0010  RW     32    0x0000 0030 0x480B CC30 Section 1.6.6.13
+ * H3A_AFCOEF110   RW     32    0x0000 0034 0x480B CC34 Section 1.6.6.14
+ * H3A_AFCOEF132   RW     32    0x0000 0038 0x480B CC38 Section 1.6.6.15
+ * H3A_AFCOEF154   RW     32    0x0000 003C 0x480B CC3C Section 1.6.6.16
+ * H3A_AFCOEF176   RW     32    0x0000 0040 0x480B CC40 Section 1.6.6.17
+ * H3A_AFCOEF198   RW     32    0x0000 0044 0x480B CC44 Section 1.6.6.18
+ * H3A_AFCOEF1010  RW     32    0x0000 0048 0x480B CC48 Section 1.6.6.19
+ * H3A_AEWWIN1     RW     32    0x0000 004C 0x480B CC4C Section 1.6.6.20
+ * H3A_AEWINSTART  RW     32    0x0000 0050 0x480B CC50 Section 1.6.6.21
+ * H3A_AEWINBLK    RW     32    0x0000 0054 0x480B CC54 Section 1.6.6.22
+ * H3A_AEWSUBWIN   RW     32    0x0000 0058 0x480B CC58 Section 1.6.6.23
+ * H3A_AEWBUFST    RW     32    0x0000 005C 0x480B CC5C Section 1.6.6.24
+ */
+
+		UVINT32 ISP_H3A[((BADDR_ISP_PREVIEW-BADDR_ISP_H3A)/4)];
+		
+	}isp_h3a;
+
+	union
+	{
+/*
+ * Register Name  Type Register   Address     Physical     Section
+ *                   Width      Offset     Address
+ *                  (Bits)
+ * PRV_PID           R 32      0x0000 0000             0x480B CE00        Section 1.6.7.1
+ * PRV_PCR          RW 32      0x0000 0004             0x480B CE04        Section 1.6.7.2
+ * PRV_HORZ_INFO    RW 32      0x0000 0008             0x480B CE08        Section 1.6.7.3
+ * PRV_VERT_INFO    RW 32      0x0000 000C             0x480B CE0C        Section 1.6.7.4
+ * PRV_RSDR_ADDR    RW 32      0x0000 0010             0x480B CE10        Section 1.6.7.5
+ * PRV_RADR_OFFSET  RW 32      0x0000 0014             0x480B CE14        Section 1.6.7.6
+ * PRV_DSDR_ADDR    RW 32      0x0000 0018             0x480B CE18        Section 1.6.7.7
+ * PRV_DRKF_OFFSET  RW 32      0x0000 001C             0x480B CE1C        Section 1.6.7.8
+ * PRV_WSDR_ADDR    RW 32      0x0000 0020             0x480B CE20        Section 1.6.7.9
+ * PRV_WADD_OFFSET  RW 32      0x0000 0024             0x480B CE24        Section 1.6.7.10
+ * PRV_AVE          RW 32      0x0000 0028             0x480B CE28        Section 1.6.7.11
+ * PRV_HMED         RW 32      0x0000 002C             0x480B CE2C        Section 1.6.7.12
+ * PRV_NF           RW 32      0x0000 0030             0x480B CE30        Section 1.6.7.13
+ * PRV_WB_DGAIN     RW 32      0x0000 0034             0x480B CE34        Section 1.6.7.14
+ * PRV_WBGAIN       RW 32      0x0000 0038             0x480B CE38        Section 1.6.7.15
+ * PRV_WBSEL        RW 32      0x0000 003C             0x480B CE3C        Section 1.6.7.16
+ * PRV_CFA          RW 32      0x0000 0040             0x480B CE40        Section 1.6.7.17
+ * PRV_BLKADJOFF    RW 32      0x0000 0044             0x480B CE44        Section 1.6.7.18
+ * PRV_RGB_MAT1     RW 32      0x0000 0048             0x480B CE48        Section 1.6.7.19
+ * PRV_RGB_MAT2     RW 32      0x0000 004C             0x480B CE4C        Section 1.6.7.20
+ * PRV_RGB_MAT3     RW 32      0x0000 0050             0x480B CE50        Section 1.6.7.21
+ * PRV_RGB_MAT4     RW 32      0x0000 0054             0x480B CE54        Section 1.6.7.22
+ * PRV_RGB_MAT5     RW 32      0x0000 0058             0x480B CE58        Section 1.6.7.23
+ * PRV_RGB_OFF1     RW 32      0x0000 005C             0x480B CE5C        Section 1.6.7.24
+ * PRV_RGB_OFF2     RW 32      0x0000 0060             0x480B CE60        Section 1.6.7.25
+ * PRV_CSC0         RW 32      0x0000 0064             0x480B CE64        Section 1.6.7.26
+ * PRV_CSC1         RW 32      0x0000 0068             0x480B CE68        Section 1.6.7.27
+ * PRV_CSC2         RW 32      0x0000 006C             0x480B CE6C        Section 1.6.7.28
+ * PRV_CSC_OFFSET   RW 32      0x0000 0070             0x480B CE70        Section 1.6.7.29
+ * PRV_CNT_BRT      RW 32      0x0000 0074             0x480B CE74        Section 1.6.7.30
+ * PRV_CSUP         RW 32      0x0000 0078             0x480B CE78        Section 1.6.7.31
+ * PRV_SETUP_YC     RW 32      0x0000 007C             0x480B CE7C        Section 1.6.7.32
+ * PRV_SET_TBL_ADDR RW 32      0x0000 0080             0x480B CE80        Section 1.6.7.33
+ * PRV_SET_TBL_DATA RW 32      0x0000 0084             0x480B CE84        Section 1.6.7.34
+ * PRV_CDC_THRx (1) RW 32      0x0000 0090 + (0x4 * x) 0x480B CE90 + (0x4 * x) Section 1.6.7.35
+ */
+
+		UVINT32 ISP_PRV[((BADDR_ISP_RESIZER-BADDR_ISP_PREVIEW)/4)];
+		
+	}isp_pview;
+
+	union
+	{
+/*
+ * Register Name  Type Register   Address     Physical     Section
+ *                   Width      Offset     Address
+ *                  (Bits)
+ * RSZ_PID         R 32 0x0000 0000 0x480B D000 Section 1.6.8.1
+ * RSZ_PCR        RW 32 0x0000 0004 0x480B D004 Section 1.6.8.2
+ * RSZ_CNT        RW 32 0x0000 0008 0x480B D008 Section 1.6.8.3
+ * RSZ_OUT_SIZE   RW 32 0x0000 000C 0x480B D00C Section 1.6.8.4
+ * RSZ_IN_START   RW 32 0x0000 0010 0x480B D010 Section 1.6.8.5
+ * RSZ_IN_SIZE    RW 32 0x0000 0014 0x480B D014 Section 1.6.8.6
+ * RSZ_SDR_INADD  RW 32 0x0000 0018 0x480B D018 Section 1.6.8.7
+ * RSZ_SDR_INOFF  RW 32 0x0000 001C 0x480B D01C Section 1.6.8.8
+ * RSZ_SDR_OUTADD RW 32 0x0000 0020 0x480B D020 Section 1.6.8.9
+ * RSZ_SDR_OUTOFF RW 32 0x0000 0024 0x480B D024 Section 1.6.8.10
+ * RSZ_HFILT10    RW 32 0x0000 0028 0x480B D028 Section 1.6.8.11
+ * RSZ_HFILT32    RW 32 0x0000 002C 0x480B D02C Section 1.6.8.12
+ * RSZ_HFILT54    RW 32 0x0000 0030 0x480B D030 Section 1.6.8.13
+ * RSZ_HFILT76    RW 32 0x0000 0034 0x480B D034 Section 1.6.8.14
+ * RSZ_HFILT98    RW 32 0x0000 0038 0x480B D038 Section 1.6.8.15
+ * RSZ_HFILT1110  RW 32 0x0000 003C 0x480B D03C Section 1.6.8.16
+ * RSZ_HFILT1312  RW 32 0x0000 0040 0x480B D040 Section 1.6.8.17
+ * RSZ_HFILT1514  RW 32 0x0000 0044 0x480B D044 Section 1.6.8.18
+ * RSZ_HFILT1716  RW 32 0x0000 0048 0x480B D048 Section 1.6.8.19
+ * RSZ_HFILT1918  RW 32 0x0000 004C 0x480B D04C Section 1.6.8.20
+ * RSZ_HFILT2120  RW 32 0x0000 0050 0x480B D050 Section 1.6.8.21
+ * RSZ_HFILT2322  RW 32 0x0000 0054 0x480B D054 Section 1.6.8.22
+ * RSZ_HFILT2524  RW 32 0x0000 0058 0x480B D058 Section 1.6.8.23
+ * RSZ_HFILT2726  RW 32 0x0000 005C 0x480B D05C Section 1.6.8.24
+ * RSZ_HFILT2928  RW 32 0x0000 0060 0x480B D060 Section 1.6.8.25
+ * RSZ_HFILT3130  RW 32 0x0000 0064 0x480B D064 Section 1.6.8.26
+ * RSZ_VFILT10    RW 32 0x0000 0068 0x480B D068 Section 1.6.8.27
+ * RSZ_VFILT32    RW 32 0x0000 006C 0x480B D06C Section 1.6.8.28
+ * RSZ_VFILT54    RW 32 0x0000 0070 0x480B D070 Section 1.6.8.29
+ * RSZ_VFILT76    RW 32 0x0000 0074 0x480B D074 Section 1.6.8.30
+ * RSZ_VFILT98    RW 32 0x0000 0078 0x480B D078 Section 1.6.8.31
+ * RSZ_VFILT1110  RW 32 0x0000 007C 0x480B D07C Section 1.6.8.32
+ * RSZ_VFILT1312  RW 32 0x0000 0080 0x480B D080 Section 1.6.8.33
+ * RSZ_VFILT1514  RW 32 0x0000 0084 0x480B D084 Section 1.6.8.34
+ * RSZ_VFILT1716  RW 32 0x0000 0088 0x480B D088 Section 1.6.8.35
+ * RSZ_VFILT1918  RW 32 0x0000 008C 0x480B D08C Section 1.6.8.36
+ * RSZ_VFILT2120  RW 32 0x0000 0090 0x480B D090 Section 1.6.8.37
+ * RSZ_VFILT2322  RW 32 0x0000 0094 0x480B D094 Section 1.6.8.38
+ * RSZ_VFILT2524  RW 32 0x0000 0098 0x480B D098 Section 1.6.8.39
+ * RSZ_VFILT2726  RW 32 0x0000 009C 0x480B D09C Section 1.6.8.40
+ * RSZ_VFILT2928  RW 32 0x0000 00A0 0x480B D0A0 Section 1.6.8.41
+ * RSZ_VFILT3130  RW 32 0x0000 00A4 0x480B D0A4 Section 1.6.8.42
+ * RSZ_YENH       RW 32 0x0000 00A8 0x480B D0A8 Section 1.6.8.43
+ */
+
+		UVINT32 ISP_RSZ[((BADDR_ISP_SBL-BADDR_ISP_RESIZER)/4)];
+		
+	}isp_rsize;
+
+	union
+	{
+
+/*
+ * Register Name  Type Register   Address     Physical     Section
+ *                   Width      Offset     Address
+ *                  (Bits)
+ * SBL_PID             R 32 0x0000 0000 0x480B D200 Section 1.6.9.1
+ * SBL_PCR            RW 32 0x0000 0004 0x480B D204 Section 1.6.9.2
+ * SBL_GLB_REG_0       R 32 0x0000 0008 0x480B D208 Section 1.6.9.3
+ * SBL_GLB_REG_1       R 32 0x0000 000C 0x480B D20C Section 1.6.9.4
+ * SBL_GLB_REG_2       R 32 0x0000 0010 0x480B D210 Section 1.6.9.5
+ * SBL_GLB_REG_3       R 32 0x0000 0014 0x480B D214 Section 1.6.9.6
+ * SBL_GLB_REG_4       R 32 0x0000 0018 0x480B D218 Section 1.6.9.7
+ * SBL_GLB_REG_5       R 32 0x0000 001C 0x480B D21C Section 1.6.9.8
+ * SBL_GLB_REG_6       R 32 0x0000 0020 0x480B D220 Section 1.6.9.9
+ * SBL_GLB_REG_7       R 32 0x0000 0024 0x480B D224 Section 1.6.9.10
+ * SBL_CCDC_WR_0       R 32 0x0000 0028 0x480B D228 Section 1.6.9.11
+ * SBL_CCDC_WR_1       R 32 0x0000 002C 0x480B D22C Section 1.6.9.12
+ * SBL_CCDC_WR_2       R 32 0x0000 0030 0x480B D230 Section 1.6.9.13
+ * SBL_CCDC_WR_3       R 32 0x0000 0034 0x480B D234 Section 1.6.9.14
+ * SBL_CCDC_FP_RD_0    R 32 0x0000 0038 0x480B D238 Section 1.6.9.15
+ * SBL_CCDC_FP_RD_1    R 32 0x0000 003C 0x480B D23C Section 1.6.9.16
+ * SBL_PRV_RD_0        R 32 0x0000 0040 0x480B D240 Section 1.6.9.17
+ * SBL_PRV_RD_1        R 32 0x0000 0044 0x480B D244 Section 1.6.9.18
+ * SBL_PRV_RD_2        R 32 0x0000 0048 0x480B D248 Section 1.6.9.19
+ * SBL_PRV_RD_3        R 32 0x0000 004C 0x480B D24C Section 1.6.9.20
+ * SBL_PRV_WR_0        R 32 0x0000 0050 0x480B D250 Section 1.6.9.21
+ * SBL_PRV_WR_1        R 32 0x0000 0054 0x480B D254 Section 1.6.9.22
+ * SBL_PRV_WR_2        R 32 0x0000 0058 0x480B D258 Section 1.6.9.23
+ * SBL_PRV_WR_3        R 32 0x0000 005C 0x480B D25C Section 1.6.9.24
+ * SBL_PRV_DK_RD_0     R 32 0x0000 0060 0x480B D260 Section 1.6.9.25
+ * SBL_PRV_DK_RD_1     R 32 0x0000 0064 0x480B D264 Section 1.6.9.26
+ * SBL_PRV_DK_RD_2     R 32 0x0000 0068 0x480B D268 Section 1.6.9.27
+ * SBL_PRV_DK_RD_3     R 32 0x0000 006C 0x480B D26C Section 1.6.9.28
+ * SBL_RSZ_RD_0        R 32 0x0000 0070 0x480B D270 Section 1.6.9.29
+ * SBL_RSZ_RD_1        R 32 0x0000 0074 0x480B D274 Section 1.6.9.30
+ * SBL_RSZ_RD_2        R 32 0x0000 0078 0x480B D278 Section 1.6.9.31
+ * SBL_RSZ_RD_3        R 32 0x0000 007C 0x480B D27C Section 1.6.9.32
+ * SBL_RSZ1_WR_0       R 32 0x0000 0080 0x480B D280 Section 1.6.9.33
+ * SBL_RSZ1_WR_1       R 32 0x0000 0084 0x480B D284 Section 1.6.9.34
+ * SBL_RSZ1_WR_2       R 32 0x0000 0088 0x480B D288 Section 1.6.9.35
+ * SBL_RSZ1_WR_3       R 32 0x0000 008C 0x480B D28C Section 1.6.9.36
+ * SBL_RSZ2_WR_0       R 32 0x0000 0090 0x480B D290 Section 1.6.9.37
+ * SBL_RSZ2_WR_1       R 32 0x0000 0094 0x480B D294 Section 1.6.9.38
+ * SBL_RSZ2_WR_2       R 32 0x0000 0098 0x480B D298 Section 1.6.9.39
+ * SBL_RSZ2_WR_3       R 32 0x0000 009C 0x480B D29C Section 1.6.9.40
+ * SBL_RSZ3_WR_0       R 32 0x0000 00A0 0x480B D2A0 Section 1.6.9.41
+ * SBL_RSZ3_WR_1       R 32 0x0000 00A4 0x480B D2A4 Section 1.6.9.42
+ * SBL_RSZ3_WR_2       R 32 0x0000 00A8 0x480B D2A8 Section 1.6.9.43
+ * SBL_RSZ3_WR_3       R 32 0x0000 00AC 0x480B D2AC Section 1.6.9.44
+ * SBL_RSZ4_WR_0       R 32 0x0000 00B0 0x480B D2B0 Section 1.6.9.45
+ * SBL_RSZ4_WR_1       R 32 0x0000 00B4 0x480B D2B4 Section 1.6.9.46
+ * SBL_RSZ4_WR_2       R 32 0x0000 00B8 0x480B D2B8 Section 1.6.9.47
+ * SBL_RSZ4_WR_3       R 32 0x0000 00BC 0x480B D2BC Section 1.6.9.48
+ * SBL_HIST_RD_0       R 32 0x0000 00C0 0x480B D2C0 Section 1.6.9.49
+ * SBL_HIST_RD_1       R 32 0x0000 00C4 0x480B D2C4 Section 1.6.9.50
+ * SBL_H3A_AF_WR_0     R 32 0x0000 00C8 0x480B D2C8 Section 1.6.9.51
+ * SBL_H3A_AF_WR_1     R 32 0x0000 00CC 0x480B D2CC Section 1.6.9.52
+ * SBL_H3A_AEAWB_WR_0  R 32 0x0000 00D0 0x480B D2D0 Section 1.6.9.53
+ * SBL_H3A_AEAWB_WR_1  R 32 0x0000 00D4 0x480B D2D4 Section 1.6.9.54
+ * SBL_SDR_REQ_EXP    RW 32 0x0000 00F8 0x480B D2F8 Section 1.6.9.55
+ */
+		UVINT32 ISP_SBL[((BADDR_ISP_SBL_END-BADDR_ISP_SBL)/4)];
+		
+	}isp_sbl;
+
+}isp_reg_bit_access;
+
diff -Naur linux-org/drivers/media/video/ecam32/KNOWN_BUGS linux-ths/drivers/media/video/ecam32/KNOWN_BUGS
--- linux-org/drivers/media/video/ecam32/KNOWN_BUGS	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/KNOWN_BUGS	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,68 @@
+					BUGS AVAILABLE
+					##############
+
+# - completed, * - Not completed
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+BUGS:
+^^^^^
+#1.  I2C arbitation lost is happening when bulk amount of registers are being dumped into the sensor.
+*1-1 Fixed by adding 100 micro second delay between each write in the i2c code.
+
+Implementation : 
+^^^^^^^^^^^^^^^^
+#1. Driver cleanup functions in the module exit code are currently not implemented.
+*2. Available IOCTLS enumerate in the driver currently not implemented.
+#3. IOCTL - CTRL not implemented
+#4. CAPTURE routine using (QBUF - DQBUF) not implemented
+#4-1. Need to test capture routine
+
+#5. Getting memory from __get_free pages producing Low memory warinig from the kernel 
+#	Need to implement e-con specific memory implementation 
+
+#6. Memory hard coded in inc_header.h which is used in phy_mem.c (This should be double checked by performing 
+#	parse the kernel boot args and get the memory free information and feed into driver).
+*6-1. Need to test work done on point 6.
+	
+#7. G_CTRL - ioctl should expose the ctrl limit to the user
+#	VIDIOC_QUERYCTRL
+#	example :
+#		Brightness means
+#		min		- -2
+#		max		- +2
+#		step size	- +1
+
+*8. poll function need to implement
+*8-1. select function need to implement
+#8-2. mmap function need to implement
+
+*9. Proper return value represents the error state must be sent from the driver.
+
+#10. Current driver will send colour format as YUYV. Need to make it as UYVY
+
+#11. Validation is needed in performing the supported colour formats available in the sensor.
+
+#12 Negotiate with the available dimention with the sensor and tell the format dimension supported by camera to user. S_FMT /G_FMT
+
+*13 Implementation of
+	crop			-	VIDIOC_CROPCAP,VIDIOC_G_CROP, VIDIOC_S_CROP
+	VIDIOC_ENUM_FMT		-	VIDIOC_ENUM_FMT,VIDIOC_ENUM_FRAMESIZES,VIDIOC_ENUM_FRAMEINTERVALS
+
+*14 Need to handle signal CTRL+C in the driver and break the capture accordingly.
+
+*15 Image Dimensions should be rounding off to nearest supported size of byte aglinment of (4) 
+
+*16 From sensor uxga frame corruoption is happening, So we fixed in the driver to exclude the problemmatic dimension.
+
+NOTE:
+Minimum ioctls needed to procced by mplayer
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Needed ioctl is 23		- VIDIOC_G_STD
+Needed ioctl is 21		- VIDIOC_G_PARM
+Needed ioctl is 25		- VIDIOC_ENUMSTD
+#Needed ioctl is 26		- VIDIOC_ENUMINPUT
+#Needed ioctl is 38		- VIDIOC_G_INPUT
+#Needed ioctl is 2		- VIDIOC_ENUM_FMT
+
+IMPLEMENTATION
+^^^^^^^^^^^^^^
+*1. Current driver is implemented in old style of v4l2 driver.
diff -Naur linux-org/drivers/media/video/ecam32/lm3553/lm3553_flash.c linux-ths/drivers/media/video/ecam32/lm3553/lm3553_flash.c
--- linux-org/drivers/media/video/ecam32/lm3553/lm3553_flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/lm3553/lm3553_flash.c	2011-08-08 13:03:04.000000000 +0200
@@ -0,0 +1,635 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ *
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+#include "../inc_header.h"
+
+/*
+ * Global Variables
+ */
+static INT32	detect_flash_sequence	= DISABLE;
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	flash_i2c_client_xfer
+ *  Parameter1	:	INT32 addr
+ *  Parameter2	:	UPINT8 reg
+ *  Parameter3	:	PINT8 buf
+ *  Parameter4	:	INT32 num
+ *  Parameter5	:	INT32 tran_flag
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT flash_i2c_client_xfer(INT32 addr, UPINT8 reg, PINT8 buf, INT32 num, INT32 tran_flag)
+{
+
+	struct i2c_msg msg[2];
+	FNRESLT ret_val;
+	INT32 ret;
+	cam_data *cam	= NULL;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);	
+	}
+
+	if(cam->cam_flash.client	== NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);	
+	}
+
+/*
+ * FIXME:
+ * 	
+ * 	I2C Write:
+ *	 	In i2c msg[0] "address part in write is success" but if we put data in msg [1] 
+ * 		that is not properly sent to device.
+ *
+ * 		so in the msg[0] part itself the data also sent here.
+ *
+ * 	I2CRead:
+ * 		But in read No problem is found and working fine
+ */
+
+	if(tran_flag & I2C_FLAG_READ)
+	{
+
+		msg[0].addr	= addr;
+		msg[0].len	= 1;
+		msg[0].buf	= reg;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		msg[1].addr	= addr;
+		msg[1].len	= num;
+		msg[1].buf	= buf;
+		msg[1].flags	= tran_flag;
+
+		if (tran_flag & I2C_FLAG_READ)
+		{
+			msg[1].flags |= I2C_M_RD;
+		}else
+		{
+			msg[1].flags &= ~I2C_M_RD;
+		}
+
+		if ((cam->cam_flash.client == NULL) || (cam->cam_flash.client->adapter == NULL))
+		{
+			printk("%s:adapter error\n", __func__);
+			return -1;
+		}
+
+		ret = i2c_transfer(cam->cam_flash.client->adapter, msg, 2);
+		if (ret >= 0)
+		{
+			/* printk("%s:i2c transfer num:%d\n", __func__, ret); */
+			return SUCCESS;
+		}
+
+	}else
+	{
+		UINT8 reg_addr_data[2];
+		
+		reg_addr_data[0] = *reg;
+		reg_addr_data[1] = *buf;
+		
+		msg[0].addr	= addr;
+		msg[0].len	= 2;
+		msg[0].buf	= reg_addr_data;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		ret = i2c_transfer(cam->cam_flash.client->adapter, msg, 1);
+		if (ret >= 0)
+		{
+			/* printk("%s:i2c transfer num:%d\n", __func__, ret); */
+			return SUCCESS;
+		}
+	}
+
+	if(detect_flash_sequence)
+	{
+		printk("%s:i2c transfer error:%d\n", __func__, ret);
+		TRACE_ERR_AND_RET(ret);
+	}else
+	{
+		return ret;
+	}
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_write
+ *  Parameter1	:	UINT8 reg
+ *  Parameter2	:	UINT8 data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_write(UINT8 reg,UINT8 data)
+{
+	if (flash_i2c_client_xfer(LM3553_SLAVE_ADDRESS,&reg,&data, 0, 0) < 0)
+	{
+		if(detect_flash_sequence)
+		{
+			printk("Flash write failed :%s: reg=%x",__func__, reg);
+			TRACE_ERR_AND_RET(FAIL);
+		}else
+		{
+			return FAIL;
+		}
+	}	
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_read
+ *  Parameter1	:	UINT8 reg
+ *  Parameter2	:	UPINT8 data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_read(UINT8 reg,UPINT8 data)
+{
+	if (flash_i2c_client_xfer(LM3553_SLAVE_ADDRESS,&reg, data, 1, 1) < 0)
+	{
+		printk("Flash write failed :%s: reg=%x",__func__, reg);
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_probe
+ *  Parameter1	:	struct i2c_client *client
+ *  Parameter2	:	const struct i2c_device_id *id
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	Configure the gpio levels for ov3640 driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+static INT32 __init lm3553_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	cam_data *cam	= NULL;
+	FNRESLT ret_val;
+
+	if (i2c_get_clientdata(client))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		goto exit;
+	}
+	
+/*
+ * 	set the client data 
+ */
+	cam->cam_flash.client =	client;
+
+	return SUCCESS;
+	exit:
+	{
+		TRACE_ERR_AND_RET(-EINVAL);
+	}	
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_remove
+ *  Parameter1	:	struct i2c_client *client
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	remove routine of ov3640 i2c driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+static INT32 __exit lm3553_remove(struct i2c_client *client)
+{
+	if (!client->adapter)
+	{
+		TRACE_ERR_AND_RET(-ENODEV);	/* our client isn't attached */
+	}
+
+	i2c_set_clientdata(client, NULL);
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_init
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+/*
+ * i2c driver init
+ */
+	static const struct i2c_device_id lm3553_id[] =			\
+	{
+		{ LM3553_DRIVER_NAME, 0 },
+		{ },
+	};
+	MODULE_DEVICE_TABLE(i2c_1, lm3553_id);
+
+FNRESLT lm3553_init(cam_data *cam)
+{
+	FNRESLT ret_val;
+	
+	cam->cam_flash.i2c.driver.name	= LM3553_DRIVER_NAME;
+	cam->cam_flash.i2c.driver.owner	= THIS_MODULE;
+	cam->cam_flash.i2c.probe	= lm3553_probe;
+	cam->cam_flash.i2c.remove	= __exit_p(lm3553_remove);
+	cam->cam_flash.i2c.id_table	= lm3553_id;
+
+	if(i2c_add_driver(&cam->cam_flash.i2c))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	if(cam->cam_flash.client	== NULL)
+	{
+		ret_val	= lm3553_exit(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+		return SUCCESS;
+	}
+/*
+ * Set the lum time value = 1400 milli seconds
+ */
+	ret_val	= lm3553_write(0xC0,0xFE);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_INFO "lm3553 flash ic not found \n");
+
+		ret_val	= lm3553_exit(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+		return SUCCESS;
+	}
+
+	detect_flash_sequence	= ENABLE;
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_exit
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_exit(cam_data *cam)
+{
+	i2c_del_driver(&cam->cam_flash.i2c);
+	memset(&cam->cam_flash,0x00,sizeof(struct _flash_driver));
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_torch_lum_ctrl
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_torch_lum_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+	static INT32 lm3553_torch_lum_ctrl_value;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= lm3553_torch_lum_ctrl_value;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 31))
+			{
+				ret_val	= lm3553_write(0xA0,((0x80)|(0x1F & cam->ctrl.value)));
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(FAIL);
+				}
+				lm3553_torch_lum_ctrl_value	= cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_TORCH_LUM;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"torch lum ctrl",strlen("torch lum ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 31;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+	return SUCCESS;
+
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_flash_lum_ctrl
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_flash_lum_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+	static INT32 lm3553_flash_lum_value;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= lm3553_flash_lum_value;
+		}break;
+
+		case SET_DATA:
+		{
+/*
+ * FIXME:
+ *  As per LM3553.pdf the maximum value for flash is 127. 
+ *  But this is currently limited to board specific dependent configuration
+ *  Due to some hardware related issue faced in specific products.
+ */
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= CONIFG_LM3553_FLASH_MAX_LUM_VALUE))
+			{
+				ret_val	= lm3553_write(0xB0,((0x80)|(0x7F & cam->ctrl.value)));
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(FAIL);
+				}
+				lm3553_flash_lum_value	= cam->ctrl.value;
+			}
+
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_FLASH_LUM;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"flash lum ctrl",strlen("flash lum ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = CONIFG_LM3553_FLASH_MAX_LUM_VALUE;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_flash
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_flash(cam_data *cam)
+{
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= cam->cam_sensor.sens_strobe_en;
+		}break;
+
+		case SET_DATA:
+		{
+/*
+ * FIXME:
+ * 	As per the LM3553 data sheet truth table the flash mode 
+ * 	works with command of 0x10 0x1B. But we are not able to get the flash,
+ * 	so we are performing shutdown mode and enable strobe signal of sensor
+ * 	to sync with image
+ */
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 1))
+			{
+				if(cam->ctrl.value)
+				{
+					cam->cam_sensor.sens_strobe_en	= ENABLE;
+#if 0
+					ret_val	= lm3553_write(0x10,0x18);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+#endif
+				}else
+				{
+					cam->cam_sensor.sens_strobe_en	= DISABLE;
+				}
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_FLASH;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"flash ctrl",strlen("flash ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+		}break;
+	}
+	return SUCCESS;
+
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_torch
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_torch(cam_data *cam)
+{
+	FNRESLT ret_val;
+	static UINT32 lm3553_torch_value;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= lm3553_torch_value;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 1))
+			{
+				if(cam->ctrl.value)
+				{
+					lm3553_torch_value	= ENABLE;
+					ret_val=lm3553_write(0x10,0x1A);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+				}else
+				{
+					lm3553_torch_value	= DISABLE;
+					ret_val=lm3553_write(0x10,0x18);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+				}
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_TORCH;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"torch ctrl",strlen("torch ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+		}break;
+	}
+	return SUCCESS;
+}
+
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	register_flash_driver
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT register_flash_driver(cam_data *cam)
+{
+	cam->cam_flash.init		= lm3553_init;
+	cam->cam_flash.flash		= lm3553_flash;
+	cam->cam_flash.torch		= lm3553_torch;
+	cam->cam_flash.flash_lum_ctrl	= lm3553_flash_lum_ctrl;
+	cam->cam_flash.torch_lum_ctrl	= lm3553_torch_lum_ctrl;
+	cam->cam_flash.exit		= lm3553_exit;
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/lm3553/lm3553_flash.h linux-ths/drivers/media/video/ecam32/lm3553/lm3553_flash.h
--- linux-org/drivers/media/video/ecam32/lm3553/lm3553_flash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/lm3553/lm3553_flash.h	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,52 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :     OMAP Camera development                                                  *
+ *   MODULE NAME           :     OV3640                                                                   *
+ *   MODULE VERSION        :     VER 1.0                                                                  *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ *
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#define LM3553_DRIVER_NAME	"lm3553"
+
+/*
+ * Slave address
+ */
+
+#define LM3553_SLAVE_ADDRESS	0x53
+
+/*
+ * Function protype
+ */
+FNRESLT register_flash_driver(cam_data *cam);
+
diff -Naur linux-org/drivers/media/video/ecam32/make_command.sh linux-ths/drivers/media/video/ecam32/make_command.sh
--- linux-org/drivers/media/video/ecam32/make_command.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/make_command.sh	2011-12-21 12:36:18.000000000 +0100
@@ -0,0 +1,291 @@
+BOARD_NAME="clean"
+CONFIG_BUILD_ALL="0"
+
+function setup_environment
+{
+	echo "-----------------------------------------------------------------------------------------"
+	echo "                        Configure Build for $BOARD_NAME		                       "
+	echo "-----------------------------------------------------------------------------------------"
+
+	if [ Board/$BOARD_NAME/auto_conf.h -nt auto_conf.h ]; then
+		cp Board/$BOARD_NAME/auto_conf.h ./
+		touch Board/$BOARD_NAME/auto_conf.h
+	fi
+
+	if [ Board/$BOARD_NAME/auto_conf.h -ot auto_conf.h ]; then
+		cp Board/$BOARD_NAME/auto_conf.h ./
+		touch Board/$BOARD_NAME/auto_conf.h
+	fi
+	cp Board/$BOARD_NAME/Makefile ./
+
+	svn update -q
+
+	SVN_REVISION=`svn info | grep 'Revision' | cut -d ' ' -f 2`
+	SVN_DATE=`svn info | grep 'Date' | cut -d ' ' -f 4`
+	SVN_TIME=`svn info | grep 'Date' | cut -d ' ' -f 5`
+
+	if [ -z $SVN_REVISION ]; then
+		echo "Warning! Please use svn version of source copy."
+	else
+		echo "#define PRODUCT_NAME \"$BOARD_NAME\""  > tmp.h
+		echo "#define SVN_REVISION \"$SVN_REVISION\"" >> tmp.h
+		echo "#define SVN_DATE \"$SVN_DATE\"" >> tmp.h
+		echo "#define SVN_TIME \"$SVN_TIME\"" >> tmp.h
+
+		cmp -s tmp.h svn_revision.h
+		RET_VAL=$?
+		if [ $RET_VAL -eq 0 ]; then
+			rm tmp.h
+		else
+			mv tmp.h svn_revision.h
+		fi
+	fi
+}
+
+function make_check_error
+{
+	if [ $? = "0" ]; then
+		echo "                                                                                         "
+		echo "                          Build completed successfully                                   "
+		echo "-----------------------------------------------------------------------------------------"
+		return 0
+	else
+		echo "                                                                                         "
+		echo "                              :-( Build Failed :-(                                       "
+		echo "-----------------------------------------------------------------------------------------"
+		return 1
+	fi
+}
+
+if [ -z $1 ]; then
+	echo "==============================================================================================================="
+	echo "Please select any one of the parameter as first argument in this shell script"
+	echo " clean                               = Clean the build environment for you"
+
+	echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
+	echo " e-CAM50_OMAP_GSTIX                  = gumstix 5MP using ov5642 in j5 connector of processor board"
+	echo " e-CAM50_CU35x_GSTIX                 = gumstix 5MP using ov5642 custom lens setup module in j5 connector of processor board"
+	echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
+	echo " e-CAM50_OMAP35x                     = omap35x 5MP using ov5642 A1 connector of omap3-evm-revG Board"
+	echo " e-CAM50_OMAP35x_Linux_2.6.32        = omap35x 5MP using ov5642 A1 connector of omap3-evm-revG Board"
+	echo " e-CAM50_CU35x                       = omap35x 5MP using ov5642 custom lens in Micron connector"
+	echo " e-CAM50_OMAP35x_MICRON_JAMEERR      = omap evm rev-G using ov5642 in Micron connector"
+	echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
+	echo " e-CAM50_DM37x                       = DM37x 5MP using ov5642 in Micron connector of omap3-evm-revG Board"
+	echo " e-CAM50_CU37x                       = DM37x 5MP using ov5642 custom lens in Micron connector"
+	echo "---------------------------------------------------------------------------------------------------------------"
+	echo " e-CAM32_OMAP_GSTIX                  = gumstix 3MP using ov3640 in j5 connector of processor board"
+	echo " e-CAM32_OMAP35x                     = omap35x 3MP using ov3640 A1 connector of omap3-evm-revG Board"
+	echo " e-CAM32_OMAP35x_MICRON              = omap35x 3MP using ov3640 in Micron connector of omap3-evm-revG Board"
+	echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
+	echo " e-CAM32_DM37x                       = DM37x 3MP using ov3640 in Micron connector of omap3-evm-revG Board"
+	echo "---------------------------------------------------------------------------------------------------------------"
+	echo " DEP_e-CAM1M_CU35x                   = omap evm rev-G using ov10630 in Micron connector"
+	echo " e-CAM1M_CU35x                       = omap evm rev-G using ov10633 in Micron connector"
+	echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
+	echo " e-CAM1M_DM37x                       = DM37x omap evm rev-G using ov10630 in Micron connector"
+	echo "---------------------------------------------------------------------------------------------------------------"
+	echo " build_all                           = Check the integraty of the development with all the boards "
+	echo "---------------------------------------------------------------------------------------------------------------"
+	echo ""
+	echo "Example :"
+	echo ". ./make_command.sh clean"
+	echo "==============================================================================================================="
+else
+	if [ $1 = "clean" ]; then
+		rm -rf `find ./ -name "*.o" -o -name "*.o.cmd" -o -name "*.ko"  \
+			-o -name "*.sh.swp" -o -name ".tmp_versions" 		\
+			-o -name "*.ko.cmd" -o -name "*.mod.*" 			\
+			-o -name "*.||der" -o -name "*.symvers"			\
+			-o -name "*.*.swo" -o -name ".*.o.d" 			\
+			-o -name "*.order" -o -name "tags"`
+	else
+		if [ $1 = "build_all" ]; then
+			 CONFIG_BUILD_ALL="1"
+		fi
+		if [ $1 = "e-CAM50_OMAP_GSTIX" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_OMAP_GSTIX"
+			setup_environment
+			echo "Select the kernel version"
+			echo "1 -> 2.6.32-psp-102g"
+			echo "2 -> 2.6.34-r100 "
+			read KERNEL_VERSION
+
+			if [ $KERNEL_VERSION = "1" ]; then
+				export KERNEL_PATH_SELECTED=/media/hdd1/svn/camera_products/e-CAM50_OMAP_GSTIX/linux-omap-psp-2.6.32-r102g 
+			else
+				export KERNEL_PATH_SELECTED=/media/hdd1/svn/camera_products/e-CAM50_OMAP_GSTIX/linux-omap3-2.6.34-r100
+			fi
+			make	KERNEL_PATH=$KERNEL_PATH_SELECTED \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_CU35x_GSTIX" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_CU35x_GSTIX"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_CU35x_GSTIX/linux-omap3-2.6.34-r100 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_OMAP35x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_OMAP35x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_OMAP35x/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_OMAP35x_Linux_2.6.32" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_OMAP35x_Linux_2.6.32"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_OMAP35x/linux-03.00.01.06 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_CU35x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_CU35x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_CU5642_MOD/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_OMAP35x_MICRON_JAMEERR" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_OMAP35x_MICRON_JAMEERR"
+			setup_environment
+			make KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_CU5642_MOD/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_DM37x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_DM37x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_DM37x/linux-03.00.01.06 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/omap37x/AM35x-OMAP35x-PSP-SDK-03.00.01.06/tool-chain/arm-2009q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_CU37x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_CU37x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_CU37x/linux-03.00.01.06 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/omap37x/AM35x-OMAP35x-PSP-SDK-03.00.01.06/tool-chain/arm-2009q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM32_OMAP_GSTIX" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM32_OMAP_GSTIX"
+			setup_environment
+			echo "Select the kernel version"
+			echo "1 -> 2.6.34 "
+			echo "2 -> 2.6.39 "
+			read KERNEL_VERSION
+
+			if [ $KERNEL_VERSION = "1" ]; then
+				export KERNEL_PATH_SELECTED=/media/hdd1/svn/camera_products/e-CAM32_OMAP_GSTIX/gumstix_ov3640_kernel/linux-omap3-2.6.34-r81 
+			else
+				export KERNEL_PATH_SELECTED=/media/hdd1/svn/camera_products/e-CAM32_OMAP_GSTIX/linux-omap3-2.6.39-r102
+			fi
+			make	KERNEL_PATH=$KERNEL_PATH_SELECTED \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM32_OMAP35x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM32_OMAP35x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM32_OMAP35x/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM32_OMAP35x_MICRON" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM32_OMAP35x_MICRON"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM32_OMAP35x_MICRON/linux-02.01.03.11/ \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM32_DM37x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM32_DM37x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM32_DM37x/linux-03.00.01.06 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/omap37x/AM35x-OMAP35x-PSP-SDK-03.00.01.06/tool-chain/arm-2009q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "DEP_e-CAM1M_CU35x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="DEP_e-CAM1M_CU35x"
+			setup_environment
+			make KERNEL_PATH=/media/hdd1/svn/camera_products/DEP_e-CAM1M_CU35x/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM1M_CU35x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM1M_CU35x"
+			setup_environment
+			make KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM1M_CU35x/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM1M_DM37x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM1M_DM37x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM1M_DM37x/linux-03.00.01.06 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/omap37x/AM35x-OMAP35x-PSP-SDK-03.00.01.06/tool-chain/arm-2009q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+	fi
+ fi
diff -Naur linux-org/drivers/media/video/ecam32/Makefile linux-ths/drivers/media/video/ecam32/Makefile
--- linux-org/drivers/media/video/ecam32/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/Makefile	2012-07-10 13:01:17.000000000 +0200
@@ -0,0 +1,12 @@
+# Makefile for ecam32 v4l2 driver
+
+ccflags-$(CONFIG_SOC_CAMERA_ECAM32_DEBUG) += -DDEBUG
+
+v4l2_driver-objs	:=	init_module.o isp.o omap_hwr_base.o 				\
+				ov3640/sens_ov3640.o  v4l2_driver_base.o                  \
+				omap_camera_interface.o omap_v4l2_fops_base.o  			\
+				isp.o omap_v4l2_ioctl_fops.o i2c.o				\
+				lm3553/lm3553_flash.o exit_module.o					\
+				resource/src/error.o resource/src/kernel/phy_mem.o
+
+obj-$(CONFIG_SOC_CAMERA_ECAM32) += v4l2_driver.o
diff -Naur linux-org/drivers/media/video/ecam32/module_id.h linux-ths/drivers/media/video/ecam32/module_id.h
--- linux-org/drivers/media/video/ecam32/module_id.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/module_id.h	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,65 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * omap_camera_interface.c
+ */
+#define OMAP_CAM_INTERFACE_01
+#define OMAP_CAM_INTERFACE_02
+#define OMAP_CAM_INTERFACE_03
+#define OMAP_CAM_INTERFACE_04
+
+/*
+ * sens_ov3640.c
+ */
+#define SENS_OV3640_01		"ov3640_init_config"
+#define SENS_OV3640_02		"configure_dimention_change"
+#define SENS_OV3640_03		"ov3640_change_dim_config"
+#define SENS_OV3640_04		"ov3640_brightness"
+#define SENS_OV3640_05		"ov3640_exposure"
+#define SENS_OV3640_06		"ov3640_sharpness"
+#define SENS_OV3640_07		"ov3640_effects"
+#define SENS_OV3640_08		"ov3640_saturation"
+#define SENS_OV3640_09		"ov3640_contrast"
+#define SENS_OV3640_10		"planckian_locus_lookuptable"
+#define SENS_OV3640_11		"ov3640_white_balance"
+#define SENS_OV3640_12		"ov3640_vertical_flip"
+#define SENS_OV3640_13		"ov3640_horizontal_mirror"
+#define SENS_OV3640_14		"ov3640_af_firmware_dump"
+#define SENS_OV3640_15		"ov3640_sens_strobe"
+#define SENS_OV3640_16		"ov3640_focus"
+#define SENS_OV3640_17		"ov3640_i2c_client_xfer"
+#define SENS_OV3640_18		"ov3640_write_reg"
+#define SENS_OV3640_19		"ov3640_read_reg"
+#define SENS_OV3640_20		"ov3640_crop"
+
+ov3640_probe
+#define OMAP_V4L2_BASE
+#define OMAP_V4L2_BASE_00
diff -Naur linux-org/drivers/media/video/ecam32/omap_camera_interface.c linux-ths/drivers/media/video/ecam32/omap_camera_interface.c
--- linux-org/drivers/media/video/ecam32/omap_camera_interface.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_camera_interface.c	2011-12-21 12:36:18.000000000 +0100
@@ -0,0 +1,356 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.1   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ * 0.0.1.1
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: OMAP_CAM_INTERFACE_01	
+ *  Name	:	omap_pin_base_struct
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Parameter2	:	UINT8 option	- command to the current function to perfom the mentioned task.
+ *  						CREATE_ADDRESS
+ *						SET_ADDRESS
+ *						GET_ADDRESS
+ *						MAKE_ADDRESS_INVALID
+ *
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative error be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	stores the omap pin base structure pointer
+ *  			and returns the base pointer when a request of GET_ADDRESS 
+ *  			command be obtained from the calling functions 
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_pin_base_struct(cam_data *cam,UINT8 option)
+{
+	static UINT32 g_cam_interface;
+
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(MEMORY_NOT_VALID);
+	}
+	switch(option)
+	{
+		case SET_ADDRESS:
+		{
+			g_cam_interface =(UINT32)cam->pin;			
+		}break;
+
+		case GET_ADDRESS:
+		{
+			cam->pin	= (cam_interface_pin_config*)g_cam_interface;
+		}break;
+
+		case MAKE_ADDRESS_INVALID:
+		{
+			if(cam->pin	== NULL)
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+			iounmap(cam->pin);
+			cam->pin	= NULL;
+			g_cam_interface	= DISABLE;
+		}break;
+		case CREATE_ADDRESS:
+		{
+			cam->pin	= ioremap(REG_CONTROL_PADCONF_CAM_HS,4*1024);
+			if(cam->pin	== NULL)
+			{
+				printk(KERN_ERR "Unable to remap the padconfig registers\n");
+				TRACE_ERR_AND_RET(FAIL);
+			}			
+		}break;
+		default:
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_CAM_INTERFACE_02
+ *  Name	:	configure_cam_interface
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative error be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	:	Confgure the interface lines between sensor and ccdc unit as camera interface lines  	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT configure_cam_interface(cam_data *cam)
+{
+/*
+ * Validate the input
+ */
+	if(cam == NULL || cam->pin == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * perform operation
+ */	
+	cam->pin->bit_hs_vs.bit.cam_hs.MUXMODE				= DISABLE;
+	cam->pin->bit_hs_vs.bit.cam_hs.INPUTENABLE			= ENABLE;
+	cam->pin->bit_hs_vs.bit.cam_hs.PULLUDENABLE			= ENABLE;
+	cam->pin->bit_hs_vs.bit.cam_hs.PULLTYPESELECT			= ENABLE;
+
+	cam->pin->bit_hs_vs.bit.cam_vs.MUXMODE				= DISABLE;
+	cam->pin->bit_hs_vs.bit.cam_vs.INPUTENABLE			= ENABLE;
+	cam->pin->bit_hs_vs.bit.cam_vs.PULLUDENABLE			= ENABLE;
+	cam->pin->bit_hs_vs.bit.cam_vs.PULLTYPESELECT			= ENABLE;
+
+	cam->pin->bit_xclka_pclk.bit.cam_xclka.MUXMODE			= DISABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_xclka.INPUTENABLE		= ENABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_xclka.PULLUDENABLE		= DISABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_xclka.PULLTYPESELECT		= DISABLE;
+
+	cam->pin->bit_xclka_pclk.bit.cam_pclk.MUXMODE			= DISABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_pclk.INPUTENABLE		= ENABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_pclk.PULLUDENABLE		= ENABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_pclk.PULLTYPESELECT		= ENABLE;
+
+	cam->pin->bit_fld_d0.bit.cam_d0.MUXMODE				= DISABLE;
+	cam->pin->bit_fld_d0.bit.cam_d0.INPUTENABLE			= ENABLE;
+	cam->pin->bit_fld_d0.bit.cam_d0.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_fld_d0.bit.cam_d0.PULLTYPESELECT			= DISABLE;
+
+
+	cam->pin->bit_d1_d2.bit.cam_d1.MUXMODE				= DISABLE;
+	cam->pin->bit_d1_d2.bit.cam_d1.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d1_d2.bit.cam_d1.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d1_d2.bit.cam_d1.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d1_d2.bit.cam_d2.MUXMODE				= DISABLE;
+	cam->pin->bit_d1_d2.bit.cam_d2.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d1_d2.bit.cam_d2.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d1_d2.bit.cam_d2.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d3_d4.bit.cam_d3.MUXMODE				= DISABLE;
+	cam->pin->bit_d3_d4.bit.cam_d3.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d3_d4.bit.cam_d3.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d3_d4.bit.cam_d3.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d3_d4.bit.cam_d4.MUXMODE				= DISABLE;
+	cam->pin->bit_d3_d4.bit.cam_d4.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d3_d4.bit.cam_d4.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d3_d4.bit.cam_d4.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d5_d6.bit.cam_d5.MUXMODE				= DISABLE;
+	cam->pin->bit_d5_d6.bit.cam_d5.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d5_d6.bit.cam_d5.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d5_d6.bit.cam_d5.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d5_d6.bit.cam_d6.MUXMODE				= DISABLE;
+	cam->pin->bit_d5_d6.bit.cam_d6.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d5_d6.bit.cam_d6.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d5_d6.bit.cam_d6.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d7_d8.bit.cam_d7.MUXMODE				= DISABLE;
+	cam->pin->bit_d7_d8.bit.cam_d7.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d7_d8.bit.cam_d7.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d7_d8.bit.cam_d7.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d7_d8.bit.cam_d8.MUXMODE				= DISABLE;
+	cam->pin->bit_d7_d8.bit.cam_d8.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d7_d8.bit.cam_d8.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d7_d8.bit.cam_d8.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d9_d10.bit.cam_d9.MUXMODE				= DISABLE;
+	cam->pin->bit_d9_d10.bit.cam_d9.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d9_d10.bit.cam_d9.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d9_d10.bit.cam_d9.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d9_d10.bit.cam_d10.MUXMODE			= DISABLE;
+	cam->pin->bit_d9_d10.bit.cam_d10.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d9_d10.bit.cam_d10.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d9_d10.bit.cam_d10.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d11_xclkb.bit.cam_d11.MUXMODE			= DISABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_d11.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_d11.PULLUDENABLE		= DISABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_d11.PULLTYPESELECT		= DISABLE;
+
+	cam->pin->bit_d11_xclkb.bit.cam_xclkb.MUXMODE			= DISABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_xclkb.INPUTENABLE		= ENABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_xclkb.PULLUDENABLE		= DISABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_xclkb.PULLTYPESELECT		= DISABLE;
+/*
+ * Reset
+ */
+	cam->pin->bit_fld_d0.bit.cam_fld.MUXMODE			= 4;
+	cam->pin->bit_fld_d0.bit.cam_fld.INPUTENABLE			= DISABLE;
+	cam->pin->bit_fld_d0.bit.cam_fld.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_fld_d0.bit.cam_fld.PULLTYPESELECT			= DISABLE;
+
+/*
+ * power down
+ */
+#if (STANDBY_GPIO == 167)
+/*
+ * GPIO 167
+ */
+	cam->pin->bit_wen_strobe.bit.cam_wen.MUXMODE			= 4;
+	cam->pin->bit_wen_strobe.bit.cam_wen.INPUTENABLE		= DISABLE;
+	cam->pin->bit_wen_strobe.bit.cam_wen.PULLUDENABLE		= DISABLE;
+	cam->pin->bit_wen_strobe.bit.cam_wen.PULLTYPESELECT		= DISABLE;
+#elif (STANDBY_GPIO == 157)
+/*
+ * GPIO 157
+ */
+	cam->pin->bit_cklr.bit.mcbsp1_fsr.MUXMODE			= 4;
+	cam->pin->bit_cklr.bit.mcbsp1_fsr.INPUTENABLE			= DISABLE;
+	cam->pin->bit_cklr.bit.mcbsp1_fsr.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_cklr.bit.mcbsp1_fsr.PULLTYPESELECT		= DISABLE;
+#endif
+/*
+ * I2C
+ */
+	cam->pin->bit_i2c2_i2c3.bit.i2c3_scl.MUXMODE			= DISABLE;
+	cam->pin->bit_i2c2_i2c3.bit.i2c3_scl.INPUTENABLE		= ENABLE;
+	cam->pin->bit_i2c2_i2c3.bit.i2c3_scl.PULLUDENABLE		= ENABLE;
+	cam->pin->bit_i2c2_i2c3.bit.i2c3_scl.PULLTYPESELECT		= ENABLE;
+
+	cam->pin->bit_i2c3_hdq_sio.bit.i2c3_sda.MUXMODE			= DISABLE;
+	cam->pin->bit_i2c3_hdq_sio.bit.i2c3_sda.INPUTENABLE		= ENABLE;
+	cam->pin->bit_i2c3_hdq_sio.bit.i2c3_sda.PULLUDENABLE		= ENABLE;
+	cam->pin->bit_i2c3_hdq_sio.bit.i2c3_sda.PULLTYPESELECT		= ENABLE;
+	return SUCCESS;
+}
+
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: OMAP_CAM_INTERFACE_03
+ *  Name	:	init_cam_interface
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative error be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	init the camera interface configuration.
+ *  Comments	:  	Each .c code have init and exit functions calling the init_xxx will initlize the 
+ *  			the local variables and structure variable in the main structure.
+ ************************************************************************************************************/
+FNRESLT init_cam_interface(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * Validate the input
+ */
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= omap_pin_base_struct(cam,CREATE_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to map the camera interface registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	ret_val	= omap_pin_base_struct(cam,SET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to map the camera interface registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+/*
+ * Configured the camera interface
+ */
+	ret_val	= configure_cam_interface(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to map the camera interface registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: OMAP_CAM_INTERFACE_04
+ *  Name	:	exit_cam_interface
+ *  Parameter1	:	INT0
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative error be returned
+ *  					  Note: For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	exit part of code in the camera interface configuration.
+ *  Comments	:  	Each .c code have init and exit functions calling the init_xxx will initlize the 
+ *  			the local variables and structure variable in the main structure.
+ *  			
+ ************************************************************************************************************/
+FNRESLT exit_cam_interface(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * Validate the input
+ */
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= omap_pin_base_struct(cam,MAKE_ADDRESS_INVALID);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to unmap the camera interface registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/omap_camera_interface.h linux-ths/drivers/media/video/ecam32/omap_camera_interface.h
--- linux-org/drivers/media/video/ecam32/omap_camera_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_camera_interface.h	2011-12-20 12:27:10.000000000 +0100
@@ -0,0 +1,230 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * 	CONTROL_PADCONF_CAM_HS[15:0]     0x4800 210C   cam_hs  		       gpio_94  hw_dbg0  safe_mode
+ * 	CONTROL_PADCONF_CAM_HS[31:16]    0x4800 210C   cam_vs   	       gpio_95  hw_dbg1  safe_mode
+ * 	CONTROL_PADCONF_CAM_XCLKA[15:0]  0x4800 2110   cam_xclka	       gpio_96           safe_mode
+ * 	CONTROL_PADCONF_CAM_XCLKA[31:16] 0x4800 2110   cam_pclk                gpio_97  hw_dbg2  safe_mode
+ * 	CONTROL_PADCONF_CAM_FLD[15:0]    0x4800 2114   cam_fld  cam_global_res gpio_98  hw_dbg3  safe_mode
+ * 	CONTROL_PADCONF_CAM_FLD[31:16]   0x4800 2114   cam_d0      csi2_dx2    gpio_99           safe_mode
+ * 	CONTROL_PADCONF_CAM_D1[15:0]     0x4800 2118   cam_d1      csi2_dy2    gpio_100          safe_mode
+ * 	CONTROL_PADCONF_CAM_D1[31:16]    0x4800 2118   cam_d2                  gpio_101 hw_dbg4  safe_mode
+ * 	CONTROL_PADCONF_CAM_D3[15:0]     0x4800 211C   cam_d3                  gpio_102 hw_dbg5  safe_mode
+ * 	CONTROL_PADCONF_CAM_D3[31:16]    0x4800 211C   cam_d4                  gpio_103 hw_dbg6  safe_mode
+ * 	CONTROL_PADCONF_CAM_D5[15:0]     0x4800 2120   cam_d5                  gpio_104 hw_dbg7  safe_mode
+ * 	CONTROL_PADCONF_CAM_D5[31:16]    0x4800 2120   cam_d6                  gpio_105          safe_mode
+ * 	CONTROL_PADCONF_CAM_D7[15:0]     0x4800 2124   cam_d7                  gpio_106          safe_mode
+ * 	CONTROL_PADCONF_CAM_D7[31:16]    0x4800 2124   cam_d8                  gpio_107          safe_mode
+ * 	CONTROL_PADCONF_CAM_D9[15:0]     0x4800 2128   cam_d9                  gpio_108          safe_mode
+ * 	CONTROL_PADCONF_CAM_D9[31:16]    0x4800 2128  cam_d10                  gpio_109 hw_dbg8  safe_mode
+ * 	CONTROL_PADCONF_CAM_D11[15:0]    0x4800 212C  cam_d11                  gpio_110 hw_dbg9  safe_mode
+ * 	CONTROL_PADCONF_CAM_D11[31:16]   0x4800 212C cam_xclkb                 gpio_111          safe_mode
+ * 	CONTROL_PADCONF_CAM_WEN[15:0]    0x4800 2130  cam_wen     cam_shutter  gpio_167 hw_dbg10 safe_mode
+ * 	CONTROL_PADCONF_CAM_WEN[31:16]   0x4800 2130 cam_strobe                gpio_126 hw_dbg11
+ */
+
+#define REG_CONTROL_PADCONF_CAM_HS 		0x4800210C
+
+
+#define REG_CONTROL_PADCONF_CAM_WEN		0x48002130
+#define REG_CONTROL_PADCONF_MCBSP4_DX 		0x48002188 
+
+#define REG_CONTROL_PADCONF_MCBSP1_CLKR		0x4800218C
+
+#define REG_CONTROL_PADCONF_I2C1_SDA		0x480021BC
+
+#define REG_CONTROL_PADCONF_I2C2_SDA		0x480021C0
+
+/*
+ * =============================================================================================================
+ * 					I2C LINES
+ * =============================================================================================================
+ *
+ *	CONTROL_PADCONF_I2C2_SDA[31:16] 0x4800 21C0  i2c3_scl                  gpio_184          safe_mode
+ *	CONTROL_PADCONF_I2C3_SDA[15:0]  0x4800 21C4  i2c3_sda                  gpio_185          safe_mode
+ * =============================================================================================================
+ */
+
+struct pad_config_value
+{
+	UVINT16 MUXMODE			:3;
+	UVINT16 PULLUDENABLE		:1;
+ 	UVINT16 PULLTYPESELECT		:1;
+	UVINT16 RESERVED		:3;
+	UVINT16 INPUTENABLE		:1;
+	UVINT16 OFFENABLE		:1;
+	UVINT16 OFFOUTENABLE		:1;
+	UVINT16 OFFOUTVALUE		:1;
+	UVINT16 OFFPULLUDENABLE		:1;
+	UVINT16 OFFPULLTYPE		:1;
+	UVINT16 WAKEUPENABLE		:1;
+	UVINT16 WAKEUPEVENT		:1;
+};
+
+typedef struct cam_interface
+{
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_HS;
+		struct
+		{
+			struct pad_config_value cam_hs;
+			struct pad_config_value cam_vs;
+		}bit;
+	}bit_hs_vs;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_XCLKA;
+		struct
+		{
+			struct pad_config_value cam_xclka;
+			struct pad_config_value cam_pclk;
+		}bit;
+	}bit_xclka_pclk;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_FLD;
+		struct
+		{
+			struct pad_config_value cam_fld;
+			struct pad_config_value cam_d0;
+		}bit;
+	}bit_fld_d0;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D1;
+		struct
+		{
+			struct pad_config_value cam_d1;
+			struct pad_config_value cam_d2;
+		}bit;
+
+	}bit_d1_d2;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D3;
+		struct
+		{
+			struct pad_config_value cam_d3;
+			struct pad_config_value cam_d4;
+		}bit;
+
+	}bit_d3_d4;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D5;
+		struct
+		{
+			struct pad_config_value cam_d5;
+			struct pad_config_value cam_d6;
+		}bit;
+
+	}bit_d5_d6;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D7;
+		struct
+		{
+			struct pad_config_value cam_d7;
+			struct pad_config_value cam_d8;
+		}bit;
+
+	}bit_d7_d8;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D9;
+		struct
+		{
+			struct pad_config_value cam_d9;
+			struct pad_config_value cam_d10;
+		}bit;
+
+	}bit_d9_d10;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D11;
+		struct
+		{
+			struct pad_config_value cam_d11;
+			struct pad_config_value cam_xclkb;
+		}bit;
+
+	}bit_d11_xclkb;
+
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_WEN;
+		struct
+		{
+			struct pad_config_value cam_wen;
+			struct pad_config_value cam_strobe;
+		}bit;
+
+	}bit_wen_strobe;
+
+	UVINT32	RESERVED1[(REG_CONTROL_PADCONF_MCBSP4_DX-REG_CONTROL_PADCONF_CAM_WEN)/4];
+	union
+	{
+		UVINT32 CONTROL_PADCONF_MCBSP1_CLKR;
+		struct
+		{
+			struct pad_config_value mcbsp1_clkr;
+			struct pad_config_value mcbsp1_fsr;
+		}bit;
+
+	}bit_cklr;
+	UVINT32	RESERVED2[(REG_CONTROL_PADCONF_I2C1_SDA-REG_CONTROL_PADCONF_MCBSP1_CLKR)/4];
+
+	union
+	{
+		UVINT32 CONTROL_PADCONF_I2C2_SDA;
+		struct
+		{
+			struct pad_config_value i2c2_sda;
+			struct pad_config_value i2c3_scl;
+		}bit;
+
+	}bit_i2c2_i2c3;
+
+	union
+	{
+		UVINT32 CONTROL_PADCONF_I2C3_SDA;
+		struct
+		{
+			struct pad_config_value i2c3_sda;
+			struct pad_config_value hdq_sio;
+		}bit;
+
+	}bit_i2c3_hdq_sio;
+
+}cam_interface_pin_config;
+
diff -Naur linux-org/drivers/media/video/ecam32/omap_hwr_base.c linux-ths/drivers/media/video/ecam32/omap_hwr_base.c
--- linux-org/drivers/media/video/ecam32/omap_hwr_base.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_hwr_base.c	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,117 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	init_omap_hwr
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_omap_hwr(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * Configure the camera interface
+ */
+	ret_val	= init_cam_interface(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+/*
+ * Configure the isp registers
+ */
+	ret_val	= init_cam_isp_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	exit_omap_hwr
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT exit_omap_hwr(cam_data *cam)
+{
+	FNRESLT ret_val;
+
+/*
+ * Free all camera interface
+ */
+	ret_val	= exit_cam_interface(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+
+/*
+ * Free isp registers
+ */
+	ret_val	= exit_cam_isp_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+
+	return SUCCESS;
+}
+
diff -Naur linux-org/drivers/media/video/ecam32/omap_v4l2_fops_base.c linux-ths/drivers/media/video/ecam32/omap_v4l2_fops_base.c
--- linux-org/drivers/media/video/ecam32/omap_v4l2_fops_base.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_v4l2_fops_base.c	2011-10-07 13:23:08.000000000 +0200
@@ -0,0 +1,842 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_open	
+ *  Parameter1	:	struct file *file
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	perform open operation of v4l2 
+ *  Comments	:  	
+ ************************************************************************************************************/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	INT32 omap_v4l2_open(struct file *file)
+#else
+	INT32 omap_v4l2_open(struct inode *inode,struct file *file)
+#endif
+{
+	INT32 err = 0;
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam;
+	FNRESLT ret_val;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to get base node of camera device\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+	
+	if (cam	== NULL)
+	{
+		printk(KERN_ERR "Internal error, cam_data not found!\n");
+		TRACE_ERR_AND_RET(-EBADF);
+	}
+	file->private_data = dev;
+
+	strcpy(cam->v4l2_cap.driver, "omap_v4l2");
+	cam->v4l2_cap.version		= KERNEL_VERSION(0, 1, 11);
+	cam->v4l2_cap.capabilities 	=	V4L2_CAP_VIDEO_CAPTURE	|	\
+						V4L2_CAP_READWRITE	|	\
+						V4L2_CAP_STREAMING;
+
+	cam->v4l2_cap.card[0]		= '\0';
+	cam->v4l2_cap.bus_info[0]	= '\0';
+
+	return err;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_close
+ *  Parameter1	:	struct file *file
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	INT32 omap_v4l2_close(struct file *file)
+#else
+	INT32 omap_v4l2_close(struct inode *inode,struct file *file)
+#endif
+{
+	INT32 err = 0;
+	FNRESLT ret_val;
+
+	cam_data *cam;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to get base node of camera device\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	if (cam	== NULL)
+	{
+		printk(KERN_ERR "Internal error, cam_data not found!\n");
+		return -EBADF;
+	}
+
+	ret_val	= omap_v4l2_stream_off(cam,NULL);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	cam->cmd	= SET_DATA;
+	cam->ctrl.id	= V4L2_SENS_FLASH_FLASH;
+	cam->ctrl.value	= DISABLE;
+
+	if(cam->cam_flash.flash)
+	{
+		ret_val = cam->cam_flash.flash(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(ret_val);
+		}
+	}
+
+	cam->cmd	= SET_DATA;
+	cam->ctrl.id	= V4L2_SENS_FLASH_TORCH;
+	cam->ctrl.value	= DISABLE;
+
+	if(cam->cam_flash.flash)
+	{
+		ret_val = cam->cam_flash.torch(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(ret_val);
+		}
+	}
+	return err;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	cam_get_pages
+ *  Parameter1	:	UPINT32 vir_addr	- Virtual of available physical address available
+ *  Parameter2	:	UINT32 size		- size of memory free and available
+ *  Parameter3	:	UPINT32 phy_addr	- Physical address of memory available from the kernel
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	get the free memory available from the kernel.  				
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT cam_get_pages(UPINT32 vir_addr,UINT32 size,UPINT32 phy_addr)
+{
+	ULINT32 adr;
+
+	*vir_addr	= (UINT32)__get_free_pages(GFP_KERNEL |					\
+						GFP_DMA,get_order(size));
+	if(*vir_addr == DISABLE)
+	{
+		printk(KERN_INFO "Memory not sufficient ...\n");
+		return FAIL;
+	}
+
+        adr = (ULINT32)*vir_addr;
+        size = PAGE_SIZE << (get_order(size));
+	for(;size > 0;)
+	{
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	*phy_addr	= (UINT32)virt_to_phys((PINT0)*vir_addr);
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	cam_free_pages
+ *  Parameter1	:	UINT32 addr		- Virtural address of allocated physical pages
+ *  Parameter2	:	UINT32 bufsize		- buffer size
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	Free the memory region allocated by cam_get_pages
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT cam_free_pages(UINT32 addr, UINT32 bufsize)
+{
+        UINT32 size, ad = addr;
+
+        size = PAGE_SIZE << (get_order(bufsize));
+        if (!addr)
+	{
+                TRACE_ERR_AND_RET(FAIL);
+	}
+
+        while (size > 0)
+	{
+                ClearPageReserved(virt_to_page(addr));
+                addr += PAGE_SIZE;
+                size -= PAGE_SIZE;
+        }
+
+        free_pages(ad, get_order(bufsize));
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_read
+ *  Parameter1	:	struct file *file
+ *  Parameter2	:	INT8 *buf
+ *  Parameter3	:	size_t count
+ *  Parameter4	:	loff_t * ppos
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned	
+ *  Description	: 	perform read operation of camera driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+INT32 omap_v4l2_read(struct file *file, INT8 *buf, size_t count, loff_t * ppos)
+{
+
+//	struct video_device *dev = video_devdata(file);
+	FNRESLT ret_val;
+	cam_data *cam = NULL;
+	INT32 err;
+	UINT32 wait_event_ret_val	= DISABLE;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	if(cam->task.bit.capture	== ENABLE)
+	{
+		TRACE_ERR_AND_RET(-EBUSY);	
+	}
+
+	cam->task.bit.still	= ENABLE;
+
+/*
+ * reset the isp 
+ */
+
+	ret_val	= isp_reset(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	ret_val	= isp_configure(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+/*
+ * Get the memory from the kernel
+ */
+
+	ret_val	= get_free_phy_mem(cam->capture.v2f.fmt.pix.sizeimage,&cam->still.phy_addr,&cam->still.vir_addr);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	ret_val	= isp_prg_sdram_addr(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	cam->still.frame_count	= DISABLE;
+	cam->still.wait_queue_head_t_dma_frame_complete_still	= DISABLE;
+
+/*
+ * Enable sensor strobe
+ */
+	if(cam->cam_sensor.sens_strobe)
+	{
+		cam->ctrl.id	= V4L2_SENS_FLASH_STROBE;
+		cam->ctrl.value	= ENABLE;
+		ret_val	= cam->cam_sensor.sens_strobe(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			goto exit;
+		}
+	}
+
+
+	ret_val	= enable_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	ret_val	= enable_isp_irq0(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+/*
+ * Wait for interrupt from the isp interrupt service routine
+ */
+	if(cam->still.wait_queue_head_t_dma_frame_complete_still	== DISABLE)
+	{
+		wait_event_ret_val	= wait_event_interruptible_timeout(cam->still.dma_frame_complete_still,		\
+					      cam->still.frame_count >= STILL_IMAGE_CAPTURE_FRAME_NUMBER,		\
+						20 * HZ);
+	}
+	
+/*
+ * Disable sensor strobe
+ */
+	if(cam->cam_sensor.sens_strobe)
+	{
+		cam->ctrl.id	= V4L2_SENS_FLASH_STROBE;
+		cam->ctrl.value	= DISABLE;
+		ret_val	= cam->cam_sensor.sens_strobe(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			goto exit;
+		}
+
+	}
+
+	ret_val	= disable_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	ret_val	= disable_isp_irq0(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	if(wait_event_ret_val == DISABLE)
+	{
+		cam->task.bit.still = DISABLE;
+
+		printk(KERN_DEBUG "wait_event_interruptible_timeout %s %d \n",__FUNCTION__,__LINE__);	
+		printk(KERN_ERR "omap_v4l_read timeout - Frame count %d\n",cam->still.frame_count);
+	
+		ret_val	= free_phy_mem(cam->still.phy_addr);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			goto exit;
+		}
+		return -ETIME;
+	}
+	err = copy_to_user(buf,(UPINT8)cam->still.vir_addr, cam->capture.v2f.fmt.pix.sizeimage);
+
+	ret_val	= free_phy_mem(cam->still.phy_addr);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	cam->task.bit.still	= DISABLE;
+
+	return cam->capture.v2f.fmt.pix.sizeimage;
+
+	exit:
+	{
+		cam->task.bit.still	= DISABLE;
+		return 0;
+	}
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_mmap
+ *  Parameter1	:	struct file *file
+ *  Parameter2	:	struct vm_area_struct *vma
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned	
+ *  Description	: 	perform mmap operation 
+ *  Comments	:  	
+ ************************************************************************************************************/
+INT32 omap_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	ULINT32 size;
+	INT32 res = DISABLE;
+
+	pr_debug("pgoff=0x%lx, start=0x%lx, end=0x%lx\n",vma->vm_pgoff, vma->vm_start, vma->vm_end);
+
+	size = vma->vm_end - vma->vm_start;
+
+/*
+ * 
+ * By introducing the Page_shared macro in vma->vm_page_prot can able to increase the frame frame.
+ * Advantages and Disadvantages are discussed here.
+ *
+ * Advantage:
+ *  1. Able to show good frame rate 30fps at 720p.
+ *
+ * Disadvantage:
+ *  1. While lines visible in the recorded video 
+ *
+ * TODO:
+ *  Need to implement mmu unit for camera (or) make use of DSS unit user buffer pointer concept.
+ *  vma->vm_page_prot = PAGE_SHARED;
+ */
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	if (remap_pfn_range(vma, vma->vm_start,vma->vm_pgoff, size, vma->vm_page_prot))
+	{
+		printk(KERN_ERR "omap_mmap: remap_pfn_range failed\n");
+		res = -ENOBUFS;
+		goto omap_mmap_exit;
+	}
+
+	vma->vm_flags |= VM_RESERVED;
+	omap_mmap_exit:
+	{
+		return res;
+	}
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_do_ioctl
+ *  Parameter1	:	struct file *file
+ *  Parameter2	:	UINT32 ioctlnr
+ *  Parameter3	:	PINT0 arg
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	process ioctl commands here
+ *  Comments	:  	
+ ************************************************************************************************************/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	LINT32 omap_v4l2_do_ioctl(struct file *file,UINT32 ioctlnr,PINT0 arg)
+#else
+	LINT32 omap_v4l2_do_ioctl(struct inode *inode, struct file *file,UINT32 ioctlnr,PINT0 arg)
+#endif
+{
+	FNRESLT ret_val;
+	cam_data *cam = NULL;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+//	printk(KERN_ERR MODULE_NAME ": IOCTL Number is :%d\n",_IOC_NR(ioctlnr));
+
+	switch (ioctlnr)
+	{
+		case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap = arg;
+			ret_val = omap_v4l2_capability(cam,cap);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}	
+	
+		}break;
+
+		case VIDIOC_S_FMT:
+		{
+			struct v4l2_format *sf = arg;
+			ret_val = omap_v4l2_s_fmt(cam, sf);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}	
+		}break;
+
+		case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *gf = arg;
+			ret_val = omap_v4l2_g_fmt(cam, gf);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}	
+		}break;
+
+		case VIDIOC_G_CTRL:
+		{
+			cam->cmd	= GET_DATA;
+			memcpy(&cam->ctrl,arg,sizeof(struct v4l2_control));
+
+			ret_val	= omap_v4l2_ctrl(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+			memcpy(arg,&cam->ctrl,sizeof(struct v4l2_control));
+		}break;
+
+		case VIDIOC_S_CTRL:
+		{
+			cam->cmd	= SET_DATA;
+			memcpy(&cam->ctrl,arg,sizeof(struct v4l2_control));
+
+			ret_val	= omap_v4l2_ctrl(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+		}break;
+
+		case VIDIOC_QUERYCTRL:
+		{
+			struct v4l2_queryctrl *qctrl	= arg;
+			memset(&cam->qctrl,0x00,sizeof(struct v4l2_queryctrl));
+			cam->cmd	= QUERY_DATA;
+
+			cam->ctrl.id	= qctrl->id;
+			
+			ret_val	= omap_v4l2_ctrl(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				cam->qctrl.flags	= V4L2_CTRL_FLAG_DISABLED;
+				memcpy(qctrl,&cam->qctrl,sizeof(struct v4l2_queryctrl));
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+			memcpy(qctrl,&cam->qctrl,sizeof(struct v4l2_queryctrl));
+		}break;
+//--------------------------------------------------------------------------------------------------
+		case VIDIOC_REQBUFS:
+		{
+			ret_val	= omap_v4l2_req_buf(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_QUERYBUF:
+		{
+			ret_val	= omap_v4l2_query_buf(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_QBUF:
+		{
+			ret_val	= omap_v4l2_queue_buf(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_DQBUF:
+		{
+			ret_val	= omap_v4l2_dqueue_buf(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_STREAMON:
+		{
+			ret_val	= omap_v4l2_stream_on(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_STREAMOFF:
+		{
+			ret_val	= omap_v4l2_stream_off(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+		}break;
+
+		case VIDIOC_ENUMINPUT:
+		{
+			struct v4l2_input *vinp_arg	= arg;
+			if(vinp_arg->index	== 0)
+			{
+				strlcpy(cam->vinp.name, "camera", sizeof(cam->vinp.name));
+				cam->vinp.type = V4L2_INPUT_TYPE_CAMERA;
+				
+				strlcpy(vinp_arg->name, "camera", sizeof(vinp_arg->name));
+				vinp_arg->type = V4L2_INPUT_TYPE_CAMERA;
+
+			}else
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+		}break;
+		case VIDIOC_G_INPUT:
+		{
+			int *index	= arg;
+			*index	= 0;
+		}break;
+
+		case VIDIOC_ENUM_FMT:
+		{
+			ret_val	= omap_v4l2_enum_fmt(cam,arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_ENUMSTD:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);
+		}break;
+
+		case VIDIOC_S_INPUT:
+		{
+			printk("FUNCTION %s FILE %s LINE %d\n",__func__,__FILE__,__LINE__);
+		}break;
+
+		case VIDIOC_G_STD:
+		{
+			v4l2_std_id *std	=  arg;
+			*std	= V4L2_STD_PAL;
+		}break;
+
+		case VIDIOC_TRY_FMT:
+		{
+			struct v4l2_format *cam_try_fmt = arg;
+			memcpy(&cam->cam_sensor.qfmt,cam_try_fmt,sizeof(struct v4l2_format));
+			if(cam->cam_sensor.qfmt_support)
+			{
+				ret_val	= cam->cam_sensor.qfmt_support(cam);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(ret_val);
+				}
+			}else
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+		}break;
+
+		case VIDIOC_G_PARM:
+		{
+			struct v4l2_streamparm *s_parm	= arg;
+
+#if defined(CONFIG_CTRL_FRAME_RATE_FRM_SENSOR)
+			memcpy(&cam->cam_sensor.s_parm,s_parm,sizeof(struct v4l2_streamparm));
+			cam->cmd	= GET_DATA;
+
+			if(cam->cam_sensor.frame_rate_ctrl)
+			{
+				ret_val	= cam->cam_sensor.frame_rate_ctrl(cam);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(ret_val);
+				}
+
+			}
+#else
+			if(s_parm->type	== V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			{
+				/* do nothing */
+			}
+#endif
+			else
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+#if defined (CONFIG_CTRL_FRAME_RATE_FRM_SENSOR)
+			memcpy(s_parm,&cam->cam_sensor.s_parm,sizeof(struct v4l2_streamparm));
+#else
+			memcpy(s_parm,&cam->capture.s_parm,sizeof(struct v4l2_streamparm));
+#endif
+		}break;
+
+		case VIDIOC_S_PARM:
+		{
+			struct v4l2_streamparm *s_parm	= arg;
+
+#if defined(CONFIG_CTRL_FRAME_RATE_FRM_SENSOR)
+			memcpy(&cam->cam_sensor.s_parm,s_parm,sizeof(struct v4l2_streamparm));
+			cam->cmd	= SET_DATA;
+
+			if(cam->cam_sensor.frame_rate_ctrl)
+			{
+				ret_val	= cam->cam_sensor.frame_rate_ctrl(cam);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(ret_val);
+				}
+			}
+#else
+			memcpy(&cam->capture.s_parm,s_parm,sizeof(struct v4l2_streamparm));
+			if(cam->capture.s_parm.type	!= V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+
+			if (cam->capture.s_parm.parm.capture.timeperframe.denominator > SENS_MAX_FPS)
+			{
+				cam->capture.s_parm.parm.capture.timeperframe.denominator	= SENS_MAX_FPS;
+			}			
+
+#endif			
+		}break;
+
+		case VIDIOC_ENUM_FRAMESIZES:
+		{
+			cam->cmd	= GET_DATA;
+			cam->cam_sensor.fmt_frm_user	= arg;
+
+			if(cam->cam_sensor.supported_formats)
+			{
+				ret_val	= cam->cam_sensor.supported_formats(cam);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(ret_val);
+				}
+			}else
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+		}break;
+
+		case VIDIOC_ENUM_FRAMEINTERVALS:
+		{
+			cam->cmd		= GET_DATA;
+			cam->cam_sensor.frame_interval_frm_user	= arg;
+
+			if(cam->cam_sensor.frame_interval)
+			{
+				ret_val	= cam->cam_sensor.frame_interval(cam);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(ret_val);
+				}
+
+			}else
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+		}break;
+
+#if 0
+
+		case VIDIOC_CROPCAP:
+		{
+///			struct v4l2_cropcap *crp_cap;
+			printk("FUNCTION %s FILE %s LINE %d\n",__func__,__FILE__,__LINE__);
+		}break;
+
+		case VIDIOC_S_CROP:
+		{
+			printk("FUNCTION %s FILE %s LINE %d\n",__func__,__FILE__,__LINE__);
+		}break;
+
+		case VIDIOC_G_CROP:
+		{
+			printk("FUNCTION %s FILE %s LINE %d\n",__func__,__FILE__,__LINE__);
+		}break;
+
+		case VIDIOC_S_STD:
+		{
+			printk("FUNCTION %s FILE %s LINE %d\n",__func__,__FILE__,__LINE__);
+		}break;
+
+#endif		
+//--------------------------------------------------------------------------------------------------
+		default:
+		{
+			printk(KERN_ERR MODULE_NAME "Ioctl currently not implemented IOCTL Number is :%d\n",_IOC_NR(ioctlnr));
+			TRACE_ERR_AND_RET(-EINVAL);
+		}
+	}
+	return SUCCESS;
+
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_ioctl
+ *  Parameter1	:	struct file *file
+ *  Parameter2	:	UINT32 cmd
+ *  Parameter3	:	ULINT32 arg
+ *
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	LINT32 omap_v4l2_ioctl( struct file *file,UINT32 cmd,ULINT32 arg)
+#else
+	LINT32 omap_v4l2_ioctl( struct inode *inode, struct file *file,UINT32 cmd,ULINT32 arg)
+#endif
+{
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	return video_usercopy(file, cmd, arg, omap_v4l2_do_ioctl);
+#else
+	return video_usercopy(inode, file, cmd, arg, omap_v4l2_do_ioctl);
+#endif
+}
diff -Naur linux-org/drivers/media/video/ecam32/omap_v4l2.h linux-ths/drivers/media/video/ecam32/omap_v4l2.h
--- linux-org/drivers/media/video/ecam32/omap_v4l2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_v4l2.h	2011-10-03 12:30:02.000000000 +0200
@@ -0,0 +1,55 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+#define V4L2_SENS_TRIG_FOCUS			(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_SENS_FCS_OLAY			(V4L2_CID_PRIVATE_BASE + 2)
+
+#define V4L2_SENS_FLASH				(V4L2_CID_PRIVATE_BASE + 3)
+#define V4L2_SENS_FLASH_LUM			(V4L2_CID_PRIVATE_BASE + 4)
+#define V4L2_SENS_FLASH_TORCH			(V4L2_CID_PRIVATE_BASE + 5)
+#define V4L2_SENS_FLASH_FLASH			(V4L2_CID_PRIVATE_BASE + 6)
+#define V4L2_SENS_FLASH_STROBE			(V4L2_CID_PRIVATE_BASE + 7)
+
+#define V4L2_SENS_EFFECTS			(V4L2_CID_PRIVATE_BASE + 8)
+#define V4L2_SENS_FOCUS_DISABLE			(V4L2_CID_PRIVATE_BASE + 9)
+
+#define V4L2_SENS_FLASH_FLASH_LUM		(V4L2_CID_PRIVATE_BASE + 10)
+#define V4L2_SENS_FLASH_TORCH_LUM		(V4L2_CID_PRIVATE_BASE + 11)
+#define V4L2_SENS_ANTISHAKE			(V4L2_CID_PRIVATE_BASE + 12)
+#define V4L2_SENS_ANTISHAKE_STATUS		(V4L2_CID_PRIVATE_BASE + 13)
+
+#define V4L2_SENS_TEST_PATTERN			(V4L2_CID_PRIVATE_BASE + 14)
+
+#define V4L2_SENS_FOCUS_FREEZE			(V4L2_CID_PRIVATE_BASE + 15)
+#define V4L2_SENS_FOCUS_UNFREEZE		(V4L2_CID_PRIVATE_BASE + 16)
+
+#define V4L2_SENS_REGISTER			(V4L2_CID_PRIVATE_BASE + 17)
diff -Naur linux-org/drivers/media/video/ecam32/omap_v4l2_ioctl_fops.c linux-ths/drivers/media/video/ecam32/omap_v4l2_ioctl_fops.c
--- linux-org/drivers/media/video/ecam32/omap_v4l2_ioctl_fops.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_v4l2_ioctl_fops.c	2011-10-07 13:23:08.000000000 +0200
@@ -0,0 +1,715 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_capability
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_capability *cap
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_capability(cam_data *cam,struct v4l2_capability *cap)
+{
+	memcpy(cap,&cam->v4l2_cap,sizeof(struct v4l2_capability));
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_s_fmt
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_format *f
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
+{
+	FNRESLT ret_val;
+	
+	if(f->type		== V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	{
+		if((cam->task.bit.capture	== ENABLE) || (cam->task.bit.still	== ENABLE))
+		{
+			TRACE_ERR_AND_RET(-EBUSY);
+		}
+
+		if(cam->cam_sensor.fix_fmt_support)
+		{
+			memcpy(&cam->cam_sensor.fmt,f,sizeof(struct v4l2_format));
+			ret_val	= cam->cam_sensor.fix_fmt_support(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{	
+				TRACE_ERR_AND_RET(FAIL);
+			}
+		}
+		memcpy(&cam->capture.v2f,&cam->cam_sensor.fmt,sizeof(struct v4l2_format));
+		memcpy(f,&cam->cam_sensor.fmt,sizeof(struct v4l2_format));
+/*
+ * configure the sensor
+ */
+		if(cam->cam_sensor.config_dim)
+		{
+			ret_val	= cam->cam_sensor.config_dim(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				return ret_val;
+			}
+		}
+	}else
+	{
+		printk(KERN_INFO "Searching for f->type %d\n",f->type);
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_g_fmt
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_format *f
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT omap_v4l2_g_fmt(cam_data *cam, struct v4l2_format *f)
+{
+	if(f->type		== V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	{
+		memcpy(f,&cam->capture.v2f,sizeof(struct v4l2_format));
+	}else
+	{
+		return FAIL;
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_ctrl
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT omap_v4l2_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+  	typedef FNRESLT (*camera_register_dump) (cam_data *cam);
+	camera_register_dump sensor_register_dump	= NULL;
+
+	switch (cam->ctrl.id)
+	{
+		case V4L2_CID_BRIGHTNESS:
+		case V4L2_CID_BLACK_LEVEL:
+		{
+			sensor_register_dump = cam->cam_sensor.brightness;
+		}break;
+
+		case V4L2_CID_CONTRAST:
+		{
+			sensor_register_dump = cam->cam_sensor.contrast;
+		
+		}break;
+
+		case V4L2_CID_SATURATION:
+		{
+			sensor_register_dump = cam->cam_sensor.saturation;
+		
+		}break;
+
+		case V4L2_CID_HUE:
+		{
+			sensor_register_dump = cam->cam_sensor.hue;
+		
+		}break;
+
+		case V4L2_CID_AUTO_WHITE_BALANCE:
+		case V4L2_CID_DO_WHITE_BALANCE:
+		case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+		{
+			sensor_register_dump = cam->cam_sensor.whitebalance;
+		
+		}break;
+
+
+		case V4L2_CID_RED_BALANCE:
+		case V4L2_CID_BLUE_BALANCE:
+		case V4L2_CID_GAMMA:
+		{
+			sensor_register_dump = cam->cam_sensor.colour_balance;
+		
+		}break;
+
+		case V4L2_CID_EXPOSURE:
+		{
+			sensor_register_dump = cam->cam_sensor.exposure;
+
+		}break;
+
+		case V4L2_CID_AUTOGAIN:
+		case V4L2_CID_GAIN:
+		{
+			sensor_register_dump = cam->cam_sensor.gain;
+
+		}break;
+
+		case V4L2_CID_HFLIP:
+		{
+			sensor_register_dump = cam->cam_sensor.h_mirror;
+
+		}break;
+
+		case V4L2_CID_VFLIP:
+		{
+			sensor_register_dump = cam->cam_sensor.v_flip;
+
+		}break;
+
+		case V4L2_CID_SHARPNESS:
+		{
+			sensor_register_dump = cam->cam_sensor.sharpness;
+
+		}break;
+		
+		case V4L2_CID_FOCUS_ABSOLUTE:
+		case V4L2_CID_FOCUS_RELATIVE:
+		case V4L2_CID_FOCUS_AUTO:
+		case V4L2_SENS_TRIG_FOCUS:
+		case V4L2_SENS_FOCUS_DISABLE:
+		case V4L2_SENS_FCS_OLAY:
+		{
+			sensor_register_dump = cam->cam_sensor.focus;
+		}break;
+/*
+ * Sensor related private controls
+ */
+		case V4L2_SENS_ANTISHAKE:
+ 		case V4L2_SENS_ANTISHAKE_STATUS:
+ 		{
+ 			sensor_register_dump = cam->cam_sensor.antishake;
+ 		}break;
+
+		case V4L2_SENS_TEST_PATTERN:
+		{
+ 			sensor_register_dump = cam->cam_sensor.test_color_pattern;
+		}break;
+
+/*
+ * Private control
+ */
+		case V4L2_SENS_FLASH_STROBE:
+		{
+			cam->cam_sensor.sens_strobe_en	= (cam->ctrl.value)?ENABLE:DISABLE;
+			sensor_register_dump = cam->cam_sensor.sens_strobe;
+		}break;
+
+		case V4L2_SENS_EFFECTS:
+		{
+			sensor_register_dump = cam->cam_sensor.effects;
+		}break;
+
+/*
+ * Flash private controls
+ */
+		case V4L2_SENS_FLASH_FLASH:
+		{
+			sensor_register_dump = cam->cam_flash.flash;
+		}break;
+
+		case V4L2_SENS_FLASH_TORCH:
+		{
+			sensor_register_dump = cam->cam_flash.torch;
+		}break;
+
+		case V4L2_SENS_FLASH_FLASH_LUM:
+		{
+			sensor_register_dump = cam->cam_flash.flash_lum_ctrl;
+		}break;
+
+		case V4L2_SENS_FLASH_TORCH_LUM:
+		{
+			sensor_register_dump = cam->cam_flash.torch_lum_ctrl;
+		}break;
+/*
+ * Sensor read and Write routines
+ */
+		case V4L2_SENS_REGISTER:
+		{
+			sensor_register_dump	= cam->cam_sensor.reg_access; 
+		}break;
+#if 0
+		case V4L2_READ_MEM_MAP:
+		{
+			cam->ctrl.value	= cam->still.buf.phy_buf_addr;
+		}break;
+
+		case V4L2_READ_SKIP_USER_CPY:
+		{
+			if(cam->cam_sensor.get_data_frm_sensor	== ENABLE)
+			{
+				cam->ctrl.value	= cam->still.read_ctrl.bit.skip_copy_to_user;
+			}else
+			{
+				if(cam->ctrl.value)
+				{
+					cam->still.read_ctrl.bit.skip_copy_to_user	= ENABLE;
+				}else
+				{
+					cam->still.read_ctrl.bit.skip_copy_to_user	= DISABLE;
+				}
+			}
+		}break;
+#endif
+
+	}
+
+	if(sensor_register_dump)
+	{
+		ret_val	= sensor_register_dump(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	
+	}else
+	{
+		TRACE_ERR_AND_RET(-EINVAL);
+	}
+	
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_req_buf
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_requestbuffers *req
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_req_buf(cam_data *cam,struct v4l2_requestbuffers *req)
+{
+	UINT32 i;
+	FNRESLT ret_val;
+
+	if(cam->task.bit.capture	== ENABLE)
+	{
+		TRACE_ERR_AND_RET(-EBUSY);
+	}
+
+	if (	(req->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) || 				\
+		(req->memory != V4L2_MEMORY_MMAP))
+	{
+		TRACE_ERR_AND_RET(-EINVAL);
+	}
+
+	if(req->count > (MAX_FRAME_SUPPORT-1))
+	{
+		req->count			= MAX_FRAME_SUPPORT -1;
+		cam->capture.available_buf	= MAX_FRAME_SUPPORT;
+	}
+/*
+ * Free the allocated buffers
+ */
+
+	for(i = 0;i < MAX_FRAME_SUPPORT;i++)
+	{
+		if(cam->capture.frame[i].buffer.m.offset)
+		{
+			ret_val	= free_phy_mem(cam->capture.frame[i].buffer.m.offset);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+			cam->capture.frame[i].buffer.m.offset		= DISABLE;
+		}
+	}
+/*
+ * request and allocate the buffer needed by the user
+ * Ask for the dummy buffer and make empty copy when there is no queued buffer (skip the frame)
+ */
+
+	for(i = 0;i <= req->count;i++)
+	{
+		ret_val	= get_free_phy_mem(	cam->capture.v2f.fmt.pix.sizeimage,
+						(UPINT32)&cam->capture.frame[i].buffer.m.offset,NULL);
+
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			break;
+		}
+
+		cam->capture.frame[i].buffer.index	= i;
+		cam->capture.frame[i].buffer.flags	= V4L2_BUF_FLAG_MAPPED;
+		cam->capture.frame[i].buffer.type	= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cam->capture.frame[i].buffer.length	= PAGE_ALIGN(cam->capture.v2f.fmt.pix.sizeimage);
+		cam->capture.frame[i].buffer.memory	= V4L2_MEMORY_MMAP;
+		cam->capture.frame[i].width		= cam->capture.v2f.fmt.pix.width;
+		cam->capture.frame[i].height		= cam->capture.v2f.fmt.pix.height;
+	}
+
+	if(req->count	== i)
+	{
+		req->count			= i;
+		cam->capture.available_buf	= i+1;
+	}else
+	{
+		req->count			= i-1;
+		cam->capture.available_buf	= i;
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_query_buf
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_buffer *buf
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_query_buf(cam_data *cam,struct v4l2_buffer *buf)
+{
+
+	if(buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	{
+		printk(KERN_ERR " pxa_cam VIDIOC_QUERYBUF buffer type not supported\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	if (buf->index < 0 || buf->index > cam->capture.available_buf)
+	{
+		printk(KERN_ERR "omap_v4l2_buffer_status buffers not allocated 	\
+				buf index %d buffer available %d\n",buf->index,cam->capture.available_buf);
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	memcpy(buf, &(cam->capture.frame[buf->index].buffer), sizeof(struct v4l2_buffer));
+	
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_queue_buf
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_buffer *buf
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_queue_buf(cam_data *cam,struct v4l2_buffer *buf)
+{
+	UINT32 index		= buf->index;
+
+	if ((cam->capture.frame[index].buffer.flags & 0x7) == V4L2_BUF_FLAG_MAPPED)
+	{
+		cam->capture.frame[index].buffer.flags |= V4L2_BUF_FLAG_QUEUED;
+		__link_node(cam->capture.Need_to_be_filled,&cam->capture.frame[index]);
+	}else if(cam->capture.frame[index].buffer.flags & V4L2_BUF_FLAG_QUEUED)
+	{
+		printk(KERN_ERR "VIDIOC_QBUF: buffer already queued\n");
+	}else if(cam->capture.frame[index].buffer.flags & V4L2_BUF_FLAG_DONE)
+	{
+		printk(KERN_DEBUG "VIDIOC_QBUF: buffer overwrite doned\n");
+	}else
+	{
+		printk(KERN_DEBUG "VIDIOC_QBUF: buffer must be mapped before queued\n");
+		return FAIL;
+	}			
+	buf->flags = cam->capture.frame[index].buffer.flags;
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_dqueue_buf
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_buffer *buf
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_dqueue_buf(cam_data *cam,struct v4l2_buffer *buf)
+{
+	UINT32 wait_event_ret_val;
+
+	struct __capture_dq_buf *current_buf;
+/*
+ * Clear the driver used flags
+ */
+	wait_event_ret_val	= wait_event_interruptible_timeout(	cam->capture.capture_frame_complete,		\
+					     				(cam->capture.valid_buf	>= ENABLE),		\
+									15 * HZ);
+
+	if(wait_event_ret_val == DISABLE)
+	{
+		TRACE_ERR_AND_RET(-EBUSY);
+	}
+
+	if(cam->capture.filled)
+	{
+		current_buf				= cam->capture.filled;
+		__update_base(cam->capture.filled);
+		current_buf->next			= NULL;
+		current_buf->buffer.flags	       &= ~(V4L2_BUF_FLAG_DONE |V4L2_BUF_FLAG_QUEUED);
+		buf->bytesused				= cam->capture.v2f.fmt.pix.sizeimage;
+		buf->index				= current_buf->buffer.index;
+		buf->flags				= current_buf->buffer.flags;
+		buf->m					= current_buf->buffer.m;
+		buf->timestamp				= current_buf->buffer.timestamp;
+		cam->capture.valid_buf--;
+		return SUCCESS;
+
+	}else
+ 	{
+		TRACE_ERR_AND_RET(-EBUSY);
+ 	}
+ 	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_stream_on
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	INT32 *type
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_stream_on(cam_data *cam,INT32 *type)
+{
+	FNRESLT ret_val;
+
+	if(cam->task.bit.capture	== ENABLE)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+/*
+ * reset the isp 
+ */
+
+	ret_val	= isp_reset(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= isp_configure(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= program_dummy_isp_sdram_addr(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= enable_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= enable_isp_irq0(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	cam->task.bit.capture	= ENABLE;
+ 
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_stream_off
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	INT32 *type
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_stream_off(cam_data *cam,INT32 *type)
+{
+	FNRESLT	ret_val;
+	UINT32	i;
+
+	ret_val	= disable_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	ret_val	= disable_isp_irq0(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+/*
+ * Free the allocated buffers
+ */
+
+	for(i = 0;i < MAX_FRAME_SUPPORT;i++)
+	{
+		if(cam->capture.frame[i].buffer.m.offset)
+		{
+			ret_val	= free_phy_mem(cam->capture.frame[i].buffer.m.offset);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+			cam->capture.frame[i].buffer.m.offset		= DISABLE;
+		}
+		memset(&cam->capture.frame[i],DISABLE,sizeof(struct __capture_dq_buf));
+	}
+
+	cam->task.bit.capture		= DISABLE;
+	cam->capture.valid_buf		= DISABLE;
+	cam->capture.available_buf	= DISABLE;
+
+	cam->capture.Need_to_be_filled	= NULL;
+	cam->capture.filled		= NULL;
+	cam->capture.processing		= NULL;
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_enum_fmt
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_fmtdesc *fmt
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_enum_fmt(cam_data *cam,struct v4l2_fmtdesc *fmt)
+{
+	if(cam->cam_sensor.total_fmt_desc <= fmt->index)
+	{
+		TRACE_ERR_AND_RET(-EINVAL);
+	}
+	
+	if(fmt->type	!= cam->cam_sensor.formats[fmt->index].type)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	memcpy(fmt,&cam->cam_sensor.formats[fmt->index],sizeof(struct v4l2_fmtdesc));
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/ov3640/sens_ov3640.c linux-ths/drivers/media/video/ecam32/ov3640/sens_ov3640.c
--- linux-org/drivers/media/video/ecam32/ov3640/sens_ov3640.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/ov3640/sens_ov3640.c	2011-12-27 10:29:38.000000000 +0100
@@ -0,0 +1,9988 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.1   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ * 0.0.1.1
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "../inc_header.h"
+
+static UINT32 sens_drive_strength	= DISABLE;
+module_param(sens_drive_strength,int, 0444);
+
+static UINT32 sens_max_pclk		= SENS_MAX_PCLK_SUPPORT;
+module_param(sens_max_pclk,int, 0444);
+
+#define WRITE_BIT(NO_OF_BITS,SHIFT_VAL,REG_VAL,WRITE_VAL) 	\
+	((~(((1<<(NO_OF_BITS))-1)<<(SHIFT_VAL)) & (REG_VAL)) | ((WRITE_VAL) << SHIFT_VAL))
+
+#define WRITE_REG_WITH_OVT_MAST(reg,value,mask) 			\
+{									\
+	UINT8 read_value;						\
+	ov3640_read_reg(reg,&read_value);				\
+	ov3640_write_reg(reg,((read_value & (~mask))| value));		\
+}
+
+#define READ_REG_WITH_OVT_MASK(reg,value,mask)				\
+{									\
+	ov3640_read_reg(reg,value);					\
+	*(value)	= mask & (*value);				\
+}
+
+UINT32 check_sequence = ENABLE;
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_01	
+ *  Name	:	ov3640_init_config
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	:	configure the ov3640 sensor to its default register settings mode	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_init_config(cam_data *cam)
+{
+	FNRESLT ret_val;
+
+	ov3640_write_reg(0x3012 ,0x80);
+	ov3640_write_reg(0x304d ,0x45);
+	ov3640_write_reg(0x30a7 ,0x5e);
+	ov3640_write_reg(0x3087 ,0x16);
+	ov3640_write_reg(0x309C ,0x1a);
+	ov3640_write_reg(0x30a2 ,0xe4);
+	ov3640_write_reg(0x30aa ,0x42);
+	ov3640_write_reg(0x30b0 ,0xff);
+	ov3640_write_reg(0x30b1 ,0xff);
+	/*
+	 * Maximise the drive strength to 4x level
+	 * Note:
+	 *    1x level = 0x10 is default
+	 *    4x level = 0x13 
+	 */
+	if(sens_drive_strength	> 0)
+	{
+		ov3640_write_reg(0x30b2 ,WRITE_BIT(2,0,0x10,sens_drive_strength-1));
+	}else
+	{
+		ov3640_write_reg(0x30b2 ,0x10);
+	}
+
+	ov3640_write_reg(0x300e ,0x32);
+	ov3640_write_reg(0x300f ,0x21);
+	ov3640_write_reg(0x3010 ,0x20);
+	ov3640_write_reg(0x304c ,0x82);
+	ov3640_write_reg(0x3011 ,0x04);
+	ret_val	= ov3640_limit_pclk_max_limit(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+	ov3640_write_reg(0x30d7 ,0x10);
+
+	ov3640_write_reg(0x30d9 ,0x0d);
+	ov3640_write_reg(0x30db ,0x08);
+	ov3640_write_reg(0x3016 ,0x82);
+
+	ov3640_write_reg(0x3018 ,0x38);
+	ov3640_write_reg(0x3019 ,0x30);
+	ov3640_write_reg(0x301a ,0x61);
+	ov3640_write_reg(0x307d ,0x00);
+	ov3640_write_reg(0x3087 ,0x02);
+	ov3640_write_reg(0x3082 ,0x20);
+
+	ov3640_write_reg(0x3015 ,0x12);
+	ov3640_write_reg(0x3014 ,0x0c);
+	ov3640_write_reg(0x3013 ,0xf7);
+
+	ov3640_write_reg(0x303c ,0x08);
+	ov3640_write_reg(0x303d ,0x18);
+	ov3640_write_reg(0x303e ,0x06);
+	ov3640_write_reg(0x303F ,0x0c);
+	ov3640_write_reg(0x3030 ,0x62);	
+	ov3640_write_reg(0x3031 ,0x26);
+	ov3640_write_reg(0x3032 ,0xe6);
+	ov3640_write_reg(0x3033 ,0x6e);
+	ov3640_write_reg(0x3034 ,0xea);
+	ov3640_write_reg(0x3035 ,0xae);
+	ov3640_write_reg(0x3036 ,0xa6);
+	ov3640_write_reg(0x3037 ,0x6a);
+
+	ov3640_write_reg(0x3104 ,0x02);
+	ov3640_write_reg(0x3105 ,0xfd);
+	ov3640_write_reg(0x3106 ,0x00);
+	ov3640_write_reg(0x3107 ,0xff);
+
+	ov3640_write_reg(0x3300 ,0x13);
+	ov3640_write_reg(0x3301 ,0xde);
+
+	ov3640_write_reg(0x3302 ,0xcf);
+
+	ov3640_write_reg(0x3312 ,0x26);
+	ov3640_write_reg(0x3314 ,0x42);
+	ov3640_write_reg(0x3313 ,0x2b);
+	ov3640_write_reg(0x3315 ,0x42);
+	ov3640_write_reg(0x3310 ,0xd0);
+	ov3640_write_reg(0x3311 ,0xbd);
+	ov3640_write_reg(0x330c ,0x18);
+	ov3640_write_reg(0x330d ,0x18);
+	ov3640_write_reg(0x330e ,0x56);
+	ov3640_write_reg(0x330f ,0x5c);
+	ov3640_write_reg(0x330b ,0x1c);
+	ov3640_write_reg(0x3306 ,0x5c);
+	ov3640_write_reg(0x3307 ,0x11);
+
+	ov3640_write_reg(0x336a ,0x52);
+	ov3640_write_reg(0x3370 ,0x44);
+	ov3640_write_reg(0x3376 ,0x40);
+	ov3640_write_reg(0x3300 ,0x13);
+
+	ov3640_write_reg(0x30b8 ,0x20);
+	ov3640_write_reg(0x30b9 ,0x17);
+	ov3640_write_reg(0x30ba ,0x04);
+	ov3640_write_reg(0x30bb ,0x08);
+
+	ov3640_write_reg(0x3500 ,0x00);
+	ov3640_write_reg(0x3507 ,0x06);
+	ov3640_write_reg(0x350a ,0x4f);
+	ov3640_write_reg(0x3610 ,0x60);
+
+	ov3640_write_reg(0x3100 ,0x32);
+	ov3640_write_reg(0x363d ,0x60);
+
+	ov3640_write_reg(0x3301 ,0xde);
+	ov3640_write_reg(0x3304 ,0x00);
+	ov3640_write_reg(0x3400 ,0x00);
+	ov3640_write_reg(0x3404 ,0x00);
+	ov3640_write_reg(0x3600 ,0xc0);
+
+	ov3640_write_reg(0x3011 ,0x04);
+	ov3640_write_reg(0x304c ,0x81);
+	ret_val	= ov3640_limit_pclk_max_limit(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	ov3640_write_reg(0x335f ,0x68);
+	ov3640_write_reg(0x3360 ,0x18);
+	ov3640_write_reg(0x3361 ,0x0c);
+	ov3640_write_reg(0x3362 ,0x46);
+	ov3640_write_reg(0x3363 ,0x48);
+	ov3640_write_reg(0x3364 ,0xb4);
+
+	ov3640_write_reg(0x3012 ,0x00);
+	ov3640_write_reg(0x3020 ,0x01);
+	ov3640_write_reg(0x3021 ,0x1d);
+	ov3640_write_reg(0x3022 ,0x00);
+	ov3640_write_reg(0x3023 ,0x0a);
+	ov3640_write_reg(0x3024 ,0x08);
+	ov3640_write_reg(0x3025 ,0x18);
+	ov3640_write_reg(0x3026 ,0x06);
+	ov3640_write_reg(0x3027 ,0x0c);
+	ov3640_write_reg(0x302a ,0x06);
+	ov3640_write_reg(0x302b ,0x20);
+	ov3640_write_reg(0x3075 ,0x44);
+	ov3640_write_reg(0x300d ,0x00);
+	ov3640_write_reg(0x30d7 ,0x10);
+	ov3640_write_reg(0x3069 ,0x44);
+	ov3640_write_reg(0x303e ,0x01);
+	ov3640_write_reg(0x303f ,0x80);
+
+	ov3640_write_reg(0x3302 ,0xef);
+	ov3640_write_reg(0x335f ,0x68);
+	ov3640_write_reg(0x3360 ,0x18);
+	ov3640_write_reg(0x3361 ,0x0c);
+
+	ov3640_write_reg(0x3404 ,0x02);
+	ov3640_write_reg(0x3100 ,0x02);
+
+
+	return SUCCESS;
+}
+
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION					MODULE ID	: SENS_OV3640_02	
+ *  Name	:	configure_dimention_change
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Configure the mode of streaming (QXGA (or) XGA) based on the Image dimension  
+ *  			request given by driver.
+ *
+ *  Comments	:  	Ov3640 supports two modes XGA and QXGA 
+ *
+ *  			In XGA mode upto maximum of 30 fps be acheived.
+ *  			In QXGA mode upto maximum of 15 fps be acheived.
+ ************************************************************************************************************/
+FNRESLT configure_dimention_change(cam_data *cam)
+{
+	static INT32 width,height,old_logic_case;
+	UINT32 logic_case;
+	FNRESLT ret_val;
+
+	if(	(cam->cam_sensor.fmt.fmt.pix.width <= MODE_XGA_WIDTH) && 	\
+		(cam->cam_sensor.fmt.fmt.pix.height <= MODE_XGA_HEIGHT))
+	{
+		logic_case	= 1;
+	}else
+	{
+		logic_case	= 2;
+	}
+
+
+	if(	 old_logic_case == logic_case)
+	{
+		return SUCCESS;
+	}else
+	{
+		old_logic_case	= logic_case;
+		width		= cam->cam_sensor.fmt.fmt.pix.width;
+		height		= cam->cam_sensor.fmt.fmt.pix.height;
+	}
+	
+
+	switch(logic_case)
+	{
+		case 1:
+		{
+			ov3640_write_reg(0x3012, 0x10);
+			ov3640_write_reg(0x3023, 0x06);
+			ov3640_write_reg(0x3026, 0x03);
+			ov3640_write_reg(0x3027, 0x04);
+
+			ov3640_write_reg(0x302a, 0x03);
+			ov3640_write_reg(0x302b, 0x10);
+			ov3640_write_reg(0x3075, 0x24);
+			ov3640_write_reg(0x300d, 0x01);
+			ov3640_write_reg(0x30d7, 0x90);
+			ov3640_write_reg(0x3069, 0x04);
+			ov3640_write_reg(0x303e, 0x00);
+			ov3640_write_reg(0x303f, 0xc0);
+			ov3640_write_reg(0x3302, 0xef);
+			ov3640_write_reg(0x335f, 0x34);
+			ov3640_write_reg(0x3360, 0x0c);
+			ov3640_write_reg(0x3361, 0x04);
+			ov3640_write_reg(0x3362, 0x34);
+			ov3640_write_reg(0x3363, 0x08);
+			ov3640_write_reg(0x3364, 0x04);
+			ov3640_write_reg(0x3403, 0x42);
+			ov3640_write_reg(0x3088, 0x04);
+			ov3640_write_reg(0x3089, 0x00);
+			ov3640_write_reg(0x308a, 0x03);
+			ov3640_write_reg(0x308b, 0x00);
+			ov3640_write_reg(0x300e, 0x32);
+			ov3640_write_reg(0x300f, 0x21);
+			ov3640_write_reg(0x3010, 0x20);
+			ov3640_write_reg(0x304c, 0x82);
+			ov3640_write_reg(0x3011, 0x00);
+			ret_val	= ov3640_limit_pclk_max_limit(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);		
+			}
+		}break;
+
+		case 2:
+		default:
+		{
+			ov3640_write_reg(0x3100 ,0x32);
+			ov3640_write_reg(0x363d ,0x60);
+
+			ov3640_write_reg(0x3301 ,0xde);
+			ov3640_write_reg(0x3304 ,0x00);
+			ov3640_write_reg(0x3400 ,0x00);
+			ov3640_write_reg(0x3404 ,0x00);
+			ov3640_write_reg(0x3600 ,0xc0);
+
+			ov3640_write_reg(0x3011 ,0x01);
+			ov3640_write_reg(0x304c ,0x81);
+			ret_val	= ov3640_limit_pclk_max_limit(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+
+			ov3640_write_reg(0x335f ,0x68);
+			ov3640_write_reg(0x3360 ,0x18);
+			ov3640_write_reg(0x3361 ,0x0c);
+			ov3640_write_reg(0x3362 ,0x46);
+			ov3640_write_reg(0x3363 ,0x48);
+			ov3640_write_reg(0x3364 ,0xb4);
+
+			ov3640_write_reg(0x3012 ,0x00);
+			ov3640_write_reg(0x3020 ,0x01);
+			ov3640_write_reg(0x3021 ,0x1d);
+			ov3640_write_reg(0x3022 ,0x00);
+			ov3640_write_reg(0x3023 ,0x0a);
+			ov3640_write_reg(0x3024 ,0x08);
+			ov3640_write_reg(0x3025 ,0x18);
+			ov3640_write_reg(0x3026 ,0x06);
+			ov3640_write_reg(0x3027 ,0x0c);
+			ov3640_write_reg(0x302a ,0x06);
+			ov3640_write_reg(0x302b ,0x20);
+			ov3640_write_reg(0x3075 ,0x44);
+			ov3640_write_reg(0x300d ,0x00);
+			ov3640_write_reg(0x30d7 ,0x10);
+			ov3640_write_reg(0x3069 ,0x44);
+			ov3640_write_reg(0x303e ,0x01);
+			ov3640_write_reg(0x303f ,0x80);
+
+			ov3640_write_reg(0x3302 ,0xef);
+			ov3640_write_reg(0x335f ,0x68);
+			ov3640_write_reg(0x3360 ,0x18);
+			ov3640_write_reg(0x3361 ,0x0c);
+
+			ov3640_write_reg(0x3404 ,0x02);
+			ov3640_write_reg(0x3100 ,0x02);
+			break;
+		}
+	}
+
+	ov3640_write_reg(0x3100 ,0x02);
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	restore_camera_config
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	:
+ ************************************************************************************************************/
+FNRESLT restore_camera_config(cam_data *cam)
+{
+	FNRESLT	ret_val;
+	UINT32 i;
+
+	typedef FNRESLT (*camera_register_dump) (cam_data *cam);
+	struct __restore_data
+	{
+		INT32 restore_id;
+		camera_register_dump restore_fnptr;
+	};
+
+	struct __restore_data restore[]	= 	 						
+	{	 										
+		{V4L2_CID_BRIGHTNESS,			cam->cam_sensor.brightness},		
+		{V4L2_CID_CONTRAST,			cam->cam_sensor.contrast},		
+		{V4L2_CID_SATURATION,			cam->cam_sensor.saturation},		
+		{V4L2_CID_HUE,				cam->cam_sensor.hue},			
+		{V4L2_CID_WHITE_BALANCE_TEMPERATURE,	cam->cam_sensor.whitebalance},		
+//		{V4L2_CID_EXPOSURE,			cam->cam_sensor.exposure},		
+		{V4L2_CID_VFLIP,			cam->cam_sensor.v_flip},		
+		{V4L2_CID_HFLIP,			cam->cam_sensor.h_mirror},		
+		{V4L2_CID_SHARPNESS,			cam->cam_sensor.sharpness},		
+//		{V4L2_CID_FOCUS_ABSOLUTE,		cam->cam_sensor.focus},			
+		{V4L2_SENS_TEST_PATTERN,		cam->cam_sensor.test_color_pattern},	
+		{V4L2_SENS_EFFECTS,			cam->cam_sensor.effects},		
+	};
+
+
+	for(i=0;i<(sizeof(restore)/sizeof(restore[0]));i++)
+	{
+		cam->cmd	= RESTORE_DATA;
+		cam->ctrl.id	= restore[i].restore_id;
+		if(restore[i].restore_fnptr)
+		{
+			ret_val	= restore[i].restore_fnptr(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_03
+ *  Name	:	ov3640_change_dim_config
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Configure the image width and height to the sensor
+ *
+ *  Comments	:  	Based on the driver request, changing the pixelformat also be performed here.
+ *  			Note:
+ *  				bfw_count be added for intel pxa based processor to overcome the loss of 
+ *  				first line
+ ************************************************************************************************************/
+FNRESLT ov3640_change_dim_config(cam_data *cam)
+{
+	static INT32 old_width,old_height;
+	UINT16 width,height,bfw_count	= 2;
+	FNRESLT ret_val;
+
+	UINT8 y_start	= 2;
+	UINT8 x_start	= 4;
+#if 0 
+	static INT32 focus_box	= ENABLE;
+	if(focus_box == ENABLE)
+	{
+		ov3640_write_reg(0x3F00 ,0x04);
+		ov3640_write_reg(0x3F00 ,0x01);
+		focus_box = DISABLE;
+	}else
+	{
+		ov3640_write_reg(0x3F00 ,0x02);
+		focus_box = ENABLE;
+	}
+#endif
+	if(cam->cam_sensor.fix_fmt_support)
+	{
+		ret_val	= cam->cam_sensor.fix_fmt_support(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+
+	if(	(cam->cam_sensor.fmt.fmt.pix.width == MODE_XGA_WIDTH) && 		\
+		(cam->cam_sensor.fmt.fmt.pix.height == MODE_XGA_HEIGHT))
+	{
+	        width	= cam->cam_sensor.fmt.fmt.pix.width + x_start +4;
+        	height	= cam->cam_sensor.fmt.fmt.pix.height+ y_start +2;
+	}else
+	{
+		width	= cam->cam_sensor.fmt.fmt.pix.width + x_start +4;
+        	height	= cam->cam_sensor.fmt.fmt.pix.height+ y_start +2 +bfw_count;
+	}
+
+	if((width == old_width) && (height == old_height))
+	{
+		goto config_pix_format_dump;
+	}else
+	{
+		old_width	= width;
+		old_height	= height;
+	}
+
+	ret_val	= configure_dimention_change(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	ov3640_write_reg(0x3362 ,((height & 0xFF00)>>4) | ((width & 0xFF00)>>8));
+	ov3640_write_reg(0x3363 ,(width & 0xFF));
+	ov3640_write_reg(0x3364 ,(height & 0xFF));
+	ov3640_write_reg(0x3403 ,((x_start<<4)|y_start));
+	ov3640_write_reg(0x3088 ,(cam->cam_sensor.fmt.fmt.pix.width & 0xFF00)>>8);
+	ov3640_write_reg(0x3089 ,(cam->cam_sensor.fmt.fmt.pix.width & 0xFF));
+	ov3640_write_reg(0x308a ,((cam->cam_sensor.fmt.fmt.pix.height+bfw_count)& 0xFF00)>>8);
+	ov3640_write_reg(0x308b ,((cam->cam_sensor.fmt.fmt.pix.height+bfw_count)& 0xFF));
+
+/*
+ * Update the autofocus driver that the width and height of the sensor be changed
+ */
+	ov3640_write_reg(0x3f00 ,0x09);
+
+	config_pix_format_dump:
+	{
+		switch(cam->cam_sensor.fmt.fmt.pix.pixelformat)
+		{
+			case V4L2_PIX_FMT_UYVY:
+			default:
+			{
+				ov3640_write_reg(0x3400 ,0x00);
+				ov3640_write_reg(0x3404 ,0x02);
+			}break;
+
+			case V4L2_PIX_FMT_YUYV:
+			{
+				ov3640_write_reg(0x3400 ,0x00);
+				ov3640_write_reg(0x3404 ,0x00);
+			}break;
+#if 0			
+			case V4L2_PIX_FMT_YUV420:
+			{
+				ov3640_write_reg(0x3400 ,0x00);
+				ov3640_write_reg(0x3404 ,0x08);
+			}break;
+#endif
+			case V4L2_PIX_FMT_YUV444:
+			{
+				ov3640_write_reg(0x3400 ,0x00);
+				ov3640_write_reg(0x3404 ,0x0E);
+			}break;
+
+			case V4L2_PIX_FMT_BGR32:
+			{
+				ov3640_write_reg(0x3400 ,0x01);
+				ov3640_write_reg(0x3404 ,0x1C);
+
+			}break;
+
+			case V4L2_PIX_FMT_RGB555:
+			{
+				ov3640_write_reg(0x3400 ,0x01); 
+				ov3640_write_reg(0x3404 ,0x13);
+			}break;
+
+			case V4L2_PIX_FMT_RGB565:
+			{
+				ov3640_write_reg(0x3400 ,0x01); 
+				ov3640_write_reg(0x3404 ,0x30);
+			}break;	
+
+			case V4L2_PIX_FMT_SBGGR8:
+			{
+				ov3640_write_reg(0x3400 ,0x01);
+				ov3640_write_reg(0x3404 ,0x18);
+			}break;
+		}
+	}
+
+	ret_val	= restore_camera_config(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_20	
+ *  Name	:	ov3640_crop
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 	
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_crop(cam_data *cam)
+{
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->cam_sensor.cropcap.bounds.top = DISABLE;
+			cam->cam_sensor.cropcap.bounds.left = DISABLE;
+			cam->cam_sensor.cropcap.bounds.width = MAX_OV3640_WIDTH;
+			cam->cam_sensor.cropcap.bounds.height = MAX_OV3640_HEIGHT;
+			cam->cam_sensor.cropcap.defrect = cam->cam_sensor.cropcap.bounds;
+			cam->cam_sensor.cropcap.pixelaspect.numerator = 1;
+			cam->cam_sensor.cropcap.pixelaspect.denominator = 1;
+
+		}break;
+		case SET_DATA:
+		{
+
+		}break;
+		case QUERY_DATA:
+		{
+
+		}break;		
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_04	
+ *  Name	:	ov3640_brightness
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 	
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Image brightness from the sensor can be increased (or) decrease
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_brightness(cam_data *cam)
+{
+	static INT32 restore_brightness;
+/*
+ * Value must be in the range of 
+ * -0x30  0x0  0x30
+ *  -48   0   +48
+ */
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT8 reg_value;
+			ov3640_read_reg(0x3354,&reg_value);
+			if(reg_value == 0x08)
+			{
+				ov3640_read_reg(0x335e,&reg_value);
+				cam->ctrl.value	= -reg_value;
+			}else
+			{
+				ov3640_read_reg(0x335e,&reg_value);
+				cam->ctrl.value	= reg_value;
+			}
+			cam->ctrl.value	= (cam->ctrl.value)>48?48:		\
+						(cam->ctrl.value)<-48?-48:	\
+						(cam->ctrl.value);
+			restore_brightness	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_brightness;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= -48) && (cam->ctrl.value <= 48))
+			{
+				if(cam->ctrl.value >= 0)
+				{
+					ov3640_write_reg(0x335e,0xFF & (cam->ctrl.value));
+					WRITE_REG_WITH_OVT_MAST(0x3355, 0x04, 0x04);
+					ov3640_write_reg(0x3354,0x01);
+				}else
+				{
+					ov3640_write_reg(0x335e,0xFF & (-cam->ctrl.value));
+					WRITE_REG_WITH_OVT_MAST(0x3355, 0x04, 0x04);
+					ov3640_write_reg(0x3354,0x08);
+				}
+				restore_brightness	= cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_BRIGHTNESS;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"Brightness",strlen("Brightness"));
+			cam->qctrl.minimum = -48;
+			cam->qctrl.maximum = 48;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_05
+ *  Name	:	ov3640_exposure
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Histogram based exposure algorithm to increase the exposure of the image
+ *  Comments	:  	In ov3640 sensor Average based and Histogram based algorithm be available
+ *  			
+ ************************************************************************************************************/
+FNRESLT ov3640_exposure(cam_data *cam)
+{
+/*
+ * Histogram-based Algorithm
+ * Value must be in the range of 
+ * 0x38 - 0x88
+ *  -40 - +40
+ */
+	static INT32 restore_exposure;
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT8 reg_value;
+			ov3640_read_reg(0x3018,&reg_value);
+			cam->ctrl.value	= reg_value -0x80;
+			cam->ctrl.value	= (cam->ctrl.value)>40?40:		\
+						(cam->ctrl.value)<-40?-40:	\
+						(cam->ctrl.value);
+
+			restore_exposure	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_exposure;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= -40) && (cam->ctrl.value <= 40))
+			{
+				ov3640_write_reg(0x3018, 0x80 + cam->ctrl.value );
+				ov3640_write_reg(0x3019, 0x60 + cam->ctrl.value );
+				restore_exposure	= cam->ctrl.value;
+			}
+
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_EXPOSURE;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"Exposure",strlen("Exposure"));
+			cam->qctrl.minimum = -40;
+			cam->qctrl.maximum = 40;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_06	
+ *  Name	:	ov3640_sharpness
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Image output sharpness from the sensor be increased or decreased. 
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_sharpness(cam_data *cam)
+{
+/*
+ * Value must be in the range of 
+ * 0x42 0x45 0x48
+ *  -3   0   +3
+ */
+	static INT32 restore_sharpness;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT8 reg_value;
+			ov3640_read_reg(0x332d,&reg_value);
+			cam->ctrl.value	= reg_value -0x45;
+			cam->ctrl.value	= (cam->ctrl.value)>3?3:		\
+						(cam->ctrl.value)<-3?-3:	\
+						(cam->ctrl.value);
+
+			restore_sharpness	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_sharpness;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= -3) && (cam->ctrl.value <= 3))
+			{
+				ov3640_write_reg(0x332d, 0x45 + (cam->ctrl.value));
+				ov3640_write_reg(0x332f, 0x03);
+			}else
+			{
+				ov3640_write_reg(0x332d, 0x60);
+				ov3640_write_reg(0x332f, 0x03);
+			}
+			restore_sharpness	= cam->ctrl.value;
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_SHARPNESS;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"sharpness",strlen("sharpness"));
+			cam->qctrl.minimum = -3;
+			cam->qctrl.maximum = 3;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_07
+ *  Name	:	ov3640_effects
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Camera effects supported by the sensor  	
+ *  Comments	:  	Supported effects by the sensor are Sepia,Monochrome,Negative,Bluish,Greenish
+ *  			and Yellowish
+ ************************************************************************************************************/
+
+FNRESLT ov3640_effects(cam_data *cam)
+{
+	static INT32 old_effects_value;
+	static INT32 restore_effects;
+/*
+ * Value must be in the range of 
+ * 0 to 7
+ *
+ * 	Normal			0
+ * 	Sepia(antique)		1
+ * 	Mono chrome		2
+ * 	Negative		3
+ * 	Bluish			4
+ * 	Greenish		5
+ * 	Reddish			6
+ * 	Yellowish		7
+ */
+
+	switch(cam->cmd)
+ 	{
+		case GET_DATA:
+ 		{
+			cam->ctrl.value	= old_effects_value;
+			restore_effects	= cam->ctrl.value;
+ 		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_effects;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+ 		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 7))
+			{
+				old_effects_value	= cam->ctrl.value;
+				switch(cam->ctrl.value)
+				{
+					case EFFECT_NORMAL:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x00, 0x58);
+					}break;
+
+					case EFFECT_SEPIA:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0x40);
+						ov3640_write_reg(0x335b, 0xa6);
+					}break;
+
+					case EFFECT_MONOCHROME:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0x80);
+						ov3640_write_reg(0x335b, 0x80);
+					}break;
+
+					case EFFECT_NEGATIVE:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x40, 0x40); // bit[6] negative
+					}break;
+
+					case EFFECT_BLUISH:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0xa0);
+						ov3640_write_reg(0x335b, 0x40);
+					}break;
+
+					case EFFECT_GREENISH:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0x60);
+						ov3640_write_reg(0x335b, 0x60);
+					}break;
+
+					case EFFECT_REDDISH:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0x80);
+						ov3640_write_reg(0x335b, 0xc0);
+					}break;
+
+					case EFFECT_YELLOWISH:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0x30);
+						ov3640_write_reg(0x335b, 0x90);
+					}break;
+				}
+				restore_effects	= cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+ 		{
+			cam->qctrl.id	= V4L2_SENS_EFFECTS;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"effects",strlen("effects"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 7;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_08
+ *  Name	:	ov3640_saturation
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Image output saturation from the sensor be increased or decreased.
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_saturation(cam_data *cam)
+{
+	static INT32 restore_saturation;
+
+/*
+ * Value must be in the range of 
+ * 0x10 0x20 0x70
+ *  -48   0   +48
+ */
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT8 reg_value;
+			ov3640_read_reg(0x3358,&reg_value);
+			cam->ctrl.value	= reg_value - 0x30;
+			cam->ctrl.value	= (cam->ctrl.value)>48?48:		\
+						(cam->ctrl.value)<-48?-48:	\
+						(cam->ctrl.value);
+			restore_saturation = cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_saturation;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= -48) && (cam->ctrl.value <= 48))
+			{
+				ov3640_write_reg(0x3302, 0xef);
+				WRITE_REG_WITH_OVT_MAST(0x3355, 0x02, 0x02);
+				ov3640_write_reg(0x3358, 0x30 + (cam->ctrl.value));
+				ov3640_write_reg(0x3359, 0x30 + (cam->ctrl.value));
+				restore_saturation = cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_SATURATION;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"saturation",strlen("saturation"));
+			cam->qctrl.minimum = -48;
+			cam->qctrl.maximum = 48;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_09
+ *  Name	:	ov3640_contrast
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Image output contrast from the sensor be increased or decreased.
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_contrast(cam_data *cam)
+{
+	static INT32 restore_contrast;
+
+/*
+ * Value must be in the range of 
+ * 0x14 0x20 0x2c
+ * -12   0   12
+ */
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT8 reg_value;
+			ov3640_read_reg(0x335c,&reg_value);
+			cam->ctrl.value	= reg_value - 0x20;
+			cam->ctrl.value	= (cam->ctrl.value)>12?12:		\
+						(cam->ctrl.value)<-12?-12:	\
+						(cam->ctrl.value);
+			restore_contrast = cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_contrast;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= -12) && (cam->ctrl.value <= 12))
+			{
+				ov3640_write_reg(0x3302, 0xef);
+				WRITE_REG_WITH_OVT_MAST(0x3355, 0x04, 0x04);
+//				ov3640_write_reg(0x3354, 0x01);
+				ov3640_write_reg(0x335c, 0x20 + (cam->ctrl.value));
+				ov3640_write_reg(0x335d, 0x20 + (cam->ctrl.value));
+				restore_contrast = cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_CONTRAST;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"contrast",strlen("contrast"));
+			cam->qctrl.minimum = -12;
+			cam->qctrl.maximum = 12;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_10
+ *  Name	:	planckian_locus_lookuptable
+ *  Parameter1	:	INT32 value	- Temperature of the source.
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	:	Adjust the whilebalance of the sensor based on envionment source temperature		
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT planckian_locus_lookuptable(INT32 value)
+{
+	typedef struct _aw_temp_gain_adj
+	{
+		UINT32 temp;
+		UINT8 r;
+		UINT8 g;
+		UINT8 b;
+	}aw_gain_adj;
+
+	aw_gain_adj temp_aw_gain[]	=	{				\
+							{3000,0x44,0x40,0x70},	\
+							{4000,0x52,0x40,0x48},	\
+							{5000,0x68,0x40,0x4e},	\
+							{6000,0x5e,0x40,0x46}	\
+						}; 
+
+	UINT32 i	= DISABLE;
+
+	if(value == ENABLE)
+	{
+		WRITE_REG_WITH_OVT_MAST(0x3308, 0x00, 0x80);
+		WRITE_REG_WITH_OVT_MAST(0x332b, 0x00, 0x08);
+	}else if(value == DISABLE)
+	{
+		WRITE_REG_WITH_OVT_MAST(0x3308, 0x80, 0x80);
+		WRITE_REG_WITH_OVT_MAST(0x332b, 0x00, 0x08);
+	}else
+	{
+		WRITE_REG_WITH_OVT_MAST(0x3308, 0x80, 0x80);
+		WRITE_REG_WITH_OVT_MAST(0x332b, 0x08, 0x08);
+		for(i	= DISABLE; i < (sizeof(temp_aw_gain)/sizeof(temp_aw_gain[0]));i++)
+		{
+			if(temp_aw_gain[i].temp == value)
+			{
+				ov3640_write_reg(0x33a7,temp_aw_gain[i].r);
+				ov3640_write_reg(0x33a8,temp_aw_gain[i].g);
+				ov3640_write_reg(0x33a9,temp_aw_gain[i].b);
+				break;
+			}
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_11	
+ *  Name	:	ov3640_white_balance
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Image Whitebalance settings from the sensor
+ *  Comments	:  	Auto White balance, Daylight,Tungsten,Fluorescent and cloudy settings are 
+ *  			available 
+ ************************************************************************************************************/
+FNRESLT ov3640_white_balance(cam_data *cam)
+{
+	FNRESLT ret_val;
+	static INT32 restore_white_balance = ENABLE;
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_AUTO_WHITE_BALANCE:
+				case V4L2_CID_DO_WHITE_BALANCE:
+				case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+				{
+					cam->ctrl.value	= restore_white_balance;
+				}break;
+			}
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_white_balance;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_AUTO_WHITE_BALANCE:
+				{
+					if(cam->ctrl.value)
+					{
+						restore_white_balance = ENABLE;
+					}else
+					{
+						restore_white_balance = DISABLE;
+						cam->ctrl.value = DISABLE;
+					}
+				}break;
+
+				case V4L2_CID_DO_WHITE_BALANCE:
+				{
+					restore_white_balance = DISABLE;
+					cam->ctrl.value = DISABLE;
+				}break;
+
+				case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+				{
+					if((cam->ctrl.value >=3000) && (cam->ctrl.value <=6000))
+					{
+						cam->ctrl.value-=cam->ctrl.value%1000;
+						restore_white_balance = cam->ctrl.value;
+					}
+				}break;
+			}
+			ret_val	= planckian_locus_lookuptable(cam->ctrl.value);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+
+		}break;
+
+		case QUERY_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+				{
+					cam->qctrl.id	= V4L2_CID_WHITE_BALANCE_TEMPERATURE;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+					strncpy(cam->qctrl.name,"White balance temperature",strlen("White balance temperature"));
+					cam->qctrl.minimum = 3000;
+					cam->qctrl.maximum = 6000;
+					cam->qctrl.step = 1000;
+					cam->qctrl.default_value = 1;
+					cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+				}break;
+			}
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_12	
+ *  Name	:	ov3640_vertical_flip
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Change the Image display order - Vertical flip 
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_vertical_flip(cam_data *cam)
+{
+	UINT8 reg_value;
+	static INT32 restore_vflip	= CONFIG_OV3640_DEFAULT_FLIP;
+	ov3640_read_reg(0x307c,&reg_value);
+	
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			if(reg_value & (0x1 <<0))
+			{
+				cam->ctrl.value = ENABLE;
+			}else
+			{
+				cam->ctrl.value	= DISABLE;
+			}
+			restore_vflip	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_vflip;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if(cam->ctrl.value)
+			{
+				reg_value = (reg_value |(0x1<<0));
+			}else
+			{
+				reg_value &=  ~((0x1<<0));
+			}
+			ov3640_write_reg(0x307c,reg_value);
+			restore_vflip	= cam->ctrl.value;
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_VFLIP;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"Vertical flip",strlen("Vertical flip"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = CONFIG_OV3640_DEFAULT_FLIP;
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_13	
+ *  Name	:	ov3640_horizontal_mirror
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Change the Image display order - Horizontal mirror
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_horizontal_mirror(cam_data *cam)
+{
+	UINT8 reg_value;
+	static INT32 restore_horizontal_mirror = CONFIG_OV3640_DEFAULT_MIRROR;
+	ov3640_read_reg(0x3090,&reg_value);
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			if(reg_value & (0x1 <<3))
+			{
+				cam->ctrl.value = ENABLE;
+			}else
+			{
+				cam->ctrl.value	= DISABLE;
+			}
+			restore_horizontal_mirror	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_horizontal_mirror;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if(cam->ctrl.value)
+			{
+				reg_value = (reg_value |(0x1<<3));
+			}else
+			{
+				reg_value &=  ~((0x1<<3));
+			}
+			ov3640_write_reg(0x3090,reg_value);
+			restore_horizontal_mirror	= cam->ctrl.value;
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_HFLIP;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"Horizontal mirror",strlen("Horizontal mirror"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = CONFIG_OV3640_DEFAULT_MIRROR;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_21
+ *
+ *  Name	:	ov3640_antishake_firmware_ctrl
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Auto focus firmware register dump
+ *  Comments	:  	Before performing autofocus related operations -Auto focus firmware dump should be 
+ *  			applied
+ ************************************************************************************************************/
+
+FNRESLT ov3640_antishake_firmware_ctrl(cam_data *cam)
+{
+	switch(cam->cmd)
+	{	
+		case GET_DATA:
+		{
+			UINT8 reg_value	= DISABLE;
+			switch(cam->ctrl.id)
+			{
+				case V4L2_SENS_ANTISHAKE_STATUS:
+				{
+					ov3640_read_reg(0x3f07,&reg_value);
+					cam->ctrl.value	= reg_value;
+				}break;
+			}
+
+		}break;
+
+		case SET_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_SENS_ANTISHAKE:
+				{
+					ov3640_write_reg(0x308c,0x00);
+					ov3640_write_reg(0x3104,0x02);
+					ov3640_write_reg(0x3105,0xff);
+					ov3640_write_reg(0x3106,0x00);
+					ov3640_write_reg(0x3107,0xff);
+					ov3640_write_reg(0x8000,0x02);
+					ov3640_write_reg(0x8001,0x07);
+					ov3640_write_reg(0x8002,0xE0);
+					ov3640_write_reg(0x8003,0x02);
+					ov3640_write_reg(0x8004,0x00);
+					ov3640_write_reg(0x8005,0x06);
+					ov3640_write_reg(0x8006,0xC0);
+					ov3640_write_reg(0x8007,0xE0);
+					ov3640_write_reg(0x8008,0xC0);
+					ov3640_write_reg(0x8009,0xF0);
+					ov3640_write_reg(0x800A,0xC0);
+					ov3640_write_reg(0x800B,0x83);
+					ov3640_write_reg(0x800C,0xC0);
+					ov3640_write_reg(0x800D,0x82);
+					ov3640_write_reg(0x800E,0xC0);
+					ov3640_write_reg(0x800F,0xD0);
+					ov3640_write_reg(0x8010,0x75);
+					ov3640_write_reg(0x8011,0xD0);
+					ov3640_write_reg(0x8012,0x00);
+					ov3640_write_reg(0x8013,0xC0);
+					ov3640_write_reg(0x8014,0x00);
+					ov3640_write_reg(0x8015,0xC0);
+					ov3640_write_reg(0x8016,0x04);
+					ov3640_write_reg(0x8017,0xC0);
+					ov3640_write_reg(0x8018,0x05);
+					ov3640_write_reg(0x8019,0xC0);
+					ov3640_write_reg(0x801A,0x06);
+					ov3640_write_reg(0x801B,0xC0);
+					ov3640_write_reg(0x801C,0x07);
+					ov3640_write_reg(0x801D,0x90);
+					ov3640_write_reg(0x801E,0x37);
+					ov3640_write_reg(0x801F,0x08);
+					ov3640_write_reg(0x8020,0xE0);
+					ov3640_write_reg(0x8021,0x20);
+					ov3640_write_reg(0x8022,0xE3);
+					ov3640_write_reg(0x8023,0x03);
+					ov3640_write_reg(0x8024,0x02);
+					ov3640_write_reg(0x8025,0x02);
+					ov3640_write_reg(0x8026,0x05);
+					ov3640_write_reg(0x8027,0x90);
+					ov3640_write_reg(0x8028,0x3F);
+					ov3640_write_reg(0x8029,0x01);
+					ov3640_write_reg(0x802A,0xE0);
+					ov3640_write_reg(0x802B,0x04);
+					ov3640_write_reg(0x802C,0xF0);
+					ov3640_write_reg(0x802D,0x30);
+					ov3640_write_reg(0x802E,0x0D);
+					ov3640_write_reg(0x802F,0x03);
+					ov3640_write_reg(0x8030,0x02);
+					ov3640_write_reg(0x8031,0x01);
+					ov3640_write_reg(0x8032,0xFB);
+					ov3640_write_reg(0x8033,0x30);
+					ov3640_write_reg(0x8034,0x0A);
+					ov3640_write_reg(0x8035,0x07);
+					ov3640_write_reg(0x8036,0x90);
+					ov3640_write_reg(0x8037,0x30);
+					ov3640_write_reg(0x8038,0xB4);
+					ov3640_write_reg(0x8039,0xE0);
+					ov3640_write_reg(0x803A,0x44);
+					ov3640_write_reg(0x803B,0x08);
+					ov3640_write_reg(0x803C,0xF0);
+					ov3640_write_reg(0x803D,0x05);
+					ov3640_write_reg(0x803E,0x45);
+					ov3640_write_reg(0x803F,0xE5);
+					ov3640_write_reg(0x8040,0x45);
+					ov3640_write_reg(0x8041,0x70);
+					ov3640_write_reg(0x8042,0x03);
+					ov3640_write_reg(0x8043,0x75);
+					ov3640_write_reg(0x8044,0x45);
+					ov3640_write_reg(0x8045,0x01);
+					ov3640_write_reg(0x8046,0x90);
+					ov3640_write_reg(0x8047,0x3A);
+					ov3640_write_reg(0x8048,0x00);
+					ov3640_write_reg(0x8049,0x74);
+					ov3640_write_reg(0x804A,0x80);
+					ov3640_write_reg(0x804B,0xF0);
+					ov3640_write_reg(0x804C,0x90);
+					ov3640_write_reg(0x804D,0x3A);
+					ov3640_write_reg(0x804E,0x03);
+					ov3640_write_reg(0x804F,0xE0);
+					ov3640_write_reg(0x8050,0xF5);
+					ov3640_write_reg(0x8051,0x51);
+					ov3640_write_reg(0x8052,0xE0);
+					ov3640_write_reg(0x8053,0xF5);
+					ov3640_write_reg(0x8054,0x53);
+					ov3640_write_reg(0x8055,0xE0);
+					ov3640_write_reg(0x8056,0xF5);
+					ov3640_write_reg(0x8057,0x55);
+					ov3640_write_reg(0x8058,0xE0);
+					ov3640_write_reg(0x8059,0xF5);
+					ov3640_write_reg(0x805A,0x57);
+					ov3640_write_reg(0x805B,0xE0);
+					ov3640_write_reg(0x805C,0xF5);
+					ov3640_write_reg(0x805D,0x52);
+					ov3640_write_reg(0x805E,0xE0);
+					ov3640_write_reg(0x805F,0xF5);
+					ov3640_write_reg(0x8060,0x54);
+					ov3640_write_reg(0x8061,0xE0);
+					ov3640_write_reg(0x8062,0xF5);
+					ov3640_write_reg(0x8063,0x56);
+					ov3640_write_reg(0x8064,0xE0);
+					ov3640_write_reg(0x8065,0xF5);
+					ov3640_write_reg(0x8066,0x58);
+					ov3640_write_reg(0x8067,0xE5);
+					ov3640_write_reg(0x8068,0x55);
+					ov3640_write_reg(0x8069,0xF5);
+					ov3640_write_reg(0x806A,0x27);
+					ov3640_write_reg(0x806B,0xE5);
+					ov3640_write_reg(0x806C,0x53);
+					ov3640_write_reg(0x806D,0xF5);
+					ov3640_write_reg(0x806E,0x28);
+					ov3640_write_reg(0x806F,0xE5);
+					ov3640_write_reg(0x8070,0x72);
+					ov3640_write_reg(0x8071,0x64);
+					ov3640_write_reg(0x8072,0x01);
+					ov3640_write_reg(0x8073,0x60);
+					ov3640_write_reg(0x8074,0x03);
+					ov3640_write_reg(0x8075,0x02);
+					ov3640_write_reg(0x8076,0x01);
+					ov3640_write_reg(0x8077,0x18);
+					ov3640_write_reg(0x8078,0x20);
+					ov3640_write_reg(0x8079,0x0A);
+					ov3640_write_reg(0x807A,0x03);
+					ov3640_write_reg(0x807B,0x02);
+					ov3640_write_reg(0x807C,0x01);
+					ov3640_write_reg(0x807D,0x24);
+					ov3640_write_reg(0x807E,0x20);
+					ov3640_write_reg(0x807F,0x0A);
+					ov3640_write_reg(0x8080,0x03);
+					ov3640_write_reg(0x8081,0x02);
+					ov3640_write_reg(0x8082,0x01);
+					ov3640_write_reg(0x8083,0xFB);
+					ov3640_write_reg(0x8084,0x20);
+					ov3640_write_reg(0x8085,0x09);
+					ov3640_write_reg(0x8086,0x3F);
+					ov3640_write_reg(0x8087,0x75);
+					ov3640_write_reg(0x8088,0x26);
+					ov3640_write_reg(0x8089,0x00);
+					ov3640_write_reg(0x808A,0x12);
+					ov3640_write_reg(0x808B,0x06);
+					ov3640_write_reg(0x808C,0x5F);
+					ov3640_write_reg(0x808D,0x25);
+					ov3640_write_reg(0x808E,0x5A);
+					ov3640_write_reg(0x808F,0xF5);
+					ov3640_write_reg(0x8090,0x5A);
+					ov3640_write_reg(0x8091,0xEE);
+					ov3640_write_reg(0x8092,0x35);
+					ov3640_write_reg(0x8093,0x59);
+					ov3640_write_reg(0x8094,0xF5);
+					ov3640_write_reg(0x8095,0x59);
+					ov3640_write_reg(0x8096,0x05);
+					ov3640_write_reg(0x8097,0x26);
+					ov3640_write_reg(0x8098,0xE5);
+					ov3640_write_reg(0x8099,0x26);
+					ov3640_write_reg(0x809A,0xB4);
+					ov3640_write_reg(0x809B,0x08);
+					ov3640_write_reg(0x809C,0xED);
+					ov3640_write_reg(0x809D,0xE5);
+					ov3640_write_reg(0x809E,0x5A);
+					ov3640_write_reg(0x809F,0xAE);
+					ov3640_write_reg(0x80A0,0x59);
+					ov3640_write_reg(0x80A1,0x78);
+					ov3640_write_reg(0x80A2,0x03);
+					ov3640_write_reg(0x80A3,0xCE);
+					ov3640_write_reg(0x80A4,0xC3);
+					ov3640_write_reg(0x80A5,0x13);
+					ov3640_write_reg(0x80A6,0xCE);
+					ov3640_write_reg(0x80A7,0x13);
+					ov3640_write_reg(0x80A8,0xD8);
+					ov3640_write_reg(0x80A9,0xF9);
+					ov3640_write_reg(0x80AA,0xF5);
+					ov3640_write_reg(0x80AB,0x5A);
+					ov3640_write_reg(0x80AC,0x8E);
+					ov3640_write_reg(0x80AD,0x59);
+					ov3640_write_reg(0x80AE,0xFF);
+					ov3640_write_reg(0x80AF,0x7C);
+					ov3640_write_reg(0x80B0,0x00);
+					ov3640_write_reg(0x80B1,0x7D);
+					ov3640_write_reg(0x80B2,0x03);
+					ov3640_write_reg(0x80B3,0x12);
+					ov3640_write_reg(0x80B4,0x0C);
+					ov3640_write_reg(0x80B5,0xC8);
+					ov3640_write_reg(0x80B6,0xEF);
+					ov3640_write_reg(0x80B7,0x78);
+					ov3640_write_reg(0x80B8,0x02);
+					ov3640_write_reg(0x80B9,0xCE);
+					ov3640_write_reg(0x80BA,0xC3);
+					ov3640_write_reg(0x80BB,0x13);
+					ov3640_write_reg(0x80BC,0xCE);
+					ov3640_write_reg(0x80BD,0x13);
+					ov3640_write_reg(0x80BE,0xD8);
+					ov3640_write_reg(0x80BF,0xF9);
+					ov3640_write_reg(0x80C0,0xF5);
+					ov3640_write_reg(0x80C1,0x4E);
+					ov3640_write_reg(0x80C2,0x8E);
+					ov3640_write_reg(0x80C3,0x4D);
+					ov3640_write_reg(0x80C4,0xD2);
+					ov3640_write_reg(0x80C5,0x09);
+					ov3640_write_reg(0x80C6,0xE5);
+					ov3640_write_reg(0x80C7,0x43);
+					ov3640_write_reg(0x80C8,0xC3);
+					ov3640_write_reg(0x80C9,0x95);
+					ov3640_write_reg(0x80CA,0x44);
+					ov3640_write_reg(0x80CB,0x50);
+					ov3640_write_reg(0x80CC,0x1D);
+					ov3640_write_reg(0x80CD,0xE5);
+					ov3640_write_reg(0x80CE,0x28);
+					ov3640_write_reg(0x80CF,0x95);
+					ov3640_write_reg(0x80D0,0x4E);
+					ov3640_write_reg(0x80D1,0xE5);
+					ov3640_write_reg(0x80D2,0x27);
+					ov3640_write_reg(0x80D3,0x95);
+					ov3640_write_reg(0x80D4,0x4D);
+					ov3640_write_reg(0x80D5,0x40);
+					ov3640_write_reg(0x80D6,0x0E);
+					ov3640_write_reg(0x80D7,0x12);
+					ov3640_write_reg(0x80D8,0x05);
+					ov3640_write_reg(0x80D9,0xD8);
+					ov3640_write_reg(0x80DA,0x40);
+					ov3640_write_reg(0x80DB,0x09);
+					ov3640_write_reg(0x80DC,0x12);
+					ov3640_write_reg(0x80DD,0x05);
+					ov3640_write_reg(0x80DE,0xE2);
+					ov3640_write_reg(0x80DF,0x85);
+					ov3640_write_reg(0x80E0,0x27);
+					ov3640_write_reg(0x80E1,0x4F);
+					ov3640_write_reg(0x80E2,0x85);
+					ov3640_write_reg(0x80E3,0x28);
+					ov3640_write_reg(0x80E4,0x50);
+					ov3640_write_reg(0x80E5,0x05);
+					ov3640_write_reg(0x80E6,0x43);
+					ov3640_write_reg(0x80E7,0x02);
+					ov3640_write_reg(0x80E8,0x01);
+					ov3640_write_reg(0x80E9,0xFB);
+					ov3640_write_reg(0x80EA,0xE5);
+					ov3640_write_reg(0x80EB,0x43);
+					ov3640_write_reg(0x80EC,0xC3);
+					ov3640_write_reg(0x80ED,0x95);
+					ov3640_write_reg(0x80EE,0x44);
+					ov3640_write_reg(0x80EF,0x50);
+					ov3640_write_reg(0x80F0,0x03);
+					ov3640_write_reg(0x80F1,0x02);
+					ov3640_write_reg(0x80F2,0x01);
+					ov3640_write_reg(0x80F3,0xFB);
+					ov3640_write_reg(0x80F4,0x12);
+					ov3640_write_reg(0x80F5,0x05);
+					ov3640_write_reg(0x80F6,0xD8);
+					ov3640_write_reg(0x80F7,0x40);
+					ov3640_write_reg(0x80F8,0x02);
+					ov3640_write_reg(0x80F9,0x80);
+					ov3640_write_reg(0x80FA,0x12);
+					ov3640_write_reg(0x80FB,0xE5);
+					ov3640_write_reg(0x80FC,0x50);
+					ov3640_write_reg(0x80FD,0x45);
+					ov3640_write_reg(0x80FE,0x4F);
+					ov3640_write_reg(0x80FF,0x70);
+					ov3640_write_reg(0x8100,0x0F);
+					ov3640_write_reg(0x8101,0xE5);
+					ov3640_write_reg(0x8102,0x59);
+					ov3640_write_reg(0x8103,0xC3);
+					ov3640_write_reg(0x8104,0x13);
+					ov3640_write_reg(0x8105,0xFE);
+					ov3640_write_reg(0x8106,0xE5);
+					ov3640_write_reg(0x8107,0x5A);
+					ov3640_write_reg(0x8108,0x12);
+					ov3640_write_reg(0x8109,0x06);
+					ov3640_write_reg(0x810A,0x1C);
+					ov3640_write_reg(0x810B,0x40);
+					ov3640_write_reg(0x810C,0x03);
+					ov3640_write_reg(0x810D,0x12);
+					ov3640_write_reg(0x810E,0x05);
+					ov3640_write_reg(0x810F,0xE2);
+					ov3640_write_reg(0x8110,0x90);
+					ov3640_write_reg(0x8111,0x3F);
+					ov3640_write_reg(0x8112,0x04);
+					ov3640_write_reg(0x8113,0xE5);
+					ov3640_write_reg(0x8114,0x43);
+					ov3640_write_reg(0x8115,0x02);
+					ov3640_write_reg(0x8116,0x01);
+					ov3640_write_reg(0x8117,0xED);
+					ov3640_write_reg(0x8118,0xE5);
+					ov3640_write_reg(0x8119,0x72);
+					ov3640_write_reg(0x811A,0x64);
+					ov3640_write_reg(0x811B,0x02);
+					ov3640_write_reg(0x811C,0x60);
+					ov3640_write_reg(0x811D,0x03);
+					ov3640_write_reg(0x811E,0x02);
+					ov3640_write_reg(0x811F,0x01);
+					ov3640_write_reg(0x8120,0xFB);
+					ov3640_write_reg(0x8121,0x20);
+					ov3640_write_reg(0x8122,0x0A);
+					ov3640_write_reg(0x8123,0x33);
+					ov3640_write_reg(0x8124,0x85);
+					ov3640_write_reg(0x8125,0x6E);
+					ov3640_write_reg(0x8126,0x70);
+					ov3640_write_reg(0x8127,0x85);
+					ov3640_write_reg(0x8128,0x6F);
+					ov3640_write_reg(0x8129,0x71);
+					ov3640_write_reg(0x812A,0x85);
+					ov3640_write_reg(0x812B,0x6C);
+					ov3640_write_reg(0x812C,0x6E);
+					ov3640_write_reg(0x812D,0x85);
+					ov3640_write_reg(0x812E,0x6D);
+					ov3640_write_reg(0x812F,0x6F);
+					ov3640_write_reg(0x8130,0x85);
+					ov3640_write_reg(0x8131,0x6A);
+					ov3640_write_reg(0x8132,0x6C);
+					ov3640_write_reg(0x8133,0x85);
+					ov3640_write_reg(0x8134,0x6B);
+					ov3640_write_reg(0x8135,0x6D);
+					ov3640_write_reg(0x8136,0x85);
+					ov3640_write_reg(0x8137,0x68);
+					ov3640_write_reg(0x8138,0x6A);
+					ov3640_write_reg(0x8139,0x85);
+					ov3640_write_reg(0x813A,0x69);
+					ov3640_write_reg(0x813B,0x6B);
+					ov3640_write_reg(0x813C,0x85);
+					ov3640_write_reg(0x813D,0x66);
+					ov3640_write_reg(0x813E,0x68);
+					ov3640_write_reg(0x813F,0x85);
+					ov3640_write_reg(0x8140,0x67);
+					ov3640_write_reg(0x8141,0x69);
+					ov3640_write_reg(0x8142,0x85);
+					ov3640_write_reg(0x8143,0x64);
+					ov3640_write_reg(0x8144,0x66);
+					ov3640_write_reg(0x8145,0x85);
+					ov3640_write_reg(0x8146,0x65);
+					ov3640_write_reg(0x8147,0x67);
+					ov3640_write_reg(0x8148,0x85);
+					ov3640_write_reg(0x8149,0x62);
+					ov3640_write_reg(0x814A,0x64);
+					ov3640_write_reg(0x814B,0x85);
+					ov3640_write_reg(0x814C,0x63);
+					ov3640_write_reg(0x814D,0x65);
+					ov3640_write_reg(0x814E,0x85);
+					ov3640_write_reg(0x814F,0x27);
+					ov3640_write_reg(0x8150,0x62);
+					ov3640_write_reg(0x8151,0x85);
+					ov3640_write_reg(0x8152,0x28);
+					ov3640_write_reg(0x8153,0x63);
+					ov3640_write_reg(0x8154,0x02);
+					ov3640_write_reg(0x8155,0x01);
+					ov3640_write_reg(0x8156,0xFB);
+					ov3640_write_reg(0x8157,0x20);
+					ov3640_write_reg(0x8158,0x0A);
+					ov3640_write_reg(0x8159,0x03);
+					ov3640_write_reg(0x815A,0x02);
+					ov3640_write_reg(0x815B,0x01);
+					ov3640_write_reg(0x815C,0xFB);
+					ov3640_write_reg(0x815D,0x20);
+					ov3640_write_reg(0x815E,0x09);
+					ov3640_write_reg(0x815F,0x36);
+					ov3640_write_reg(0x8160,0x75);
+					ov3640_write_reg(0x8161,0x5F);
+					ov3640_write_reg(0x8162,0x00);
+					ov3640_write_reg(0x8163,0x75);
+					ov3640_write_reg(0x8164,0x60);
+					ov3640_write_reg(0x8165,0x00);
+					ov3640_write_reg(0x8166,0x75);
+					ov3640_write_reg(0x8167,0x5D);
+					ov3640_write_reg(0x8168,0xFF);
+					ov3640_write_reg(0x8169,0x75);
+					ov3640_write_reg(0x816A,0x5E);
+					ov3640_write_reg(0x816B,0xFF);
+					ov3640_write_reg(0x816C,0x75);
+					ov3640_write_reg(0x816D,0x26);
+					ov3640_write_reg(0x816E,0x00);
+					ov3640_write_reg(0x816F,0x12);
+					ov3640_write_reg(0x8170,0x06);
+					ov3640_write_reg(0x8171,0x5F);
+					ov3640_write_reg(0x8172,0xFF);
+					ov3640_write_reg(0x8173,0xC3);
+					ov3640_write_reg(0x8174,0xE5);
+					ov3640_write_reg(0x8175,0x60);
+					ov3640_write_reg(0x8176,0x9F);
+					ov3640_write_reg(0x8177,0xE5);
+					ov3640_write_reg(0x8178,0x5F);
+					ov3640_write_reg(0x8179,0x9E);
+					ov3640_write_reg(0x817A,0x50);
+					ov3640_write_reg(0x817B,0x04);
+					ov3640_write_reg(0x817C,0x8E);
+					ov3640_write_reg(0x817D,0x5F);
+					ov3640_write_reg(0x817E,0x8F);
+					ov3640_write_reg(0x817F,0x60);
+					ov3640_write_reg(0x8180,0xD3);
+					ov3640_write_reg(0x8181,0xE5);
+					ov3640_write_reg(0x8182,0x5E);
+					ov3640_write_reg(0x8183,0x9F);
+					ov3640_write_reg(0x8184,0xE5);
+					ov3640_write_reg(0x8185,0x5D);
+					ov3640_write_reg(0x8186,0x9E);
+					ov3640_write_reg(0x8187,0x40);
+					ov3640_write_reg(0x8188,0x04);
+					ov3640_write_reg(0x8189,0x8E);
+					ov3640_write_reg(0x818A,0x5D);
+					ov3640_write_reg(0x818B,0x8F);
+					ov3640_write_reg(0x818C,0x5E);
+					ov3640_write_reg(0x818D,0x05);
+					ov3640_write_reg(0x818E,0x26);
+					ov3640_write_reg(0x818F,0xE5);
+					ov3640_write_reg(0x8190,0x26);
+					ov3640_write_reg(0x8191,0xB4);
+					ov3640_write_reg(0x8192,0x08);
+					ov3640_write_reg(0x8193,0xDB);
+					ov3640_write_reg(0x8194,0xD2);
+					ov3640_write_reg(0x8195,0x09);
+					ov3640_write_reg(0x8196,0xE5);
+					ov3640_write_reg(0x8197,0x43);
+					ov3640_write_reg(0x8198,0xC3);
+					ov3640_write_reg(0x8199,0x95);
+					ov3640_write_reg(0x819A,0x44);
+					ov3640_write_reg(0x819B,0x50);
+					ov3640_write_reg(0x819C,0x1E);
+					ov3640_write_reg(0x819D,0xE5);
+					ov3640_write_reg(0x819E,0x5F);
+					ov3640_write_reg(0x819F,0xC3);
+					ov3640_write_reg(0x81A0,0x13);
+					ov3640_write_reg(0x81A1,0xFE);
+					ov3640_write_reg(0x81A2,0xE5);
+					ov3640_write_reg(0x81A3,0x60);
+					ov3640_write_reg(0x81A4,0x12);
+					ov3640_write_reg(0x81A5,0x06);
+					ov3640_write_reg(0x81A6,0x1C);
+					ov3640_write_reg(0x81A7,0x40);
+					ov3640_write_reg(0x81A8,0x0E);
+					ov3640_write_reg(0x81A9,0x12);
+					ov3640_write_reg(0x81AA,0x05);
+					ov3640_write_reg(0x81AB,0xD8);
+					ov3640_write_reg(0x81AC,0x40);
+					ov3640_write_reg(0x81AD,0x09);
+					ov3640_write_reg(0x81AE,0x12);
+					ov3640_write_reg(0x81AF,0x05);
+					ov3640_write_reg(0x81B0,0xE2);
+					ov3640_write_reg(0x81B1,0x85);
+					ov3640_write_reg(0x81B2,0x27);
+					ov3640_write_reg(0x81B3,0x4F);
+					ov3640_write_reg(0x81B4,0x85);
+					ov3640_write_reg(0x81B5,0x28);
+					ov3640_write_reg(0x81B6,0x50);
+					ov3640_write_reg(0x81B7,0x05);
+					ov3640_write_reg(0x81B8,0x43);
+					ov3640_write_reg(0x81B9,0x80);
+					ov3640_write_reg(0x81BA,0x40);
+					ov3640_write_reg(0x81BB,0xE5);
+					ov3640_write_reg(0x81BC,0x43);
+					ov3640_write_reg(0x81BD,0xC3);
+					ov3640_write_reg(0x81BE,0x95);
+					ov3640_write_reg(0x81BF,0x44);
+					ov3640_write_reg(0x81C0,0x40);
+					ov3640_write_reg(0x81C1,0x39);
+					ov3640_write_reg(0x81C2,0x12);
+					ov3640_write_reg(0x81C3,0x05);
+					ov3640_write_reg(0x81C4,0xD8);
+					ov3640_write_reg(0x81C5,0x40);
+					ov3640_write_reg(0x81C6,0x02);
+					ov3640_write_reg(0x81C7,0x80);
+					ov3640_write_reg(0x81C8,0x1A);
+					ov3640_write_reg(0x81C9,0xE5);
+					ov3640_write_reg(0x81CA,0x50);
+					ov3640_write_reg(0x81CB,0x45);
+					ov3640_write_reg(0x81CC,0x4F);
+					ov3640_write_reg(0x81CD,0x70);
+					ov3640_write_reg(0x81CE,0x17);
+					ov3640_write_reg(0x81CF,0xAE);
+					ov3640_write_reg(0x81D0,0x5D);
+					ov3640_write_reg(0x81D1,0xAF);
+					ov3640_write_reg(0x81D2,0x5E);
+					ov3640_write_reg(0x81D3,0xFC);
+					ov3640_write_reg(0x81D4,0x7D);
+					ov3640_write_reg(0x81D5,0x03);
+					ov3640_write_reg(0x81D6,0x12);
+					ov3640_write_reg(0x81D7,0x0C);
+					ov3640_write_reg(0x81D8,0xC8);
+					ov3640_write_reg(0x81D9,0xEE);
+					ov3640_write_reg(0x81DA,0xC3);
+					ov3640_write_reg(0x81DB,0x13);
+					ov3640_write_reg(0x81DC,0xFE);
+					ov3640_write_reg(0x81DD,0xEF);
+					ov3640_write_reg(0x81DE,0x12);
+					ov3640_write_reg(0x81DF,0x06);
+					ov3640_write_reg(0x81E0,0x1C);
+					ov3640_write_reg(0x81E1,0x40);
+					ov3640_write_reg(0x81E2,0x03);
+					ov3640_write_reg(0x81E3,0x12);
+					ov3640_write_reg(0x81E4,0x05);
+					ov3640_write_reg(0x81E5,0xE2);
+					ov3640_write_reg(0x81E6,0xE5);
+					ov3640_write_reg(0x81E7,0x43);
+					ov3640_write_reg(0x81E8,0x44);
+					ov3640_write_reg(0x81E9,0x10);
+					ov3640_write_reg(0x81EA,0x90);
+					ov3640_write_reg(0x81EB,0x3F);
+					ov3640_write_reg(0x81EC,0x04);
+					ov3640_write_reg(0x81ED,0xF0);
+					ov3640_write_reg(0x81EE,0x75);
+					ov3640_write_reg(0x81EF,0x4F);
+					ov3640_write_reg(0x81F0,0x00);
+					ov3640_write_reg(0x81F1,0x75);
+					ov3640_write_reg(0x81F2,0x50);
+					ov3640_write_reg(0x81F3,0x00);
+					ov3640_write_reg(0x81F4,0x75);
+					ov3640_write_reg(0x81F5,0x43);
+					ov3640_write_reg(0x81F6,0x00);
+					ov3640_write_reg(0x81F7,0xC2);
+					ov3640_write_reg(0x81F8,0x0A);
+					ov3640_write_reg(0x81F9,0xC2);
+					ov3640_write_reg(0x81FA,0x09);
+					ov3640_write_reg(0x81FB,0x90);
+					ov3640_write_reg(0x81FC,0x37);
+					ov3640_write_reg(0x81FD,0x08);
+					ov3640_write_reg(0x81FE,0x74);
+					ov3640_write_reg(0x81FF,0x08);
+					ov3640_write_reg(0x8200,0xF0);
+					ov3640_write_reg(0x8201,0xD2);
+					ov3640_write_reg(0x8202,0x08);
+					ov3640_write_reg(0x8203,0x80);
+					ov3640_write_reg(0x8204,0x5A);
+					ov3640_write_reg(0x8205,0x90);
+					ov3640_write_reg(0x8206,0x37);
+					ov3640_write_reg(0x8207,0x08);
+					ov3640_write_reg(0x8208,0xE0);
+					ov3640_write_reg(0x8209,0x30);
+					ov3640_write_reg(0x820A,0xE6);
+					ov3640_write_reg(0x820B,0x5A);
+					ov3640_write_reg(0x820C,0x30);
+					ov3640_write_reg(0x820D,0x0A);
+					ov3640_write_reg(0x820E,0x07);
+					ov3640_write_reg(0x820F,0x90);
+					ov3640_write_reg(0x8210,0x30);
+					ov3640_write_reg(0x8211,0xB4);
+					ov3640_write_reg(0x8212,0xE0);
+					ov3640_write_reg(0x8213,0x44);
+					ov3640_write_reg(0x8214,0x08);
+					ov3640_write_reg(0x8215,0xF0);
+					ov3640_write_reg(0x8216,0x90);
+					ov3640_write_reg(0x8217,0x38);
+					ov3640_write_reg(0x8218,0x02);
+					ov3640_write_reg(0x8219,0xE0);
+					ov3640_write_reg(0x821A,0xF5);
+					ov3640_write_reg(0x821B,0x25);
+					ov3640_write_reg(0x821C,0x30);
+					ov3640_write_reg(0x821D,0xE3);
+					ov3640_write_reg(0x821E,0x06);
+					ov3640_write_reg(0x821F,0xA3);
+					ov3640_write_reg(0x8220,0x74);
+					ov3640_write_reg(0x8221,0xD9);
+					ov3640_write_reg(0x8222,0xF0);
+					ov3640_write_reg(0x8223,0x80);
+					ov3640_write_reg(0x8224,0x03);
+					ov3640_write_reg(0x8225,0x90);
+					ov3640_write_reg(0x8226,0x38);
+					ov3640_write_reg(0x8227,0x03);
+					ov3640_write_reg(0x8228,0xE5);
+					ov3640_write_reg(0x8229,0x45);
+					ov3640_write_reg(0x822A,0xF0);
+					ov3640_write_reg(0x822B,0xE5);
+					ov3640_write_reg(0x822C,0x51);
+					ov3640_write_reg(0x822D,0xF0);
+					ov3640_write_reg(0x822E,0xE5);
+					ov3640_write_reg(0x822F,0x53);
+					ov3640_write_reg(0x8230,0xF0);
+					ov3640_write_reg(0x8231,0xE5);
+					ov3640_write_reg(0x8232,0x55);
+					ov3640_write_reg(0x8233,0xF0);
+					ov3640_write_reg(0x8234,0xE5);
+					ov3640_write_reg(0x8235,0x57);
+					ov3640_write_reg(0x8236,0xF0);
+					ov3640_write_reg(0x8237,0xE5);
+					ov3640_write_reg(0x8238,0x52);
+					ov3640_write_reg(0x8239,0xF0);
+					ov3640_write_reg(0x823A,0xE5);
+					ov3640_write_reg(0x823B,0x54);
+					ov3640_write_reg(0x823C,0xF0);
+					ov3640_write_reg(0x823D,0xE5);
+					ov3640_write_reg(0x823E,0x56);
+					ov3640_write_reg(0x823F,0xF0);
+					ov3640_write_reg(0x8240,0xE5);
+					ov3640_write_reg(0x8241,0x58);
+					ov3640_write_reg(0x8242,0xF0);
+					ov3640_write_reg(0x8243,0xE5);
+					ov3640_write_reg(0x8244,0x61);
+					ov3640_write_reg(0x8245,0xF0);
+					ov3640_write_reg(0x8246,0xE5);
+					ov3640_write_reg(0x8247,0x5B);
+					ov3640_write_reg(0x8248,0xF0);
+					ov3640_write_reg(0x8249,0xE5);
+					ov3640_write_reg(0x824A,0x5C);
+					ov3640_write_reg(0x824B,0xF0);
+					ov3640_write_reg(0x824C,0x74);
+					ov3640_write_reg(0x824D,0x88);
+					ov3640_write_reg(0x824E,0xF0);
+					ov3640_write_reg(0x824F,0xF0);
+					ov3640_write_reg(0x8250,0x75);
+					ov3640_write_reg(0x8251,0x61);
+					ov3640_write_reg(0x8252,0x00);
+					ov3640_write_reg(0x8253,0x90);
+					ov3640_write_reg(0x8254,0x38);
+					ov3640_write_reg(0x8255,0x02);
+					ov3640_write_reg(0x8256,0x74);
+					ov3640_write_reg(0x8257,0x02);
+					ov3640_write_reg(0x8258,0xF0);
+					ov3640_write_reg(0x8259,0x90);
+					ov3640_write_reg(0x825A,0x37);
+					ov3640_write_reg(0x825B,0x08);
+					ov3640_write_reg(0x825C,0x74);
+					ov3640_write_reg(0x825D,0x40);
+					ov3640_write_reg(0x825E,0xF0);
+					ov3640_write_reg(0x825F,0x90);
+					ov3640_write_reg(0x8260,0x30);
+					ov3640_write_reg(0x8261,0xB4);
+					ov3640_write_reg(0x8262,0xE0);
+					ov3640_write_reg(0x8263,0x54);
+					ov3640_write_reg(0x8264,0xF7);
+					ov3640_write_reg(0x8265,0xF0);
+					ov3640_write_reg(0x8266,0xD0);
+					ov3640_write_reg(0x8267,0x07);
+					ov3640_write_reg(0x8268,0xD0);
+					ov3640_write_reg(0x8269,0x06);
+					ov3640_write_reg(0x826A,0xD0);
+					ov3640_write_reg(0x826B,0x05);
+					ov3640_write_reg(0x826C,0xD0);
+					ov3640_write_reg(0x826D,0x04);
+					ov3640_write_reg(0x826E,0xD0);
+					ov3640_write_reg(0x826F,0x00);
+					ov3640_write_reg(0x8270,0xD0);
+					ov3640_write_reg(0x8271,0xD0);
+					ov3640_write_reg(0x8272,0xD0);
+					ov3640_write_reg(0x8273,0x82);
+					ov3640_write_reg(0x8274,0xD0);
+					ov3640_write_reg(0x8275,0x83);
+					ov3640_write_reg(0x8276,0xD0);
+					ov3640_write_reg(0x8277,0xF0);
+					ov3640_write_reg(0x8278,0xD0);
+					ov3640_write_reg(0x8279,0xE0);
+					ov3640_write_reg(0x827A,0x32);
+					ov3640_write_reg(0x827B,0xE5);
+					ov3640_write_reg(0x827C,0x2F);
+					ov3640_write_reg(0x827D,0x14);
+					ov3640_write_reg(0x827E,0x60);
+					ov3640_write_reg(0x827F,0x57);
+					ov3640_write_reg(0x8280,0x14);
+					ov3640_write_reg(0x8281,0x70);
+					ov3640_write_reg(0x8282,0x03);
+					ov3640_write_reg(0x8283,0x02);
+					ov3640_write_reg(0x8284,0x03);
+					ov3640_write_reg(0x8285,0x27);
+					ov3640_write_reg(0x8286,0x14);
+					ov3640_write_reg(0x8287,0x70);
+					ov3640_write_reg(0x8288,0x03);
+					ov3640_write_reg(0x8289,0x02);
+					ov3640_write_reg(0x828A,0x03);
+					ov3640_write_reg(0x828B,0x69);
+					ov3640_write_reg(0x828C,0x14);
+					ov3640_write_reg(0x828D,0x70);
+					ov3640_write_reg(0x828E,0x03);
+					ov3640_write_reg(0x828F,0x02);
+					ov3640_write_reg(0x8290,0x03);
+					ov3640_write_reg(0x8291,0xD8);
+					ov3640_write_reg(0x8292,0x24);
+					ov3640_write_reg(0x8293,0x04);
+					ov3640_write_reg(0x8294,0x60);
+					ov3640_write_reg(0x8295,0x03);
+					ov3640_write_reg(0x8296,0x02);
+					ov3640_write_reg(0x8297,0x03);
+					ov3640_write_reg(0x8298,0xEF);
+					ov3640_write_reg(0x8299,0xE4);
+					ov3640_write_reg(0x829A,0xFD);
+					ov3640_write_reg(0x829B,0xFF);
+					ov3640_write_reg(0x829C,0x12);
+					ov3640_write_reg(0x829D,0x0B);
+					ov3640_write_reg(0x829E,0x2C);
+					ov3640_write_reg(0x829F,0x8E);
+					ov3640_write_reg(0x82A0,0x30);
+					ov3640_write_reg(0x82A1,0x8F);
+					ov3640_write_reg(0x82A2,0x31);
+					ov3640_write_reg(0x82A3,0x0D);
+					ov3640_write_reg(0x82A4,0xE4);
+					ov3640_write_reg(0x82A5,0xFF);
+					ov3640_write_reg(0x82A6,0x12);
+					ov3640_write_reg(0x82A7,0x0B);
+					ov3640_write_reg(0x82A8,0x2C);
+					ov3640_write_reg(0x82A9,0x8E);
+					ov3640_write_reg(0x82AA,0x34);
+					ov3640_write_reg(0x82AB,0x8F);
+					ov3640_write_reg(0x82AC,0x35);
+					ov3640_write_reg(0x82AD,0x12);
+					ov3640_write_reg(0x82AE,0x05);
+					ov3640_write_reg(0x82AF,0xAE);
+					ov3640_write_reg(0x82B0,0x50);
+					ov3640_write_reg(0x82B1,0x08);
+					ov3640_write_reg(0x82B2,0x75);
+					ov3640_write_reg(0x82B3,0x2E);
+					ov3640_write_reg(0x82B4,0x01);
+					ov3640_write_reg(0x82B5,0x75);
+					ov3640_write_reg(0x82B6,0x2F);
+					ov3640_write_reg(0x82B7,0x01);
+					ov3640_write_reg(0x82B8,0x80);
+					ov3640_write_reg(0x82B9,0x06);
+					ov3640_write_reg(0x82BA,0x75);
+					ov3640_write_reg(0x82BB,0x2E);
+					ov3640_write_reg(0x82BC,0xFF);
+					ov3640_write_reg(0x82BD,0x75);
+					ov3640_write_reg(0x82BE,0x2F);
+					ov3640_write_reg(0x82BF,0x03);
+					ov3640_write_reg(0x82C0,0x12);
+					ov3640_write_reg(0x82C1,0x03);
+					ov3640_write_reg(0x82C2,0xF8);
+					ov3640_write_reg(0x82C3,0x90);
+					ov3640_write_reg(0x82C4,0x33);
+					ov3640_write_reg(0x82C5,0xB3);
+					ov3640_write_reg(0x82C6,0x74);
+					ov3640_write_reg(0x82C7,0x80);
+					ov3640_write_reg(0x82C8,0xF0);
+					ov3640_write_reg(0x82C9,0xA3);
+					ov3640_write_reg(0x82CA,0x74);
+					ov3640_write_reg(0x82CB,0x2A);
+					ov3640_write_reg(0x82CC,0xF0);
+					ov3640_write_reg(0x82CD,0xA3);
+					ov3640_write_reg(0x82CE,0x74);
+					ov3640_write_reg(0x82CF,0x14);
+					ov3640_write_reg(0x82D0,0xF0);
+					ov3640_write_reg(0x82D1,0xA3);
+					ov3640_write_reg(0x82D2,0xE4);
+					ov3640_write_reg(0x82D3,0xF0);
+					ov3640_write_reg(0x82D4,0x02);
+					ov3640_write_reg(0x82D5,0x03);
+					ov3640_write_reg(0x82D6,0xEF);
+					ov3640_write_reg(0x82D7,0x12);
+					ov3640_write_reg(0x82D8,0x04);
+					ov3640_write_reg(0x82D9,0x44);
+					ov3640_write_reg(0x82DA,0xC0);
+					ov3640_write_reg(0x82DB,0x06);
+					ov3640_write_reg(0x82DC,0xC0);
+					ov3640_write_reg(0x82DD,0x07);
+					ov3640_write_reg(0x82DE,0x12);
+					ov3640_write_reg(0x82DF,0x04);
+					ov3640_write_reg(0x82E0,0x88);
+					ov3640_write_reg(0x82E1,0xD0);
+					ov3640_write_reg(0x82E2,0x05);
+					ov3640_write_reg(0x82E3,0xD0);
+					ov3640_write_reg(0x82E4,0x04);
+					ov3640_write_reg(0x82E5,0x12);
+					ov3640_write_reg(0x82E6,0x06);
+					ov3640_write_reg(0x82E7,0x10);
+					ov3640_write_reg(0x82E8,0x40);
+					ov3640_write_reg(0x82E9,0x05);
+					ov3640_write_reg(0x82EA,0x12);
+					ov3640_write_reg(0x82EB,0x05);
+					ov3640_write_reg(0x82EC,0xF6);
+					ov3640_write_reg(0x82ED,0x80);
+					ov3640_write_reg(0x82EE,0x03);
+					ov3640_write_reg(0x82EF,0x12);
+					ov3640_write_reg(0x82F0,0x06);
+					ov3640_write_reg(0x82F1,0x03);
+					ov3640_write_reg(0x82F2,0x12);
+					ov3640_write_reg(0x82F3,0x06);
+					ov3640_write_reg(0x82F4,0x26);
+					ov3640_write_reg(0x82F5,0x40);
+					ov3640_write_reg(0x82F6,0x11);
+					ov3640_write_reg(0x82F7,0x12);
+					ov3640_write_reg(0x82F8,0x05);
+					ov3640_write_reg(0x82F9,0xAE);
+					ov3640_write_reg(0x82FA,0x50);
+					ov3640_write_reg(0x82FB,0x09);
+					ov3640_write_reg(0x82FC,0x12);
+					ov3640_write_reg(0x82FD,0x03);
+					ov3640_write_reg(0x82FE,0xF8);
+					ov3640_write_reg(0x82FF,0x75);
+					ov3640_write_reg(0x8300,0x2F);
+					ov3640_write_reg(0x8301,0x02);
+					ov3640_write_reg(0x8302,0x02);
+					ov3640_write_reg(0x8303,0x03);
+					ov3640_write_reg(0x8304,0xB8);
+					ov3640_write_reg(0x8305,0x02);
+					ov3640_write_reg(0x8306,0x03);
+					ov3640_write_reg(0x8307,0xD3);
+					ov3640_write_reg(0x8308,0x75);
+					ov3640_write_reg(0x8309,0x2E);
+					ov3640_write_reg(0x830A,0xFF);
+					ov3640_write_reg(0x830B,0xD3);
+					ov3640_write_reg(0x830C,0xE5);
+					ov3640_write_reg(0x830D,0x4C);
+					ov3640_write_reg(0x830E,0x94);
+					ov3640_write_reg(0x830F,0x28);
+					ov3640_write_reg(0x8310,0xE5);
+					ov3640_write_reg(0x8311,0x4B);
+					ov3640_write_reg(0x8312,0x94);
+					ov3640_write_reg(0x8313,0x00);
+					ov3640_write_reg(0x8314,0xAF);
+					ov3640_write_reg(0x8315,0x2E);
+					ov3640_write_reg(0x8316,0xEF);
+					ov3640_write_reg(0x8317,0x40);
+					ov3640_write_reg(0x8318,0x0B);
+					ov3640_write_reg(0x8319,0x7D);
+					ov3640_write_reg(0x831A,0x50);
+					ov3640_write_reg(0x831B,0x12);
+					ov3640_write_reg(0x831C,0x04);
+					ov3640_write_reg(0x831D,0x67);
+					ov3640_write_reg(0x831E,0x75);
+					ov3640_write_reg(0x831F,0x2F);
+					ov3640_write_reg(0x8320,0x03);
+					ov3640_write_reg(0x8321,0x02);
+					ov3640_write_reg(0x8322,0x03);
+					ov3640_write_reg(0x8323,0xB8);
+					ov3640_write_reg(0x8324,0x02);
+					ov3640_write_reg(0x8325,0x03);
+					ov3640_write_reg(0x8326,0xCE);
+					ov3640_write_reg(0x8327,0x12);
+					ov3640_write_reg(0x8328,0x04);
+					ov3640_write_reg(0x8329,0x44);
+					ov3640_write_reg(0x832A,0xC0);
+					ov3640_write_reg(0x832B,0x06);
+					ov3640_write_reg(0x832C,0xC0);
+					ov3640_write_reg(0x832D,0x07);
+					ov3640_write_reg(0x832E,0xC3);
+					ov3640_write_reg(0x832F,0xE5);
+					ov3640_write_reg(0x8330,0x39);
+					ov3640_write_reg(0x8331,0x95);
+					ov3640_write_reg(0x8332,0x31);
+					ov3640_write_reg(0x8333,0xFF);
+					ov3640_write_reg(0x8334,0xE5);
+					ov3640_write_reg(0x8335,0x38);
+					ov3640_write_reg(0x8336,0x95);
+					ov3640_write_reg(0x8337,0x30);
+					ov3640_write_reg(0x8338,0xFE);
+					ov3640_write_reg(0x8339,0x12);
+					ov3640_write_reg(0x833A,0x0C);
+					ov3640_write_reg(0x833B,0xF7);
+					ov3640_write_reg(0x833C,0xD0);
+					ov3640_write_reg(0x833D,0x05);
+					ov3640_write_reg(0x833E,0xD0);
+					ov3640_write_reg(0x833F,0x04);
+					ov3640_write_reg(0x8340,0x12);
+					ov3640_write_reg(0x8341,0x06);
+					ov3640_write_reg(0x8342,0x10);
+					ov3640_write_reg(0x8343,0x40);
+					ov3640_write_reg(0x8344,0x05);
+					ov3640_write_reg(0x8345,0x12);
+					ov3640_write_reg(0x8346,0x05);
+					ov3640_write_reg(0x8347,0xF6);
+					ov3640_write_reg(0x8348,0x80);
+					ov3640_write_reg(0x8349,0x03);
+					ov3640_write_reg(0x834A,0x12);
+					ov3640_write_reg(0x834B,0x06);
+					ov3640_write_reg(0x834C,0x03);
+					ov3640_write_reg(0x834D,0x12);
+					ov3640_write_reg(0x834E,0x06);
+					ov3640_write_reg(0x834F,0x26);
+					ov3640_write_reg(0x8350,0x40);
+					ov3640_write_reg(0x8351,0x0E);
+					ov3640_write_reg(0x8352,0x12);
+					ov3640_write_reg(0x8353,0x05);
+					ov3640_write_reg(0x8354,0xAE);
+					ov3640_write_reg(0x8355,0x50);
+					ov3640_write_reg(0x8356,0x06);
+					ov3640_write_reg(0x8357,0x12);
+					ov3640_write_reg(0x8358,0x04);
+					ov3640_write_reg(0x8359,0x1E);
+					ov3640_write_reg(0x835A,0x02);
+					ov3640_write_reg(0x835B,0x03);
+					ov3640_write_reg(0x835C,0xB8);
+					ov3640_write_reg(0x835D,0x02);
+					ov3640_write_reg(0x835E,0x03);
+					ov3640_write_reg(0x835F,0xD3);
+					ov3640_write_reg(0x8360,0x75);
+					ov3640_write_reg(0x8361,0x2E);
+					ov3640_write_reg(0x8362,0xFF);
+					ov3640_write_reg(0x8363,0xAF);
+					ov3640_write_reg(0x8364,0x2E);
+					ov3640_write_reg(0x8365,0xEF);
+					ov3640_write_reg(0x8366,0x02);
+					ov3640_write_reg(0x8367,0x03);
+					ov3640_write_reg(0x8368,0xCE);
+					ov3640_write_reg(0x8369,0xE4);
+					ov3640_write_reg(0x836A,0xFD);
+					ov3640_write_reg(0x836B,0xFF);
+					ov3640_write_reg(0x836C,0x12);
+					ov3640_write_reg(0x836D,0x0B);
+					ov3640_write_reg(0x836E,0x2C);
+					ov3640_write_reg(0x836F,0x8E);
+					ov3640_write_reg(0x8370,0x32);
+					ov3640_write_reg(0x8371,0x8F);
+					ov3640_write_reg(0x8372,0x33);
+					ov3640_write_reg(0x8373,0x0D);
+					ov3640_write_reg(0x8374,0xE4);
+					ov3640_write_reg(0x8375,0xFF);
+					ov3640_write_reg(0x8376,0x12);
+					ov3640_write_reg(0x8377,0x0B);
+					ov3640_write_reg(0x8378,0x2C);
+					ov3640_write_reg(0x8379,0x8E);
+					ov3640_write_reg(0x837A,0x36);
+					ov3640_write_reg(0x837B,0x8F);
+					ov3640_write_reg(0x837C,0x37);
+					ov3640_write_reg(0x837D,0xC3);
+					ov3640_write_reg(0x837E,0xE5);
+					ov3640_write_reg(0x837F,0x37);
+					ov3640_write_reg(0x8380,0x95);
+					ov3640_write_reg(0x8381,0x35);
+					ov3640_write_reg(0x8382,0xFF);
+					ov3640_write_reg(0x8383,0xE5);
+					ov3640_write_reg(0x8384,0x36);
+					ov3640_write_reg(0x8385,0x95);
+					ov3640_write_reg(0x8386,0x34);
+					ov3640_write_reg(0x8387,0xFE);
+					ov3640_write_reg(0x8388,0x12);
+					ov3640_write_reg(0x8389,0x0C);
+					ov3640_write_reg(0x838A,0xF7);
+					ov3640_write_reg(0x838B,0xC0);
+					ov3640_write_reg(0x838C,0x06);
+					ov3640_write_reg(0x838D,0xC0);
+					ov3640_write_reg(0x838E,0x07);
+					ov3640_write_reg(0x838F,0x12);
+					ov3640_write_reg(0x8390,0x04);
+					ov3640_write_reg(0x8391,0x88);
+					ov3640_write_reg(0x8392,0xD0);
+					ov3640_write_reg(0x8393,0x05);
+					ov3640_write_reg(0x8394,0xD0);
+					ov3640_write_reg(0x8395,0x04);
+					ov3640_write_reg(0x8396,0xC3);
+					ov3640_write_reg(0x8397,0x12);
+					ov3640_write_reg(0x8398,0x06);
+					ov3640_write_reg(0x8399,0x11);
+					ov3640_write_reg(0x839A,0x40);
+					ov3640_write_reg(0x839B,0x05);
+					ov3640_write_reg(0x839C,0x12);
+					ov3640_write_reg(0x839D,0x05);
+					ov3640_write_reg(0x839E,0xF6);
+					ov3640_write_reg(0x839F,0x80);
+					ov3640_write_reg(0x83A0,0x03);
+					ov3640_write_reg(0x83A1,0x12);
+					ov3640_write_reg(0x83A2,0x06);
+					ov3640_write_reg(0x83A3,0x03);
+					ov3640_write_reg(0x83A4,0xC3);
+					ov3640_write_reg(0x83A5,0x12);
+					ov3640_write_reg(0x83A6,0x06);
+					ov3640_write_reg(0x83A7,0x27);
+					ov3640_write_reg(0x83A8,0x40);
+					ov3640_write_reg(0x83A9,0x1E);
+					ov3640_write_reg(0x83AA,0xD3);
+					ov3640_write_reg(0x83AB,0xE5);
+					ov3640_write_reg(0x83AC,0x4C);
+					ov3640_write_reg(0x83AD,0x94);
+					ov3640_write_reg(0x83AE,0x00);
+					ov3640_write_reg(0x83AF,0xE5);
+					ov3640_write_reg(0x83B0,0x4B);
+					ov3640_write_reg(0x83B1,0x94);
+					ov3640_write_reg(0x83B2,0x00);
+					ov3640_write_reg(0x83B3,0x40);
+					ov3640_write_reg(0x83B4,0x11);
+					ov3640_write_reg(0x83B5,0x12);
+					ov3640_write_reg(0x83B6,0x04);
+					ov3640_write_reg(0x83B7,0x1E);
+					ov3640_write_reg(0x83B8,0x85);
+					ov3640_write_reg(0x83B9,0x32);
+					ov3640_write_reg(0x83BA,0x30);
+					ov3640_write_reg(0x83BB,0x85);
+					ov3640_write_reg(0x83BC,0x33);
+					ov3640_write_reg(0x83BD,0x31);
+					ov3640_write_reg(0x83BE,0x85);
+					ov3640_write_reg(0x83BF,0x36);
+					ov3640_write_reg(0x83C0,0x34);
+					ov3640_write_reg(0x83C1,0x85);
+					ov3640_write_reg(0x83C2,0x37);
+					ov3640_write_reg(0x83C3,0x35);
+					ov3640_write_reg(0x83C4,0x80);
+					ov3640_write_reg(0x83C5,0x29);
+					ov3640_write_reg(0x83C6,0x80);
+					ov3640_write_reg(0x83C7,0x0B);
+					ov3640_write_reg(0x83C8,0x75);
+					ov3640_write_reg(0x83C9,0x2E);
+					ov3640_write_reg(0x83CA,0x01);
+					ov3640_write_reg(0x83CB,0xAF);
+					ov3640_write_reg(0x83CC,0x2E);
+					ov3640_write_reg(0x83CD,0xEF);
+					ov3640_write_reg(0x83CE,0x7D);
+					ov3640_write_reg(0x83CF,0x28);
+					ov3640_write_reg(0x83D0,0x12);
+					ov3640_write_reg(0x83D1,0x04);
+					ov3640_write_reg(0x83D2,0x67);
+					ov3640_write_reg(0x83D3,0x75);
+					ov3640_write_reg(0x83D4,0x2F);
+					ov3640_write_reg(0x83D5,0x04);
+					ov3640_write_reg(0x83D6,0x80);
+					ov3640_write_reg(0x83D7,0x17);
+					ov3640_write_reg(0x83D8,0x90);
+					ov3640_write_reg(0x83D9,0x33);
+					ov3640_write_reg(0x83DA,0xB3);
+					ov3640_write_reg(0x83DB,0x12);
+					ov3640_write_reg(0x83DC,0x06);
+					ov3640_write_reg(0x83DD,0x30);
+					ov3640_write_reg(0x83DE,0xE5);
+					ov3640_write_reg(0x83DF,0x4C);
+					ov3640_write_reg(0x83E0,0x45);
+					ov3640_write_reg(0x83E1,0x4B);
+					ov3640_write_reg(0x83E2,0x70);
+					ov3640_write_reg(0x83E3,0x05);
+					ov3640_write_reg(0x83E4,0xFF);
+					ov3640_write_reg(0x83E5,0xFE);
+					ov3640_write_reg(0x83E6,0x12);
+					ov3640_write_reg(0x83E7,0x0B);
+					ov3640_write_reg(0x83E8,0x7A);
+					ov3640_write_reg(0x83E9,0xE4);
+					ov3640_write_reg(0x83EA,0xF5);
+					ov3640_write_reg(0x83EB,0x2F);
+					ov3640_write_reg(0x83EC,0x75);
+					ov3640_write_reg(0x83ED,0x3C);
+					ov3640_write_reg(0x83EE,0x04);
+					ov3640_write_reg(0x83EF,0x90);
+					ov3640_write_reg(0x83F0,0x3F);
+					ov3640_write_reg(0x83F1,0x03);
+					ov3640_write_reg(0x83F2,0xE0);
+					ov3640_write_reg(0x83F3,0x04);
+					ov3640_write_reg(0x83F4,0xF0);
+					ov3640_write_reg(0x83F5,0xC2);
+					ov3640_write_reg(0x83F6,0x08);
+					ov3640_write_reg(0x83F7,0x22);
+					ov3640_write_reg(0x83F8,0xAF);
+					ov3640_write_reg(0x83F9,0x2E);
+					ov3640_write_reg(0x83FA,0xEF);
+					ov3640_write_reg(0x83FB,0x33);
+					ov3640_write_reg(0x83FC,0x95);
+					ov3640_write_reg(0x83FD,0xE0);
+					ov3640_write_reg(0x83FE,0xFE);
+					ov3640_write_reg(0x83FF,0x7C);
+					ov3640_write_reg(0x8400,0x00);
+					ov3640_write_reg(0x8401,0x7D);
+					ov3640_write_reg(0x8402,0x28);
+					ov3640_write_reg(0x8403,0x12);
+					ov3640_write_reg(0x8404,0x0C);
+					ov3640_write_reg(0x8405,0xC8);
+					ov3640_write_reg(0x8406,0xEF);
+					ov3640_write_reg(0x8407,0x25);
+					ov3640_write_reg(0x8408,0x4C);
+					ov3640_write_reg(0x8409,0xF5);
+					ov3640_write_reg(0x840A,0x4C);
+					ov3640_write_reg(0x840B,0xEE);
+					ov3640_write_reg(0x840C,0x35);
+					ov3640_write_reg(0x840D,0x4B);
+					ov3640_write_reg(0x840E,0xF5);
+					ov3640_write_reg(0x840F,0x4B);
+					ov3640_write_reg(0x8410,0xE5);
+					ov3640_write_reg(0x8411,0x4C);
+					ov3640_write_reg(0x8412,0x25);
+					ov3640_write_reg(0x8413,0x3E);
+					ov3640_write_reg(0x8414,0xFF);
+					ov3640_write_reg(0x8415,0xE5);
+					ov3640_write_reg(0x8416,0x4B);
+					ov3640_write_reg(0x8417,0x35);
+					ov3640_write_reg(0x8418,0x3D);
+					ov3640_write_reg(0x8419,0xFE);
+					ov3640_write_reg(0x841A,0x12);
+					ov3640_write_reg(0x841B,0x0B);
+					ov3640_write_reg(0x841C,0x7A);
+					ov3640_write_reg(0x841D,0x22);
+					ov3640_write_reg(0x841E,0xAF);
+					ov3640_write_reg(0x841F,0x2E);
+					ov3640_write_reg(0x8420,0xEF);
+					ov3640_write_reg(0x8421,0x33);
+					ov3640_write_reg(0x8422,0x95);
+					ov3640_write_reg(0x8423,0xE0);
+					ov3640_write_reg(0x8424,0xFE);
+					ov3640_write_reg(0x8425,0x7C);
+					ov3640_write_reg(0x8426,0x00);
+					ov3640_write_reg(0x8427,0x7D);
+					ov3640_write_reg(0x8428,0x28);
+					ov3640_write_reg(0x8429,0x12);
+					ov3640_write_reg(0x842A,0x0C);
+					ov3640_write_reg(0x842B,0xC8);
+					ov3640_write_reg(0x842C,0xEF);
+					ov3640_write_reg(0x842D,0x25);
+					ov3640_write_reg(0x842E,0x4C);
+					ov3640_write_reg(0x842F,0xF5);
+					ov3640_write_reg(0x8430,0x4C);
+					ov3640_write_reg(0x8431,0xEE);
+					ov3640_write_reg(0x8432,0x35);
+					ov3640_write_reg(0x8433,0x4B);
+					ov3640_write_reg(0x8434,0xF5);
+					ov3640_write_reg(0x8435,0x4B);
+					ov3640_write_reg(0x8436,0xE5);
+					ov3640_write_reg(0x8437,0x4C);
+					ov3640_write_reg(0x8438,0x25);
+					ov3640_write_reg(0x8439,0x3E);
+					ov3640_write_reg(0x843A,0xFF);
+					ov3640_write_reg(0x843B,0xE5);
+					ov3640_write_reg(0x843C,0x4B);
+					ov3640_write_reg(0x843D,0x35);
+					ov3640_write_reg(0x843E,0x3D);
+					ov3640_write_reg(0x843F,0xFE);
+					ov3640_write_reg(0x8440,0x12);
+					ov3640_write_reg(0x8441,0x0B);
+					ov3640_write_reg(0x8442,0x7A);
+					ov3640_write_reg(0x8443,0x22);
+					ov3640_write_reg(0x8444,0xE4);
+					ov3640_write_reg(0x8445,0xFD);
+					ov3640_write_reg(0x8446,0xFF);
+					ov3640_write_reg(0x8447,0x12);
+					ov3640_write_reg(0x8448,0x0B);
+					ov3640_write_reg(0x8449,0x2C);
+					ov3640_write_reg(0x844A,0x8E);
+					ov3640_write_reg(0x844B,0x32);
+					ov3640_write_reg(0x844C,0x8F);
+					ov3640_write_reg(0x844D,0x33);
+					ov3640_write_reg(0x844E,0x0D);
+					ov3640_write_reg(0x844F,0xE4);
+					ov3640_write_reg(0x8450,0xFF);
+					ov3640_write_reg(0x8451,0x12);
+					ov3640_write_reg(0x8452,0x0B);
+					ov3640_write_reg(0x8453,0x2C);
+					ov3640_write_reg(0x8454,0x8E);
+					ov3640_write_reg(0x8455,0x36);
+					ov3640_write_reg(0x8456,0x8F);
+					ov3640_write_reg(0x8457,0x37);
+					ov3640_write_reg(0x8458,0xC3);
+					ov3640_write_reg(0x8459,0xE5);
+					ov3640_write_reg(0x845A,0x37);
+					ov3640_write_reg(0x845B,0x95);
+					ov3640_write_reg(0x845C,0x35);
+					ov3640_write_reg(0x845D,0xFF);
+					ov3640_write_reg(0x845E,0xE5);
+					ov3640_write_reg(0x845F,0x36);
+					ov3640_write_reg(0x8460,0x95);
+					ov3640_write_reg(0x8461,0x34);
+					ov3640_write_reg(0x8462,0xFE);
+					ov3640_write_reg(0x8463,0x12);
+					ov3640_write_reg(0x8464,0x0C);
+					ov3640_write_reg(0x8465,0xF7);
+					ov3640_write_reg(0x8466,0x22);
+					ov3640_write_reg(0x8467,0x33);
+					ov3640_write_reg(0x8468,0x95);
+					ov3640_write_reg(0x8469,0xE0);
+					ov3640_write_reg(0x846A,0xFE);
+					ov3640_write_reg(0x846B,0x7C);
+					ov3640_write_reg(0x846C,0x00);
+					ov3640_write_reg(0x846D,0x12);
+					ov3640_write_reg(0x846E,0x0C);
+					ov3640_write_reg(0x846F,0xC8);
+					ov3640_write_reg(0x8470,0xEF);
+					ov3640_write_reg(0x8471,0x25);
+					ov3640_write_reg(0x8472,0x4C);
+					ov3640_write_reg(0x8473,0xF5);
+					ov3640_write_reg(0x8474,0x4C);
+					ov3640_write_reg(0x8475,0xEE);
+					ov3640_write_reg(0x8476,0x35);
+					ov3640_write_reg(0x8477,0x4B);
+					ov3640_write_reg(0x8478,0xF5);
+					ov3640_write_reg(0x8479,0x4B);
+					ov3640_write_reg(0x847A,0xE5);
+					ov3640_write_reg(0x847B,0x4C);
+					ov3640_write_reg(0x847C,0x25);
+					ov3640_write_reg(0x847D,0x3E);
+					ov3640_write_reg(0x847E,0xFF);
+					ov3640_write_reg(0x847F,0xE5);
+					ov3640_write_reg(0x8480,0x4B);
+					ov3640_write_reg(0x8481,0x35);
+					ov3640_write_reg(0x8482,0x3D);
+					ov3640_write_reg(0x8483,0xFE);
+					ov3640_write_reg(0x8484,0x12);
+					ov3640_write_reg(0x8485,0x0B);
+					ov3640_write_reg(0x8486,0x7A);
+					ov3640_write_reg(0x8487,0x22);
+					ov3640_write_reg(0x8488,0xC3);
+					ov3640_write_reg(0x8489,0xE5);
+					ov3640_write_reg(0x848A,0x33);
+					ov3640_write_reg(0x848B,0x95);
+					ov3640_write_reg(0x848C,0x31);
+					ov3640_write_reg(0x848D,0xFF);
+					ov3640_write_reg(0x848E,0xE5);
+					ov3640_write_reg(0x848F,0x32);
+					ov3640_write_reg(0x8490,0x95);
+					ov3640_write_reg(0x8491,0x30);
+					ov3640_write_reg(0x8492,0xFE);
+					ov3640_write_reg(0x8493,0x12);
+					ov3640_write_reg(0x8494,0x0C);
+					ov3640_write_reg(0x8495,0xF7);
+					ov3640_write_reg(0x8496,0x22);
+					ov3640_write_reg(0x8497,0x90);
+					ov3640_write_reg(0x8498,0x3F);
+					ov3640_write_reg(0x8499,0x00);
+					ov3640_write_reg(0x849A,0xE0);
+					ov3640_write_reg(0x849B,0x54);
+					ov3640_write_reg(0x849C,0x1F);
+					ov3640_write_reg(0x849D,0xFF);
+					ov3640_write_reg(0x849E,0x60);
+					ov3640_write_reg(0x849F,0x02);
+					ov3640_write_reg(0x84A0,0xE4);
+					ov3640_write_reg(0x84A1,0xF0);
+					ov3640_write_reg(0x84A2,0xEF);
+					ov3640_write_reg(0x84A3,0x14);
+					ov3640_write_reg(0x84A4,0xB4);
+					ov3640_write_reg(0x84A5,0x19);
+					ov3640_write_reg(0x84A6,0x00);
+					ov3640_write_reg(0x84A7,0x40);
+					ov3640_write_reg(0x84A8,0x03);
+					ov3640_write_reg(0x84A9,0x02);
+					ov3640_write_reg(0x84AA,0x05);
+					ov3640_write_reg(0x84AB,0x9B);
+					ov3640_write_reg(0x84AC,0x90);
+					ov3640_write_reg(0x84AD,0x04);
+					ov3640_write_reg(0x84AE,0xBA);
+					ov3640_write_reg(0x84AF,0x75);
+					ov3640_write_reg(0x84B0,0xF0);
+					ov3640_write_reg(0x84B1,0x03);
+					ov3640_write_reg(0x84B2,0xA4);
+					ov3640_write_reg(0x84B3,0xC5);
+					ov3640_write_reg(0x84B4,0x83);
+					ov3640_write_reg(0x84B5,0x25);
+					ov3640_write_reg(0x84B6,0xF0);
+					ov3640_write_reg(0x84B7,0xC5);
+					ov3640_write_reg(0x84B8,0x83);
+					ov3640_write_reg(0x84B9,0x73);
+					ov3640_write_reg(0x84BA,0x02);
+					ov3640_write_reg(0x84BB,0x05);
+					ov3640_write_reg(0x84BC,0x05);
+					ov3640_write_reg(0x84BD,0x02);
+					ov3640_write_reg(0x84BE,0x05);
+					ov3640_write_reg(0x84BF,0x09);
+					ov3640_write_reg(0x84C0,0x02);
+					ov3640_write_reg(0x84C1,0x05);
+					ov3640_write_reg(0x84C2,0x0E);
+					ov3640_write_reg(0x84C3,0x02);
+					ov3640_write_reg(0x84C4,0x05);
+					ov3640_write_reg(0x84C5,0x12);
+					ov3640_write_reg(0x84C6,0x02);
+					ov3640_write_reg(0x84C7,0x05);
+					ov3640_write_reg(0x84C8,0x17);
+					ov3640_write_reg(0x84C9,0x02);
+					ov3640_write_reg(0x84CA,0x05);
+					ov3640_write_reg(0x84CB,0x26);
+					ov3640_write_reg(0x84CC,0x02);
+					ov3640_write_reg(0x84CD,0x05);
+					ov3640_write_reg(0x84CE,0x2E);
+					ov3640_write_reg(0x84CF,0x02);
+					ov3640_write_reg(0x84D0,0x05);
+					ov3640_write_reg(0x84D1,0x38);
+					ov3640_write_reg(0x84D2,0x02);
+					ov3640_write_reg(0x84D3,0x05);
+					ov3640_write_reg(0x84D4,0x47);
+					ov3640_write_reg(0x84D5,0x02);
+					ov3640_write_reg(0x84D6,0x05);
+					ov3640_write_reg(0x84D7,0x4C);
+					ov3640_write_reg(0x84D8,0x02);
+					ov3640_write_reg(0x84D9,0x05);
+					ov3640_write_reg(0x84DA,0x54);
+					ov3640_write_reg(0x84DB,0x02);
+					ov3640_write_reg(0x84DC,0x05);
+					ov3640_write_reg(0x84DD,0x5C);
+					ov3640_write_reg(0x84DE,0x02);
+					ov3640_write_reg(0x84DF,0x05);
+					ov3640_write_reg(0x84E0,0x9B);
+					ov3640_write_reg(0x84E1,0x02);
+					ov3640_write_reg(0x84E2,0x05);
+					ov3640_write_reg(0x84E3,0x9B);
+					ov3640_write_reg(0x84E4,0x02);
+					ov3640_write_reg(0x84E5,0x05);
+					ov3640_write_reg(0x84E6,0x66);
+					ov3640_write_reg(0x84E7,0x02);
+					ov3640_write_reg(0x84E8,0x05);
+					ov3640_write_reg(0x84E9,0x9B);
+					ov3640_write_reg(0x84EA,0x02);
+					ov3640_write_reg(0x84EB,0x05);
+					ov3640_write_reg(0x84EC,0x9B);
+					ov3640_write_reg(0x84ED,0x02);
+					ov3640_write_reg(0x84EE,0x05);
+					ov3640_write_reg(0x84EF,0x9B);
+					ov3640_write_reg(0x84F0,0x02);
+					ov3640_write_reg(0x84F1,0x05);
+					ov3640_write_reg(0x84F2,0x9B);
+					ov3640_write_reg(0x84F3,0x02);
+					ov3640_write_reg(0x84F4,0x05);
+					ov3640_write_reg(0x84F5,0x71);
+					ov3640_write_reg(0x84F6,0x02);
+					ov3640_write_reg(0x84F7,0x05);
+					ov3640_write_reg(0x84F8,0x9B);
+					ov3640_write_reg(0x84F9,0x02);
+					ov3640_write_reg(0x84FA,0x05);
+					ov3640_write_reg(0x84FB,0x9B);
+					ov3640_write_reg(0x84FC,0x02);
+					ov3640_write_reg(0x84FD,0x05);
+					ov3640_write_reg(0x84FE,0x9B);
+					ov3640_write_reg(0x84FF,0x02);
+					ov3640_write_reg(0x8500,0x05);
+					ov3640_write_reg(0x8501,0x86);
+					ov3640_write_reg(0x8502,0x02);
+					ov3640_write_reg(0x8503,0x05);
+					ov3640_write_reg(0x8504,0x8E);
+					ov3640_write_reg(0x8505,0x7F);
+					ov3640_write_reg(0x8506,0x01);
+					ov3640_write_reg(0x8507,0x80);
+					ov3640_write_reg(0x8508,0x02);
+					ov3640_write_reg(0x8509,0xE4);
+					ov3640_write_reg(0x850A,0xFF);
+					ov3640_write_reg(0x850B,0x02);
+					ov3640_write_reg(0x850C,0x0C);
+					ov3640_write_reg(0x850D,0xDA);
+					ov3640_write_reg(0x850E,0xD2);
+					ov3640_write_reg(0x850F,0x0F);
+					ov3640_write_reg(0x8510,0x80);
+					ov3640_write_reg(0x8511,0x02);
+					ov3640_write_reg(0x8512,0xC2);
+					ov3640_write_reg(0x8513,0x0F);
+					ov3640_write_reg(0x8514,0x02);
+					ov3640_write_reg(0x8515,0x0C);
+					ov3640_write_reg(0x8516,0x76);
+					ov3640_write_reg(0x8517,0xC2);
+					ov3640_write_reg(0x8518,0x0D);
+					ov3640_write_reg(0x8519,0x75);
+					ov3640_write_reg(0x851A,0x3C);
+					ov3640_write_reg(0x851B,0x01);
+					ov3640_write_reg(0x851C,0xC2);
+					ov3640_write_reg(0x851D,0x0C);
+					ov3640_write_reg(0x851E,0x90);
+					ov3640_write_reg(0x851F,0x3F);
+					ov3640_write_reg(0x8520,0x02);
+					ov3640_write_reg(0x8521,0xE4);
+					ov3640_write_reg(0x8522,0xF0);
+					ov3640_write_reg(0x8523,0xA3);
+					ov3640_write_reg(0x8524,0xF0);
+					ov3640_write_reg(0x8525,0x22);
+					ov3640_write_reg(0x8526,0xC2);
+					ov3640_write_reg(0x8527,0x0D);
+					ov3640_write_reg(0x8528,0xE4);
+					ov3640_write_reg(0x8529,0xF5);
+					ov3640_write_reg(0x852A,0x3C);
+					ov3640_write_reg(0x852B,0xD2);
+					ov3640_write_reg(0x852C,0x0C);
+					ov3640_write_reg(0x852D,0x22);
+					ov3640_write_reg(0x852E,0xE4);
+					ov3640_write_reg(0x852F,0xF5);
+					ov3640_write_reg(0x8530,0x3C);
+					ov3640_write_reg(0x8531,0xC2);
+					ov3640_write_reg(0x8532,0x0C);
+					ov3640_write_reg(0x8533,0xC2);
+					ov3640_write_reg(0x8534,0x0B);
+					ov3640_write_reg(0x8535,0xD2);
+					ov3640_write_reg(0x8536,0x0D);
+					ov3640_write_reg(0x8537,0x22);
+					ov3640_write_reg(0x8538,0xC2);
+					ov3640_write_reg(0x8539,0x0D);
+					ov3640_write_reg(0x853A,0xE4);
+					ov3640_write_reg(0x853B,0xF5);
+					ov3640_write_reg(0x853C,0x3C);
+					ov3640_write_reg(0x853D,0xC2);
+					ov3640_write_reg(0x853E,0x0C);
+					ov3640_write_reg(0x853F,0xF5);
+					ov3640_write_reg(0x8540,0x72);
+					ov3640_write_reg(0x8541,0xF5);
+					ov3640_write_reg(0x8542,0x4B);
+					ov3640_write_reg(0x8543,0xF5);
+					ov3640_write_reg(0x8544,0x4C);
+					ov3640_write_reg(0x8545,0x80);
+					ov3640_write_reg(0x8546,0x4D);
+					ov3640_write_reg(0x8547,0xC2);
+					ov3640_write_reg(0x8548,0x0D);
+					ov3640_write_reg(0x8549,0xD2);
+					ov3640_write_reg(0x854A,0x0B);
+					ov3640_write_reg(0x854B,0x22);
+					ov3640_write_reg(0x854C,0x12);
+					ov3640_write_reg(0x854D,0x06);
+					ov3640_write_reg(0x854E,0x53);
+					ov3640_write_reg(0x854F,0x75);
+					ov3640_write_reg(0x8550,0x72);
+					ov3640_write_reg(0x8551,0x01);
+					ov3640_write_reg(0x8552,0x80);
+					ov3640_write_reg(0x8553,0x0B);
+					ov3640_write_reg(0x8554,0x12);
+					ov3640_write_reg(0x8555,0x06);
+					ov3640_write_reg(0x8556,0x53);
+					ov3640_write_reg(0x8557,0x75);
+					ov3640_write_reg(0x8558,0x72);
+					ov3640_write_reg(0x8559,0x02);
+					ov3640_write_reg(0x855A,0x80);
+					ov3640_write_reg(0x855B,0x03);
+					ov3640_write_reg(0x855C,0xE4);
+					ov3640_write_reg(0x855D,0xF5);
+					ov3640_write_reg(0x855E,0x72);
+					ov3640_write_reg(0x855F,0x90);
+					ov3640_write_reg(0x8560,0x3F);
+					ov3640_write_reg(0x8561,0x04);
+					ov3640_write_reg(0x8562,0xE5);
+					ov3640_write_reg(0x8563,0x72);
+					ov3640_write_reg(0x8564,0xF0);
+					ov3640_write_reg(0x8565,0x22);
+					ov3640_write_reg(0x8566,0xD2);
+					ov3640_write_reg(0x8567,0x0A);
+					ov3640_write_reg(0x8568,0x90);
+					ov3640_write_reg(0x8569,0x3F);
+					ov3640_write_reg(0x856A,0x01);
+					ov3640_write_reg(0x856B,0xE0);
+					ov3640_write_reg(0x856C,0x90);
+					ov3640_write_reg(0x856D,0x3F);
+					ov3640_write_reg(0x856E,0x05);
+					ov3640_write_reg(0x856F,0xF0);
+					ov3640_write_reg(0x8570,0x22);
+					ov3640_write_reg(0x8571,0x90);
+					ov3640_write_reg(0x8572,0x3F);
+					ov3640_write_reg(0x8573,0x06);
+					ov3640_write_reg(0x8574,0xE0);
+					ov3640_write_reg(0x8575,0xF5);
+					ov3640_write_reg(0x8576,0x46);
+					ov3640_write_reg(0x8577,0xE4);
+					ov3640_write_reg(0x8578,0xF0);
+					ov3640_write_reg(0x8579,0xE5);
+					ov3640_write_reg(0x857A,0x46);
+					ov3640_write_reg(0x857B,0xD3);
+					ov3640_write_reg(0x857C,0x94);
+					ov3640_write_reg(0x857D,0x06);
+					ov3640_write_reg(0x857E,0x40);
+					ov3640_write_reg(0x857F,0x03);
+					ov3640_write_reg(0x8580,0x75);
+					ov3640_write_reg(0x8581,0x46);
+					ov3640_write_reg(0x8582,0x06);
+					ov3640_write_reg(0x8583,0xD2);
+					ov3640_write_reg(0x8584,0x0E);
+					ov3640_write_reg(0x8585,0x22);
+					ov3640_write_reg(0x8586,0x75);
+					ov3640_write_reg(0x8587,0x4B);
+					ov3640_write_reg(0x8588,0x02);
+					ov3640_write_reg(0x8589,0x75);
+					ov3640_write_reg(0x858A,0x4C);
+					ov3640_write_reg(0x858B,0x58);
+					ov3640_write_reg(0x858C,0x80);
+					ov3640_write_reg(0x858D,0x06);
+					ov3640_write_reg(0x858E,0x85);
+					ov3640_write_reg(0x858F,0x3D);
+					ov3640_write_reg(0x8590,0x4B);
+					ov3640_write_reg(0x8591,0x85);
+					ov3640_write_reg(0x8592,0x3E);
+					ov3640_write_reg(0x8593,0x4C);
+					ov3640_write_reg(0x8594,0xAF);
+					ov3640_write_reg(0x8595,0x4C);
+					ov3640_write_reg(0x8596,0xAE);
+					ov3640_write_reg(0x8597,0x4B);
+					ov3640_write_reg(0x8598,0x12);
+					ov3640_write_reg(0x8599,0x0B);
+					ov3640_write_reg(0x859A,0x7A);
+					ov3640_write_reg(0x859B,0x22);
+					ov3640_write_reg(0x859C,0xE5);
+					ov3640_write_reg(0x859D,0x46);
+					ov3640_write_reg(0x859E,0x24);
+					ov3640_write_reg(0x859F,0x09);
+					ov3640_write_reg(0x85A0,0xFF);
+					ov3640_write_reg(0x85A1,0xE4);
+					ov3640_write_reg(0x85A2,0x33);
+					ov3640_write_reg(0x85A3,0xFE);
+					ov3640_write_reg(0x85A4,0x12);
+					ov3640_write_reg(0x85A5,0x0C);
+					ov3640_write_reg(0x85A6,0xC8);
+					ov3640_write_reg(0x85A7,0xEE);
+					ov3640_write_reg(0x85A8,0xC4);
+					ov3640_write_reg(0x85A9,0xF8);
+					ov3640_write_reg(0x85AA,0x54);
+					ov3640_write_reg(0x85AB,0xF0);
+					ov3640_write_reg(0x85AC,0xC8);
+					ov3640_write_reg(0x85AD,0x22);
+					ov3640_write_reg(0x85AE,0xE5);
+					ov3640_write_reg(0x85AF,0x4C);
+					ov3640_write_reg(0x85B0,0x25);
+					ov3640_write_reg(0x85B1,0x3E);
+					ov3640_write_reg(0x85B2,0xCF);
+					ov3640_write_reg(0x85B3,0xE5);
+					ov3640_write_reg(0x85B4,0x4B);
+					ov3640_write_reg(0x85B5,0x35);
+					ov3640_write_reg(0x85B6,0x3D);
+					ov3640_write_reg(0x85B7,0xCF);
+					ov3640_write_reg(0x85B8,0x24);
+					ov3640_write_reg(0x85B9,0x28);
+					ov3640_write_reg(0x85BA,0xCF);
+					ov3640_write_reg(0x85BB,0x34);
+					ov3640_write_reg(0x85BC,0x00);
+					ov3640_write_reg(0x85BD,0xFE);
+					ov3640_write_reg(0x85BE,0xC3);
+					ov3640_write_reg(0x85BF,0xEF);
+					ov3640_write_reg(0x85C0,0x94);
+					ov3640_write_reg(0x85C1,0x58);
+					ov3640_write_reg(0x85C2,0xEE);
+					ov3640_write_reg(0x85C3,0x94);
+					ov3640_write_reg(0x85C4,0x02);
+					ov3640_write_reg(0x85C5,0x22);
+					ov3640_write_reg(0x85C6,0xC2);
+					ov3640_write_reg(0x85C7,0x00);
+					ov3640_write_reg(0x85C8,0x90);
+					ov3640_write_reg(0x85C9,0x30);
+					ov3640_write_reg(0x85CA,0xB4);
+					ov3640_write_reg(0x85CB,0xE5);
+					ov3640_write_reg(0x85CC,0x20);
+					ov3640_write_reg(0x85CD,0xF0);
+					ov3640_write_reg(0x85CE,0x22);
+					ov3640_write_reg(0x85CF,0x90);
+					ov3640_write_reg(0x85D0,0x3A);
+					ov3640_write_reg(0x85D1,0x00);
+					ov3640_write_reg(0x85D2,0xF0);
+					ov3640_write_reg(0x85D3,0x90);
+					ov3640_write_reg(0x85D4,0x3A);
+					ov3640_write_reg(0x85D5,0x03);
+					ov3640_write_reg(0x85D6,0xE0);
+					ov3640_write_reg(0x85D7,0x22);
+					ov3640_write_reg(0x85D8,0xD3);
+					ov3640_write_reg(0x85D9,0xE5);
+					ov3640_write_reg(0x85DA,0x28);
+					ov3640_write_reg(0x85DB,0x95);
+					ov3640_write_reg(0x85DC,0x50);
+					ov3640_write_reg(0x85DD,0xE5);
+					ov3640_write_reg(0x85DE,0x27);
+					ov3640_write_reg(0x85DF,0x95);
+					ov3640_write_reg(0x85E0,0x4F);
+					ov3640_write_reg(0x85E1,0x22);
+					ov3640_write_reg(0x85E2,0x85);
+					ov3640_write_reg(0x85E3,0x45);
+					ov3640_write_reg(0x85E4,0x61);
+					ov3640_write_reg(0x85E5,0x90);
+					ov3640_write_reg(0x85E6,0x3F);
+					ov3640_write_reg(0x85E7,0x07);
+					ov3640_write_reg(0x85E8,0xE5);
+					ov3640_write_reg(0x85E9,0x61);
+					ov3640_write_reg(0x85EA,0xF0);
+					ov3640_write_reg(0x85EB,0x22);
+					ov3640_write_reg(0x85EC,0xC3);
+					ov3640_write_reg(0x85ED,0x74);
+					ov3640_write_reg(0x85EE,0x07);
+					ov3640_write_reg(0x85EF,0x95);
+					ov3640_write_reg(0x85F0,0x46);
+					ov3640_write_reg(0x85F1,0xFF);
+					ov3640_write_reg(0x85F2,0xE4);
+					ov3640_write_reg(0x85F3,0x94);
+					ov3640_write_reg(0x85F4,0x00);
+					ov3640_write_reg(0x85F5,0x22);
+					ov3640_write_reg(0x85F6,0x85);
+					ov3640_write_reg(0x85F7,0x32);
+					ov3640_write_reg(0x85F8,0x38);
+					ov3640_write_reg(0x85F9,0x85);
+					ov3640_write_reg(0x85FA,0x33);
+					ov3640_write_reg(0x85FB,0x39);
+					ov3640_write_reg(0x85FC,0x85);
+					ov3640_write_reg(0x85FD,0x30);
+					ov3640_write_reg(0x85FE,0x3A);
+					ov3640_write_reg(0x85FF,0x85);
+					ov3640_write_reg(0x8600,0x31);
+					ov3640_write_reg(0x8601,0x3B);
+					ov3640_write_reg(0x8602,0x22);
+					ov3640_write_reg(0x8603,0x85);
+					ov3640_write_reg(0x8604,0x36);
+					ov3640_write_reg(0x8605,0x38);
+					ov3640_write_reg(0x8606,0x85);
+					ov3640_write_reg(0x8607,0x37);
+					ov3640_write_reg(0x8608,0x39);
+					ov3640_write_reg(0x8609,0x85);
+					ov3640_write_reg(0x860A,0x34);
+					ov3640_write_reg(0x860B,0x3A);
+					ov3640_write_reg(0x860C,0x85);
+					ov3640_write_reg(0x860D,0x35);
+					ov3640_write_reg(0x860E,0x3B);
+					ov3640_write_reg(0x860F,0x22);
+					ov3640_write_reg(0x8610,0xD3);
+					ov3640_write_reg(0x8611,0xEF);
+					ov3640_write_reg(0x8612,0x9D);
+					ov3640_write_reg(0x8613,0xEC);
+					ov3640_write_reg(0x8614,0x64);
+					ov3640_write_reg(0x8615,0x80);
+					ov3640_write_reg(0x8616,0xF8);
+					ov3640_write_reg(0x8617,0xEE);
+					ov3640_write_reg(0x8618,0x64);
+					ov3640_write_reg(0x8619,0x80);
+					ov3640_write_reg(0x861A,0x98);
+					ov3640_write_reg(0x861B,0x22);
+					ov3640_write_reg(0x861C,0x13);
+					ov3640_write_reg(0x861D,0xFF);
+					ov3640_write_reg(0x861E,0xD3);
+					ov3640_write_reg(0x861F,0xE5);
+					ov3640_write_reg(0x8620,0x28);
+					ov3640_write_reg(0x8621,0x9F);
+					ov3640_write_reg(0x8622,0xE5);
+					ov3640_write_reg(0x8623,0x27);
+					ov3640_write_reg(0x8624,0x9E);
+					ov3640_write_reg(0x8625,0x22);
+					ov3640_write_reg(0x8626,0xD3);
+					ov3640_write_reg(0x8627,0xE5);
+					ov3640_write_reg(0x8628,0x39);
+					ov3640_write_reg(0x8629,0x95);
+					ov3640_write_reg(0x862A,0x3B);
+					ov3640_write_reg(0x862B,0xE5);
+					ov3640_write_reg(0x862C,0x38);
+					ov3640_write_reg(0x862D,0x95);
+					ov3640_write_reg(0x862E,0x3A);
+					ov3640_write_reg(0x862F,0x22);
+					ov3640_write_reg(0x8630,0x74);
+					ov3640_write_reg(0x8631,0xFF);
+					ov3640_write_reg(0x8632,0xF0);
+					ov3640_write_reg(0x8633,0xA3);
+					ov3640_write_reg(0x8634,0x74);
+					ov3640_write_reg(0x8635,0x80);
+					ov3640_write_reg(0x8636,0xF0);
+					ov3640_write_reg(0x8637,0xA3);
+					ov3640_write_reg(0x8638,0xF0);
+					ov3640_write_reg(0x8639,0xA3);
+					ov3640_write_reg(0x863A,0x74);
+					ov3640_write_reg(0x863B,0x01);
+					ov3640_write_reg(0x863C,0xF0);
+					ov3640_write_reg(0x863D,0x22);
+					ov3640_write_reg(0x863E,0xFB);
+					ov3640_write_reg(0x863F,0xEF);
+					ov3640_write_reg(0x8640,0x75);
+					ov3640_write_reg(0x8641,0xF0);
+					ov3640_write_reg(0x8642,0x08);
+					ov3640_write_reg(0x8643,0xA4);
+					ov3640_write_reg(0x8644,0xFE);
+					ov3640_write_reg(0x8645,0x22);
+					ov3640_write_reg(0x8646,0x54);
+					ov3640_write_reg(0x8647,0x07);
+					ov3640_write_reg(0x8648,0xC4);
+					ov3640_write_reg(0x8649,0xF8);
+					ov3640_write_reg(0x864A,0x54);
+					ov3640_write_reg(0x864B,0xF0);
+					ov3640_write_reg(0x864C,0xC8);
+					ov3640_write_reg(0x864D,0xE4);
+					ov3640_write_reg(0x864E,0xC4);
+					ov3640_write_reg(0x864F,0x54);
+					ov3640_write_reg(0x8650,0x0F);
+					ov3640_write_reg(0x8651,0x48);
+					ov3640_write_reg(0x8652,0x22);
+					ov3640_write_reg(0x8653,0xE4);
+					ov3640_write_reg(0x8654,0xF5);
+					ov3640_write_reg(0x8655,0x4F);
+					ov3640_write_reg(0x8656,0xF5);
+					ov3640_write_reg(0x8657,0x50);
+					ov3640_write_reg(0x8658,0xF5);
+					ov3640_write_reg(0x8659,0x43);
+					ov3640_write_reg(0x865A,0xC2);
+					ov3640_write_reg(0x865B,0x09);
+					ov3640_write_reg(0x865C,0xC2);
+					ov3640_write_reg(0x865D,0x0A);
+					ov3640_write_reg(0x865E,0x22);
+					ov3640_write_reg(0x865F,0xE5);
+					ov3640_write_reg(0x8660,0x26);
+					ov3640_write_reg(0x8661,0x25);
+					ov3640_write_reg(0x8662,0xE0);
+					ov3640_write_reg(0x8663,0x24);
+					ov3640_write_reg(0x8664,0x62);
+					ov3640_write_reg(0x8665,0xF8);
+					ov3640_write_reg(0x8666,0xE6);
+					ov3640_write_reg(0x8667,0xFE);
+					ov3640_write_reg(0x8668,0x08);
+					ov3640_write_reg(0x8669,0xE6);
+					ov3640_write_reg(0x866A,0x22);
+					ov3640_write_reg(0x866B,0xFE);
+					ov3640_write_reg(0x866C,0xA3);
+					ov3640_write_reg(0x866D,0xE0);
+					ov3640_write_reg(0x866E,0xFD);
+					ov3640_write_reg(0x866F,0xEE);
+					ov3640_write_reg(0x8670,0xF5);
+					ov3640_write_reg(0x8671,0x08);
+					ov3640_write_reg(0x8672,0xED);
+					ov3640_write_reg(0x8673,0xF5);
+					ov3640_write_reg(0x8674,0x09);
+					ov3640_write_reg(0x8675,0x22);
+					ov3640_write_reg(0x8676,0xD3);
+					ov3640_write_reg(0x8677,0xE5);
+					ov3640_write_reg(0x8678,0x0B);
+					ov3640_write_reg(0x8679,0x94);
+					ov3640_write_reg(0x867A,0x40);
+					ov3640_write_reg(0x867B,0xE5);
+					ov3640_write_reg(0x867C,0x0A);
+					ov3640_write_reg(0x867D,0x94);
+					ov3640_write_reg(0x867E,0x00);
+					ov3640_write_reg(0x867F,0x22);
+					ov3640_write_reg(0x8680,0x90);
+					ov3640_write_reg(0x8681,0x33);
+					ov3640_write_reg(0x8682,0x5F);
+					ov3640_write_reg(0x8683,0xE0);
+					ov3640_write_reg(0x8684,0x54);
+					ov3640_write_reg(0x8685,0x0F);
+					ov3640_write_reg(0x8686,0x12);
+					ov3640_write_reg(0x8687,0x06);
+					ov3640_write_reg(0x8688,0x6B);
+					ov3640_write_reg(0x8689,0x90);
+					ov3640_write_reg(0x868A,0x33);
+					ov3640_write_reg(0x868B,0x5F);
+					ov3640_write_reg(0x868C,0xE0);
+					ov3640_write_reg(0x868D,0x54);
+					ov3640_write_reg(0x868E,0x70);
+					ov3640_write_reg(0x868F,0x75);
+					ov3640_write_reg(0x8690,0xF0);
+					ov3640_write_reg(0x8691,0x10);
+					ov3640_write_reg(0x8692,0xA4);
+					ov3640_write_reg(0x8693,0xFF);
+					ov3640_write_reg(0x8694,0x90);
+					ov3640_write_reg(0x8695,0x33);
+					ov3640_write_reg(0x8696,0x61);
+					ov3640_write_reg(0x8697,0xE0);
+					ov3640_write_reg(0x8698,0xFD);
+					ov3640_write_reg(0x8699,0xE5);
+					ov3640_write_reg(0x869A,0xF0);
+					ov3640_write_reg(0x869B,0xF5);
+					ov3640_write_reg(0x869C,0x0A);
+					ov3640_write_reg(0x869D,0xEF);
+					ov3640_write_reg(0x869E,0x4D);
+					ov3640_write_reg(0x869F,0xF5);
+					ov3640_write_reg(0x86A0,0x0B);
+					ov3640_write_reg(0x86A1,0xE5);
+					ov3640_write_reg(0x86A2,0x4A);
+					ov3640_write_reg(0x86A3,0xB5);
+					ov3640_write_reg(0x86A4,0x09);
+					ov3640_write_reg(0x86A5,0x11);
+					ov3640_write_reg(0x86A6,0xE5);
+					ov3640_write_reg(0x86A7,0x49);
+					ov3640_write_reg(0x86A8,0xB5);
+					ov3640_write_reg(0x86A9,0x08);
+					ov3640_write_reg(0x86AA,0x0C);
+					ov3640_write_reg(0x86AB,0xE5);
+					ov3640_write_reg(0x86AC,0x42);
+					ov3640_write_reg(0x86AD,0x65);
+					ov3640_write_reg(0x86AE,0x0B);
+					ov3640_write_reg(0x86AF,0x70);
+					ov3640_write_reg(0x86B0,0x04);
+					ov3640_write_reg(0x86B1,0xE5);
+					ov3640_write_reg(0x86B2,0x41);
+					ov3640_write_reg(0x86B3,0x65);
+					ov3640_write_reg(0x86B4,0x0A);
+					ov3640_write_reg(0x86B5,0x60);
+					ov3640_write_reg(0x86B6,0x19);
+					ov3640_write_reg(0x86B7,0x85);
+					ov3640_write_reg(0x86B8,0x08);
+					ov3640_write_reg(0x86B9,0x49);
+					ov3640_write_reg(0x86BA,0x85);
+					ov3640_write_reg(0x86BB,0x09);
+					ov3640_write_reg(0x86BC,0x4A);
+					ov3640_write_reg(0x86BD,0x85);
+					ov3640_write_reg(0x86BE,0x0A);
+					ov3640_write_reg(0x86BF,0x41);
+					ov3640_write_reg(0x86C0,0x85);
+					ov3640_write_reg(0x86C1,0x0B);
+					ov3640_write_reg(0x86C2,0x42);
+					ov3640_write_reg(0x86C3,0xE4);
+					ov3640_write_reg(0x86C4,0xFB);
+					ov3640_write_reg(0x86C5,0xAD);
+					ov3640_write_reg(0x86C6,0x0B);
+					ov3640_write_reg(0x86C7,0xAC);
+					ov3640_write_reg(0x86C8,0x0A);
+					ov3640_write_reg(0x86C9,0xAF);
+					ov3640_write_reg(0x86CA,0x09);
+					ov3640_write_reg(0x86CB,0xAE);
+					ov3640_write_reg(0x86CC,0x08);
+					ov3640_write_reg(0x86CD,0x12);
+					ov3640_write_reg(0x86CE,0x08);
+					ov3640_write_reg(0x86CF,0xEF);
+					ov3640_write_reg(0x86D0,0x90);
+					ov3640_write_reg(0x86D1,0x33);
+					ov3640_write_reg(0x86D2,0x02);
+					ov3640_write_reg(0x86D3,0xE0);
+					ov3640_write_reg(0x86D4,0x20);
+					ov3640_write_reg(0x86D5,0xE5);
+					ov3640_write_reg(0x86D6,0x03);
+					ov3640_write_reg(0x86D7,0x12);
+					ov3640_write_reg(0x86D8,0x07);
+					ov3640_write_reg(0x86D9,0x2B);
+					ov3640_write_reg(0x86DA,0x90);
+					ov3640_write_reg(0x86DB,0x33);
+					ov3640_write_reg(0x86DC,0x02);
+					ov3640_write_reg(0x86DD,0xE0);
+					ov3640_write_reg(0x86DE,0x30);
+					ov3640_write_reg(0x86DF,0xE5);
+					ov3640_write_reg(0x86E0,0x2C);
+					ov3640_write_reg(0x86E1,0x90);
+					ov3640_write_reg(0x86E2,0x30);
+					ov3640_write_reg(0x86E3,0x88);
+					ov3640_write_reg(0x86E4,0xE0);
+					ov3640_write_reg(0x86E5,0x12);
+					ov3640_write_reg(0x86E6,0x06);
+					ov3640_write_reg(0x86E7,0x6B);
+					ov3640_write_reg(0x86E8,0xA3);
+					ov3640_write_reg(0x86E9,0xE0);
+					ov3640_write_reg(0x86EA,0xFE);
+					ov3640_write_reg(0x86EB,0xA3);
+					ov3640_write_reg(0x86EC,0xE0);
+					ov3640_write_reg(0x86ED,0xFD);
+					ov3640_write_reg(0x86EE,0xEE);
+					ov3640_write_reg(0x86EF,0xF5);
+					ov3640_write_reg(0x86F0,0x0A);
+					ov3640_write_reg(0x86F1,0xED);
+					ov3640_write_reg(0x86F2,0xF5);
+					ov3640_write_reg(0x86F3,0x0B);
+					ov3640_write_reg(0x86F4,0xE5);
+					ov3640_write_reg(0x86F5,0x48);
+					ov3640_write_reg(0x86F6,0xB5);
+					ov3640_write_reg(0x86F7,0x09);
+					ov3640_write_reg(0x86F8,0x11);
+					ov3640_write_reg(0x86F9,0xE5);
+					ov3640_write_reg(0x86FA,0x47);
+					ov3640_write_reg(0x86FB,0xB5);
+					ov3640_write_reg(0x86FC,0x08);
+					ov3640_write_reg(0x86FD,0x0C);
+					ov3640_write_reg(0x86FE,0xE5);
+					ov3640_write_reg(0x86FF,0x40);
+					ov3640_write_reg(0x8700,0x65);
+					ov3640_write_reg(0x8701,0x0B);
+					ov3640_write_reg(0x8702,0x70);
+					ov3640_write_reg(0x8703,0x04);
+					ov3640_write_reg(0x8704,0xE5);
+					ov3640_write_reg(0x8705,0x3F);
+					ov3640_write_reg(0x8706,0x65);
+					ov3640_write_reg(0x8707,0x0A);
+					ov3640_write_reg(0x8708,0x60);
+					ov3640_write_reg(0x8709,0x03);
+					ov3640_write_reg(0x870A,0x12);
+					ov3640_write_reg(0x870B,0x07);
+					ov3640_write_reg(0x870C,0x2B);
+					ov3640_write_reg(0x870D,0x30);
+					ov3640_write_reg(0x870E,0x0E);
+					ov3640_write_reg(0x870F,0x1A);
+					ov3640_write_reg(0x8710,0xE4);
+					ov3640_write_reg(0x8711,0xFB);
+					ov3640_write_reg(0x8712,0xAD);
+					ov3640_write_reg(0x8713,0x42);
+					ov3640_write_reg(0x8714,0xAC);
+					ov3640_write_reg(0x8715,0x41);
+					ov3640_write_reg(0x8716,0xAF);
+					ov3640_write_reg(0x8717,0x4A);
+					ov3640_write_reg(0x8718,0xAE);
+					ov3640_write_reg(0x8719,0x49);
+					ov3640_write_reg(0x871A,0x12);
+					ov3640_write_reg(0x871B,0x08);
+					ov3640_write_reg(0x871C,0xEF);
+					ov3640_write_reg(0x871D,0xAD);
+					ov3640_write_reg(0x871E,0x40);
+					ov3640_write_reg(0x871F,0xAC);
+					ov3640_write_reg(0x8720,0x3F);
+					ov3640_write_reg(0x8721,0xAF);
+					ov3640_write_reg(0x8722,0x48);
+					ov3640_write_reg(0x8723,0xAE);
+					ov3640_write_reg(0x8724,0x47);
+					ov3640_write_reg(0x8725,0x12);
+					ov3640_write_reg(0x8726,0x09);
+					ov3640_write_reg(0x8727,0x6D);
+					ov3640_write_reg(0x8728,0xC2);
+					ov3640_write_reg(0x8729,0x0E);
+					ov3640_write_reg(0x872A,0x22);
+					ov3640_write_reg(0x872B,0x85);
+					ov3640_write_reg(0x872C,0x08);
+					ov3640_write_reg(0x872D,0x47);
+					ov3640_write_reg(0x872E,0x85);
+					ov3640_write_reg(0x872F,0x09);
+					ov3640_write_reg(0x8730,0x48);
+					ov3640_write_reg(0x8731,0x85);
+					ov3640_write_reg(0x8732,0x0A);
+					ov3640_write_reg(0x8733,0x3F);
+					ov3640_write_reg(0x8734,0x85);
+					ov3640_write_reg(0x8735,0x0B);
+					ov3640_write_reg(0x8736,0x40);
+					ov3640_write_reg(0x8737,0xAD);
+					ov3640_write_reg(0x8738,0x40);
+					ov3640_write_reg(0x8739,0xAC);
+					ov3640_write_reg(0x873A,0x3F);
+					ov3640_write_reg(0x873B,0xAF);
+					ov3640_write_reg(0x873C,0x48);
+					ov3640_write_reg(0x873D,0xAE);
+					ov3640_write_reg(0x873E,0x47);
+					ov3640_write_reg(0x873F,0x12);
+					ov3640_write_reg(0x8740,0x09);
+					ov3640_write_reg(0x8741,0x6D);
+					ov3640_write_reg(0x8742,0x22);
+					ov3640_write_reg(0x8743,0xE5);
+					ov3640_write_reg(0x8744,0x24);
+					ov3640_write_reg(0x8745,0x70);
+					ov3640_write_reg(0x8746,0x0A);
+					ov3640_write_reg(0x8747,0xF5);
+					ov3640_write_reg(0x8748,0x3D);
+					ov3640_write_reg(0x8749,0xF5);
+					ov3640_write_reg(0x874A,0x3E);
+					ov3640_write_reg(0x874B,0x12);
+					ov3640_write_reg(0x874C,0x0C);
+					ov3640_write_reg(0x874D,0xEA);
+					ov3640_write_reg(0x874E,0x05);
+					ov3640_write_reg(0x874F,0x24);
+					ov3640_write_reg(0x8750,0x22);
+					ov3640_write_reg(0x8751,0xE5);
+					ov3640_write_reg(0x8752,0x24);
+					ov3640_write_reg(0x8753,0xC3);
+					ov3640_write_reg(0x8754,0x94);
+					ov3640_write_reg(0x8755,0x01);
+					ov3640_write_reg(0x8756,0x50);
+					ov3640_write_reg(0x8757,0x03);
+					ov3640_write_reg(0x8758,0x05);
+					ov3640_write_reg(0x8759,0x24);
+					ov3640_write_reg(0x875A,0x22);
+					ov3640_write_reg(0x875B,0xE5);
+					ov3640_write_reg(0x875C,0x24);
+					ov3640_write_reg(0x875D,0xB4);
+					ov3640_write_reg(0x875E,0x01);
+					ov3640_write_reg(0x875F,0x1A);
+					ov3640_write_reg(0x8760,0xE4);
+					ov3640_write_reg(0x8761,0xFD);
+					ov3640_write_reg(0x8762,0xFF);
+					ov3640_write_reg(0x8763,0x12);
+					ov3640_write_reg(0x8764,0x0B);
+					ov3640_write_reg(0x8765,0x2C);
+					ov3640_write_reg(0x8766,0x8E);
+					ov3640_write_reg(0x8767,0x22);
+					ov3640_write_reg(0x8768,0x8F);
+					ov3640_write_reg(0x8769,0x23);
+					ov3640_write_reg(0x876A,0x75);
+					ov3640_write_reg(0x876B,0x3D);
+					ov3640_write_reg(0x876C,0x00);
+					ov3640_write_reg(0x876D,0x75);
+					ov3640_write_reg(0x876E,0x3E);
+					ov3640_write_reg(0x876F,0x0A);
+					ov3640_write_reg(0x8770,0xAF);
+					ov3640_write_reg(0x8771,0x3E);
+					ov3640_write_reg(0x8772,0xAE);
+					ov3640_write_reg(0x8773,0x3D);
+					ov3640_write_reg(0x8774,0x12);
+					ov3640_write_reg(0x8775,0x0B);
+					ov3640_write_reg(0x8776,0x7A);
+					ov3640_write_reg(0x8777,0x05);
+					ov3640_write_reg(0x8778,0x24);
+					ov3640_write_reg(0x8779,0x22);
+					ov3640_write_reg(0x877A,0xE4);
+					ov3640_write_reg(0x877B,0xFD);
+					ov3640_write_reg(0x877C,0xFF);
+					ov3640_write_reg(0x877D,0x12);
+					ov3640_write_reg(0x877E,0x0B);
+					ov3640_write_reg(0x877F,0x2C);
+					ov3640_write_reg(0x8780,0xC3);
+					ov3640_write_reg(0x8781,0xEF);
+					ov3640_write_reg(0x8782,0x95);
+					ov3640_write_reg(0x8783,0x23);
+					ov3640_write_reg(0x8784,0xFF);
+					ov3640_write_reg(0x8785,0xEE);
+					ov3640_write_reg(0x8786,0x95);
+					ov3640_write_reg(0x8787,0x22);
+					ov3640_write_reg(0x8788,0xFE);
+					ov3640_write_reg(0x8789,0x12);
+					ov3640_write_reg(0x878A,0x0C);
+					ov3640_write_reg(0x878B,0xF7);
+					ov3640_write_reg(0x878C,0xD3);
+					ov3640_write_reg(0x878D,0xEF);
+					ov3640_write_reg(0x878E,0x94);
+					ov3640_write_reg(0x878F,0x20);
+					ov3640_write_reg(0x8790,0xEE);
+					ov3640_write_reg(0x8791,0x64);
+					ov3640_write_reg(0x8792,0x80);
+					ov3640_write_reg(0x8793,0x94);
+					ov3640_write_reg(0x8794,0x80);
+					ov3640_write_reg(0x8795,0x40);
+					ov3640_write_reg(0x8796,0x15);
+					ov3640_write_reg(0x8797,0xC2);
+					ov3640_write_reg(0x8798,0x0B);
+					ov3640_write_reg(0x8799,0xE4);
+					ov3640_write_reg(0x879A,0xF5);
+					ov3640_write_reg(0x879B,0x24);
+					ov3640_write_reg(0x879C,0x74);
+					ov3640_write_reg(0x879D,0xF6);
+					ov3640_write_reg(0x879E,0x25);
+					ov3640_write_reg(0x879F,0x3E);
+					ov3640_write_reg(0x87A0,0xF5);
+					ov3640_write_reg(0x87A1,0x3E);
+					ov3640_write_reg(0x87A2,0x74);
+					ov3640_write_reg(0x87A3,0xFF);
+					ov3640_write_reg(0x87A4,0x35);
+					ov3640_write_reg(0x87A5,0x3D);
+					ov3640_write_reg(0x87A6,0xF5);
+					ov3640_write_reg(0x87A7,0x3D);
+					ov3640_write_reg(0x87A8,0xE4);
+					ov3640_write_reg(0x87A9,0xFF);
+					ov3640_write_reg(0x87AA,0x80);
+					ov3640_write_reg(0x87AB,0x1F);
+					ov3640_write_reg(0x87AC,0xC3);
+					ov3640_write_reg(0x87AD,0xE5);
+					ov3640_write_reg(0x87AE,0x3E);
+					ov3640_write_reg(0x87AF,0x94);
+					ov3640_write_reg(0x87B0,0x96);
+					ov3640_write_reg(0x87B1,0xE5);
+					ov3640_write_reg(0x87B2,0x3D);
+					ov3640_write_reg(0x87B3,0x94);
+					ov3640_write_reg(0x87B4,0x00);
+					ov3640_write_reg(0x87B5,0x50);
+					ov3640_write_reg(0x87B6,0x18);
+					ov3640_write_reg(0x87B7,0x74);
+					ov3640_write_reg(0x87B8,0x0A);
+					ov3640_write_reg(0x87B9,0x25);
+					ov3640_write_reg(0x87BA,0x3E);
+					ov3640_write_reg(0x87BB,0xF5);
+					ov3640_write_reg(0x87BC,0x3E);
+					ov3640_write_reg(0x87BD,0xE4);
+					ov3640_write_reg(0x87BE,0x35);
+					ov3640_write_reg(0x87BF,0x3D);
+					ov3640_write_reg(0x87C0,0xF5);
+					ov3640_write_reg(0x87C1,0x3D);
+					ov3640_write_reg(0x87C2,0xE5);
+					ov3640_write_reg(0x87C3,0x3E);
+					ov3640_write_reg(0x87C4,0x24);
+					ov3640_write_reg(0x87C5,0xFF);
+					ov3640_write_reg(0x87C6,0xFF);
+					ov3640_write_reg(0x87C7,0xE5);
+					ov3640_write_reg(0x87C8,0x3D);
+					ov3640_write_reg(0x87C9,0x34);
+					ov3640_write_reg(0x87CA,0xFF);
+					ov3640_write_reg(0x87CB,0xFE);
+					ov3640_write_reg(0x87CC,0x02);
+					ov3640_write_reg(0x87CD,0x0B);
+					ov3640_write_reg(0x87CE,0x7A);
+					ov3640_write_reg(0x87CF,0xC2);
+					ov3640_write_reg(0x87D0,0x0B);
+					ov3640_write_reg(0x87D1,0xE4);
+					ov3640_write_reg(0x87D2,0xF5);
+					ov3640_write_reg(0x87D3,0x24);
+					ov3640_write_reg(0x87D4,0xFF);
+					ov3640_write_reg(0x87D5,0xFE);
+					ov3640_write_reg(0x87D6,0x12);
+					ov3640_write_reg(0x87D7,0x0B);
+					ov3640_write_reg(0x87D8,0x7A);
+					ov3640_write_reg(0x87D9,0x75);
+					ov3640_write_reg(0x87DA,0x3D);
+					ov3640_write_reg(0x87DB,0x00);
+					ov3640_write_reg(0x87DC,0x75);
+					ov3640_write_reg(0x87DD,0x3E);
+					ov3640_write_reg(0x87DE,0xC8);
+					ov3640_write_reg(0x87DF,0x22);
+					ov3640_write_reg(0x87E0,0x78);
+					ov3640_write_reg(0x87E1,0x7F);
+					ov3640_write_reg(0x87E2,0xE4);
+					ov3640_write_reg(0x87E3,0xF6);
+					ov3640_write_reg(0x87E4,0xD8);
+					ov3640_write_reg(0x87E5,0xFD);
+					ov3640_write_reg(0x87E6,0x75);
+					ov3640_write_reg(0x87E7,0x81);
+					ov3640_write_reg(0x87E8,0x72);
+					ov3640_write_reg(0x87E9,0x02);
+					ov3640_write_reg(0x87EA,0x08);
+					ov3640_write_reg(0x87EB,0x27);
+					ov3640_write_reg(0x87EC,0x02);
+					ov3640_write_reg(0x87ED,0x0B);
+					ov3640_write_reg(0x87EE,0xEF);
+					ov3640_write_reg(0x87EF,0xE4);
+					ov3640_write_reg(0x87F0,0x93);
+					ov3640_write_reg(0x87F1,0xA3);
+					ov3640_write_reg(0x87F2,0xF8);
+					ov3640_write_reg(0x87F3,0xE4);
+					ov3640_write_reg(0x87F4,0x93);
+					ov3640_write_reg(0x87F5,0xA3);
+					ov3640_write_reg(0x87F6,0x40);
+					ov3640_write_reg(0x87F7,0x03);
+					ov3640_write_reg(0x87F8,0xF6);
+					ov3640_write_reg(0x87F9,0x80);
+					ov3640_write_reg(0x87FA,0x01);
+					ov3640_write_reg(0x87FB,0xF2);
+					ov3640_write_reg(0x87FC,0x08);
+					ov3640_write_reg(0x87FD,0xDF);
+					ov3640_write_reg(0x87FE,0xF4);
+					ov3640_write_reg(0x87FF,0x80);
+					ov3640_write_reg(0x8800,0x29);
+					ov3640_write_reg(0x8801,0xE4);
+					ov3640_write_reg(0x8802,0x93);
+					ov3640_write_reg(0x8803,0xA3);
+					ov3640_write_reg(0x8804,0xF8);
+					ov3640_write_reg(0x8805,0x54);
+					ov3640_write_reg(0x8806,0x07);
+					ov3640_write_reg(0x8807,0x24);
+					ov3640_write_reg(0x8808,0x0C);
+					ov3640_write_reg(0x8809,0xC8);
+					ov3640_write_reg(0x880A,0xC3);
+					ov3640_write_reg(0x880B,0x33);
+					ov3640_write_reg(0x880C,0xC4);
+					ov3640_write_reg(0x880D,0x54);
+					ov3640_write_reg(0x880E,0x0F);
+					ov3640_write_reg(0x880F,0x44);
+					ov3640_write_reg(0x8810,0x20);
+					ov3640_write_reg(0x8811,0xC8);
+					ov3640_write_reg(0x8812,0x83);
+					ov3640_write_reg(0x8813,0x40);
+					ov3640_write_reg(0x8814,0x04);
+					ov3640_write_reg(0x8815,0xF4);
+					ov3640_write_reg(0x8816,0x56);
+					ov3640_write_reg(0x8817,0x80);
+					ov3640_write_reg(0x8818,0x01);
+					ov3640_write_reg(0x8819,0x46);
+					ov3640_write_reg(0x881A,0xF6);
+					ov3640_write_reg(0x881B,0xDF);
+					ov3640_write_reg(0x881C,0xE4);
+					ov3640_write_reg(0x881D,0x80);
+					ov3640_write_reg(0x881E,0x0B);
+					ov3640_write_reg(0x881F,0x01);
+					ov3640_write_reg(0x8820,0x02);
+					ov3640_write_reg(0x8821,0x04);
+					ov3640_write_reg(0x8822,0x08);
+					ov3640_write_reg(0x8823,0x10);
+					ov3640_write_reg(0x8824,0x20);
+					ov3640_write_reg(0x8825,0x40);
+					ov3640_write_reg(0x8826,0x80);
+					ov3640_write_reg(0x8827,0x90);
+					ov3640_write_reg(0x8828,0x0B);
+					ov3640_write_reg(0x8829,0xB9);
+					ov3640_write_reg(0x882A,0xE4);
+					ov3640_write_reg(0x882B,0x7E);
+					ov3640_write_reg(0x882C,0x01);
+					ov3640_write_reg(0x882D,0x93);
+					ov3640_write_reg(0x882E,0x60);
+					ov3640_write_reg(0x882F,0xBC);
+					ov3640_write_reg(0x8830,0xA3);
+					ov3640_write_reg(0x8831,0xFF);
+					ov3640_write_reg(0x8832,0x54);
+					ov3640_write_reg(0x8833,0x3F);
+					ov3640_write_reg(0x8834,0x30);
+					ov3640_write_reg(0x8835,0xE5);
+					ov3640_write_reg(0x8836,0x09);
+					ov3640_write_reg(0x8837,0x54);
+					ov3640_write_reg(0x8838,0x1F);
+					ov3640_write_reg(0x8839,0xFE);
+					ov3640_write_reg(0x883A,0xE4);
+					ov3640_write_reg(0x883B,0x93);
+					ov3640_write_reg(0x883C,0xA3);
+					ov3640_write_reg(0x883D,0x60);
+					ov3640_write_reg(0x883E,0x01);
+					ov3640_write_reg(0x883F,0x0E);
+					ov3640_write_reg(0x8840,0xCF);
+					ov3640_write_reg(0x8841,0x54);
+					ov3640_write_reg(0x8842,0xC0);
+					ov3640_write_reg(0x8843,0x25);
+					ov3640_write_reg(0x8844,0xE0);
+					ov3640_write_reg(0x8845,0x60);
+					ov3640_write_reg(0x8846,0xA8);
+					ov3640_write_reg(0x8847,0x40);
+					ov3640_write_reg(0x8848,0xB8);
+					ov3640_write_reg(0x8849,0xE4);
+					ov3640_write_reg(0x884A,0x93);
+					ov3640_write_reg(0x884B,0xA3);
+					ov3640_write_reg(0x884C,0xFA);
+					ov3640_write_reg(0x884D,0xE4);
+					ov3640_write_reg(0x884E,0x93);
+					ov3640_write_reg(0x884F,0xA3);
+					ov3640_write_reg(0x8850,0xF8);
+					ov3640_write_reg(0x8851,0xE4);
+					ov3640_write_reg(0x8852,0x93);
+					ov3640_write_reg(0x8853,0xA3);
+					ov3640_write_reg(0x8854,0xC8);
+					ov3640_write_reg(0x8855,0xC5);
+					ov3640_write_reg(0x8856,0x82);
+					ov3640_write_reg(0x8857,0xC8);
+					ov3640_write_reg(0x8858,0xCA);
+					ov3640_write_reg(0x8859,0xC5);
+					ov3640_write_reg(0x885A,0x83);
+					ov3640_write_reg(0x885B,0xCA);
+					ov3640_write_reg(0x885C,0xF0);
+					ov3640_write_reg(0x885D,0xA3);
+					ov3640_write_reg(0x885E,0xC8);
+					ov3640_write_reg(0x885F,0xC5);
+					ov3640_write_reg(0x8860,0x82);
+					ov3640_write_reg(0x8861,0xC8);
+					ov3640_write_reg(0x8862,0xCA);
+					ov3640_write_reg(0x8863,0xC5);
+					ov3640_write_reg(0x8864,0x83);
+					ov3640_write_reg(0x8865,0xCA);
+					ov3640_write_reg(0x8866,0xDF);
+					ov3640_write_reg(0x8867,0xE9);
+					ov3640_write_reg(0x8868,0xDE);
+					ov3640_write_reg(0x8869,0xE7);
+					ov3640_write_reg(0x886A,0x80);
+					ov3640_write_reg(0x886B,0xBE);
+					ov3640_write_reg(0x886C,0xC2);
+					ov3640_write_reg(0x886D,0x8C);
+					ov3640_write_reg(0x886E,0x75);
+					ov3640_write_reg(0x886F,0x89);
+					ov3640_write_reg(0x8870,0x03);
+					ov3640_write_reg(0x8871,0x90);
+					ov3640_write_reg(0x8872,0x31);
+					ov3640_write_reg(0x8873,0x00);
+					ov3640_write_reg(0x8874,0xE0);
+					ov3640_write_reg(0x8875,0x54);
+					ov3640_write_reg(0x8876,0xFE);
+					ov3640_write_reg(0x8877,0xF0);
+					ov3640_write_reg(0x8878,0xE0);
+					ov3640_write_reg(0x8879,0x54);
+					ov3640_write_reg(0x887A,0xFD);
+					ov3640_write_reg(0x887B,0xF0);
+					ov3640_write_reg(0x887C,0xA3);
+					ov3640_write_reg(0x887D,0xE4);
+					ov3640_write_reg(0x887E,0xF0);
+					ov3640_write_reg(0x887F,0x90);
+					ov3640_write_reg(0x8880,0x33);
+					ov3640_write_reg(0x8881,0xB0);
+					ov3640_write_reg(0x8882,0xF0);
+					ov3640_write_reg(0x8883,0xA3);
+					ov3640_write_reg(0x8884,0x04);
+					ov3640_write_reg(0x8885,0xF0);
+					ov3640_write_reg(0x8886,0xA3);
+					ov3640_write_reg(0x8887,0xF0);
+					ov3640_write_reg(0x8888,0xA3);
+					ov3640_write_reg(0x8889,0x12);
+					ov3640_write_reg(0x888A,0x06);
+					ov3640_write_reg(0x888B,0x30);
+					ov3640_write_reg(0x888C,0x90);
+					ov3640_write_reg(0x888D,0x33);
+					ov3640_write_reg(0x888E,0x00);
+					ov3640_write_reg(0x888F,0x74);
+					ov3640_write_reg(0x8890,0x13);
+					ov3640_write_reg(0x8891,0xF0);
+					ov3640_write_reg(0x8892,0x90);
+					ov3640_write_reg(0x8893,0x30);
+					ov3640_write_reg(0x8894,0xB2);
+					ov3640_write_reg(0x8895,0xE0);
+					ov3640_write_reg(0x8896,0x44);
+					ov3640_write_reg(0x8897,0x18);
+					ov3640_write_reg(0x8898,0xF0);
+					ov3640_write_reg(0x8899,0x90);
+					ov3640_write_reg(0x889A,0x30);
+					ov3640_write_reg(0x889B,0xB0);
+					ov3640_write_reg(0x889C,0xE0);
+					ov3640_write_reg(0x889D,0x44);
+					ov3640_write_reg(0x889E,0x03);
+					ov3640_write_reg(0x889F,0xF0);
+					ov3640_write_reg(0x88A0,0xA3);
+					ov3640_write_reg(0x88A1,0xE0);
+					ov3640_write_reg(0x88A2,0x44);
+					ov3640_write_reg(0x88A3,0xC0);
+					ov3640_write_reg(0x88A4,0xF0);
+					ov3640_write_reg(0x88A5,0x90);
+					ov3640_write_reg(0x88A6,0x30);
+					ov3640_write_reg(0x88A7,0xB4);
+					ov3640_write_reg(0x88A8,0xE0);
+					ov3640_write_reg(0x88A9,0x44);
+					ov3640_write_reg(0x88AA,0x0F);
+					ov3640_write_reg(0x88AB,0xF0);
+					ov3640_write_reg(0x88AC,0xE0);
+					ov3640_write_reg(0x88AD,0x54);
+					ov3640_write_reg(0x88AE,0xF7);
+					ov3640_write_reg(0x88AF,0xF0);
+					ov3640_write_reg(0x88B0,0xE0);
+					ov3640_write_reg(0x88B1,0xF5);
+					ov3640_write_reg(0x88B2,0x20);
+					ov3640_write_reg(0x88B3,0x90);
+					ov3640_write_reg(0x88B4,0x39);
+					ov3640_write_reg(0x88B5,0x01);
+					ov3640_write_reg(0x88B6,0x74);
+					ov3640_write_reg(0x88B7,0x35);
+					ov3640_write_reg(0x88B8,0xF0);
+					ov3640_write_reg(0x88B9,0x90);
+					ov3640_write_reg(0x88BA,0x39);
+					ov3640_write_reg(0x88BB,0x00);
+					ov3640_write_reg(0x88BC,0x74);
+					ov3640_write_reg(0x88BD,0x20);
+					ov3640_write_reg(0x88BE,0xF0);
+					ov3640_write_reg(0x88BF,0x90);
+					ov3640_write_reg(0x88C0,0x30);
+					ov3640_write_reg(0x88C1,0x0E);
+					ov3640_write_reg(0x88C2,0x74);
+					ov3640_write_reg(0x88C3,0x36);
+					ov3640_write_reg(0x88C4,0xF0);
+					ov3640_write_reg(0x88C5,0x90);
+					ov3640_write_reg(0x88C6,0x30);
+					ov3640_write_reg(0x88C7,0x11);
+					ov3640_write_reg(0x88C8,0xE4);
+					ov3640_write_reg(0x88C9,0xF0);
+					ov3640_write_reg(0x88CA,0x90);
+					ov3640_write_reg(0x88CB,0x30);
+					ov3640_write_reg(0x88CC,0x14);
+					ov3640_write_reg(0x88CD,0x74);
+					ov3640_write_reg(0x88CE,0x04);
+					ov3640_write_reg(0x88CF,0xF0);
+					ov3640_write_reg(0x88D0,0x90);
+					ov3640_write_reg(0x88D1,0x30);
+					ov3640_write_reg(0x88D2,0x2D);
+					ov3640_write_reg(0x88D3,0xE4);
+					ov3640_write_reg(0x88D4,0xF0);
+					ov3640_write_reg(0x88D5,0xA3);
+					ov3640_write_reg(0x88D6,0xF0);
+					ov3640_write_reg(0x88D7,0x90);
+					ov3640_write_reg(0x88D8,0x37);
+					ov3640_write_reg(0x88D9,0x00);
+					ov3640_write_reg(0x88DA,0xE0);
+					ov3640_write_reg(0x88DB,0x54);
+					ov3640_write_reg(0x88DC,0xF7);
+					ov3640_write_reg(0x88DD,0xF0);
+					ov3640_write_reg(0x88DE,0xE0);
+					ov3640_write_reg(0x88DF,0x54);
+					ov3640_write_reg(0x88E0,0xBF);
+					ov3640_write_reg(0x88E1,0xF0);
+					ov3640_write_reg(0x88E2,0x90);
+					ov3640_write_reg(0x88E3,0x35);
+					ov3640_write_reg(0x88E4,0x08);
+					ov3640_write_reg(0x88E5,0x74);
+					ov3640_write_reg(0x88E6,0x07);
+					ov3640_write_reg(0x88E7,0xF0);
+					ov3640_write_reg(0x88E8,0x75);
+					ov3640_write_reg(0x88E9,0xB8);
+					ov3640_write_reg(0x88EA,0x01);
+					ov3640_write_reg(0x88EB,0x75);
+					ov3640_write_reg(0x88EC,0xA8);
+					ov3640_write_reg(0x88ED,0x81);
+					ov3640_write_reg(0x88EE,0x22);
+					ov3640_write_reg(0x88EF,0x8E);
+					ov3640_write_reg(0x88F0,0x0C);
+					ov3640_write_reg(0x88F1,0x8F);
+					ov3640_write_reg(0x88F2,0x0D);
+					ov3640_write_reg(0x88F3,0x8C);
+					ov3640_write_reg(0x88F4,0x0E);
+					ov3640_write_reg(0x88F5,0x8D);
+					ov3640_write_reg(0x88F6,0x0F);
+					ov3640_write_reg(0x88F7,0xEB);
+					ov3640_write_reg(0x88F8,0xD3);
+					ov3640_write_reg(0x88F9,0x94);
+					ov3640_write_reg(0x88FA,0x03);
+					ov3640_write_reg(0x88FB,0x40);
+					ov3640_write_reg(0x88FC,0x02);
+					ov3640_write_reg(0x88FD,0xE4);
+					ov3640_write_reg(0x88FE,0xFB);
+					ov3640_write_reg(0x88FF,0xE5);
+					ov3640_write_reg(0x8900,0x0F);
+					ov3640_write_reg(0x8901,0xAE);
+					ov3640_write_reg(0x8902,0x0E);
+					ov3640_write_reg(0x8903,0x78);
+					ov3640_write_reg(0x8904,0x03);
+					ov3640_write_reg(0x8905,0xCE);
+					ov3640_write_reg(0x8906,0xC3);
+					ov3640_write_reg(0x8907,0x13);
+					ov3640_write_reg(0x8908,0xCE);
+					ov3640_write_reg(0x8909,0x13);
+					ov3640_write_reg(0x890A,0xD8);
+					ov3640_write_reg(0x890B,0xF9);
+					ov3640_write_reg(0x890C,0xFB);
+					ov3640_write_reg(0x890D,0xAA);
+					ov3640_write_reg(0x890E,0x06);
+					ov3640_write_reg(0x890F,0x12);
+					ov3640_write_reg(0x8910,0x05);
+					ov3640_write_reg(0x8911,0xEC);
+					ov3640_write_reg(0x8912,0xFE);
+					ov3640_write_reg(0x8913,0xAD);
+					ov3640_write_reg(0x8914,0x03);
+					ov3640_write_reg(0x8915,0xAC);
+					ov3640_write_reg(0x8916,0x02);
+					ov3640_write_reg(0x8917,0x12);
+					ov3640_write_reg(0x8918,0x05);
+					ov3640_write_reg(0x8919,0xA4);
+					ov3640_write_reg(0x891A,0xEF);
+					ov3640_write_reg(0x891B,0xC4);
+					ov3640_write_reg(0x891C,0x54);
+					ov3640_write_reg(0x891D,0x0F);
+					ov3640_write_reg(0x891E,0x48);
+					ov3640_write_reg(0x891F,0xF9);
+					ov3640_write_reg(0x8920,0x12);
+					ov3640_write_reg(0x8921,0x05);
+					ov3640_write_reg(0x8922,0x9C);
+					ov3640_write_reg(0x8923,0xEF);
+					ov3640_write_reg(0x8924,0xC4);
+					ov3640_write_reg(0x8925,0x54);
+					ov3640_write_reg(0x8926,0x0F);
+					ov3640_write_reg(0x8927,0x48);
+					ov3640_write_reg(0x8928,0xFB);
+					ov3640_write_reg(0x8929,0xE5);
+					ov3640_write_reg(0x892A,0x0D);
+					ov3640_write_reg(0x892B,0xAE);
+					ov3640_write_reg(0x892C,0x0C);
+					ov3640_write_reg(0x892D,0x78);
+					ov3640_write_reg(0x892E,0x05);
+					ov3640_write_reg(0x892F,0xCE);
+					ov3640_write_reg(0x8930,0xC3);
+					ov3640_write_reg(0x8931,0x13);
+					ov3640_write_reg(0x8932,0xCE);
+					ov3640_write_reg(0x8933,0x13);
+					ov3640_write_reg(0x8934,0xD8);
+					ov3640_write_reg(0x8935,0xF9);
+					ov3640_write_reg(0x8936,0xFD);
+					ov3640_write_reg(0x8937,0xAC);
+					ov3640_write_reg(0x8938,0x06);
+					ov3640_write_reg(0x8939,0x12);
+					ov3640_write_reg(0x893A,0x05);
+					ov3640_write_reg(0x893B,0xEC);
+					ov3640_write_reg(0x893C,0x12);
+					ov3640_write_reg(0x893D,0x05);
+					ov3640_write_reg(0x893E,0xA3);
+					ov3640_write_reg(0x893F,0xEF);
+					ov3640_write_reg(0x8940,0xC4);
+					ov3640_write_reg(0x8941,0x54);
+					ov3640_write_reg(0x8942,0x0F);
+					ov3640_write_reg(0x8943,0x48);
+					ov3640_write_reg(0x8944,0xFA);
+					ov3640_write_reg(0x8945,0xE5);
+					ov3640_write_reg(0x8946,0x0D);
+					ov3640_write_reg(0x8947,0xAE);
+					ov3640_write_reg(0x8948,0x0C);
+					ov3640_write_reg(0x8949,0x78);
+					ov3640_write_reg(0x894A,0x05);
+					ov3640_write_reg(0x894B,0xCE);
+					ov3640_write_reg(0x894C,0xC3);
+					ov3640_write_reg(0x894D,0x13);
+					ov3640_write_reg(0x894E,0xCE);
+					ov3640_write_reg(0x894F,0x13);
+					ov3640_write_reg(0x8950,0xD8);
+					ov3640_write_reg(0x8951,0xF9);
+					ov3640_write_reg(0x8952,0xFD);
+					ov3640_write_reg(0x8953,0xAC);
+					ov3640_write_reg(0x8954,0x06);
+					ov3640_write_reg(0x8955,0x12);
+					ov3640_write_reg(0x8956,0x05);
+					ov3640_write_reg(0x8957,0x9C);
+					ov3640_write_reg(0x8958,0xEF);
+					ov3640_write_reg(0x8959,0xC4);
+					ov3640_write_reg(0x895A,0x54);
+					ov3640_write_reg(0x895B,0x0F);
+					ov3640_write_reg(0x895C,0x48);
+					ov3640_write_reg(0x895D,0xFF);
+					ov3640_write_reg(0x895E,0x90);
+					ov3640_write_reg(0x895F,0x39);
+					ov3640_write_reg(0x8960,0x0A);
+					ov3640_write_reg(0x8961,0xEA);
+					ov3640_write_reg(0x8962,0xF0);
+					ov3640_write_reg(0x8963,0xA3);
+					ov3640_write_reg(0x8964,0xE9);
+					ov3640_write_reg(0x8965,0xF0);
+					ov3640_write_reg(0x8966,0xA3);
+					ov3640_write_reg(0x8967,0xEF);
+					ov3640_write_reg(0x8968,0xF0);
+					ov3640_write_reg(0x8969,0xA3);
+					ov3640_write_reg(0x896A,0xEB);
+					ov3640_write_reg(0x896B,0xF0);
+					ov3640_write_reg(0x896C,0x22);
+					ov3640_write_reg(0x896D,0xAB);
+					ov3640_write_reg(0x896E,0x05);
+					ov3640_write_reg(0x896F,0xAA);
+					ov3640_write_reg(0x8970,0x04);
+					ov3640_write_reg(0x8971,0x8F);
+					ov3640_write_reg(0x8972,0x82);
+					ov3640_write_reg(0x8973,0x8E);
+					ov3640_write_reg(0x8974,0x83);
+					ov3640_write_reg(0x8975,0x12);
+					ov3640_write_reg(0x8976,0x05);
+					ov3640_write_reg(0x8977,0xEC);
+					ov3640_write_reg(0x8978,0xFE);
+					ov3640_write_reg(0x8979,0xAD);
+					ov3640_write_reg(0x897A,0x82);
+					ov3640_write_reg(0x897B,0xAC);
+					ov3640_write_reg(0x897C,0x83);
+					ov3640_write_reg(0x897D,0x12);
+					ov3640_write_reg(0x897E,0x05);
+					ov3640_write_reg(0x897F,0xA4);
+					ov3640_write_reg(0x8980,0x68);
+					ov3640_write_reg(0x8981,0xF5);
+					ov3640_write_reg(0x8982,0x0C);
+					ov3640_write_reg(0x8983,0xEF);
+					ov3640_write_reg(0x8984,0xC4);
+					ov3640_write_reg(0x8985,0x54);
+					ov3640_write_reg(0x8986,0x0F);
+					ov3640_write_reg(0x8987,0x48);
+					ov3640_write_reg(0x8988,0xF5);
+					ov3640_write_reg(0x8989,0x0D);
+					ov3640_write_reg(0x898A,0x12);
+					ov3640_write_reg(0x898B,0x05);
+					ov3640_write_reg(0x898C,0x9C);
+					ov3640_write_reg(0x898D,0x68);
+					ov3640_write_reg(0x898E,0xF5);
+					ov3640_write_reg(0x898F,0x10);
+					ov3640_write_reg(0x8990,0xEF);
+					ov3640_write_reg(0x8991,0xC4);
+					ov3640_write_reg(0x8992,0x54);
+					ov3640_write_reg(0x8993,0x0F);
+					ov3640_write_reg(0x8994,0x48);
+					ov3640_write_reg(0x8995,0xF5);
+					ov3640_write_reg(0x8996,0x11);
+					ov3640_write_reg(0x8997,0x12);
+					ov3640_write_reg(0x8998,0x05);
+					ov3640_write_reg(0x8999,0xEC);
+					ov3640_write_reg(0x899A,0xFE);
+					ov3640_write_reg(0x899B,0xAD);
+					ov3640_write_reg(0x899C,0x03);
+					ov3640_write_reg(0x899D,0xAC);
+					ov3640_write_reg(0x899E,0x02);
+					ov3640_write_reg(0x899F,0x12);
+					ov3640_write_reg(0x89A0,0x05);
+					ov3640_write_reg(0x89A1,0xA4);
+					ov3640_write_reg(0x89A2,0x68);
+					ov3640_write_reg(0x89A3,0xF5);
+					ov3640_write_reg(0x89A4,0x0E);
+					ov3640_write_reg(0x89A5,0xEF);
+					ov3640_write_reg(0x89A6,0xC4);
+					ov3640_write_reg(0x89A7,0x54);
+					ov3640_write_reg(0x89A8,0x0F);
+					ov3640_write_reg(0x89A9,0x48);
+					ov3640_write_reg(0x89AA,0xF5);
+					ov3640_write_reg(0x89AB,0x0F);
+					ov3640_write_reg(0x89AC,0x12);
+					ov3640_write_reg(0x89AD,0x05);
+					ov3640_write_reg(0x89AE,0x9C);
+					ov3640_write_reg(0x89AF,0x68);
+					ov3640_write_reg(0x89B0,0xFE);
+					ov3640_write_reg(0x89B1,0xEF);
+					ov3640_write_reg(0x89B2,0xC4);
+					ov3640_write_reg(0x89B3,0x54);
+					ov3640_write_reg(0x89B4,0x0F);
+					ov3640_write_reg(0x89B5,0x48);
+					ov3640_write_reg(0x89B6,0xFD);
+					ov3640_write_reg(0x89B7,0xAC);
+					ov3640_write_reg(0x89B8,0x06);
+					ov3640_write_reg(0x89B9,0xE5);
+					ov3640_write_reg(0x89BA,0x0C);
+					ov3640_write_reg(0x89BB,0x54);
+					ov3640_write_reg(0x89BC,0x0F);
+					ov3640_write_reg(0x89BD,0xFB);
+					ov3640_write_reg(0x89BE,0xE5);
+					ov3640_write_reg(0x89BF,0x0E);
+					ov3640_write_reg(0x89C0,0x12);
+					ov3640_write_reg(0x89C1,0x06);
+					ov3640_write_reg(0x89C2,0x46);
+					ov3640_write_reg(0x89C3,0x4B);
+					ov3640_write_reg(0x89C4,0xFB);
+					ov3640_write_reg(0x89C5,0xE5);
+					ov3640_write_reg(0x89C6,0x10);
+					ov3640_write_reg(0x89C7,0x54);
+					ov3640_write_reg(0x89C8,0x0F);
+					ov3640_write_reg(0x89C9,0xFA);
+					ov3640_write_reg(0x89CA,0xEC);
+					ov3640_write_reg(0x89CB,0x12);
+					ov3640_write_reg(0x89CC,0x06);
+					ov3640_write_reg(0x89CD,0x46);
+					ov3640_write_reg(0x89CE,0x4A);
+					ov3640_write_reg(0x89CF,0xFF);
+					ov3640_write_reg(0x89D0,0x90);
+					ov3640_write_reg(0x89D1,0x33);
+					ov3640_write_reg(0x89D2,0xAA);
+					ov3640_write_reg(0x89D3,0xEB);
+					ov3640_write_reg(0x89D4,0xF0);
+					ov3640_write_reg(0x89D5,0xE5);
+					ov3640_write_reg(0x89D6,0x0D);
+					ov3640_write_reg(0x89D7,0xA3);
+					ov3640_write_reg(0x89D8,0xF0);
+					ov3640_write_reg(0x89D9,0xE5);
+					ov3640_write_reg(0x89DA,0x0F);
+					ov3640_write_reg(0x89DB,0xA3);
+					ov3640_write_reg(0x89DC,0xF0);
+					ov3640_write_reg(0x89DD,0xA3);
+					ov3640_write_reg(0x89DE,0xEF);
+					ov3640_write_reg(0x89DF,0xF0);
+					ov3640_write_reg(0x89E0,0xE5);
+					ov3640_write_reg(0x89E1,0x11);
+					ov3640_write_reg(0x89E2,0xA3);
+					ov3640_write_reg(0x89E3,0xF0);
+					ov3640_write_reg(0x89E4,0xAF);
+					ov3640_write_reg(0x89E5,0x05);
+					ov3640_write_reg(0x89E6,0xEF);
+					ov3640_write_reg(0x89E7,0xA3);
+					ov3640_write_reg(0x89E8,0xF0);
+					ov3640_write_reg(0x89E9,0x22);
+					ov3640_write_reg(0x89EA,0x90);
+					ov3640_write_reg(0x89EB,0x3F);
+					ov3640_write_reg(0x89EC,0x05);
+					ov3640_write_reg(0x89ED,0xE0);
+					ov3640_write_reg(0x89EE,0x54);
+					ov3640_write_reg(0x89EF,0xE0);
+					ov3640_write_reg(0x89F0,0xF5);
+					ov3640_write_reg(0x89F1,0x08);
+					ov3640_write_reg(0x89F2,0xE0);
+					ov3640_write_reg(0x89F3,0x54);
+					ov3640_write_reg(0x89F4,0x1F);
+					ov3640_write_reg(0x89F5,0xF0);
+					ov3640_write_reg(0x89F6,0xE5);
+					ov3640_write_reg(0x89F7,0x08);
+					ov3640_write_reg(0x89F8,0xB4);
+					ov3640_write_reg(0x89F9,0x80);
+					ov3640_write_reg(0x89FA,0x1D);
+					ov3640_write_reg(0x89FB,0xC3);
+					ov3640_write_reg(0x89FC,0xE5);
+					ov3640_write_reg(0x89FD,0x4C);
+					ov3640_write_reg(0x89FE,0x94);
+					ov3640_write_reg(0x89FF,0xFF);
+					ov3640_write_reg(0x8A00,0xE5);
+					ov3640_write_reg(0x8A01,0x4B);
+					ov3640_write_reg(0x8A02,0x94);
+					ov3640_write_reg(0x8A03,0x03);
+					ov3640_write_reg(0x8A04,0x40);
+					ov3640_write_reg(0x8A05,0x08);
+					ov3640_write_reg(0x8A06,0x75);
+					ov3640_write_reg(0x8A07,0x4B);
+					ov3640_write_reg(0x8A08,0x03);
+					ov3640_write_reg(0x8A09,0x75);
+					ov3640_write_reg(0x8A0A,0x4C);
+					ov3640_write_reg(0x8A0B,0xFF);
+					ov3640_write_reg(0x8A0C,0x80);
+					ov3640_write_reg(0x8A0D,0x4F);
+					ov3640_write_reg(0x8A0E,0x05);
+					ov3640_write_reg(0x8A0F,0x4C);
+					ov3640_write_reg(0x8A10,0xE5);
+					ov3640_write_reg(0x8A11,0x4C);
+					ov3640_write_reg(0x8A12,0x70);
+					ov3640_write_reg(0x8A13,0x02);
+					ov3640_write_reg(0x8A14,0x05);
+					ov3640_write_reg(0x8A15,0x4B);
+					ov3640_write_reg(0x8A16,0x80);
+					ov3640_write_reg(0x8A17,0x45);
+					ov3640_write_reg(0x8A18,0xE5);
+					ov3640_write_reg(0x8A19,0x08);
+					ov3640_write_reg(0x8A1A,0xB4);
+					ov3640_write_reg(0x8A1B,0x40);
+					ov3640_write_reg(0x8A1C,0x16);
+					ov3640_write_reg(0x8A1D,0xE5);
+					ov3640_write_reg(0x8A1E,0x4C);
+					ov3640_write_reg(0x8A1F,0x45);
+					ov3640_write_reg(0x8A20,0x4B);
+					ov3640_write_reg(0x8A21,0x70);
+					ov3640_write_reg(0x8A22,0x06);
+					ov3640_write_reg(0x8A23,0xF5);
+					ov3640_write_reg(0x8A24,0x4B);
+					ov3640_write_reg(0x8A25,0xF5);
+					ov3640_write_reg(0x8A26,0x4C);
+					ov3640_write_reg(0x8A27,0x80);
+					ov3640_write_reg(0x8A28,0x08);
+					ov3640_write_reg(0x8A29,0xE5);
+					ov3640_write_reg(0x8A2A,0x4C);
+					ov3640_write_reg(0x8A2B,0x15);
+					ov3640_write_reg(0x8A2C,0x4C);
+					ov3640_write_reg(0x8A2D,0x70);
+					ov3640_write_reg(0x8A2E,0x02);
+					ov3640_write_reg(0x8A2F,0x15);
+					ov3640_write_reg(0x8A30,0x4B);
+					ov3640_write_reg(0x8A31,0x80);
+					ov3640_write_reg(0x8A32,0x2A);
+					ov3640_write_reg(0x8A33,0xE5);
+					ov3640_write_reg(0x8A34,0x08);
+					ov3640_write_reg(0x8A35,0x64);
+					ov3640_write_reg(0x8A36,0x20);
+					ov3640_write_reg(0x8A37,0x70);
+					ov3640_write_reg(0x8A38,0x2B);
+					ov3640_write_reg(0x8A39,0x90);
+					ov3640_write_reg(0x8A3A,0x3F);
+					ov3640_write_reg(0x8A3B,0x05);
+					ov3640_write_reg(0x8A3C,0xE0);
+					ov3640_write_reg(0x8A3D,0x54);
+					ov3640_write_reg(0x8A3E,0x03);
+					ov3640_write_reg(0x8A3F,0xFE);
+					ov3640_write_reg(0x8A40,0xA3);
+					ov3640_write_reg(0x8A41,0xE0);
+					ov3640_write_reg(0x8A42,0x7C);
+					ov3640_write_reg(0x8A43,0x00);
+					ov3640_write_reg(0x8A44,0x24);
+					ov3640_write_reg(0x8A45,0x00);
+					ov3640_write_reg(0x8A46,0xF5);
+					ov3640_write_reg(0x8A47,0x4C);
+					ov3640_write_reg(0x8A48,0xEC);
+					ov3640_write_reg(0x8A49,0x3E);
+					ov3640_write_reg(0x8A4A,0xF5);
+					ov3640_write_reg(0x8A4B,0x4B);
+					ov3640_write_reg(0x8A4C,0xD3);
+					ov3640_write_reg(0x8A4D,0xE5);
+					ov3640_write_reg(0x8A4E,0x4C);
+					ov3640_write_reg(0x8A4F,0x94);
+					ov3640_write_reg(0x8A50,0xFF);
+					ov3640_write_reg(0x8A51,0xE5);
+					ov3640_write_reg(0x8A52,0x4B);
+					ov3640_write_reg(0x8A53,0x94);
+					ov3640_write_reg(0x8A54,0x03);
+					ov3640_write_reg(0x8A55,0x40);
+					ov3640_write_reg(0x8A56,0x06);
+					ov3640_write_reg(0x8A57,0x75);
+					ov3640_write_reg(0x8A58,0x4B);
+					ov3640_write_reg(0x8A59,0x03);
+					ov3640_write_reg(0x8A5A,0x75);
+					ov3640_write_reg(0x8A5B,0x4C);
+					ov3640_write_reg(0x8A5C,0xFF);
+					ov3640_write_reg(0x8A5D,0xAF);
+					ov3640_write_reg(0x8A5E,0x4C);
+					ov3640_write_reg(0x8A5F,0xAE);
+					ov3640_write_reg(0x8A60,0x4B);
+					ov3640_write_reg(0x8A61,0x12);
+					ov3640_write_reg(0x8A62,0x0B);
+					ov3640_write_reg(0x8A63,0x7A);
+					ov3640_write_reg(0x8A64,0x22);
+					ov3640_write_reg(0x8A65,0xE5);
+					ov3640_write_reg(0x8A66,0x3C);
+					ov3640_write_reg(0x8A67,0xD3);
+					ov3640_write_reg(0x8A68,0x94);
+					ov3640_write_reg(0x8A69,0x02);
+					ov3640_write_reg(0x8A6A,0x40);
+					ov3640_write_reg(0x8A6B,0x03);
+					ov3640_write_reg(0x8A6C,0x15);
+					ov3640_write_reg(0x8A6D,0x3C);
+					ov3640_write_reg(0x8A6E,0x22);
+					ov3640_write_reg(0x8A6F,0xE5);
+					ov3640_write_reg(0x8A70,0x3C);
+					ov3640_write_reg(0x8A71,0xB4);
+					ov3640_write_reg(0x8A72,0x02);
+					ov3640_write_reg(0x8A73,0x0D);
+					ov3640_write_reg(0x8A74,0xE4);
+					ov3640_write_reg(0x8A75,0xF5);
+					ov3640_write_reg(0x8A76,0x3C);
+					ov3640_write_reg(0x8A77,0xFD);
+					ov3640_write_reg(0x8A78,0xFF);
+					ov3640_write_reg(0x8A79,0x12);
+					ov3640_write_reg(0x8A7A,0x0B);
+					ov3640_write_reg(0x8A7B,0x2C);
+					ov3640_write_reg(0x8A7C,0x8E);
+					ov3640_write_reg(0x8A7D,0x2B);
+					ov3640_write_reg(0x8A7E,0x8F);
+					ov3640_write_reg(0x8A7F,0x2C);
+					ov3640_write_reg(0x8A80,0x22);
+					ov3640_write_reg(0x8A81,0xE4);
+					ov3640_write_reg(0x8A82,0xFD);
+					ov3640_write_reg(0x8A83,0xFF);
+					ov3640_write_reg(0x8A84,0x12);
+					ov3640_write_reg(0x8A85,0x0B);
+					ov3640_write_reg(0x8A86,0x2C);
+					ov3640_write_reg(0x8A87,0x8E);
+					ov3640_write_reg(0x8A88,0x08);
+					ov3640_write_reg(0x8A89,0x8F);
+					ov3640_write_reg(0x8A8A,0x09);
+					ov3640_write_reg(0x8A8B,0xC3);
+					ov3640_write_reg(0x8A8C,0xE5);
+					ov3640_write_reg(0x8A8D,0x09);
+					ov3640_write_reg(0x8A8E,0x95);
+					ov3640_write_reg(0x8A8F,0x2C);
+					ov3640_write_reg(0x8A90,0xFF);
+					ov3640_write_reg(0x8A91,0xE5);
+					ov3640_write_reg(0x8A92,0x08);
+					ov3640_write_reg(0x8A93,0x95);
+					ov3640_write_reg(0x8A94,0x2B);
+					ov3640_write_reg(0x8A95,0xFE);
+					ov3640_write_reg(0x8A96,0x12);
+					ov3640_write_reg(0x8A97,0x0C);
+					ov3640_write_reg(0x8A98,0xF7);
+					ov3640_write_reg(0x8A99,0x8E);
+					ov3640_write_reg(0x8A9A,0x0A);
+					ov3640_write_reg(0x8A9B,0x8F);
+					ov3640_write_reg(0x8A9C,0x0B);
+					ov3640_write_reg(0x8A9D,0xE5);
+					ov3640_write_reg(0x8A9E,0x29);
+					ov3640_write_reg(0x8A9F,0xD3);
+					ov3640_write_reg(0x8AA0,0x94);
+					ov3640_write_reg(0x8AA1,0x02);
+					ov3640_write_reg(0x8AA2,0x40);
+					ov3640_write_reg(0x8AA3,0x28);
+					ov3640_write_reg(0x8AA4,0x12);
+					ov3640_write_reg(0x8AA5,0x06);
+					ov3640_write_reg(0x8AA6,0x76);
+					ov3640_write_reg(0x8AA7,0x50);
+					ov3640_write_reg(0x8AA8,0x05);
+					ov3640_write_reg(0x8AA9,0x12);
+					ov3640_write_reg(0x8AAA,0x0C);
+					ov3640_write_reg(0x8AAB,0xB6);
+					ov3640_write_reg(0x8AAC,0x50);
+					ov3640_write_reg(0x8AAD,0x0A);
+					ov3640_write_reg(0x8AAE,0x85);
+					ov3640_write_reg(0x8AAF,0x08);
+					ov3640_write_reg(0x8AB0,0x2B);
+					ov3640_write_reg(0x8AB1,0x85);
+					ov3640_write_reg(0x8AB2,0x09);
+					ov3640_write_reg(0x8AB3,0x2C);
+					ov3640_write_reg(0x8AB4,0xE4);
+					ov3640_write_reg(0x8AB5,0xF5);
+					ov3640_write_reg(0x8AB6,0x2A);
+					ov3640_write_reg(0x8AB7,0x22);
+					ov3640_write_reg(0x8AB8,0x05);
+					ov3640_write_reg(0x8AB9,0x2A);
+					ov3640_write_reg(0x8ABA,0xE5);
+					ov3640_write_reg(0x8ABB,0x2A);
+					ov3640_write_reg(0x8ABC,0xD3);
+					ov3640_write_reg(0x8ABD,0x94);
+					ov3640_write_reg(0x8ABE,0x02);
+					ov3640_write_reg(0x8ABF,0x40);
+					ov3640_write_reg(0x8AC0,0x1B);
+					ov3640_write_reg(0x8AC1,0xE4);
+					ov3640_write_reg(0x8AC2,0xF5);
+					ov3640_write_reg(0x8AC3,0x29);
+					ov3640_write_reg(0x8AC4,0xF5);
+					ov3640_write_reg(0x8AC5,0x2A);
+					ov3640_write_reg(0x8AC6,0x75);
+					ov3640_write_reg(0x8AC7,0x3C);
+					ov3640_write_reg(0x8AC8,0x01);
+					ov3640_write_reg(0x8AC9,0x02);
+					ov3640_write_reg(0x8ACA,0x02);
+					ov3640_write_reg(0x8ACB,0x7B);
+					ov3640_write_reg(0x8ACC,0x12);
+					ov3640_write_reg(0x8ACD,0x06);
+					ov3640_write_reg(0x8ACE,0x76);
+					ov3640_write_reg(0x8ACF,0x50);
+					ov3640_write_reg(0x8AD0,0x05);
+					ov3640_write_reg(0x8AD1,0x12);
+					ov3640_write_reg(0x8AD2,0x0C);
+					ov3640_write_reg(0x8AD3,0xB6);
+					ov3640_write_reg(0x8AD4,0x50);
+					ov3640_write_reg(0x8AD5,0x03);
+					ov3640_write_reg(0x8AD6,0x05);
+					ov3640_write_reg(0x8AD7,0x29);
+					ov3640_write_reg(0x8AD8,0x22);
+					ov3640_write_reg(0x8AD9,0xE4);
+					ov3640_write_reg(0x8ADA,0xF5);
+					ov3640_write_reg(0x8ADB,0x29);
+					ov3640_write_reg(0x8ADC,0x22);
+					ov3640_write_reg(0x8ADD,0x7D);
+					ov3640_write_reg(0x8ADE,0x08);
+					ov3640_write_reg(0x8ADF,0xEF);
+					ov3640_write_reg(0x8AE0,0x33);
+					ov3640_write_reg(0x8AE1,0x92);
+					ov3640_write_reg(0x8AE2,0x01);
+					ov3640_write_reg(0x8AE3,0x12);
+					ov3640_write_reg(0x8AE4,0x05);
+					ov3640_write_reg(0x8AE5,0xC8);
+					ov3640_write_reg(0x8AE6,0xEF);
+					ov3640_write_reg(0x8AE7,0x25);
+					ov3640_write_reg(0x8AE8,0xE0);
+					ov3640_write_reg(0x8AE9,0xFF);
+					ov3640_write_reg(0x8AEA,0xD2);
+					ov3640_write_reg(0x8AEB,0x00);
+					ov3640_write_reg(0x8AEC,0xE5);
+					ov3640_write_reg(0x8AED,0x20);
+					ov3640_write_reg(0x8AEE,0xF0);
+					ov3640_write_reg(0x8AEF,0x7E);
+					ov3640_write_reg(0x8AF0,0x01);
+					ov3640_write_reg(0x8AF1,0xAC);
+					ov3640_write_reg(0x8AF2,0x06);
+					ov3640_write_reg(0x8AF3,0x1E);
+					ov3640_write_reg(0x8AF4,0xEC);
+					ov3640_write_reg(0x8AF5,0x70);
+					ov3640_write_reg(0x8AF6,0xFA);
+					ov3640_write_reg(0x8AF7,0x12);
+					ov3640_write_reg(0x8AF8,0x05);
+					ov3640_write_reg(0x8AF9,0xC6);
+					ov3640_write_reg(0x8AFA,0xDD);
+					ov3640_write_reg(0x8AFB,0xE3);
+					ov3640_write_reg(0x8AFC,0x90);
+					ov3640_write_reg(0x8AFD,0x30);
+					ov3640_write_reg(0x8AFE,0xB1);
+					ov3640_write_reg(0x8AFF,0xE0);
+					ov3640_write_reg(0x8B00,0x54);
+					ov3640_write_reg(0x8B01,0x7F);
+					ov3640_write_reg(0x8B02,0xF0);
+					ov3640_write_reg(0x8B03,0xD2);
+					ov3640_write_reg(0x8B04,0x00);
+					ov3640_write_reg(0x8B05,0x12);
+					ov3640_write_reg(0x8B06,0x05);
+					ov3640_write_reg(0x8B07,0xC8);
+					ov3640_write_reg(0x8B08,0x7E);
+					ov3640_write_reg(0x8B09,0x01);
+					ov3640_write_reg(0x8B0A,0xAF);
+					ov3640_write_reg(0x8B0B,0x06);
+					ov3640_write_reg(0x8B0C,0x1E);
+					ov3640_write_reg(0x8B0D,0xEF);
+					ov3640_write_reg(0x8B0E,0x70);
+					ov3640_write_reg(0x8B0F,0xFA);
+					ov3640_write_reg(0x8B10,0x90);
+					ov3640_write_reg(0x8B11,0x30);
+					ov3640_write_reg(0x8B12,0xB5);
+					ov3640_write_reg(0x8B13,0xE0);
+					ov3640_write_reg(0x8B14,0x54);
+					ov3640_write_reg(0x8B15,0x02);
+					ov3640_write_reg(0x8B16,0xF5);
+					ov3640_write_reg(0x8B17,0x10);
+					ov3640_write_reg(0x8B18,0x12);
+					ov3640_write_reg(0x8B19,0x05);
+					ov3640_write_reg(0x8B1A,0xC6);
+					ov3640_write_reg(0x8B1B,0x90);
+					ov3640_write_reg(0x8B1C,0x30);
+					ov3640_write_reg(0x8B1D,0xB1);
+					ov3640_write_reg(0x8B1E,0xE0);
+					ov3640_write_reg(0x8B1F,0x44);
+					ov3640_write_reg(0x8B20,0x80);
+					ov3640_write_reg(0x8B21,0xF0);
+					ov3640_write_reg(0x8B22,0x7E);
+					ov3640_write_reg(0x8B23,0x01);
+					ov3640_write_reg(0x8B24,0xAF);
+					ov3640_write_reg(0x8B25,0x06);
+					ov3640_write_reg(0x8B26,0x1E);
+					ov3640_write_reg(0x8B27,0xEF);
+					ov3640_write_reg(0x8B28,0x70);
+					ov3640_write_reg(0x8B29,0xFA);
+					ov3640_write_reg(0x8B2A,0xD3);
+					ov3640_write_reg(0x8B2B,0x22);
+					ov3640_write_reg(0x8B2C,0xED);
+					ov3640_write_reg(0x8B2D,0x70);
+					ov3640_write_reg(0x8B2E,0x1E);
+					ov3640_write_reg(0x8B2F,0x12);
+					ov3640_write_reg(0x8B30,0x06);
+					ov3640_write_reg(0x8B31,0x3F);
+					ov3640_write_reg(0x8B32,0x24);
+					ov3640_write_reg(0x8B33,0x80);
+					ov3640_write_reg(0x8B34,0x12);
+					ov3640_write_reg(0x8B35,0x05);
+					ov3640_write_reg(0x8B36,0xCF);
+					ov3640_write_reg(0x8B37,0xF5);
+					ov3640_write_reg(0x8B38,0x0C);
+					ov3640_write_reg(0x8B39,0xEE);
+					ov3640_write_reg(0x8B3A,0x24);
+					ov3640_write_reg(0x8B3B,0x81);
+					ov3640_write_reg(0x8B3C,0x12);
+					ov3640_write_reg(0x8B3D,0x05);
+					ov3640_write_reg(0x8B3E,0xCF);
+					ov3640_write_reg(0x8B3F,0x12);
+					ov3640_write_reg(0x8B40,0x06);
+					ov3640_write_reg(0x8B41,0x3E);
+					ov3640_write_reg(0x8B42,0x24);
+					ov3640_write_reg(0x8B43,0x82);
+					ov3640_write_reg(0x8B44,0x12);
+					ov3640_write_reg(0x8B45,0x05);
+					ov3640_write_reg(0x8B46,0xCF);
+					ov3640_write_reg(0x8B47,0xFC);
+					ov3640_write_reg(0x8B48,0xEE);
+					ov3640_write_reg(0x8B49,0x24);
+					ov3640_write_reg(0x8B4A,0x83);
+					ov3640_write_reg(0x8B4B,0x80);
+					ov3640_write_reg(0x8B4C,0x21);
+					ov3640_write_reg(0x8B4D,0xED);
+					ov3640_write_reg(0x8B4E,0x64);
+					ov3640_write_reg(0x8B4F,0x01);
+					ov3640_write_reg(0x8B50,0x70);
+					ov3640_write_reg(0x8B51,0x1F);
+					ov3640_write_reg(0x8B52,0x12);
+					ov3640_write_reg(0x8B53,0x06);
+					ov3640_write_reg(0x8B54,0x3F);
+					ov3640_write_reg(0x8B55,0x24);
+					ov3640_write_reg(0x8B56,0x84);
+					ov3640_write_reg(0x8B57,0x12);
+					ov3640_write_reg(0x8B58,0x05);
+					ov3640_write_reg(0x8B59,0xCF);
+					ov3640_write_reg(0x8B5A,0xF5);
+					ov3640_write_reg(0x8B5B,0x0C);
+					ov3640_write_reg(0x8B5C,0xEE);
+					ov3640_write_reg(0x8B5D,0x24);
+					ov3640_write_reg(0x8B5E,0x85);
+					ov3640_write_reg(0x8B5F,0x12);
+					ov3640_write_reg(0x8B60,0x05);
+					ov3640_write_reg(0x8B61,0xCF);
+					ov3640_write_reg(0x8B62,0x12);
+					ov3640_write_reg(0x8B63,0x06);
+					ov3640_write_reg(0x8B64,0x3E);
+					ov3640_write_reg(0x8B65,0x24);
+					ov3640_write_reg(0x8B66,0x86);
+					ov3640_write_reg(0x8B67,0x12);
+					ov3640_write_reg(0x8B68,0x05);
+					ov3640_write_reg(0x8B69,0xCF);
+					ov3640_write_reg(0x8B6A,0xFC);
+					ov3640_write_reg(0x8B6B,0xEE);
+					ov3640_write_reg(0x8B6C,0x24);
+					ov3640_write_reg(0x8B6D,0x87);
+					ov3640_write_reg(0x8B6E,0x12);
+					ov3640_write_reg(0x8B6F,0x05);
+					ov3640_write_reg(0x8B70,0xCF);
+					ov3640_write_reg(0x8B71,0xEC);
+					ov3640_write_reg(0x8B72,0xFE);
+					ov3640_write_reg(0x8B73,0xEB);
+					ov3640_write_reg(0x8B74,0xF5);
+					ov3640_write_reg(0x8B75,0x82);
+					ov3640_write_reg(0x8B76,0xE5);
+					ov3640_write_reg(0x8B77,0x82);
+					ov3640_write_reg(0x8B78,0xFF);
+					ov3640_write_reg(0x8B79,0x22);
+					ov3640_write_reg(0x8B7A,0x8E);
+					ov3640_write_reg(0x8B7B,0x0C);
+					ov3640_write_reg(0x8B7C,0x8F);
+					ov3640_write_reg(0x8B7D,0x0D);
+					ov3640_write_reg(0x8B7E,0xE5);
+					ov3640_write_reg(0x8B7F,0x0C);
+					ov3640_write_reg(0x8B80,0x54);
+					ov3640_write_reg(0x8B81,0x03);
+					ov3640_write_reg(0x8B82,0xFC);
+					ov3640_write_reg(0x8B83,0xAD);
+					ov3640_write_reg(0x8B84,0x0D);
+					ov3640_write_reg(0x8B85,0xED);
+					ov3640_write_reg(0x8B86,0xC4);
+					ov3640_write_reg(0x8B87,0xF8);
+					ov3640_write_reg(0x8B88,0x54);
+					ov3640_write_reg(0x8B89,0x0F);
+					ov3640_write_reg(0x8B8A,0xC8);
+					ov3640_write_reg(0x8B8B,0x68);
+					ov3640_write_reg(0x8B8C,0xFF);
+					ov3640_write_reg(0x8B8D,0xEC);
+					ov3640_write_reg(0x8B8E,0xC4);
+					ov3640_write_reg(0x8B8F,0x54);
+					ov3640_write_reg(0x8B90,0xF0);
+					ov3640_write_reg(0x8B91,0x48);
+					ov3640_write_reg(0x8B92,0xAB);
+					ov3640_write_reg(0x8B93,0x07);
+					ov3640_write_reg(0x8B94,0xFA);
+					ov3640_write_reg(0x8B95,0xEC);
+					ov3640_write_reg(0x8B96,0x90);
+					ov3640_write_reg(0x8B97,0x3F);
+					ov3640_write_reg(0x8B98,0x05);
+					ov3640_write_reg(0x8B99,0xF0);
+					ov3640_write_reg(0x8B9A,0xA3);
+					ov3640_write_reg(0x8B9B,0xE5);
+					ov3640_write_reg(0x8B9C,0x0D);
+					ov3640_write_reg(0x8B9D,0xF0);
+					ov3640_write_reg(0x8B9E,0x45);
+					ov3640_write_reg(0x8B9F,0x0C);
+					ov3640_write_reg(0x8BA0,0x70);
+					ov3640_write_reg(0x8BA1,0x03);
+					ov3640_write_reg(0x8BA2,0x7A);
+					ov3640_write_reg(0x8BA3,0x80);
+					ov3640_write_reg(0x8BA4,0xFB);
+					ov3640_write_reg(0x8BA5,0x43);
+					ov3640_write_reg(0x8BA6,0x03);
+					ov3640_write_reg(0x8BA7,0x0F);
+					ov3640_write_reg(0x8BA8,0xAF);
+					ov3640_write_reg(0x8BA9,0x03);
+					ov3640_write_reg(0x8BAA,0xAE);
+					ov3640_write_reg(0x8BAB,0x02);
+					ov3640_write_reg(0x8BAC,0x12);
+					ov3640_write_reg(0x8BAD,0x0C);
+					ov3640_write_reg(0x8BAE,0x22);
+					ov3640_write_reg(0x8BAF,0xE5);
+					ov3640_write_reg(0x8BB0,0x0C);
+					ov3640_write_reg(0x8BB1,0x54);
+					ov3640_write_reg(0x8BB2,0x03);
+					ov3640_write_reg(0x8BB3,0xF5);
+					ov3640_write_reg(0x8BB4,0x5B);
+					ov3640_write_reg(0x8BB5,0x85);
+					ov3640_write_reg(0x8BB6,0x0D);
+					ov3640_write_reg(0x8BB7,0x5C);
+					ov3640_write_reg(0x8BB8,0x22);
+					ov3640_write_reg(0x8BB9,0x02);
+					ov3640_write_reg(0x8BBA,0x3D);
+					ov3640_write_reg(0x8BBB,0x00);
+					ov3640_write_reg(0x8BBC,0x96);
+					ov3640_write_reg(0x8BBD,0x01);
+					ov3640_write_reg(0x8BBE,0x3C);
+					ov3640_write_reg(0x8BBF,0x00);
+					ov3640_write_reg(0x8BC0,0x01);
+					ov3640_write_reg(0x8BC1,0x72);
+					ov3640_write_reg(0x8BC2,0x00);
+					ov3640_write_reg(0x8BC3,0x01);
+					ov3640_write_reg(0x8BC4,0x46);
+					ov3640_write_reg(0x8BC5,0x01);
+					ov3640_write_reg(0x8BC6,0x02);
+					ov3640_write_reg(0x8BC7,0x49);
+					ov3640_write_reg(0x8BC8,0x00);
+					ov3640_write_reg(0x8BC9,0x00);
+					ov3640_write_reg(0x8BCA,0x02);
+					ov3640_write_reg(0x8BCB,0x41);
+					ov3640_write_reg(0x8BCC,0x00);
+					ov3640_write_reg(0x8BCD,0x00);
+					ov3640_write_reg(0x8BCE,0x02);
+					ov3640_write_reg(0x8BCF,0x47);
+					ov3640_write_reg(0x8BD0,0x00);
+					ov3640_write_reg(0x8BD1,0x00);
+					ov3640_write_reg(0x8BD2,0x02);
+					ov3640_write_reg(0x8BD3,0x3F);
+					ov3640_write_reg(0x8BD4,0x00);
+					ov3640_write_reg(0x8BD5,0x00);
+					ov3640_write_reg(0x8BD6,0x01);
+					ov3640_write_reg(0x8BD7,0x43);
+					ov3640_write_reg(0x8BD8,0x00);
+					ov3640_write_reg(0x8BD9,0x01);
+					ov3640_write_reg(0x8BDA,0x61);
+					ov3640_write_reg(0x8BDB,0x00);
+					ov3640_write_reg(0x8BDC,0x01);
+					ov3640_write_reg(0x8BDD,0x45);
+					ov3640_write_reg(0x8BDE,0x00);
+					ov3640_write_reg(0x8BDF,0x02);
+					ov3640_write_reg(0x8BE0,0x4F);
+					ov3640_write_reg(0x8BE1,0x00);
+					ov3640_write_reg(0x8BE2,0x00);
+					ov3640_write_reg(0x8BE3,0xC1);
+					ov3640_write_reg(0x8BE4,0x0D);
+					ov3640_write_reg(0x8BE5,0xC1);
+					ov3640_write_reg(0x8BE6,0x0A);
+					ov3640_write_reg(0x8BE7,0xC1);
+					ov3640_write_reg(0x8BE8,0x09);
+					ov3640_write_reg(0x8BE9,0xC1);
+					ov3640_write_reg(0x8BEA,0x0E);
+					ov3640_write_reg(0x8BEB,0x01);
+					ov3640_write_reg(0x8BEC,0x44);
+					ov3640_write_reg(0x8BED,0x07);
+					ov3640_write_reg(0x8BEE,0x00);
+					ov3640_write_reg(0x8BEF,0x12);
+					ov3640_write_reg(0x8BF0,0x08);
+					ov3640_write_reg(0x8BF1,0x6C);
+					ov3640_write_reg(0x8BF2,0x12);
+					ov3640_write_reg(0x8BF3,0x0C);
+					ov3640_write_reg(0x8BF4,0xEA);
+					ov3640_write_reg(0x8BF5,0x12);
+					ov3640_write_reg(0x8BF6,0x06);
+					ov3640_write_reg(0x8BF7,0x80);
+					ov3640_write_reg(0x8BF8,0x12);
+					ov3640_write_reg(0x8BF9,0x04);
+					ov3640_write_reg(0x8BFA,0x97);
+					ov3640_write_reg(0x8BFB,0x30);
+					ov3640_write_reg(0x8BFC,0x08);
+					ov3640_write_reg(0x8BFD,0xF7);
+					ov3640_write_reg(0x8BFE,0xC2);
+					ov3640_write_reg(0x8BFF,0x08);
+					ov3640_write_reg(0x8C00,0x30);
+					ov3640_write_reg(0x8C01,0x0B);
+					ov3640_write_reg(0x8C02,0x05);
+					ov3640_write_reg(0x8C03,0x12);
+					ov3640_write_reg(0x8C04,0x07);
+					ov3640_write_reg(0x8C05,0x43);
+					ov3640_write_reg(0x8C06,0x80);
+					ov3640_write_reg(0x8C07,0xED);
+					ov3640_write_reg(0x8C08,0xE5);
+					ov3640_write_reg(0x8C09,0x3C);
+					ov3640_write_reg(0x8C0A,0xB4);
+					ov3640_write_reg(0x8C0B,0x01);
+					ov3640_write_reg(0x8C0C,0x05);
+					ov3640_write_reg(0x8C0D,0x12);
+					ov3640_write_reg(0x8C0E,0x02);
+					ov3640_write_reg(0x8C0F,0x7B);
+					ov3640_write_reg(0x8C10,0x80);
+					ov3640_write_reg(0x8C11,0xE3);
+					ov3640_write_reg(0x8C12,0x30);
+					ov3640_write_reg(0x8C13,0x0C);
+					ov3640_write_reg(0x8C14,0x05);
+					ov3640_write_reg(0x8C15,0x12);
+					ov3640_write_reg(0x8C16,0x0A);
+					ov3640_write_reg(0x8C17,0x65);
+					ov3640_write_reg(0x8C18,0x80);
+					ov3640_write_reg(0x8C19,0xDB);
+					ov3640_write_reg(0x8C1A,0x30);
+					ov3640_write_reg(0x8C1B,0x0D);
+					ov3640_write_reg(0x8C1C,0xD8);
+					ov3640_write_reg(0x8C1D,0x12);
+					ov3640_write_reg(0x8C1E,0x09);
+					ov3640_write_reg(0x8C1F,0xEA);
+					ov3640_write_reg(0x8C20,0x80);
+					ov3640_write_reg(0x8C21,0xD3);
+					ov3640_write_reg(0x8C22,0x8E);
+					ov3640_write_reg(0x8C23,0x0E);
+					ov3640_write_reg(0x8C24,0x8F);
+					ov3640_write_reg(0x8C25,0x0F);
+					ov3640_write_reg(0x8C26,0x12);
+					ov3640_write_reg(0x8C27,0x0C);
+					ov3640_write_reg(0x8C28,0x96);
+					ov3640_write_reg(0x8C29,0x7F);
+					ov3640_write_reg(0x8C2A,0x18);
+					ov3640_write_reg(0x8C2B,0x12);
+					ov3640_write_reg(0x8C2C,0x0A);
+					ov3640_write_reg(0x8C2D,0xDD);
+					ov3640_write_reg(0x8C2E,0x40);
+					ov3640_write_reg(0x8C2F,0x02);
+					ov3640_write_reg(0x8C30,0x80);
+					ov3640_write_reg(0x8C31,0x13);
+					ov3640_write_reg(0x8C32,0xE5);
+					ov3640_write_reg(0x8C33,0x0E);
+					ov3640_write_reg(0x8C34,0xFF);
+					ov3640_write_reg(0x8C35,0x12);
+					ov3640_write_reg(0x8C36,0x0A);
+					ov3640_write_reg(0x8C37,0xDD);
+					ov3640_write_reg(0x8C38,0x40);
+					ov3640_write_reg(0x8C39,0x02);
+					ov3640_write_reg(0x8C3A,0x80);
+					ov3640_write_reg(0x8C3B,0x09);
+					ov3640_write_reg(0x8C3C,0xAF);
+					ov3640_write_reg(0x8C3D,0x0F);
+					ov3640_write_reg(0x8C3E,0xE5);
+					ov3640_write_reg(0x8C3F,0x0F);
+					ov3640_write_reg(0x8C40,0x12);
+					ov3640_write_reg(0x8C41,0x0A);
+					ov3640_write_reg(0x8C42,0xDD);
+					ov3640_write_reg(0x8C43,0x40);
+					ov3640_write_reg(0x8C44,0x05);
+					ov3640_write_reg(0x8C45,0x12);
+					ov3640_write_reg(0x8C46,0x0C);
+					ov3640_write_reg(0x8C47,0x4E);
+					ov3640_write_reg(0x8C48,0x80);
+					ov3640_write_reg(0x8C49,0xDC);
+					ov3640_write_reg(0x8C4A,0x12);
+					ov3640_write_reg(0x8C4B,0x0C);
+					ov3640_write_reg(0x8C4C,0x4E);
+					ov3640_write_reg(0x8C4D,0x22);
+					ov3640_write_reg(0x8C4E,0xC2);
+					ov3640_write_reg(0x8C4F,0x01);
+					ov3640_write_reg(0x8C50,0x12);
+					ov3640_write_reg(0x8C51,0x05);
+					ov3640_write_reg(0x8C52,0xC8);
+					ov3640_write_reg(0x8C53,0x7F);
+					ov3640_write_reg(0x8C54,0x01);
+					ov3640_write_reg(0x8C55,0xAE);
+					ov3640_write_reg(0x8C56,0x07);
+					ov3640_write_reg(0x8C57,0x1F);
+					ov3640_write_reg(0x8C58,0xEE);
+					ov3640_write_reg(0x8C59,0x70);
+					ov3640_write_reg(0x8C5A,0xFA);
+					ov3640_write_reg(0x8C5B,0xD2);
+					ov3640_write_reg(0x8C5C,0x00);
+					ov3640_write_reg(0x8C5D,0x12);
+					ov3640_write_reg(0x8C5E,0x05);
+					ov3640_write_reg(0x8C5F,0xC8);
+					ov3640_write_reg(0x8C60,0x7F);
+					ov3640_write_reg(0x8C61,0x01);
+					ov3640_write_reg(0x8C62,0xAE);
+					ov3640_write_reg(0x8C63,0x07);
+					ov3640_write_reg(0x8C64,0x1F);
+					ov3640_write_reg(0x8C65,0xEE);
+					ov3640_write_reg(0x8C66,0x70);
+					ov3640_write_reg(0x8C67,0xFA);
+					ov3640_write_reg(0x8C68,0xD2);
+					ov3640_write_reg(0x8C69,0x01);
+					ov3640_write_reg(0x8C6A,0x12);
+					ov3640_write_reg(0x8C6B,0x05);
+					ov3640_write_reg(0x8C6C,0xC8);
+					ov3640_write_reg(0x8C6D,0x7F);
+					ov3640_write_reg(0x8C6E,0x01);
+					ov3640_write_reg(0x8C6F,0xAE);
+					ov3640_write_reg(0x8C70,0x07);
+					ov3640_write_reg(0x8C71,0x1F);
+					ov3640_write_reg(0x8C72,0xEE);
+					ov3640_write_reg(0x8C73,0x70);
+					ov3640_write_reg(0x8C74,0xFA);
+					ov3640_write_reg(0x8C75,0x22);
+					ov3640_write_reg(0x8C76,0x90);
+					ov3640_write_reg(0x8C77,0x30);
+					ov3640_write_reg(0x8C78,0x14);
+					ov3640_write_reg(0x8C79,0xE0);
+					ov3640_write_reg(0x8C7A,0x30);
+					ov3640_write_reg(0x8C7B,0x0F);
+					ov3640_write_reg(0x8C7C,0x10);
+					ov3640_write_reg(0x8C7D,0x54);
+					ov3640_write_reg(0x8C7E,0xF7);
+					ov3640_write_reg(0x8C7F,0xF0);
+					ov3640_write_reg(0x8C80,0xA3);
+					ov3640_write_reg(0x8C81,0xE0);
+					ov3640_write_reg(0x8C82,0x54);
+					ov3640_write_reg(0x8C83,0xBF);
+					ov3640_write_reg(0x8C84,0xF0);
+					ov3640_write_reg(0x8C85,0x90);
+					ov3640_write_reg(0x8C86,0x30);
+					ov3640_write_reg(0x8C87,0x2D);
+					ov3640_write_reg(0x8C88,0xE4);
+					ov3640_write_reg(0x8C89,0xF0);
+					ov3640_write_reg(0x8C8A,0xA3);
+					ov3640_write_reg(0x8C8B,0xF0);
+					ov3640_write_reg(0x8C8C,0x22);
+					ov3640_write_reg(0x8C8D,0x44);
+					ov3640_write_reg(0x8C8E,0x08);
+					ov3640_write_reg(0x8C8F,0xF0);
+					ov3640_write_reg(0x8C90,0xA3);
+					ov3640_write_reg(0x8C91,0xE0);
+					ov3640_write_reg(0x8C92,0x44);
+					ov3640_write_reg(0x8C93,0x40);
+					ov3640_write_reg(0x8C94,0xF0);
+					ov3640_write_reg(0x8C95,0x22);
+					ov3640_write_reg(0x8C96,0xD2);
+					ov3640_write_reg(0x8C97,0x01);
+					ov3640_write_reg(0x8C98,0xD2);
+					ov3640_write_reg(0x8C99,0x00);
+					ov3640_write_reg(0x8C9A,0x12);
+					ov3640_write_reg(0x8C9B,0x05);
+					ov3640_write_reg(0x8C9C,0xC8);
+					ov3640_write_reg(0x8C9D,0x7F);
+					ov3640_write_reg(0x8C9E,0x02);
+					ov3640_write_reg(0x8C9F,0xAE);
+					ov3640_write_reg(0x8CA0,0x07);
+					ov3640_write_reg(0x8CA1,0x1F);
+					ov3640_write_reg(0x8CA2,0xEE);
+					ov3640_write_reg(0x8CA3,0x70);
+					ov3640_write_reg(0x8CA4,0xFA);
+					ov3640_write_reg(0x8CA5,0xC2);
+					ov3640_write_reg(0x8CA6,0x01);
+					ov3640_write_reg(0x8CA7,0x12);
+					ov3640_write_reg(0x8CA8,0x05);
+					ov3640_write_reg(0x8CA9,0xC8);
+					ov3640_write_reg(0x8CAA,0x7F);
+					ov3640_write_reg(0x8CAB,0x01);
+					ov3640_write_reg(0x8CAC,0xAE);
+					ov3640_write_reg(0x8CAD,0x07);
+					ov3640_write_reg(0x8CAE,0x1F);
+					ov3640_write_reg(0x8CAF,0xEE);
+					ov3640_write_reg(0x8CB0,0x70);
+					ov3640_write_reg(0x8CB1,0xFA);
+					ov3640_write_reg(0x8CB2,0x12);
+					ov3640_write_reg(0x8CB3,0x05);
+					ov3640_write_reg(0x8CB4,0xC6);
+					ov3640_write_reg(0x8CB5,0x22);
+					ov3640_write_reg(0x8CB6,0x90);
+					ov3640_write_reg(0x8CB7,0x30);
+					ov3640_write_reg(0x8CB8,0x1B);
+					ov3640_write_reg(0x8CB9,0xE0);
+					ov3640_write_reg(0x8CBA,0xFF);
+					ov3640_write_reg(0x8CBB,0x65);
+					ov3640_write_reg(0x8CBC,0x2D);
+					ov3640_write_reg(0x8CBD,0x70);
+					ov3640_write_reg(0x8CBE,0x01);
+					ov3640_write_reg(0x8CBF,0xE4);
+					ov3640_write_reg(0x8CC0,0x60);
+					ov3640_write_reg(0x8CC1,0x04);
+					ov3640_write_reg(0x8CC2,0x8F);
+					ov3640_write_reg(0x8CC3,0x2D);
+					ov3640_write_reg(0x8CC4,0xD3);
+					ov3640_write_reg(0x8CC5,0x22);
+					ov3640_write_reg(0x8CC6,0xC3);
+					ov3640_write_reg(0x8CC7,0x22);
+					ov3640_write_reg(0x8CC8,0xEF);
+					ov3640_write_reg(0x8CC9,0x8D);
+					ov3640_write_reg(0x8CCA,0xF0);
+					ov3640_write_reg(0x8CCB,0xA4);
+					ov3640_write_reg(0x8CCC,0xA8);
+					ov3640_write_reg(0x8CCD,0xF0);
+					ov3640_write_reg(0x8CCE,0xCF);
+					ov3640_write_reg(0x8CCF,0x8C);
+					ov3640_write_reg(0x8CD0,0xF0);
+					ov3640_write_reg(0x8CD1,0xA4);
+					ov3640_write_reg(0x8CD2,0x28);
+					ov3640_write_reg(0x8CD3,0xCE);
+					ov3640_write_reg(0x8CD4,0x8D);
+					ov3640_write_reg(0x8CD5,0xF0);
+					ov3640_write_reg(0x8CD6,0xA4);
+					ov3640_write_reg(0x8CD7,0x2E);
+					ov3640_write_reg(0x8CD8,0xFE);
+					ov3640_write_reg(0x8CD9,0x22);
+					ov3640_write_reg(0x8CDA,0xEF);
+					ov3640_write_reg(0x8CDB,0x90);
+					ov3640_write_reg(0x8CDC,0x33);
+					ov3640_write_reg(0x8CDD,0x00);
+					ov3640_write_reg(0x8CDE,0x60);
+					ov3640_write_reg(0x8CDF,0x05);
+					ov3640_write_reg(0x8CE0,0xE0);
+					ov3640_write_reg(0x8CE1,0x44);
+					ov3640_write_reg(0x8CE2,0x40);
+					ov3640_write_reg(0x8CE3,0xF0);
+					ov3640_write_reg(0x8CE4,0x22);
+					ov3640_write_reg(0x8CE5,0xE0);
+					ov3640_write_reg(0x8CE6,0x54);
+					ov3640_write_reg(0x8CE7,0xBF);
+					ov3640_write_reg(0x8CE8,0xF0);
+					ov3640_write_reg(0x8CE9,0x22);
+					ov3640_write_reg(0x8CEA,0x85);
+					ov3640_write_reg(0x8CEB,0x3D);
+					ov3640_write_reg(0x8CEC,0x4B);
+					ov3640_write_reg(0x8CED,0x85);
+					ov3640_write_reg(0x8CEE,0x3E);
+					ov3640_write_reg(0x8CEF,0x4C);
+					ov3640_write_reg(0x8CF0,0xAF);
+					ov3640_write_reg(0x8CF1,0x4C);
+					ov3640_write_reg(0x8CF2,0xAE);
+					ov3640_write_reg(0x8CF3,0x4B);
+					ov3640_write_reg(0x8CF4,0x02);
+					ov3640_write_reg(0x8CF5,0x0B);
+					ov3640_write_reg(0x8CF6,0x7A);
+					ov3640_write_reg(0x8CF7,0xEE);
+					ov3640_write_reg(0x8CF8,0x30);
+					ov3640_write_reg(0x8CF9,0xE7);
+					ov3640_write_reg(0x8CFA,0x07);
+					ov3640_write_reg(0x8CFB,0xC3);
+					ov3640_write_reg(0x8CFC,0xE4);
+					ov3640_write_reg(0x8CFD,0x9F);
+					ov3640_write_reg(0x8CFE,0xFF);
+					ov3640_write_reg(0x8CFF,0xE4);
+					ov3640_write_reg(0x8D00,0x9E);
+					ov3640_write_reg(0x8D01,0xFE);
+					ov3640_write_reg(0x8D02,0x22);
+					ov3640_write_reg(0x3104,0x00);
+					mdelay(100);
+/*
+ * V4L2_SENS_ANTISHAKE_ENABLE
+ */					ov3640_write_reg(0x3f00,0x0A);
+					ov3640_write_reg(0x3f00,0x0F);
+				}break;
+			}
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_14
+ *  Name	:	ov3640_af_firmware_dump
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Auto focus firmware register dump
+ *  Comments	:  	Before performing autofocus related operations -Auto focus firmware dump should be 
+ *  			applied
+ ************************************************************************************************************/
+
+FNRESLT ov3640_af_firmware_dump(cam_data *cam)
+{
+	check_sequence	= DISABLE;
+	ov3640_write_reg(0x308c,0x00);
+	ov3640_write_reg(0x3104,0x02);
+	ov3640_write_reg(0x3105,0xff);
+	ov3640_write_reg(0x3106,0x00);
+	ov3640_write_reg(0x3107,0xff);
+	ov3640_write_reg(0x8000,0x02);
+	ov3640_write_reg(0x8001,0x07);
+	ov3640_write_reg(0x8002,0x74);
+	ov3640_write_reg(0x8003,0x02);
+	ov3640_write_reg(0x8004,0x08);
+	ov3640_write_reg(0x8005,0x00);
+	ov3640_write_reg(0x8006,0x85);
+	ov3640_write_reg(0x8007,0x3C);
+	ov3640_write_reg(0x8008,0x27);
+	ov3640_write_reg(0x8009,0x85);
+	ov3640_write_reg(0x800A,0x3D);
+	ov3640_write_reg(0x800B,0x28);
+	ov3640_write_reg(0x800C,0x85);
+	ov3640_write_reg(0x800D,0x3E);
+	ov3640_write_reg(0x800E,0x2B);
+	ov3640_write_reg(0x800F,0x85);
+	ov3640_write_reg(0x8010,0x3F);
+	ov3640_write_reg(0x8011,0x2C);
+	ov3640_write_reg(0x8012,0xE5);
+	ov3640_write_reg(0x8013,0x24);
+	ov3640_write_reg(0x8014,0x14);
+	ov3640_write_reg(0x8015,0x70);
+	ov3640_write_reg(0x8016,0x03);
+	ov3640_write_reg(0x8017,0x02);
+	ov3640_write_reg(0x8018,0x00);
+	ov3640_write_reg(0x8019,0xA7);
+	ov3640_write_reg(0x801A,0x14);
+	ov3640_write_reg(0x801B,0x70);
+	ov3640_write_reg(0x801C,0x03);
+	ov3640_write_reg(0x801D,0x02);
+	ov3640_write_reg(0x801E,0x01);
+	ov3640_write_reg(0x801F,0x45);
+	ov3640_write_reg(0x8020,0x14);
+	ov3640_write_reg(0x8021,0x70);
+	ov3640_write_reg(0x8022,0x03);
+	ov3640_write_reg(0x8023,0x02);
+	ov3640_write_reg(0x8024,0x01);
+	ov3640_write_reg(0x8025,0xEC);
+	ov3640_write_reg(0x8026,0x24);
+	ov3640_write_reg(0x8027,0x03);
+	ov3640_write_reg(0x8028,0x60);
+	ov3640_write_reg(0x8029,0x03);
+	ov3640_write_reg(0x802A,0x02);
+	ov3640_write_reg(0x802B,0x02);
+	ov3640_write_reg(0x802C,0x42);
+	ov3640_write_reg(0x802D,0xE5);
+	ov3640_write_reg(0x802E,0x48);
+	ov3640_write_reg(0x802F,0x45);
+	ov3640_write_reg(0x8030,0x47);
+	ov3640_write_reg(0x8031,0x70);
+	ov3640_write_reg(0x8032,0x12);
+	ov3640_write_reg(0x8033,0x85);
+	ov3640_write_reg(0x8034,0x27);
+	ov3640_write_reg(0x8035,0x25);
+	ov3640_write_reg(0x8036,0x85);
+	ov3640_write_reg(0x8037,0x28);
+	ov3640_write_reg(0x8038,0x26);
+	ov3640_write_reg(0x8039,0x85);
+	ov3640_write_reg(0x803A,0x2B);
+	ov3640_write_reg(0x803B,0x29);
+	ov3640_write_reg(0x803C,0x85);
+	ov3640_write_reg(0x803D,0x2C);
+	ov3640_write_reg(0x803E,0x2A);
+	ov3640_write_reg(0x803F,0xF5);
+	ov3640_write_reg(0x8040,0x22);
+	ov3640_write_reg(0x8041,0xF5);
+	ov3640_write_reg(0x8042,0x23);
+	ov3640_write_reg(0x8043,0x80);
+	ov3640_write_reg(0x8044,0x1D);
+	ov3640_write_reg(0x8045,0xC3);
+	ov3640_write_reg(0x8046,0xE5);
+	ov3640_write_reg(0x8047,0x2C);
+	ov3640_write_reg(0x8048,0x95);
+	ov3640_write_reg(0x8049,0x2A);
+	ov3640_write_reg(0x804A,0xE5);
+	ov3640_write_reg(0x804B,0x2B);
+	ov3640_write_reg(0x804C,0x95);
+	ov3640_write_reg(0x804D,0x29);
+	ov3640_write_reg(0x804E,0x40);
+	ov3640_write_reg(0x804F,0x12);
+	ov3640_write_reg(0x8050,0x85);
+	ov3640_write_reg(0x8051,0x27);
+	ov3640_write_reg(0x8052,0x25);
+	ov3640_write_reg(0x8053,0x85);
+	ov3640_write_reg(0x8054,0x28);
+	ov3640_write_reg(0x8055,0x26);
+	ov3640_write_reg(0x8056,0x85);
+	ov3640_write_reg(0x8057,0x2B);
+	ov3640_write_reg(0x8058,0x29);
+	ov3640_write_reg(0x8059,0x85);
+	ov3640_write_reg(0x805A,0x2C);
+	ov3640_write_reg(0x805B,0x2A);
+	ov3640_write_reg(0x805C,0x85);
+	ov3640_write_reg(0x805D,0x47);
+	ov3640_write_reg(0x805E,0x22);
+	ov3640_write_reg(0x805F,0x85);
+	ov3640_write_reg(0x8060,0x48);
+	ov3640_write_reg(0x8061,0x23);
+	ov3640_write_reg(0x8062,0xE5);
+	ov3640_write_reg(0x8063,0x48);
+	ov3640_write_reg(0x8064,0x45);
+	ov3640_write_reg(0x8065,0x47);
+	ov3640_write_reg(0x8066,0x70);
+	ov3640_write_reg(0x8067,0x08);
+	ov3640_write_reg(0x8068,0x85);
+	ov3640_write_reg(0x8069,0x35);
+	ov3640_write_reg(0x806A,0x47);
+	ov3640_write_reg(0x806B,0x85);
+	ov3640_write_reg(0x806C,0x36);
+	ov3640_write_reg(0x806D,0x48);
+	ov3640_write_reg(0x806E,0x80);
+	ov3640_write_reg(0x806F,0x1A);
+	ov3640_write_reg(0x8070,0xC3);
+	ov3640_write_reg(0x8071,0xE5);
+	ov3640_write_reg(0x8072,0x48);
+	ov3640_write_reg(0x8073,0x95);
+	ov3640_write_reg(0x8074,0x4A);
+	ov3640_write_reg(0x8075,0xE5);
+	ov3640_write_reg(0x8076,0x47);
+	ov3640_write_reg(0x8077,0x95);
+	ov3640_write_reg(0x8078,0x49);
+	ov3640_write_reg(0x8079,0x50);
+	ov3640_write_reg(0x807A,0x04);
+	ov3640_write_reg(0x807B,0xE5);
+	ov3640_write_reg(0x807C,0x3B);
+	ov3640_write_reg(0x807D,0x80);
+	ov3640_write_reg(0x807E,0x02);
+	ov3640_write_reg(0x807F,0xE5);
+	ov3640_write_reg(0x8080,0x4C);
+	ov3640_write_reg(0x8081,0x25);
+	ov3640_write_reg(0x8082,0x48);
+	ov3640_write_reg(0x8083,0xF5);
+	ov3640_write_reg(0x8084,0x48);
+	ov3640_write_reg(0x8085,0xE4);
+	ov3640_write_reg(0x8086,0x35);
+	ov3640_write_reg(0x8087,0x47);
+	ov3640_write_reg(0x8088,0xF5);
+	ov3640_write_reg(0x8089,0x47);
+	ov3640_write_reg(0x808A,0x85);
+	ov3640_write_reg(0x808B,0x47);
+	ov3640_write_reg(0x808C,0x13);
+	ov3640_write_reg(0x808D,0x85);
+	ov3640_write_reg(0x808E,0x48);
+	ov3640_write_reg(0x808F,0x14);
+	ov3640_write_reg(0x8090,0x12);
+	ov3640_write_reg(0x8091,0x0B);
+	ov3640_write_reg(0x8092,0x86);
+	ov3640_write_reg(0x8093,0xD3);
+	ov3640_write_reg(0x8094,0xE5);
+	ov3640_write_reg(0x8095,0x48);
+	ov3640_write_reg(0x8096,0x95);
+	ov3640_write_reg(0x8097,0x4A);
+	ov3640_write_reg(0x8098,0xE5);
+	ov3640_write_reg(0x8099,0x47);
+	ov3640_write_reg(0x809A,0x95);
+	ov3640_write_reg(0x809B,0x49);
+	ov3640_write_reg(0x809C,0x50);
+	ov3640_write_reg(0x809D,0x03);
+	ov3640_write_reg(0x809E,0x02);
+	ov3640_write_reg(0x809F,0x02);
+	ov3640_write_reg(0x80A0,0x42);
+	ov3640_write_reg(0x80A1,0x75);
+	ov3640_write_reg(0x80A2,0x24);
+	ov3640_write_reg(0x80A3,0x01);
+	ov3640_write_reg(0x80A4,0x02);
+	ov3640_write_reg(0x80A5,0x02);
+	ov3640_write_reg(0x80A6,0x42);
+	ov3640_write_reg(0x80A7,0xC3);
+	ov3640_write_reg(0x80A8,0xE5);
+	ov3640_write_reg(0x80A9,0x2C);
+	ov3640_write_reg(0x80AA,0x95);
+	ov3640_write_reg(0x80AB,0x2A);
+	ov3640_write_reg(0x80AC,0xFF);
+	ov3640_write_reg(0x80AD,0xE5);
+	ov3640_write_reg(0x80AE,0x2B);
+	ov3640_write_reg(0x80AF,0x95);
+	ov3640_write_reg(0x80B0,0x29);
+	ov3640_write_reg(0x80B1,0xFE);
+	ov3640_write_reg(0x80B2,0x12);
+	ov3640_write_reg(0x80B3,0x0D);
+	ov3640_write_reg(0x80B4,0x27);
+	ov3640_write_reg(0x80B5,0xC0);
+	ov3640_write_reg(0x80B6,0x06);
+	ov3640_write_reg(0x80B7,0xC0);
+	ov3640_write_reg(0x80B8,0x07);
+	ov3640_write_reg(0x80B9,0xC3);
+	ov3640_write_reg(0x80BA,0xE5);
+	ov3640_write_reg(0x80BB,0x28);
+	ov3640_write_reg(0x80BC,0x95);
+	ov3640_write_reg(0x80BD,0x26);
+	ov3640_write_reg(0x80BE,0xFF);
+	ov3640_write_reg(0x80BF,0xE5);
+	ov3640_write_reg(0x80C0,0x27);
+	ov3640_write_reg(0x80C1,0x95);
+	ov3640_write_reg(0x80C2,0x25);
+	ov3640_write_reg(0x80C3,0xFE);
+	ov3640_write_reg(0x80C4,0x12);
+	ov3640_write_reg(0x80C5,0x0D);
+	ov3640_write_reg(0x80C6,0x27);
+	ov3640_write_reg(0x80C7,0xD0);
+	ov3640_write_reg(0x80C8,0x05);
+	ov3640_write_reg(0x80C9,0xD0);
+	ov3640_write_reg(0x80CA,0x04);
+	ov3640_write_reg(0x80CB,0xD3);
+	ov3640_write_reg(0x80CC,0xEF);
+	ov3640_write_reg(0x80CD,0x9D);
+	ov3640_write_reg(0x80CE,0xEC);
+	ov3640_write_reg(0x80CF,0x64);
+	ov3640_write_reg(0x80D0,0x80);
+	ov3640_write_reg(0x80D1,0xF8);
+	ov3640_write_reg(0x80D2,0xEE);
+	ov3640_write_reg(0x80D3,0x64);
+	ov3640_write_reg(0x80D4,0x80);
+	ov3640_write_reg(0x80D5,0x98);
+	ov3640_write_reg(0x80D6,0x40);
+	ov3640_write_reg(0x80D7,0x0E);
+	ov3640_write_reg(0x80D8,0x85);
+	ov3640_write_reg(0x80D9,0x27);
+	ov3640_write_reg(0x80DA,0x2D);
+	ov3640_write_reg(0x80DB,0x85);
+	ov3640_write_reg(0x80DC,0x28);
+	ov3640_write_reg(0x80DD,0x2E);
+	ov3640_write_reg(0x80DE,0x85);
+	ov3640_write_reg(0x80DF,0x25);
+	ov3640_write_reg(0x80E0,0x2F);
+	ov3640_write_reg(0x80E1,0x85);
+	ov3640_write_reg(0x80E2,0x26);
+	ov3640_write_reg(0x80E3,0x30);
+	ov3640_write_reg(0x80E4,0x80);
+	ov3640_write_reg(0x80E5,0x0C);
+	ov3640_write_reg(0x80E6,0x85);
+	ov3640_write_reg(0x80E7,0x2B);
+	ov3640_write_reg(0x80E8,0x2D);
+	ov3640_write_reg(0x80E9,0x85);
+	ov3640_write_reg(0x80EA,0x2C);
+	ov3640_write_reg(0x80EB,0x2E);
+	ov3640_write_reg(0x80EC,0x85);
+	ov3640_write_reg(0x80ED,0x29);
+	ov3640_write_reg(0x80EE,0x2F);
+	ov3640_write_reg(0x80EF,0x85);
+	ov3640_write_reg(0x80F0,0x2A);
+	ov3640_write_reg(0x80F1,0x30);
+	ov3640_write_reg(0x80F2,0xC3);
+	ov3640_write_reg(0x80F3,0xE5);
+	ov3640_write_reg(0x80F4,0x2E);
+	ov3640_write_reg(0x80F5,0x95);
+	ov3640_write_reg(0x80F6,0x30);
+	ov3640_write_reg(0x80F7,0xE5);
+	ov3640_write_reg(0x80F8,0x2D);
+	ov3640_write_reg(0x80F9,0x95);
+	ov3640_write_reg(0x80FA,0x2F);
+	ov3640_write_reg(0x80FB,0x40);
+	ov3640_write_reg(0x80FC,0x30);
+	ov3640_write_reg(0x80FD,0xAF);
+	ov3640_write_reg(0x80FE,0x4C);
+	ov3640_write_reg(0x80FF,0x7E);
+	ov3640_write_reg(0x8100,0x00);
+	ov3640_write_reg(0x8101,0xE5);
+	ov3640_write_reg(0x8102,0x48);
+	ov3640_write_reg(0x8103,0x2F);
+	ov3640_write_reg(0x8104,0xFD);
+	ov3640_write_reg(0x8105,0xEE);
+	ov3640_write_reg(0x8106,0x35);
+	ov3640_write_reg(0x8107,0x47);
+	ov3640_write_reg(0x8108,0xFC);
+	ov3640_write_reg(0x8109,0xC3);
+	ov3640_write_reg(0x810A,0xED);
+	ov3640_write_reg(0x810B,0x95);
+	ov3640_write_reg(0x810C,0x4E);
+	ov3640_write_reg(0x810D,0xEC);
+	ov3640_write_reg(0x810E,0x95);
+	ov3640_write_reg(0x810F,0x4D);
+	ov3640_write_reg(0x8110,0x50);
+	ov3640_write_reg(0x8111,0x18);
+	ov3640_write_reg(0x8112,0xEF);
+	ov3640_write_reg(0x8113,0x25);
+	ov3640_write_reg(0x8114,0x48);
+	ov3640_write_reg(0x8115,0xF5);
+	ov3640_write_reg(0x8116,0x48);
+	ov3640_write_reg(0x8117,0xEE);
+	ov3640_write_reg(0x8118,0x35);
+	ov3640_write_reg(0x8119,0x47);
+	ov3640_write_reg(0x811A,0xF5);
+	ov3640_write_reg(0x811B,0x47);
+	ov3640_write_reg(0x811C,0xF5);
+	ov3640_write_reg(0x811D,0x13);
+	ov3640_write_reg(0x811E,0x85);
+	ov3640_write_reg(0x811F,0x48);
+	ov3640_write_reg(0x8120,0x14);
+	ov3640_write_reg(0x8121,0x12);
+	ov3640_write_reg(0x8122,0x0B);
+	ov3640_write_reg(0x8123,0x86);
+	ov3640_write_reg(0x8124,0x75);
+	ov3640_write_reg(0x8125,0x24);
+	ov3640_write_reg(0x8126,0x02);
+	ov3640_write_reg(0x8127,0x02);
+	ov3640_write_reg(0x8128,0x01);
+	ov3640_write_reg(0x8129,0xC2);
+	ov3640_write_reg(0x812A,0x02);
+	ov3640_write_reg(0x812B,0x01);
+	ov3640_write_reg(0x812C,0xD0);
+	ov3640_write_reg(0x812D,0x85);
+	ov3640_write_reg(0x812E,0x47);
+	ov3640_write_reg(0x812F,0x0D);
+	ov3640_write_reg(0x8130,0x85);
+	ov3640_write_reg(0x8131,0x48);
+	ov3640_write_reg(0x8132,0x0E);
+	ov3640_write_reg(0x8133,0x85);
+	ov3640_write_reg(0x8134,0x22);
+	ov3640_write_reg(0x8135,0x0F);
+	ov3640_write_reg(0x8136,0x85);
+	ov3640_write_reg(0x8137,0x23);
+	ov3640_write_reg(0x8138,0x10);
+	ov3640_write_reg(0x8139,0x12);
+	ov3640_write_reg(0x813A,0x0B);
+	ov3640_write_reg(0x813B,0x41);
+	ov3640_write_reg(0x813C,0x85);
+	ov3640_write_reg(0x813D,0x22);
+	ov3640_write_reg(0x813E,0x47);
+	ov3640_write_reg(0x813F,0x85);
+	ov3640_write_reg(0x8140,0x23);
+	ov3640_write_reg(0x8141,0x48);
+	ov3640_write_reg(0x8142,0x02);
+	ov3640_write_reg(0x8143,0x01);
+	ov3640_write_reg(0x8144,0xE7);
+	ov3640_write_reg(0x8145,0xC3);
+	ov3640_write_reg(0x8146,0xE5);
+	ov3640_write_reg(0x8147,0x2C);
+	ov3640_write_reg(0x8148,0x95);
+	ov3640_write_reg(0x8149,0x2A);
+	ov3640_write_reg(0x814A,0xFF);
+	ov3640_write_reg(0x814B,0xE5);
+	ov3640_write_reg(0x814C,0x2B);
+	ov3640_write_reg(0x814D,0x95);
+	ov3640_write_reg(0x814E,0x29);
+	ov3640_write_reg(0x814F,0xFE);
+	ov3640_write_reg(0x8150,0x12);
+	ov3640_write_reg(0x8151,0x0D);
+	ov3640_write_reg(0x8152,0x27);
+	ov3640_write_reg(0x8153,0xC0);
+	ov3640_write_reg(0x8154,0x06);
+	ov3640_write_reg(0x8155,0xC0);
+	ov3640_write_reg(0x8156,0x07);
+	ov3640_write_reg(0x8157,0xC3);
+	ov3640_write_reg(0x8158,0xE5);
+	ov3640_write_reg(0x8159,0x28);
+	ov3640_write_reg(0x815A,0x95);
+	ov3640_write_reg(0x815B,0x26);
+	ov3640_write_reg(0x815C,0xFF);
+	ov3640_write_reg(0x815D,0xE5);
+	ov3640_write_reg(0x815E,0x27);
+	ov3640_write_reg(0x815F,0x95);
+	ov3640_write_reg(0x8160,0x25);
+	ov3640_write_reg(0x8161,0xFE);
+	ov3640_write_reg(0x8162,0x12);
+	ov3640_write_reg(0x8163,0x0D);
+	ov3640_write_reg(0x8164,0x27);
+	ov3640_write_reg(0x8165,0xD0);
+	ov3640_write_reg(0x8166,0x05);
+	ov3640_write_reg(0x8167,0xD0);
+	ov3640_write_reg(0x8168,0x04);
+	ov3640_write_reg(0x8169,0xD3);
+	ov3640_write_reg(0x816A,0xEF);
+	ov3640_write_reg(0x816B,0x9D);
+	ov3640_write_reg(0x816C,0xEC);
+	ov3640_write_reg(0x816D,0x64);
+	ov3640_write_reg(0x816E,0x80);
+	ov3640_write_reg(0x816F,0xF8);
+	ov3640_write_reg(0x8170,0xEE);
+	ov3640_write_reg(0x8171,0x64);
+	ov3640_write_reg(0x8172,0x80);
+	ov3640_write_reg(0x8173,0x98);
+	ov3640_write_reg(0x8174,0x40);
+	ov3640_write_reg(0x8175,0x0E);
+	ov3640_write_reg(0x8176,0x85);
+	ov3640_write_reg(0x8177,0x27);
+	ov3640_write_reg(0x8178,0x2D);
+	ov3640_write_reg(0x8179,0x85);
+	ov3640_write_reg(0x817A,0x28);
+	ov3640_write_reg(0x817B,0x2E);
+	ov3640_write_reg(0x817C,0x85);
+	ov3640_write_reg(0x817D,0x25);
+	ov3640_write_reg(0x817E,0x2F);
+	ov3640_write_reg(0x817F,0x85);
+	ov3640_write_reg(0x8180,0x26);
+	ov3640_write_reg(0x8181,0x30);
+	ov3640_write_reg(0x8182,0x80);
+	ov3640_write_reg(0x8183,0x0C);
+	ov3640_write_reg(0x8184,0x85);
+	ov3640_write_reg(0x8185,0x2B);
+	ov3640_write_reg(0x8186,0x2D);
+	ov3640_write_reg(0x8187,0x85);
+	ov3640_write_reg(0x8188,0x2C);
+	ov3640_write_reg(0x8189,0x2E);
+	ov3640_write_reg(0x818A,0x85);
+	ov3640_write_reg(0x818B,0x29);
+	ov3640_write_reg(0x818C,0x2F);
+	ov3640_write_reg(0x818D,0x85);
+	ov3640_write_reg(0x818E,0x2A);
+	ov3640_write_reg(0x818F,0x30);
+	ov3640_write_reg(0x8190,0xC3);
+	ov3640_write_reg(0x8191,0xE5);
+	ov3640_write_reg(0x8192,0x2E);
+	ov3640_write_reg(0x8193,0x95);
+	ov3640_write_reg(0x8194,0x30);
+	ov3640_write_reg(0x8195,0xE5);
+	ov3640_write_reg(0x8196,0x2D);
+	ov3640_write_reg(0x8197,0x95);
+	ov3640_write_reg(0x8198,0x2F);
+	ov3640_write_reg(0x8199,0x40);
+	ov3640_write_reg(0x819A,0x37);
+	ov3640_write_reg(0x819B,0xAF);
+	ov3640_write_reg(0x819C,0x4C);
+	ov3640_write_reg(0x819D,0x7E);
+	ov3640_write_reg(0x819E,0x00);
+	ov3640_write_reg(0x819F,0xE5);
+	ov3640_write_reg(0x81A0,0x48);
+	ov3640_write_reg(0x81A1,0x2F);
+	ov3640_write_reg(0x81A2,0xFD);
+	ov3640_write_reg(0x81A3,0xEE);
+	ov3640_write_reg(0x81A4,0x35);
+	ov3640_write_reg(0x81A5,0x47);
+	ov3640_write_reg(0x81A6,0xFC);
+	ov3640_write_reg(0x81A7,0xC3);
+	ov3640_write_reg(0x81A8,0xED);
+	ov3640_write_reg(0x81A9,0x95);
+	ov3640_write_reg(0x81AA,0x4E);
+	ov3640_write_reg(0x81AB,0xEC);
+	ov3640_write_reg(0x81AC,0x95);
+	ov3640_write_reg(0x81AD,0x4D);
+	ov3640_write_reg(0x81AE,0x50);
+	ov3640_write_reg(0x81AF,0x20);
+	ov3640_write_reg(0x81B0,0xEF);
+	ov3640_write_reg(0x81B1,0x25);
+	ov3640_write_reg(0x81B2,0x48);
+	ov3640_write_reg(0x81B3,0xF5);
+	ov3640_write_reg(0x81B4,0x48);
+	ov3640_write_reg(0x81B5,0xEE);
+	ov3640_write_reg(0x81B6,0x35);
+	ov3640_write_reg(0x81B7,0x47);
+	ov3640_write_reg(0x81B8,0xF5);
+	ov3640_write_reg(0x81B9,0x47);
+	ov3640_write_reg(0x81BA,0xF5);
+	ov3640_write_reg(0x81BB,0x13);
+	ov3640_write_reg(0x81BC,0x85);
+	ov3640_write_reg(0x81BD,0x48);
+	ov3640_write_reg(0x81BE,0x14);
+	ov3640_write_reg(0x81BF,0x12);
+	ov3640_write_reg(0x81C0,0x0B);
+	ov3640_write_reg(0x81C1,0x86);
+	ov3640_write_reg(0x81C2,0x85);
+	ov3640_write_reg(0x81C3,0x27);
+	ov3640_write_reg(0x81C4,0x25);
+	ov3640_write_reg(0x81C5,0x85);
+	ov3640_write_reg(0x81C6,0x28);
+	ov3640_write_reg(0x81C7,0x26);
+	ov3640_write_reg(0x81C8,0x85);
+	ov3640_write_reg(0x81C9,0x2B);
+	ov3640_write_reg(0x81CA,0x29);
+	ov3640_write_reg(0x81CB,0x85);
+	ov3640_write_reg(0x81CC,0x2C);
+	ov3640_write_reg(0x81CD,0x2A);
+	ov3640_write_reg(0x81CE,0x80);
+	ov3640_write_reg(0x81CF,0x72);
+	ov3640_write_reg(0x81D0,0x80);
+	ov3640_write_reg(0x81D1,0x15);
+	ov3640_write_reg(0x81D2,0xC3);
+	ov3640_write_reg(0x81D3,0xE5);
+	ov3640_write_reg(0x81D4,0x48);
+	ov3640_write_reg(0x81D5,0x95);
+	ov3640_write_reg(0x81D6,0x4C);
+	ov3640_write_reg(0x81D7,0xF5);
+	ov3640_write_reg(0x81D8,0x48);
+	ov3640_write_reg(0x81D9,0xE5);
+	ov3640_write_reg(0x81DA,0x47);
+	ov3640_write_reg(0x81DB,0x94);
+	ov3640_write_reg(0x81DC,0x00);
+	ov3640_write_reg(0x81DD,0xF5);
+	ov3640_write_reg(0x81DE,0x47);
+	ov3640_write_reg(0x81DF,0xF5);
+	ov3640_write_reg(0x81E0,0x13);
+	ov3640_write_reg(0x81E1,0x85);
+	ov3640_write_reg(0x81E2,0x48);
+	ov3640_write_reg(0x81E3,0x14);
+	ov3640_write_reg(0x81E4,0x12);
+	ov3640_write_reg(0x81E5,0x0B);
+	ov3640_write_reg(0x81E6,0x86);
+	ov3640_write_reg(0x81E7,0x75);
+	ov3640_write_reg(0x81E8,0x24);
+	ov3640_write_reg(0x81E9,0x03);
+	ov3640_write_reg(0x81EA,0x80);
+	ov3640_write_reg(0x81EB,0x56);
+	ov3640_write_reg(0x81EC,0xE4);
+	ov3640_write_reg(0x81ED,0xF5);
+	ov3640_write_reg(0x81EE,0x24);
+	ov3640_write_reg(0x81EF,0xC3);
+	ov3640_write_reg(0x81F0,0xE5);
+	ov3640_write_reg(0x81F1,0x42);
+	ov3640_write_reg(0x81F2,0x95);
+	ov3640_write_reg(0x81F3,0x30);
+	ov3640_write_reg(0x81F4,0xE5);
+	ov3640_write_reg(0x81F5,0x41);
+	ov3640_write_reg(0x81F6,0x95);
+	ov3640_write_reg(0x81F7,0x2F);
+	ov3640_write_reg(0x81F8,0x50);
+	ov3640_write_reg(0x81F9,0x23);
+	ov3640_write_reg(0x81FA,0xE5);
+	ov3640_write_reg(0x81FB,0x40);
+	ov3640_write_reg(0x81FC,0x54);
+	ov3640_write_reg(0x81FD,0x0C);
+	ov3640_write_reg(0x81FE,0xFF);
+	ov3640_write_reg(0x81FF,0xBF);
+	ov3640_write_reg(0x8200,0x04);
+	ov3640_write_reg(0x8201,0x05);
+	ov3640_write_reg(0x8202,0x75);
+	ov3640_write_reg(0x8203,0x40);
+	ov3640_write_reg(0x8204,0x46);
+	ov3640_write_reg(0x8205,0x80);
+	ov3640_write_reg(0x8206,0x32);
+	ov3640_write_reg(0x8207,0xEF);
+	ov3640_write_reg(0x8208,0x64);
+	ov3640_write_reg(0x8209,0x08);
+	ov3640_write_reg(0x820A,0x70);
+	ov3640_write_reg(0x820B,0x2D);
+	ov3640_write_reg(0x820C,0x75);
+	ov3640_write_reg(0x820D,0x40);
+	ov3640_write_reg(0x820E,0x4A);
+	ov3640_write_reg(0x820F,0x85);
+	ov3640_write_reg(0x8210,0x3C);
+	ov3640_write_reg(0x8211,0x43);
+	ov3640_write_reg(0x8212,0x85);
+	ov3640_write_reg(0x8213,0x3D);
+	ov3640_write_reg(0x8214,0x44);
+	ov3640_write_reg(0x8215,0x85);
+	ov3640_write_reg(0x8216,0x3E);
+	ov3640_write_reg(0x8217,0x45);
+	ov3640_write_reg(0x8218,0x85);
+	ov3640_write_reg(0x8219,0x3F);
+	ov3640_write_reg(0x821A,0x46);
+	ov3640_write_reg(0x821B,0x80);
+	ov3640_write_reg(0x821C,0x1C);
+	ov3640_write_reg(0x821D,0xE5);
+	ov3640_write_reg(0x821E,0x40);
+	ov3640_write_reg(0x821F,0x54);
+	ov3640_write_reg(0x8220,0x0C);
+	ov3640_write_reg(0x8221,0xFF);
+	ov3640_write_reg(0x8222,0xBF);
+	ov3640_write_reg(0x8223,0x04);
+	ov3640_write_reg(0x8224,0x05);
+	ov3640_write_reg(0x8225,0x75);
+	ov3640_write_reg(0x8226,0x40);
+	ov3640_write_reg(0x8227,0xC6);
+	ov3640_write_reg(0x8228,0x80);
+	ov3640_write_reg(0x8229,0x0F);
+	ov3640_write_reg(0x822A,0xBF);
+	ov3640_write_reg(0x822B,0x08);
+	ov3640_write_reg(0x822C,0x0C);
+	ov3640_write_reg(0x822D,0x75);
+	ov3640_write_reg(0x822E,0x40);
+	ov3640_write_reg(0x822F,0xCA);
+	ov3640_write_reg(0x8230,0xE4);
+	ov3640_write_reg(0x8231,0xF5);
+	ov3640_write_reg(0x8232,0x43);
+	ov3640_write_reg(0x8233,0xF5);
+	ov3640_write_reg(0x8234,0x44);
+	ov3640_write_reg(0x8235,0xF5);
+	ov3640_write_reg(0x8236,0x45);
+	ov3640_write_reg(0x8237,0xF5);
+	ov3640_write_reg(0x8238,0x46);
+	ov3640_write_reg(0x8239,0x12);
+	ov3640_write_reg(0x823A,0x0A);
+	ov3640_write_reg(0x823B,0x7D);
+	ov3640_write_reg(0x823C,0x90);
+	ov3640_write_reg(0x823D,0x3F);
+	ov3640_write_reg(0x823E,0x01);
+	ov3640_write_reg(0x823F,0xE5);
+	ov3640_write_reg(0x8240,0x40);
+	ov3640_write_reg(0x8241,0xF0);
+	ov3640_write_reg(0x8242,0xC2);
+	ov3640_write_reg(0x8243,0x09);
+	ov3640_write_reg(0x8244,0x22);
+	ov3640_write_reg(0x8245,0xE5);
+	ov3640_write_reg(0x8246,0x4B);
+	ov3640_write_reg(0x8247,0x70);
+	ov3640_write_reg(0x8248,0x03);
+	ov3640_write_reg(0x8249,0x02);
+	ov3640_write_reg(0x824A,0x03);
+	ov3640_write_reg(0x824B,0x7A);
+	ov3640_write_reg(0x824C,0xC2);
+	ov3640_write_reg(0x824D,0xAF);
+	ov3640_write_reg(0x824E,0x85);
+	ov3640_write_reg(0x824F,0x4B);
+	ov3640_write_reg(0x8250,0x0C);
+	ov3640_write_reg(0x8251,0xE4);
+	ov3640_write_reg(0x8252,0xF5);
+	ov3640_write_reg(0x8253,0x4B);
+	ov3640_write_reg(0x8254,0xD2);
+	ov3640_write_reg(0x8255,0xAF);
+	ov3640_write_reg(0x8256,0xE5);
+	ov3640_write_reg(0x8257,0x0C);
+	ov3640_write_reg(0x8258,0x12);
+	ov3640_write_reg(0x8259,0x0C);
+	ov3640_write_reg(0x825A,0x48);
+	ov3640_write_reg(0x825B,0x02);
+	ov3640_write_reg(0x825C,0x92);
+	ov3640_write_reg(0x825D,0x00);
+	ov3640_write_reg(0x825E,0x02);
+	ov3640_write_reg(0x825F,0xA3);
+	ov3640_write_reg(0x8260,0x01);
+	ov3640_write_reg(0x8261,0x02);
+	ov3640_write_reg(0x8262,0xAE);
+	ov3640_write_reg(0x8263,0x02);
+	ov3640_write_reg(0x8264,0x02);
+	ov3640_write_reg(0x8265,0xB9);
+	ov3640_write_reg(0x8266,0x03);
+	ov3640_write_reg(0x8267,0x02);
+	ov3640_write_reg(0x8268,0xCC);
+	ov3640_write_reg(0x8269,0x04);
+	ov3640_write_reg(0x826A,0x02);
+	ov3640_write_reg(0x826B,0xE3);
+	ov3640_write_reg(0x826C,0x05);
+	ov3640_write_reg(0x826D,0x02);
+	ov3640_write_reg(0x826E,0xF6);
+	ov3640_write_reg(0x826F,0x06);
+	ov3640_write_reg(0x8270,0x03);
+	ov3640_write_reg(0x8271,0x0F);
+	ov3640_write_reg(0x8272,0x07);
+	ov3640_write_reg(0x8273,0x03);
+	ov3640_write_reg(0x8274,0x2C);
+	ov3640_write_reg(0x8275,0x08);
+	ov3640_write_reg(0x8276,0x03);
+	ov3640_write_reg(0x8277,0x4B);
+	ov3640_write_reg(0x8278,0x09);
+	ov3640_write_reg(0x8279,0x03);
+	ov3640_write_reg(0x827A,0x50);
+	ov3640_write_reg(0x827B,0x10);
+	ov3640_write_reg(0x827C,0x03);
+	ov3640_write_reg(0x827D,0x50);
+	ov3640_write_reg(0x827E,0x11);
+	ov3640_write_reg(0x827F,0x03);
+	ov3640_write_reg(0x8280,0x50);
+	ov3640_write_reg(0x8281,0x12);
+	ov3640_write_reg(0x8282,0x03);
+	ov3640_write_reg(0x8283,0x50);
+	ov3640_write_reg(0x8284,0x13);
+	ov3640_write_reg(0x8285,0x03);
+	ov3640_write_reg(0x8286,0x50);
+	ov3640_write_reg(0x8287,0x14);
+	ov3640_write_reg(0x8288,0x03);
+	ov3640_write_reg(0x8289,0x50);
+	ov3640_write_reg(0x828A,0x15);
+	ov3640_write_reg(0x828B,0x03);
+	ov3640_write_reg(0x828C,0x60);
+	ov3640_write_reg(0x828D,0x20);
+	ov3640_write_reg(0x828E,0x00);
+	ov3640_write_reg(0x828F,0x00);
+	ov3640_write_reg(0x8290,0x03);
+	ov3640_write_reg(0x8291,0x74);
+	ov3640_write_reg(0x8292,0xE5);
+	ov3640_write_reg(0x8293,0x4F);
+	ov3640_write_reg(0x8294,0x70);
+	ov3640_write_reg(0x8295,0x03);
+	ov3640_write_reg(0x8296,0x02);
+	ov3640_write_reg(0x8297,0x03);
+	ov3640_write_reg(0x8298,0x74);
+	ov3640_write_reg(0x8299,0xE5);
+	ov3640_write_reg(0x829A,0x40);
+	ov3640_write_reg(0x829B,0x60);
+	ov3640_write_reg(0x829C,0x03);
+	ov3640_write_reg(0x829D,0x02);
+	ov3640_write_reg(0x829E,0x03);
+	ov3640_write_reg(0x829F,0x74);
+	ov3640_write_reg(0x82A0,0x02);
+	ov3640_write_reg(0x82A1,0x03);
+	ov3640_write_reg(0x82A2,0x27);
+	ov3640_write_reg(0x82A3,0xD2);
+	ov3640_write_reg(0x82A4,0x08);
+	ov3640_write_reg(0x82A5,0x75);
+	ov3640_write_reg(0x82A6,0x0E);
+	ov3640_write_reg(0x82A7,0x01);
+	ov3640_write_reg(0x82A8,0x12);
+	ov3640_write_reg(0x82A9,0x0D);
+	ov3640_write_reg(0x82AA,0x13);
+	ov3640_write_reg(0x82AB,0x02);
+	ov3640_write_reg(0x82AC,0x03);
+	ov3640_write_reg(0x82AD,0x74);
+	ov3640_write_reg(0x82AE,0xE4);
+	ov3640_write_reg(0x82AF,0xF5);
+	ov3640_write_reg(0x82B0,0x0E);
+	ov3640_write_reg(0x82B1,0x12);
+	ov3640_write_reg(0x82B2,0x0D);
+	ov3640_write_reg(0x82B3,0x13);
+	ov3640_write_reg(0x82B4,0xC2);
+	ov3640_write_reg(0x82B5,0x08);
+	ov3640_write_reg(0x82B6,0x02);
+	ov3640_write_reg(0x82B7,0x03);
+	ov3640_write_reg(0x82B8,0x74);
+	ov3640_write_reg(0x82B9,0xE5);
+	ov3640_write_reg(0x82BA,0x40);
+	ov3640_write_reg(0x82BB,0x60);
+	ov3640_write_reg(0x82BC,0x03);
+	ov3640_write_reg(0x82BD,0x02);
+	ov3640_write_reg(0x82BE,0x03);
+	ov3640_write_reg(0x82BF,0x74);
+	ov3640_write_reg(0x82C0,0xE5);
+	ov3640_write_reg(0x82C1,0x4F);
+	ov3640_write_reg(0x82C2,0x60);
+	ov3640_write_reg(0x82C3,0x03);
+	ov3640_write_reg(0x82C4,0x02);
+	ov3640_write_reg(0x82C5,0x03);
+	ov3640_write_reg(0x82C6,0x74);
+	ov3640_write_reg(0x82C7,0x75);
+	ov3640_write_reg(0x82C8,0x40);
+	ov3640_write_reg(0x82C9,0x65);
+	ov3640_write_reg(0x82CA,0x80);
+	ov3640_write_reg(0x82CB,0x77);
+	ov3640_write_reg(0x82CC,0xE5);
+	ov3640_write_reg(0x82CD,0x40);
+	ov3640_write_reg(0x82CE,0x60);
+	ov3640_write_reg(0x82CF,0x03);
+	ov3640_write_reg(0x82D0,0x02);
+	ov3640_write_reg(0x82D1,0x03);
+	ov3640_write_reg(0x82D2,0x74);
+	ov3640_write_reg(0x82D3,0xE5);
+	ov3640_write_reg(0x82D4,0x4F);
+	ov3640_write_reg(0x82D5,0x60);
+	ov3640_write_reg(0x82D6,0x03);
+	ov3640_write_reg(0x82D7,0x02);
+	ov3640_write_reg(0x82D8,0x03);
+	ov3640_write_reg(0x82D9,0x74);
+	ov3640_write_reg(0x82DA,0x75);
+	ov3640_write_reg(0x82DB,0x40);
+	ov3640_write_reg(0x82DC,0x4A);
+	ov3640_write_reg(0x82DD,0x75);
+	ov3640_write_reg(0x82DE,0x4F);
+	ov3640_write_reg(0x82DF,0x01);
+	ov3640_write_reg(0x82E0,0x02);
+	ov3640_write_reg(0x82E1,0x03);
+	ov3640_write_reg(0x82E2,0x74);
+	ov3640_write_reg(0x82E3,0xE5);
+	ov3640_write_reg(0x82E4,0x40);
+	ov3640_write_reg(0x82E5,0x60);
+	ov3640_write_reg(0x82E6,0x03);
+	ov3640_write_reg(0x82E7,0x02);
+	ov3640_write_reg(0x82E8,0x03);
+	ov3640_write_reg(0x82E9,0x74);
+	ov3640_write_reg(0x82EA,0xE5);
+	ov3640_write_reg(0x82EB,0x4F);
+	ov3640_write_reg(0x82EC,0x60);
+	ov3640_write_reg(0x82ED,0x03);
+	ov3640_write_reg(0x82EE,0x02);
+	ov3640_write_reg(0x82EF,0x03);
+	ov3640_write_reg(0x82F0,0x74);
+	ov3640_write_reg(0x82F1,0x75);
+	ov3640_write_reg(0x82F2,0x40);
+	ov3640_write_reg(0x82F3,0x4E);
+	ov3640_write_reg(0x82F4,0x80);
+	ov3640_write_reg(0x82F5,0x4D);
+	ov3640_write_reg(0x82F6,0xE5);
+	ov3640_write_reg(0x82F7,0x40);
+	ov3640_write_reg(0x82F8,0xB4);
+	ov3640_write_reg(0x82F9,0x46);
+	ov3640_write_reg(0x82FA,0x09);
+	ov3640_write_reg(0x82FB,0x75);
+	ov3640_write_reg(0x82FC,0x40);
+	ov3640_write_reg(0x82FD,0x47);
+	ov3640_write_reg(0x82FE,0x85);
+	ov3640_write_reg(0x82FF,0x40);
+	ov3640_write_reg(0x8300,0x0D);
+	ov3640_write_reg(0x8301,0x12);
+	ov3640_write_reg(0x8302,0x0A);
+	ov3640_write_reg(0x8303,0x80);
+	ov3640_write_reg(0x8304,0xE5);
+	ov3640_write_reg(0x8305,0x40);
+	ov3640_write_reg(0x8306,0x64);
+	ov3640_write_reg(0x8307,0x4A);
+	ov3640_write_reg(0x8308,0x70);
+	ov3640_write_reg(0x8309,0x6A);
+	ov3640_write_reg(0x830A,0x75);
+	ov3640_write_reg(0x830B,0x40);
+	ov3640_write_reg(0x830C,0x4B);
+	ov3640_write_reg(0x830D,0x80);
+	ov3640_write_reg(0x830E,0x34);
+	ov3640_write_reg(0x830F,0xE5);
+	ov3640_write_reg(0x8310,0x40);
+	ov3640_write_reg(0x8311,0x64);
+	ov3640_write_reg(0x8312,0x4B);
+	ov3640_write_reg(0x8313,0x70);
+	ov3640_write_reg(0x8314,0x5F);
+	ov3640_write_reg(0x8315,0x85);
+	ov3640_write_reg(0x8316,0x47);
+	ov3640_write_reg(0x8317,0x0D);
+	ov3640_write_reg(0x8318,0x85);
+	ov3640_write_reg(0x8319,0x48);
+	ov3640_write_reg(0x831A,0x0E);
+	ov3640_write_reg(0x831B,0xF5);
+	ov3640_write_reg(0x831C,0x0F);
+	ov3640_write_reg(0x831D,0xF5);
+	ov3640_write_reg(0x831E,0x10);
+	ov3640_write_reg(0x831F,0x12);
+	ov3640_write_reg(0x8320,0x0B);
+	ov3640_write_reg(0x8321,0x41);
+	ov3640_write_reg(0x8322,0xE4);
+	ov3640_write_reg(0x8323,0xF5);
+	ov3640_write_reg(0x8324,0x47);
+	ov3640_write_reg(0x8325,0xF5);
+	ov3640_write_reg(0x8326,0x48);
+	ov3640_write_reg(0x8327,0x75);
+	ov3640_write_reg(0x8328,0x40);
+	ov3640_write_reg(0x8329,0x69);
+	ov3640_write_reg(0x832A,0x80);
+	ov3640_write_reg(0x832B,0x17);
+	ov3640_write_reg(0x832C,0xE4);
+	ov3640_write_reg(0x832D,0xF5);
+	ov3640_write_reg(0x832E,0x40);
+	ov3640_write_reg(0x832F,0xF5);
+	ov3640_write_reg(0x8330,0x4F);
+	ov3640_write_reg(0x8331,0x85);
+	ov3640_write_reg(0x8332,0x47);
+	ov3640_write_reg(0x8333,0x0D);
+	ov3640_write_reg(0x8334,0x85);
+	ov3640_write_reg(0x8335,0x48);
+	ov3640_write_reg(0x8336,0x0E);
+	ov3640_write_reg(0x8337,0xF5);
+	ov3640_write_reg(0x8338,0x0F);
+	ov3640_write_reg(0x8339,0xF5);
+	ov3640_write_reg(0x833A,0x10);
+	ov3640_write_reg(0x833B,0x12);
+	ov3640_write_reg(0x833C,0x0B);
+	ov3640_write_reg(0x833D,0x41);
+	ov3640_write_reg(0x833E,0xE4);
+	ov3640_write_reg(0x833F,0xF5);
+	ov3640_write_reg(0x8340,0x47);
+	ov3640_write_reg(0x8341,0xF5);
+	ov3640_write_reg(0x8342,0x48);
+	ov3640_write_reg(0x8343,0x85);
+	ov3640_write_reg(0x8344,0x40);
+	ov3640_write_reg(0x8345,0x0D);
+	ov3640_write_reg(0x8346,0x12);
+	ov3640_write_reg(0x8347,0x0A);
+	ov3640_write_reg(0x8348,0x80);
+	ov3640_write_reg(0x8349,0x80);
+	ov3640_write_reg(0x834A,0x29);
+	ov3640_write_reg(0x834B,0x12);
+	ov3640_write_reg(0x834C,0x06);
+	ov3640_write_reg(0x834D,0xD6);
+	ov3640_write_reg(0x834E,0x80);
+	ov3640_write_reg(0x834F,0x24);
+	ov3640_write_reg(0x8350,0xE5);
+	ov3640_write_reg(0x8351,0x4F);
+	ov3640_write_reg(0x8352,0x70);
+	ov3640_write_reg(0x8353,0x20);
+	ov3640_write_reg(0x8354,0xE5);
+	ov3640_write_reg(0x8355,0x40);
+	ov3640_write_reg(0x8356,0x70);
+	ov3640_write_reg(0x8357,0x1C);
+	ov3640_write_reg(0x8358,0x85);
+	ov3640_write_reg(0x8359,0x0C);
+	ov3640_write_reg(0x835A,0x0D);
+	ov3640_write_reg(0x835B,0x12);
+	ov3640_write_reg(0x835C,0x05);
+	ov3640_write_reg(0x835D,0x7E);
+	ov3640_write_reg(0x835E,0x80);
+	ov3640_write_reg(0x835F,0x14);
+	ov3640_write_reg(0x8360,0xE5);
+	ov3640_write_reg(0x8361,0x3C);
+	ov3640_write_reg(0x8362,0x90);
+	ov3640_write_reg(0x8363,0x3F);
+	ov3640_write_reg(0x8364,0x02);
+	ov3640_write_reg(0x8365,0xF0);
+	ov3640_write_reg(0x8366,0xA3);
+	ov3640_write_reg(0x8367,0xE5);
+	ov3640_write_reg(0x8368,0x3D);
+	ov3640_write_reg(0x8369,0xF0);
+	ov3640_write_reg(0x836A,0xE5);
+	ov3640_write_reg(0x836B,0x3E);
+	ov3640_write_reg(0x836C,0xA3);
+	ov3640_write_reg(0x836D,0xF0);
+	ov3640_write_reg(0x836E,0x90);
+	ov3640_write_reg(0x836F,0x3F);
+	ov3640_write_reg(0x8370,0x07);
+	ov3640_write_reg(0x8371,0xE5);
+	ov3640_write_reg(0x8372,0x3F);
+	ov3640_write_reg(0x8373,0xF0);
+	ov3640_write_reg(0x8374,0x90);
+	ov3640_write_reg(0x8375,0x3F);
+	ov3640_write_reg(0x8376,0x01);
+	ov3640_write_reg(0x8377,0xE5);
+	ov3640_write_reg(0x8378,0x40);
+	ov3640_write_reg(0x8379,0xF0);
+	ov3640_write_reg(0x837A,0x22);
+	ov3640_write_reg(0x837B,0xE5);
+	ov3640_write_reg(0x837C,0x15);
+	ov3640_write_reg(0x837D,0xD3);
+	ov3640_write_reg(0x837E,0x94);
+	ov3640_write_reg(0x837F,0x04);
+	ov3640_write_reg(0x8380,0x40);
+	ov3640_write_reg(0x8381,0x03);
+	ov3640_write_reg(0x8382,0xE4);
+	ov3640_write_reg(0x8383,0xF5);
+	ov3640_write_reg(0x8384,0x15);
+	ov3640_write_reg(0x8385,0xE5);
+	ov3640_write_reg(0x8386,0x15);
+	ov3640_write_reg(0x8387,0x25);
+	ov3640_write_reg(0x8388,0xE0);
+	ov3640_write_reg(0x8389,0x25);
+	ov3640_write_reg(0x838A,0xE0);
+	ov3640_write_reg(0x838B,0xF5);
+	ov3640_write_reg(0x838C,0x15);
+	ov3640_write_reg(0x838D,0xE5);
+	ov3640_write_reg(0x838E,0x12);
+	ov3640_write_reg(0x838F,0xAE);
+	ov3640_write_reg(0x8390,0x11);
+	ov3640_write_reg(0x8391,0x78);
+	ov3640_write_reg(0x8392,0x05);
+	ov3640_write_reg(0x8393,0xCE);
+	ov3640_write_reg(0x8394,0xC3);
+	ov3640_write_reg(0x8395,0x13);
+	ov3640_write_reg(0x8396,0xCE);
+	ov3640_write_reg(0x8397,0x13);
+	ov3640_write_reg(0x8398,0xD8);
+	ov3640_write_reg(0x8399,0xF9);
+	ov3640_write_reg(0x839A,0xFB);
+	ov3640_write_reg(0x839B,0xAA);
+	ov3640_write_reg(0x839C,0x06);
+	ov3640_write_reg(0x839D,0x25);
+	ov3640_write_reg(0x839E,0xE0);
+	ov3640_write_reg(0x839F,0xFF);
+	ov3640_write_reg(0x83A0,0xEA);
+	ov3640_write_reg(0x83A1,0x33);
+	ov3640_write_reg(0x83A2,0xFE);
+	ov3640_write_reg(0x83A3,0xEF);
+	ov3640_write_reg(0x83A4,0x78);
+	ov3640_write_reg(0x83A5,0x03);
+	ov3640_write_reg(0x83A6,0xCE);
+	ov3640_write_reg(0x83A7,0xC3);
+	ov3640_write_reg(0x83A8,0x13);
+	ov3640_write_reg(0x83A9,0xCE);
+	ov3640_write_reg(0x83AA,0x13);
+	ov3640_write_reg(0x83AB,0xD8);
+	ov3640_write_reg(0x83AC,0xF9);
+	ov3640_write_reg(0x83AD,0xF5);
+	ov3640_write_reg(0x83AE,0x1C);
+	ov3640_write_reg(0x83AF,0xE5);
+	ov3640_write_reg(0x83B0,0x14);
+	ov3640_write_reg(0x83B1,0xAE);
+	ov3640_write_reg(0x83B2,0x13);
+	ov3640_write_reg(0x83B3,0x78);
+	ov3640_write_reg(0x83B4,0x03);
+	ov3640_write_reg(0x83B5,0xCE);
+	ov3640_write_reg(0x83B6,0xC3);
+	ov3640_write_reg(0x83B7,0x13);
+	ov3640_write_reg(0x83B8,0xCE);
+	ov3640_write_reg(0x83B9,0x13);
+	ov3640_write_reg(0x83BA,0xD8);
+	ov3640_write_reg(0x83BB,0xF9);
+	ov3640_write_reg(0x83BC,0x25);
+	ov3640_write_reg(0x83BD,0xE0);
+	ov3640_write_reg(0x83BE,0xFF);
+	ov3640_write_reg(0x83BF,0xEE);
+	ov3640_write_reg(0x83C0,0x33);
+	ov3640_write_reg(0x83C1,0xFE);
+	ov3640_write_reg(0x83C2,0xEF);
+	ov3640_write_reg(0x83C3,0x78);
+	ov3640_write_reg(0x83C4,0x03);
+	ov3640_write_reg(0x83C5,0xCE);
+	ov3640_write_reg(0x83C6,0xC3);
+	ov3640_write_reg(0x83C7,0x13);
+	ov3640_write_reg(0x83C8,0xCE);
+	ov3640_write_reg(0x83C9,0x13);
+	ov3640_write_reg(0x83CA,0xD8);
+	ov3640_write_reg(0x83CB,0xF9);
+	ov3640_write_reg(0x83CC,0xF9);
+	ov3640_write_reg(0x83CD,0x7C);
+	ov3640_write_reg(0x83CE,0x00);
+	ov3640_write_reg(0x83CF,0x7D);
+	ov3640_write_reg(0x83D0,0x06);
+	ov3640_write_reg(0x83D1,0xAF);
+	ov3640_write_reg(0x83D2,0x03);
+	ov3640_write_reg(0x83D3,0xAE);
+	ov3640_write_reg(0x83D4,0x02);
+	ov3640_write_reg(0x83D5,0x12);
+	ov3640_write_reg(0x83D6,0x0C);
+	ov3640_write_reg(0x83D7,0x36);
+	ov3640_write_reg(0x83D8,0xEF);
+	ov3640_write_reg(0x83D9,0x78);
+	ov3640_write_reg(0x83DA,0x03);
+	ov3640_write_reg(0x83DB,0xCE);
+	ov3640_write_reg(0x83DC,0xC3);
+	ov3640_write_reg(0x83DD,0x13);
+	ov3640_write_reg(0x83DE,0xCE);
+	ov3640_write_reg(0x83DF,0x13);
+	ov3640_write_reg(0x83E0,0xD8);
+	ov3640_write_reg(0x83E1,0xF9);
+	ov3640_write_reg(0x83E2,0xFB);
+	ov3640_write_reg(0x83E3,0xE5);
+	ov3640_write_reg(0x83E4,0x14);
+	ov3640_write_reg(0x83E5,0xAE);
+	ov3640_write_reg(0x83E6,0x13);
+	ov3640_write_reg(0x83E7,0x78);
+	ov3640_write_reg(0x83E8,0x03);
+	ov3640_write_reg(0x83E9,0xCE);
+	ov3640_write_reg(0x83EA,0xC3);
+	ov3640_write_reg(0x83EB,0x13);
+	ov3640_write_reg(0x83EC,0xCE);
+	ov3640_write_reg(0x83ED,0x13);
+	ov3640_write_reg(0x83EE,0xD8);
+	ov3640_write_reg(0x83EF,0xF9);
+	ov3640_write_reg(0x83F0,0xFF);
+	ov3640_write_reg(0x83F1,0x7C);
+	ov3640_write_reg(0x83F2,0x00);
+	ov3640_write_reg(0x83F3,0x7D);
+	ov3640_write_reg(0x83F4,0x06);
+	ov3640_write_reg(0x83F5,0x12);
+	ov3640_write_reg(0x83F6,0x0C);
+	ov3640_write_reg(0x83F7,0x36);
+	ov3640_write_reg(0x83F8,0xEF);
+	ov3640_write_reg(0x83F9,0x78);
+	ov3640_write_reg(0x83FA,0x03);
+	ov3640_write_reg(0x83FB,0xCE);
+	ov3640_write_reg(0x83FC,0xC3);
+	ov3640_write_reg(0x83FD,0x13);
+	ov3640_write_reg(0x83FE,0xCE);
+	ov3640_write_reg(0x83FF,0x13);
+	ov3640_write_reg(0x8400,0xD8);
+	ov3640_write_reg(0x8401,0xF9);
+	ov3640_write_reg(0x8402,0xFD);
+	ov3640_write_reg(0x8403,0xE5);
+	ov3640_write_reg(0x8404,0x1C);
+	ov3640_write_reg(0x8405,0x75);
+	ov3640_write_reg(0x8406,0xF0);
+	ov3640_write_reg(0x8407,0x20);
+	ov3640_write_reg(0x8408,0xA4);
+	ov3640_write_reg(0x8409,0x85);
+	ov3640_write_reg(0x840A,0xF0);
+	ov3640_write_reg(0x840B,0x16);
+	ov3640_write_reg(0x840C,0xF5);
+	ov3640_write_reg(0x840D,0x17);
+	ov3640_write_reg(0x840E,0xE9);
+	ov3640_write_reg(0x840F,0x75);
+	ov3640_write_reg(0x8410,0xF0);
+	ov3640_write_reg(0x8411,0x08);
+	ov3640_write_reg(0x8412,0xA4);
+	ov3640_write_reg(0x8413,0x85);
+	ov3640_write_reg(0x8414,0xF0);
+	ov3640_write_reg(0x8415,0x18);
+	ov3640_write_reg(0x8416,0xF5);
+	ov3640_write_reg(0x8417,0x19);
+	ov3640_write_reg(0x8418,0xEB);
+	ov3640_write_reg(0x8419,0x75);
+	ov3640_write_reg(0x841A,0xF0);
+	ov3640_write_reg(0x841B,0x20);
+	ov3640_write_reg(0x841C,0xA4);
+	ov3640_write_reg(0x841D,0x85);
+	ov3640_write_reg(0x841E,0xF0);
+	ov3640_write_reg(0x841F,0x1A);
+	ov3640_write_reg(0x8420,0xF5);
+	ov3640_write_reg(0x8421,0x1B);
+	ov3640_write_reg(0x8422,0xAF);
+	ov3640_write_reg(0x8423,0x05);
+	ov3640_write_reg(0x8424,0xEF);
+	ov3640_write_reg(0x8425,0x75);
+	ov3640_write_reg(0x8426,0xF0);
+	ov3640_write_reg(0x8427,0x08);
+	ov3640_write_reg(0x8428,0xA4);
+	ov3640_write_reg(0x8429,0xFD);
+	ov3640_write_reg(0x842A,0xAC);
+	ov3640_write_reg(0x842B,0xF0);
+	ov3640_write_reg(0x842C,0xE5);
+	ov3640_write_reg(0x842D,0x16);
+	ov3640_write_reg(0x842E,0x54);
+	ov3640_write_reg(0x842F,0x0F);
+	ov3640_write_reg(0x8430,0xFB);
+	ov3640_write_reg(0x8431,0xE5);
+	ov3640_write_reg(0x8432,0x18);
+	ov3640_write_reg(0x8433,0x54);
+	ov3640_write_reg(0x8434,0x07);
+	ov3640_write_reg(0x8435,0xC4);
+	ov3640_write_reg(0x8436,0xF8);
+	ov3640_write_reg(0x8437,0x54);
+	ov3640_write_reg(0x8438,0xF0);
+	ov3640_write_reg(0x8439,0xC8);
+	ov3640_write_reg(0x843A,0xE4);
+	ov3640_write_reg(0x843B,0xC4);
+	ov3640_write_reg(0x843C,0x54);
+	ov3640_write_reg(0x843D,0x0F);
+	ov3640_write_reg(0x843E,0x48);
+	ov3640_write_reg(0x843F,0x2B);
+	ov3640_write_reg(0x8440,0xFB);
+	ov3640_write_reg(0x8441,0xE5);
+	ov3640_write_reg(0x8442,0x1A);
+	ov3640_write_reg(0x8443,0x54);
+	ov3640_write_reg(0x8444,0x0F);
+	ov3640_write_reg(0x8445,0xFA);
+	ov3640_write_reg(0x8446,0xEC);
+	ov3640_write_reg(0x8447,0x54);
+	ov3640_write_reg(0x8448,0x07);
+	ov3640_write_reg(0x8449,0xC4);
+	ov3640_write_reg(0x844A,0xF8);
+	ov3640_write_reg(0x844B,0x54);
+	ov3640_write_reg(0x844C,0xF0);
+	ov3640_write_reg(0x844D,0xC8);
+	ov3640_write_reg(0x844E,0xE4);
+	ov3640_write_reg(0x844F,0xC4);
+	ov3640_write_reg(0x8450,0x54);
+	ov3640_write_reg(0x8451,0x0F);
+	ov3640_write_reg(0x8452,0x48);
+	ov3640_write_reg(0x8453,0x2A);
+	ov3640_write_reg(0x8454,0xFF);
+	ov3640_write_reg(0x8455,0x90);
+	ov3640_write_reg(0x8456,0x33);
+	ov3640_write_reg(0x8457,0x5F);
+	ov3640_write_reg(0x8458,0xE0);
+	ov3640_write_reg(0x8459,0x90);
+	ov3640_write_reg(0x845A,0x39);
+	ov3640_write_reg(0x845B,0x0A);
+	ov3640_write_reg(0x845C,0xB4);
+	ov3640_write_reg(0x845D,0x68);
+	ov3640_write_reg(0x845E,0x11);
+	ov3640_write_reg(0x845F,0x74);
+	ov3640_write_reg(0x8460,0x18);
+	ov3640_write_reg(0x8461,0xF0);
+	ov3640_write_reg(0x8462,0xA3);
+	ov3640_write_reg(0x8463,0x74);
+	ov3640_write_reg(0x8464,0x48);
+	ov3640_write_reg(0x8465,0xF0);
+	ov3640_write_reg(0x8466,0xA3);
+	ov3640_write_reg(0x8467,0x74);
+	ov3640_write_reg(0x8468,0x28);
+	ov3640_write_reg(0x8469,0xF0);
+	ov3640_write_reg(0x846A,0xA3);
+	ov3640_write_reg(0x846B,0x74);
+	ov3640_write_reg(0x846C,0x78);
+	ov3640_write_reg(0x846D,0xF0);
+	ov3640_write_reg(0x846E,0x80);
+	ov3640_write_reg(0x846F,0x0F);
+	ov3640_write_reg(0x8470,0x74);
+	ov3640_write_reg(0x8471,0x0C);
+	ov3640_write_reg(0x8472,0xF0);
+	ov3640_write_reg(0x8473,0xA3);
+	ov3640_write_reg(0x8474,0x74);
+	ov3640_write_reg(0x8475,0x24);
+	ov3640_write_reg(0x8476,0xF0);
+	ov3640_write_reg(0x8477,0xA3);
+	ov3640_write_reg(0x8478,0x74);
+	ov3640_write_reg(0x8479,0x14);
+	ov3640_write_reg(0x847A,0xF0);
+	ov3640_write_reg(0x847B,0xA3);
+	ov3640_write_reg(0x847C,0x74);
+	ov3640_write_reg(0x847D,0x3C);
+	ov3640_write_reg(0x847E,0xF0);
+	ov3640_write_reg(0x847F,0x90);
+	ov3640_write_reg(0x8480,0x33);
+	ov3640_write_reg(0x8481,0xAA);
+	ov3640_write_reg(0x8482,0xEB);
+	ov3640_write_reg(0x8483,0xF0);
+	ov3640_write_reg(0x8484,0xE5);
+	ov3640_write_reg(0x8485,0x17);
+	ov3640_write_reg(0x8486,0xA3);
+	ov3640_write_reg(0x8487,0xF0);
+	ov3640_write_reg(0x8488,0xE5);
+	ov3640_write_reg(0x8489,0x19);
+	ov3640_write_reg(0x848A,0xA3);
+	ov3640_write_reg(0x848B,0xF0);
+	ov3640_write_reg(0x848C,0xA3);
+	ov3640_write_reg(0x848D,0xEF);
+	ov3640_write_reg(0x848E,0xF0);
+	ov3640_write_reg(0x848F,0xE5);
+	ov3640_write_reg(0x8490,0x1B);
+	ov3640_write_reg(0x8491,0xA3);
+	ov3640_write_reg(0x8492,0xF0);
+	ov3640_write_reg(0x8493,0xED);
+	ov3640_write_reg(0x8494,0xA3);
+	ov3640_write_reg(0x8495,0xF0);
+	ov3640_write_reg(0x8496,0x22);
+	ov3640_write_reg(0x8497,0x90);
+	ov3640_write_reg(0x8498,0x3F);
+	ov3640_write_reg(0x8499,0x05);
+	ov3640_write_reg(0x849A,0xE0);
+	ov3640_write_reg(0x849B,0xF5);
+	ov3640_write_reg(0x849C,0x0C);
+	ov3640_write_reg(0x849D,0x54);
+	ov3640_write_reg(0x849E,0x03);
+	ov3640_write_reg(0x849F,0x75);
+	ov3640_write_reg(0x84A0,0x0D);
+	ov3640_write_reg(0x84A1,0x00);
+	ov3640_write_reg(0x84A2,0xF5);
+	ov3640_write_reg(0x84A3,0x0E);
+	ov3640_write_reg(0x84A4,0x75);
+	ov3640_write_reg(0x84A5,0x0E);
+	ov3640_write_reg(0x84A6,0x00);
+	ov3640_write_reg(0x84A7,0xF5);
+	ov3640_write_reg(0x84A8,0x0D);
+	ov3640_write_reg(0x84A9,0xA3);
+	ov3640_write_reg(0x84AA,0xE0);
+	ov3640_write_reg(0x84AB,0x25);
+	ov3640_write_reg(0x84AC,0x0E);
+	ov3640_write_reg(0x84AD,0xF5);
+	ov3640_write_reg(0x84AE,0x0E);
+	ov3640_write_reg(0x84AF,0xE4);
+	ov3640_write_reg(0x84B0,0x35);
+	ov3640_write_reg(0x84B1,0x0D);
+	ov3640_write_reg(0x84B2,0xF5);
+	ov3640_write_reg(0x84B3,0x0D);
+	ov3640_write_reg(0x84B4,0x53);
+	ov3640_write_reg(0x84B5,0x0C);
+	ov3640_write_reg(0x84B6,0xE0);
+	ov3640_write_reg(0x84B7,0xE5);
+	ov3640_write_reg(0x84B8,0x0C);
+	ov3640_write_reg(0x84B9,0x64);
+	ov3640_write_reg(0x84BA,0x20);
+	ov3640_write_reg(0x84BB,0x70);
+	ov3640_write_reg(0x84BC,0x03);
+	ov3640_write_reg(0x84BD,0x02);
+	ov3640_write_reg(0x84BE,0x05);
+	ov3640_write_reg(0x84BF,0x51);
+	ov3640_write_reg(0x84C0,0xE5);
+	ov3640_write_reg(0x84C1,0x0C);
+	ov3640_write_reg(0x84C2,0xB4);
+	ov3640_write_reg(0x84C3,0x80);
+	ov3640_write_reg(0x84C4,0x49);
+	ov3640_write_reg(0x84C5,0xE5);
+	ov3640_write_reg(0x84C6,0x48);
+	ov3640_write_reg(0x84C7,0x25);
+	ov3640_write_reg(0x84C8,0x0E);
+	ov3640_write_reg(0x84C9,0xF5);
+	ov3640_write_reg(0x84CA,0x0E);
+	ov3640_write_reg(0x84CB,0xE5);
+	ov3640_write_reg(0x84CC,0x47);
+	ov3640_write_reg(0x84CD,0x35);
+	ov3640_write_reg(0x84CE,0x0D);
+	ov3640_write_reg(0x84CF,0xF5);
+	ov3640_write_reg(0x84D0,0x0D);
+	ov3640_write_reg(0x84D1,0xD3);
+	ov3640_write_reg(0x84D2,0xE5);
+	ov3640_write_reg(0x84D3,0x0E);
+	ov3640_write_reg(0x84D4,0x95);
+	ov3640_write_reg(0x84D5,0x4E);
+	ov3640_write_reg(0x84D6,0xE5);
+	ov3640_write_reg(0x84D7,0x0D);
+	ov3640_write_reg(0x84D8,0x95);
+	ov3640_write_reg(0x84D9,0x4D);
+	ov3640_write_reg(0x84DA,0x40);
+	ov3640_write_reg(0x84DB,0x06);
+	ov3640_write_reg(0x84DC,0x85);
+	ov3640_write_reg(0x84DD,0x4D);
+	ov3640_write_reg(0x84DE,0x0D);
+	ov3640_write_reg(0x84DF,0x85);
+	ov3640_write_reg(0x84E0,0x4E);
+	ov3640_write_reg(0x84E1,0x0E);
+	ov3640_write_reg(0x84E2,0xE5);
+	ov3640_write_reg(0x84E3,0x48);
+	ov3640_write_reg(0x84E4,0x65);
+	ov3640_write_reg(0x84E5,0x0E);
+	ov3640_write_reg(0x84E6,0x70);
+	ov3640_write_reg(0x84E7,0x04);
+	ov3640_write_reg(0x84E8,0xE5);
+	ov3640_write_reg(0x84E9,0x47);
+	ov3640_write_reg(0x84EA,0x65);
+	ov3640_write_reg(0x84EB,0x0D);
+	ov3640_write_reg(0x84EC,0x60);
+	ov3640_write_reg(0x84ED,0x20);
+	ov3640_write_reg(0x84EE,0xD3);
+	ov3640_write_reg(0x84EF,0xE5);
+	ov3640_write_reg(0x84F0,0x0E);
+	ov3640_write_reg(0x84F1,0x95);
+	ov3640_write_reg(0x84F2,0x4E);
+	ov3640_write_reg(0x84F3,0xE5);
+	ov3640_write_reg(0x84F4,0x0D);
+	ov3640_write_reg(0x84F5,0x95);
+	ov3640_write_reg(0x84F6,0x4D);
+	ov3640_write_reg(0x84F7,0x40);
+	ov3640_write_reg(0x84F8,0x06);
+	ov3640_write_reg(0x84F9,0x85);
+	ov3640_write_reg(0x84FA,0x4D);
+	ov3640_write_reg(0x84FB,0x0D);
+	ov3640_write_reg(0x84FC,0x85);
+	ov3640_write_reg(0x84FD,0x4E);
+	ov3640_write_reg(0x84FE,0x0E);
+	ov3640_write_reg(0x84FF,0x85);
+	ov3640_write_reg(0x8500,0x0D);
+	ov3640_write_reg(0x8501,0x13);
+	ov3640_write_reg(0x8502,0x85);
+	ov3640_write_reg(0x8503,0x0E);
+	ov3640_write_reg(0x8504,0x14);
+	ov3640_write_reg(0x8505,0x12);
+	ov3640_write_reg(0x8506,0x0B);
+	ov3640_write_reg(0x8507,0x86);
+	ov3640_write_reg(0x8508,0x85);
+	ov3640_write_reg(0x8509,0x0D);
+	ov3640_write_reg(0x850A,0x47);
+	ov3640_write_reg(0x850B,0x85);
+	ov3640_write_reg(0x850C,0x0E);
+	ov3640_write_reg(0x850D,0x48);
+	ov3640_write_reg(0x850E,0xE5);
+	ov3640_write_reg(0x850F,0x0C);
+	ov3640_write_reg(0x8510,0x64);
+	ov3640_write_reg(0x8511,0x40);
+	ov3640_write_reg(0x8512,0x70);
+	ov3640_write_reg(0x8513,0x69);
+	ov3640_write_reg(0x8514,0xD3);
+	ov3640_write_reg(0x8515,0xE5);
+	ov3640_write_reg(0x8516,0x48);
+	ov3640_write_reg(0x8517,0x95);
+	ov3640_write_reg(0x8518,0x4A);
+	ov3640_write_reg(0x8519,0xE5);
+	ov3640_write_reg(0x851A,0x47);
+	ov3640_write_reg(0x851B,0x95);
+	ov3640_write_reg(0x851C,0x49);
+	ov3640_write_reg(0x851D,0x40);
+	ov3640_write_reg(0x851E,0x0E);
+	ov3640_write_reg(0x851F,0xE5);
+	ov3640_write_reg(0x8520,0x48);
+	ov3640_write_reg(0x8521,0x95);
+	ov3640_write_reg(0x8522,0x0E);
+	ov3640_write_reg(0x8523,0xF5);
+	ov3640_write_reg(0x8524,0x0E);
+	ov3640_write_reg(0x8525,0xE5);
+	ov3640_write_reg(0x8526,0x47);
+	ov3640_write_reg(0x8527,0x95);
+	ov3640_write_reg(0x8528,0x0D);
+	ov3640_write_reg(0x8529,0xF5);
+	ov3640_write_reg(0x852A,0x0D);
+	ov3640_write_reg(0x852B,0x80);
+	ov3640_write_reg(0x852C,0x05);
+	ov3640_write_reg(0x852D,0xE4);
+	ov3640_write_reg(0x852E,0xF5);
+	ov3640_write_reg(0x852F,0x0D);
+	ov3640_write_reg(0x8530,0xF5);
+	ov3640_write_reg(0x8531,0x0E);
+	ov3640_write_reg(0x8532,0xE5);
+	ov3640_write_reg(0x8533,0x48);
+	ov3640_write_reg(0x8534,0x65);
+	ov3640_write_reg(0x8535,0x0E);
+	ov3640_write_reg(0x8536,0x70);
+	ov3640_write_reg(0x8537,0x04);
+	ov3640_write_reg(0x8538,0xE5);
+	ov3640_write_reg(0x8539,0x47);
+	ov3640_write_reg(0x853A,0x65);
+	ov3640_write_reg(0x853B,0x0D);
+	ov3640_write_reg(0x853C,0x60);
+	ov3640_write_reg(0x853D,0x3F);
+	ov3640_write_reg(0x853E,0xD3);
+	ov3640_write_reg(0x853F,0xE5);
+	ov3640_write_reg(0x8540,0x0E);
+	ov3640_write_reg(0x8541,0x95);
+	ov3640_write_reg(0x8542,0x4E);
+	ov3640_write_reg(0x8543,0xE5);
+	ov3640_write_reg(0x8544,0x0D);
+	ov3640_write_reg(0x8545,0x95);
+	ov3640_write_reg(0x8546,0x4D);
+	ov3640_write_reg(0x8547,0x40);
+	ov3640_write_reg(0x8548,0x25);
+	ov3640_write_reg(0x8549,0x85);
+	ov3640_write_reg(0x854A,0x4D);
+	ov3640_write_reg(0x854B,0x0D);
+	ov3640_write_reg(0x854C,0x85);
+	ov3640_write_reg(0x854D,0x4E);
+	ov3640_write_reg(0x854E,0x0E);
+	ov3640_write_reg(0x854F,0x80);
+	ov3640_write_reg(0x8550,0x1D);
+	ov3640_write_reg(0x8551,0xE5);
+	ov3640_write_reg(0x8552,0x48);
+	ov3640_write_reg(0x8553,0x65);
+	ov3640_write_reg(0x8554,0x0E);
+	ov3640_write_reg(0x8555,0x70);
+	ov3640_write_reg(0x8556,0x04);
+	ov3640_write_reg(0x8557,0xE5);
+	ov3640_write_reg(0x8558,0x47);
+	ov3640_write_reg(0x8559,0x65);
+	ov3640_write_reg(0x855A,0x0D);
+	ov3640_write_reg(0x855B,0x60);
+	ov3640_write_reg(0x855C,0x20);
+	ov3640_write_reg(0x855D,0xD3);
+	ov3640_write_reg(0x855E,0xE5);
+	ov3640_write_reg(0x855F,0x0E);
+	ov3640_write_reg(0x8560,0x95);
+	ov3640_write_reg(0x8561,0x4E);
+	ov3640_write_reg(0x8562,0xE5);
+	ov3640_write_reg(0x8563,0x0D);
+	ov3640_write_reg(0x8564,0x95);
+	ov3640_write_reg(0x8565,0x4D);
+	ov3640_write_reg(0x8566,0x40);
+	ov3640_write_reg(0x8567,0x06);
+	ov3640_write_reg(0x8568,0x85);
+	ov3640_write_reg(0x8569,0x4D);
+	ov3640_write_reg(0x856A,0x0D);
+	ov3640_write_reg(0x856B,0x85);
+	ov3640_write_reg(0x856C,0x4E);
+	ov3640_write_reg(0x856D,0x0E);
+	ov3640_write_reg(0x856E,0x85);
+	ov3640_write_reg(0x856F,0x0D);
+	ov3640_write_reg(0x8570,0x13);
+	ov3640_write_reg(0x8571,0x85);
+	ov3640_write_reg(0x8572,0x0E);
+	ov3640_write_reg(0x8573,0x14);
+	ov3640_write_reg(0x8574,0x12);
+	ov3640_write_reg(0x8575,0x0B);
+	ov3640_write_reg(0x8576,0x86);
+	ov3640_write_reg(0x8577,0x85);
+	ov3640_write_reg(0x8578,0x0D);
+	ov3640_write_reg(0x8579,0x47);
+	ov3640_write_reg(0x857A,0x85);
+	ov3640_write_reg(0x857B,0x0E);
+	ov3640_write_reg(0x857C,0x48);
+	ov3640_write_reg(0x857D,0x22);
+	ov3640_write_reg(0x857E,0xE5);
+	ov3640_write_reg(0x857F,0x0D);
+	ov3640_write_reg(0x8580,0x30);
+	ov3640_write_reg(0x8581,0xE7);
+	ov3640_write_reg(0x8582,0x70);
+	ov3640_write_reg(0x8583,0x54);
+	ov3640_write_reg(0x8584,0x7F);
+	ov3640_write_reg(0x8585,0xF5);
+	ov3640_write_reg(0x8586,0x3B);
+	ov3640_write_reg(0x8587,0x90);
+	ov3640_write_reg(0x8588,0x3F);
+	ov3640_write_reg(0x8589,0x01);
+	ov3640_write_reg(0x858A,0xE0);
+	ov3640_write_reg(0x858B,0xF5);
+	ov3640_write_reg(0x858C,0x4C);
+	ov3640_write_reg(0x858D,0xA3);
+	ov3640_write_reg(0x858E,0xE0);
+	ov3640_write_reg(0x858F,0x75);
+	ov3640_write_reg(0x8590,0x35);
+	ov3640_write_reg(0x8591,0x00);
+	ov3640_write_reg(0x8592,0xF5);
+	ov3640_write_reg(0x8593,0x36);
+	ov3640_write_reg(0x8594,0xA3);
+	ov3640_write_reg(0x8595,0xE0);
+	ov3640_write_reg(0x8596,0x75);
+	ov3640_write_reg(0x8597,0x49);
+	ov3640_write_reg(0x8598,0x00);
+	ov3640_write_reg(0x8599,0xF5);
+	ov3640_write_reg(0x859A,0x4A);
+	ov3640_write_reg(0x859B,0xA3);
+	ov3640_write_reg(0x859C,0xE0);
+	ov3640_write_reg(0x859D,0x75);
+	ov3640_write_reg(0x859E,0x4D);
+	ov3640_write_reg(0x859F,0x00);
+	ov3640_write_reg(0x85A0,0xF5);
+	ov3640_write_reg(0x85A1,0x4E);
+	ov3640_write_reg(0x85A2,0x75);
+	ov3640_write_reg(0x85A3,0x4E);
+	ov3640_write_reg(0x85A4,0x00);
+	ov3640_write_reg(0x85A5,0xF5);
+	ov3640_write_reg(0x85A6,0x4D);
+	ov3640_write_reg(0x85A7,0xA3);
+	ov3640_write_reg(0x85A8,0xE0);
+	ov3640_write_reg(0x85A9,0x25);
+	ov3640_write_reg(0x85AA,0x4E);
+	ov3640_write_reg(0x85AB,0xF5);
+	ov3640_write_reg(0x85AC,0x4E);
+	ov3640_write_reg(0x85AD,0xE4);
+	ov3640_write_reg(0x85AE,0x35);
+	ov3640_write_reg(0x85AF,0x4D);
+	ov3640_write_reg(0x85B0,0xF5);
+	ov3640_write_reg(0x85B1,0x4D);
+	ov3640_write_reg(0x85B2,0xA3);
+	ov3640_write_reg(0x85B3,0xE0);
+	ov3640_write_reg(0x85B4,0x75);
+	ov3640_write_reg(0x85B5,0x41);
+	ov3640_write_reg(0x85B6,0x00);
+	ov3640_write_reg(0x85B7,0xF5);
+	ov3640_write_reg(0x85B8,0x42);
+	ov3640_write_reg(0x85B9,0x75);
+	ov3640_write_reg(0x85BA,0x42);
+	ov3640_write_reg(0x85BB,0x00);
+	ov3640_write_reg(0x85BC,0xF5);
+	ov3640_write_reg(0x85BD,0x41);
+	ov3640_write_reg(0x85BE,0xA3);
+	ov3640_write_reg(0x85BF,0xE0);
+	ov3640_write_reg(0x85C0,0x25);
+	ov3640_write_reg(0x85C1,0x42);
+	ov3640_write_reg(0x85C2,0xF5);
+	ov3640_write_reg(0x85C3,0x42);
+	ov3640_write_reg(0x85C4,0xE4);
+	ov3640_write_reg(0x85C5,0x35);
+	ov3640_write_reg(0x85C6,0x41);
+	ov3640_write_reg(0x85C7,0xF5);
+	ov3640_write_reg(0x85C8,0x41);
+	ov3640_write_reg(0x85C9,0xE5);
+	ov3640_write_reg(0x85CA,0x36);
+	ov3640_write_reg(0x85CB,0x25);
+	ov3640_write_reg(0x85CC,0xE0);
+	ov3640_write_reg(0x85CD,0xF5);
+	ov3640_write_reg(0x85CE,0x36);
+	ov3640_write_reg(0x85CF,0xE5);
+	ov3640_write_reg(0x85D0,0x35);
+	ov3640_write_reg(0x85D1,0x33);
+	ov3640_write_reg(0x85D2,0xF5);
+	ov3640_write_reg(0x85D3,0x35);
+	ov3640_write_reg(0x85D4,0xE5);
+	ov3640_write_reg(0x85D5,0x4A);
+	ov3640_write_reg(0x85D6,0x25);
+	ov3640_write_reg(0x85D7,0xE0);
+	ov3640_write_reg(0x85D8,0xF5);
+	ov3640_write_reg(0x85D9,0x4A);
+	ov3640_write_reg(0x85DA,0xE5);
+	ov3640_write_reg(0x85DB,0x49);
+	ov3640_write_reg(0x85DC,0x33);
+	ov3640_write_reg(0x85DD,0xF5);
+	ov3640_write_reg(0x85DE,0x49);
+	ov3640_write_reg(0x85DF,0x90);
+	ov3640_write_reg(0x85E0,0x3F);
+	ov3640_write_reg(0x85E1,0x00);
+	ov3640_write_reg(0x85E2,0xE4);
+	ov3640_write_reg(0x85E3,0xF0);
+	ov3640_write_reg(0x85E4,0xA3);
+	ov3640_write_reg(0x85E5,0xF0);
+	ov3640_write_reg(0x85E6,0xA3);
+	ov3640_write_reg(0x85E7,0xF0);
+	ov3640_write_reg(0x85E8,0xA3);
+	ov3640_write_reg(0x85E9,0xF0);
+	ov3640_write_reg(0x85EA,0xA3);
+	ov3640_write_reg(0x85EB,0xF0);
+	ov3640_write_reg(0x85EC,0xA3);
+	ov3640_write_reg(0x85ED,0xF0);
+	ov3640_write_reg(0x85EE,0xA3);
+	ov3640_write_reg(0x85EF,0xF0);
+	ov3640_write_reg(0x85F0,0xA3);
+	ov3640_write_reg(0x85F1,0xF0);
+	ov3640_write_reg(0x85F2,0x22);
+	ov3640_write_reg(0x85F3,0x90);
+	ov3640_write_reg(0x85F4,0x3F);
+	ov3640_write_reg(0x85F5,0x02);
+	ov3640_write_reg(0x85F6,0xE0);
+	ov3640_write_reg(0x85F7,0xFF);
+	ov3640_write_reg(0x85F8,0x7E);
+	ov3640_write_reg(0x85F9,0x00);
+	ov3640_write_reg(0x85FA,0x7F);
+	ov3640_write_reg(0x85FB,0x00);
+	ov3640_write_reg(0x85FC,0xFE);
+	ov3640_write_reg(0x85FD,0xA3);
+	ov3640_write_reg(0x85FE,0xE0);
+	ov3640_write_reg(0x85FF,0x2F);
+	ov3640_write_reg(0x8600,0xFF);
+	ov3640_write_reg(0x8601,0xE4);
+	ov3640_write_reg(0x8602,0x3E);
+	ov3640_write_reg(0x8603,0xFE);
+	ov3640_write_reg(0x8604,0xE5);
+	ov3640_write_reg(0x8605,0x0D);
+	ov3640_write_reg(0x8606,0x24);
+	ov3640_write_reg(0x8607,0xEF);
+	ov3640_write_reg(0x8608,0x60);
+	ov3640_write_reg(0x8609,0x13);
+	ov3640_write_reg(0x860A,0x14);
+	ov3640_write_reg(0x860B,0x60);
+	ov3640_write_reg(0x860C,0x13);
+	ov3640_write_reg(0x860D,0x14);
+	ov3640_write_reg(0x860E,0x60);
+	ov3640_write_reg(0x860F,0x15);
+	ov3640_write_reg(0x8610,0x14);
+	ov3640_write_reg(0x8611,0x60);
+	ov3640_write_reg(0x8612,0x17);
+	ov3640_write_reg(0x8613,0x14);
+	ov3640_write_reg(0x8614,0x60);
+	ov3640_write_reg(0x8615,0x19);
+	ov3640_write_reg(0x8616,0x24);
+	ov3640_write_reg(0x8617,0x05);
+	ov3640_write_reg(0x8618,0x70);
+	ov3640_write_reg(0x8619,0x19);
+	ov3640_write_reg(0x861A,0x8F);
+	ov3640_write_reg(0x861B,0x3B);
+	ov3640_write_reg(0x861C,0x22);
+	ov3640_write_reg(0x861D,0x8F);
+	ov3640_write_reg(0x861E,0x4C);
+	ov3640_write_reg(0x861F,0x22);
+	ov3640_write_reg(0x8620,0x8E);
+	ov3640_write_reg(0x8621,0x35);
+	ov3640_write_reg(0x8622,0x8F);
+	ov3640_write_reg(0x8623,0x36);
+	ov3640_write_reg(0x8624,0x22);
+	ov3640_write_reg(0x8625,0x8E);
+	ov3640_write_reg(0x8626,0x49);
+	ov3640_write_reg(0x8627,0x8F);
+	ov3640_write_reg(0x8628,0x4A);
+	ov3640_write_reg(0x8629,0x22);
+	ov3640_write_reg(0x862A,0x8E);
+	ov3640_write_reg(0x862B,0x4D);
+	ov3640_write_reg(0x862C,0x8F);
+	ov3640_write_reg(0x862D,0x4E);
+	ov3640_write_reg(0x862E,0x22);
+	ov3640_write_reg(0x862F,0x8E);
+	ov3640_write_reg(0x8630,0x41);
+	ov3640_write_reg(0x8631,0x8F);
+	ov3640_write_reg(0x8632,0x42);
+	ov3640_write_reg(0x8633,0x22);
+	ov3640_write_reg(0x8634,0xE5);
+	ov3640_write_reg(0x8635,0x12);
+	ov3640_write_reg(0x8636,0x25);
+	ov3640_write_reg(0x8637,0xE0);
+	ov3640_write_reg(0x8638,0xFF);
+	ov3640_write_reg(0x8639,0xE5);
+	ov3640_write_reg(0x863A,0x11);
+	ov3640_write_reg(0x863B,0x33);
+	ov3640_write_reg(0x863C,0xFE);
+	ov3640_write_reg(0x863D,0xEF);
+	ov3640_write_reg(0x863E,0x78);
+	ov3640_write_reg(0x863F,0x03);
+	ov3640_write_reg(0x8640,0xCE);
+	ov3640_write_reg(0x8641,0xC3);
+	ov3640_write_reg(0x8642,0x13);
+	ov3640_write_reg(0x8643,0xCE);
+	ov3640_write_reg(0x8644,0x13);
+	ov3640_write_reg(0x8645,0xD8);
+	ov3640_write_reg(0x8646,0xF9);
+	ov3640_write_reg(0x8647,0xF5);
+	ov3640_write_reg(0x8648,0x16);
+	ov3640_write_reg(0x8649,0x8E);
+	ov3640_write_reg(0x864A,0x15);
+	ov3640_write_reg(0x864B,0xE5);
+	ov3640_write_reg(0x864C,0x14);
+	ov3640_write_reg(0x864D,0x25);
+	ov3640_write_reg(0x864E,0xE0);
+	ov3640_write_reg(0x864F,0xFF);
+	ov3640_write_reg(0x8650,0xE5);
+	ov3640_write_reg(0x8651,0x13);
+	ov3640_write_reg(0x8652,0x33);
+	ov3640_write_reg(0x8653,0xFE);
+	ov3640_write_reg(0x8654,0xEF);
+	ov3640_write_reg(0x8655,0x78);
+	ov3640_write_reg(0x8656,0x03);
+	ov3640_write_reg(0x8657,0xCE);
+	ov3640_write_reg(0x8658,0xC3);
+	ov3640_write_reg(0x8659,0x13);
+	ov3640_write_reg(0x865A,0xCE);
+	ov3640_write_reg(0x865B,0x13);
+	ov3640_write_reg(0x865C,0xD8);
+	ov3640_write_reg(0x865D,0xF9);
+	ov3640_write_reg(0x865E,0xF5);
+	ov3640_write_reg(0x865F,0x18);
+	ov3640_write_reg(0x8660,0x8E);
+	ov3640_write_reg(0x8661,0x17);
+	ov3640_write_reg(0x8662,0xAE);
+	ov3640_write_reg(0x8663,0x11);
+	ov3640_write_reg(0x8664,0xAF);
+	ov3640_write_reg(0x8665,0x12);
+	ov3640_write_reg(0x8666,0x7C);
+	ov3640_write_reg(0x8667,0x00);
+	ov3640_write_reg(0x8668,0x7D);
+	ov3640_write_reg(0x8669,0x06);
+	ov3640_write_reg(0x866A,0x12);
+	ov3640_write_reg(0x866B,0x0C);
+	ov3640_write_reg(0x866C,0x36);
+	ov3640_write_reg(0x866D,0xEF);
+	ov3640_write_reg(0x866E,0x78);
+	ov3640_write_reg(0x866F,0x03);
+	ov3640_write_reg(0x8670,0xCE);
+	ov3640_write_reg(0x8671,0xC3);
+	ov3640_write_reg(0x8672,0x13);
+	ov3640_write_reg(0x8673,0xCE);
+	ov3640_write_reg(0x8674,0x13);
+	ov3640_write_reg(0x8675,0xD8);
+	ov3640_write_reg(0x8676,0xF9);
+	ov3640_write_reg(0x8677,0xF5);
+	ov3640_write_reg(0x8678,0x1A);
+	ov3640_write_reg(0x8679,0x8E);
+	ov3640_write_reg(0x867A,0x19);
+	ov3640_write_reg(0x867B,0xAE);
+	ov3640_write_reg(0x867C,0x13);
+	ov3640_write_reg(0x867D,0xAF);
+	ov3640_write_reg(0x867E,0x14);
+	ov3640_write_reg(0x867F,0x7C);
+	ov3640_write_reg(0x8680,0x00);
+	ov3640_write_reg(0x8681,0x7D);
+	ov3640_write_reg(0x8682,0x06);
+	ov3640_write_reg(0x8683,0x12);
+	ov3640_write_reg(0x8684,0x0C);
+	ov3640_write_reg(0x8685,0x36);
+	ov3640_write_reg(0x8686,0xEF);
+	ov3640_write_reg(0x8687,0x78);
+	ov3640_write_reg(0x8688,0x03);
+	ov3640_write_reg(0x8689,0xCE);
+	ov3640_write_reg(0x868A,0xC3);
+	ov3640_write_reg(0x868B,0x13);
+	ov3640_write_reg(0x868C,0xCE);
+	ov3640_write_reg(0x868D,0x13);
+	ov3640_write_reg(0x868E,0xD8);
+	ov3640_write_reg(0x868F,0xF9);
+	ov3640_write_reg(0x8690,0xFD);
+	ov3640_write_reg(0x8691,0xAC);
+	ov3640_write_reg(0x8692,0x06);
+	ov3640_write_reg(0x8693,0xE5);
+	ov3640_write_reg(0x8694,0x15);
+	ov3640_write_reg(0x8695,0x54);
+	ov3640_write_reg(0x8696,0x0F);
+	ov3640_write_reg(0x8697,0xFB);
+	ov3640_write_reg(0x8698,0xE5);
+	ov3640_write_reg(0x8699,0x17);
+	ov3640_write_reg(0x869A,0x54);
+	ov3640_write_reg(0x869B,0x07);
+	ov3640_write_reg(0x869C,0xC4);
+	ov3640_write_reg(0x869D,0xF8);
+	ov3640_write_reg(0x869E,0x54);
+	ov3640_write_reg(0x869F,0xF0);
+	ov3640_write_reg(0x86A0,0xC8);
+	ov3640_write_reg(0x86A1,0xE4);
+	ov3640_write_reg(0x86A2,0xC4);
+	ov3640_write_reg(0x86A3,0x54);
+	ov3640_write_reg(0x86A4,0x0F);
+	ov3640_write_reg(0x86A5,0x48);
+	ov3640_write_reg(0x86A6,0x2B);
+	ov3640_write_reg(0x86A7,0xFB);
+	ov3640_write_reg(0x86A8,0xE5);
+	ov3640_write_reg(0x86A9,0x19);
+	ov3640_write_reg(0x86AA,0x54);
+	ov3640_write_reg(0x86AB,0x0F);
+	ov3640_write_reg(0x86AC,0xFA);
+	ov3640_write_reg(0x86AD,0xEC);
+	ov3640_write_reg(0x86AE,0x54);
+	ov3640_write_reg(0x86AF,0x07);
+	ov3640_write_reg(0x86B0,0xC4);
+	ov3640_write_reg(0x86B1,0xF8);
+	ov3640_write_reg(0x86B2,0x54);
+	ov3640_write_reg(0x86B3,0xF0);
+	ov3640_write_reg(0x86B4,0xC8);
+	ov3640_write_reg(0x86B5,0xE4);
+	ov3640_write_reg(0x86B6,0xC4);
+	ov3640_write_reg(0x86B7,0x54);
+	ov3640_write_reg(0x86B8,0x0F);
+	ov3640_write_reg(0x86B9,0x48);
+	ov3640_write_reg(0x86BA,0x2A);
+	ov3640_write_reg(0x86BB,0xFF);
+	ov3640_write_reg(0x86BC,0x90);
+	ov3640_write_reg(0x86BD,0x33);
+	ov3640_write_reg(0x86BE,0xAA);
+	ov3640_write_reg(0x86BF,0xEB);
+	ov3640_write_reg(0x86C0,0xF0);
+	ov3640_write_reg(0x86C1,0xE5);
+	ov3640_write_reg(0x86C2,0x16);
+	ov3640_write_reg(0x86C3,0xA3);
+	ov3640_write_reg(0x86C4,0xF0);
+	ov3640_write_reg(0x86C5,0xE5);
+	ov3640_write_reg(0x86C6,0x18);
+	ov3640_write_reg(0x86C7,0xA3);
+	ov3640_write_reg(0x86C8,0xF0);
+	ov3640_write_reg(0x86C9,0xA3);
+	ov3640_write_reg(0x86CA,0xEF);
+	ov3640_write_reg(0x86CB,0xF0);
+	ov3640_write_reg(0x86CC,0xE5);
+	ov3640_write_reg(0x86CD,0x1A);
+	ov3640_write_reg(0x86CE,0xA3);
+	ov3640_write_reg(0x86CF,0xF0);
+	ov3640_write_reg(0x86D0,0xAF);
+	ov3640_write_reg(0x86D1,0x05);
+	ov3640_write_reg(0x86D2,0xEF);
+	ov3640_write_reg(0x86D3,0xA3);
+	ov3640_write_reg(0x86D4,0xF0);
+	ov3640_write_reg(0x86D5,0x22);
+	ov3640_write_reg(0x86D6,0x90);
+	ov3640_write_reg(0x86D7,0x33);
+	ov3640_write_reg(0x86D8,0x62);
+	ov3640_write_reg(0x86D9,0xE0);
+	ov3640_write_reg(0x86DA,0x54);
+	ov3640_write_reg(0x86DB,0x0F);
+	ov3640_write_reg(0x86DC,0xFE);
+	ov3640_write_reg(0x86DD,0xA3);
+	ov3640_write_reg(0x86DE,0xE0);
+	ov3640_write_reg(0x86DF,0x7C);
+	ov3640_write_reg(0x86E0,0x00);
+	ov3640_write_reg(0x86E1,0x24);
+	ov3640_write_reg(0x86E2,0x00);
+	ov3640_write_reg(0x86E3,0xF5);
+	ov3640_write_reg(0x86E4,0x0E);
+	ov3640_write_reg(0x86E5,0xEC);
+	ov3640_write_reg(0x86E6,0x3E);
+	ov3640_write_reg(0x86E7,0xF5);
+	ov3640_write_reg(0x86E8,0x0D);
+	ov3640_write_reg(0x86E9,0x90);
+	ov3640_write_reg(0x86EA,0x33);
+	ov3640_write_reg(0x86EB,0x62);
+	ov3640_write_reg(0x86EC,0xE0);
+	ov3640_write_reg(0x86ED,0x54);
+	ov3640_write_reg(0x86EE,0x70);
+	ov3640_write_reg(0x86EF,0x75);
+	ov3640_write_reg(0x86F0,0xF0);
+	ov3640_write_reg(0x86F1,0x10);
+	ov3640_write_reg(0x86F2,0xA4);
+	ov3640_write_reg(0x86F3,0xFF);
+	ov3640_write_reg(0x86F4,0xAE);
+	ov3640_write_reg(0x86F5,0xF0);
+	ov3640_write_reg(0x86F6,0x90);
+	ov3640_write_reg(0x86F7,0x33);
+	ov3640_write_reg(0x86F8,0x64);
+	ov3640_write_reg(0x86F9,0xE0);
+	ov3640_write_reg(0x86FA,0x2F);
+	ov3640_write_reg(0x86FB,0xF5);
+	ov3640_write_reg(0x86FC,0x10);
+	ov3640_write_reg(0x86FD,0xEC);
+	ov3640_write_reg(0x86FE,0x3E);
+	ov3640_write_reg(0x86FF,0xF5);
+	ov3640_write_reg(0x8700,0x0F);
+	ov3640_write_reg(0x8701,0x85);
+	ov3640_write_reg(0x8702,0x0D);
+	ov3640_write_reg(0x8703,0x51);
+	ov3640_write_reg(0x8704,0x85);
+	ov3640_write_reg(0x8705,0x0E);
+	ov3640_write_reg(0x8706,0x52);
+	ov3640_write_reg(0x8707,0xF5);
+	ov3640_write_reg(0x8708,0x53);
+	ov3640_write_reg(0x8709,0x85);
+	ov3640_write_reg(0x870A,0x10);
+	ov3640_write_reg(0x870B,0x54);
+	ov3640_write_reg(0x870C,0x85);
+	ov3640_write_reg(0x870D,0x0D);
+	ov3640_write_reg(0x870E,0x11);
+	ov3640_write_reg(0x870F,0x85);
+	ov3640_write_reg(0x8710,0x0E);
+	ov3640_write_reg(0x8711,0x12);
+	ov3640_write_reg(0x8712,0xF5);
+	ov3640_write_reg(0x8713,0x13);
+	ov3640_write_reg(0x8714,0x85);
+	ov3640_write_reg(0x8715,0x10);
+	ov3640_write_reg(0x8716,0x14);
+	ov3640_write_reg(0x8717,0xE4);
+	ov3640_write_reg(0x8718,0xF5);
+	ov3640_write_reg(0x8719,0x15);
+	ov3640_write_reg(0x871A,0x12);
+	ov3640_write_reg(0x871B,0x03);
+	ov3640_write_reg(0x871C,0x7B);
+	ov3640_write_reg(0x871D,0x90);
+	ov3640_write_reg(0x871E,0x33);
+	ov3640_write_reg(0x871F,0x65);
+	ov3640_write_reg(0x8720,0xE0);
+	ov3640_write_reg(0x8721,0x30);
+	ov3640_write_reg(0x8722,0xE3);
+	ov3640_write_reg(0x8723,0x35);
+	ov3640_write_reg(0x8724,0x90);
+	ov3640_write_reg(0x8725,0x33);
+	ov3640_write_reg(0x8726,0xA4);
+	ov3640_write_reg(0x8727,0xE0);
+	ov3640_write_reg(0x8728,0x54);
+	ov3640_write_reg(0x8729,0x0F);
+	ov3640_write_reg(0x872A,0xFC);
+	ov3640_write_reg(0x872B,0xA3);
+	ov3640_write_reg(0x872C,0xE0);
+	ov3640_write_reg(0x872D,0x75);
+	ov3640_write_reg(0x872E,0xF0);
+	ov3640_write_reg(0x872F,0x04);
+	ov3640_write_reg(0x8730,0xA4);
+	ov3640_write_reg(0x8731,0xAE);
+	ov3640_write_reg(0x8732,0xF0);
+	ov3640_write_reg(0x8733,0x24);
+	ov3640_write_reg(0x8734,0x00);
+	ov3640_write_reg(0x8735,0xF5);
+	ov3640_write_reg(0x8736,0x0E);
+	ov3640_write_reg(0x8737,0xEE);
+	ov3640_write_reg(0x8738,0x3C);
+	ov3640_write_reg(0x8739,0xF5);
+	ov3640_write_reg(0x873A,0x0D);
+	ov3640_write_reg(0x873B,0x90);
+	ov3640_write_reg(0x873C,0x33);
+	ov3640_write_reg(0x873D,0xA4);
+	ov3640_write_reg(0x873E,0xE0);
+	ov3640_write_reg(0x873F,0x54);
+	ov3640_write_reg(0x8740,0x70);
+	ov3640_write_reg(0x8741,0x75);
+	ov3640_write_reg(0x8742,0xF0);
+	ov3640_write_reg(0x8743,0x10);
+	ov3640_write_reg(0x8744,0xA4);
+	ov3640_write_reg(0x8745,0xFD);
+	ov3640_write_reg(0x8746,0xAC);
+	ov3640_write_reg(0x8747,0xF0);
+	ov3640_write_reg(0x8748,0x90);
+	ov3640_write_reg(0x8749,0x33);
+	ov3640_write_reg(0x874A,0xA6);
+	ov3640_write_reg(0x874B,0xE0);
+	ov3640_write_reg(0x874C,0x75);
+	ov3640_write_reg(0x874D,0xF0);
+	ov3640_write_reg(0x874E,0x04);
+	ov3640_write_reg(0x874F,0xA4);
+	ov3640_write_reg(0x8750,0xAE);
+	ov3640_write_reg(0x8751,0xF0);
+	ov3640_write_reg(0x8752,0x2D);
+	ov3640_write_reg(0x8753,0xF5);
+	ov3640_write_reg(0x8754,0x10);
+	ov3640_write_reg(0x8755,0xEE);
+	ov3640_write_reg(0x8756,0x3C);
+	ov3640_write_reg(0x8757,0xF5);
+	ov3640_write_reg(0x8758,0x0F);
+	ov3640_write_reg(0x8759,0x85);
+	ov3640_write_reg(0x875A,0x0D);
+	ov3640_write_reg(0x875B,0x55);
+	ov3640_write_reg(0x875C,0x85);
+	ov3640_write_reg(0x875D,0x0E);
+	ov3640_write_reg(0x875E,0x56);
+	ov3640_write_reg(0x875F,0x85);
+	ov3640_write_reg(0x8760,0x0F);
+	ov3640_write_reg(0x8761,0x57);
+	ov3640_write_reg(0x8762,0x85);
+	ov3640_write_reg(0x8763,0x10);
+	ov3640_write_reg(0x8764,0x58);
+	ov3640_write_reg(0x8765,0x85);
+	ov3640_write_reg(0x8766,0x0D);
+	ov3640_write_reg(0x8767,0x11);
+	ov3640_write_reg(0x8768,0x85);
+	ov3640_write_reg(0x8769,0x0E);
+	ov3640_write_reg(0x876A,0x12);
+	ov3640_write_reg(0x876B,0x85);
+	ov3640_write_reg(0x876C,0x0F);
+	ov3640_write_reg(0x876D,0x13);
+	ov3640_write_reg(0x876E,0x85);
+	ov3640_write_reg(0x876F,0x10);
+	ov3640_write_reg(0x8770,0x14);
+	ov3640_write_reg(0x8771,0x02);
+	ov3640_write_reg(0x8772,0x06);
+	ov3640_write_reg(0x8773,0x34);
+	ov3640_write_reg(0x8774,0x78);
+	ov3640_write_reg(0x8775,0x7F);
+	ov3640_write_reg(0x8776,0xE4);
+	ov3640_write_reg(0x8777,0xF6);
+	ov3640_write_reg(0x8778,0xD8);
+	ov3640_write_reg(0x8779,0xFD);
+	ov3640_write_reg(0x877A,0x75);
+	ov3640_write_reg(0x877B,0x81);
+	ov3640_write_reg(0x877C,0x58);
+	ov3640_write_reg(0x877D,0x02);
+	ov3640_write_reg(0x877E,0x07);
+	ov3640_write_reg(0x877F,0xBB);
+	ov3640_write_reg(0x8780,0x02);
+	ov3640_write_reg(0x8781,0x0B);
+	ov3640_write_reg(0x8782,0xFE);
+	ov3640_write_reg(0x8783,0xE4);
+	ov3640_write_reg(0x8784,0x93);
+	ov3640_write_reg(0x8785,0xA3);
+	ov3640_write_reg(0x8786,0xF8);
+	ov3640_write_reg(0x8787,0xE4);
+	ov3640_write_reg(0x8788,0x93);
+	ov3640_write_reg(0x8789,0xA3);
+	ov3640_write_reg(0x878A,0x40);
+	ov3640_write_reg(0x878B,0x03);
+	ov3640_write_reg(0x878C,0xF6);
+	ov3640_write_reg(0x878D,0x80);
+	ov3640_write_reg(0x878E,0x01);
+	ov3640_write_reg(0x878F,0xF2);
+	ov3640_write_reg(0x8790,0x08);
+	ov3640_write_reg(0x8791,0xDF);
+	ov3640_write_reg(0x8792,0xF4);
+	ov3640_write_reg(0x8793,0x80);
+	ov3640_write_reg(0x8794,0x29);
+	ov3640_write_reg(0x8795,0xE4);
+	ov3640_write_reg(0x8796,0x93);
+	ov3640_write_reg(0x8797,0xA3);
+	ov3640_write_reg(0x8798,0xF8);
+	ov3640_write_reg(0x8799,0x54);
+	ov3640_write_reg(0x879A,0x07);
+	ov3640_write_reg(0x879B,0x24);
+	ov3640_write_reg(0x879C,0x0C);
+	ov3640_write_reg(0x879D,0xC8);
+	ov3640_write_reg(0x879E,0xC3);
+	ov3640_write_reg(0x879F,0x33);
+	ov3640_write_reg(0x87A0,0xC4);
+	ov3640_write_reg(0x87A1,0x54);
+	ov3640_write_reg(0x87A2,0x0F);
+	ov3640_write_reg(0x87A3,0x44);
+	ov3640_write_reg(0x87A4,0x20);
+	ov3640_write_reg(0x87A5,0xC8);
+	ov3640_write_reg(0x87A6,0x83);
+	ov3640_write_reg(0x87A7,0x40);
+	ov3640_write_reg(0x87A8,0x04);
+	ov3640_write_reg(0x87A9,0xF4);
+	ov3640_write_reg(0x87AA,0x56);
+	ov3640_write_reg(0x87AB,0x80);
+	ov3640_write_reg(0x87AC,0x01);
+	ov3640_write_reg(0x87AD,0x46);
+	ov3640_write_reg(0x87AE,0xF6);
+	ov3640_write_reg(0x87AF,0xDF);
+	ov3640_write_reg(0x87B0,0xE4);
+	ov3640_write_reg(0x87B1,0x80);
+	ov3640_write_reg(0x87B2,0x0B);
+	ov3640_write_reg(0x87B3,0x01);
+	ov3640_write_reg(0x87B4,0x02);
+	ov3640_write_reg(0x87B5,0x04);
+	ov3640_write_reg(0x87B6,0x08);
+	ov3640_write_reg(0x87B7,0x10);
+	ov3640_write_reg(0x87B8,0x20);
+	ov3640_write_reg(0x87B9,0x40);
+	ov3640_write_reg(0x87BA,0x80);
+	ov3640_write_reg(0x87BB,0x90);
+	ov3640_write_reg(0x87BC,0x0D);
+	ov3640_write_reg(0x87BD,0x39);
+	ov3640_write_reg(0x87BE,0xE4);
+	ov3640_write_reg(0x87BF,0x7E);
+	ov3640_write_reg(0x87C0,0x01);
+	ov3640_write_reg(0x87C1,0x93);
+	ov3640_write_reg(0x87C2,0x60);
+	ov3640_write_reg(0x87C3,0xBC);
+	ov3640_write_reg(0x87C4,0xA3);
+	ov3640_write_reg(0x87C5,0xFF);
+	ov3640_write_reg(0x87C6,0x54);
+	ov3640_write_reg(0x87C7,0x3F);
+	ov3640_write_reg(0x87C8,0x30);
+	ov3640_write_reg(0x87C9,0xE5);
+	ov3640_write_reg(0x87CA,0x09);
+	ov3640_write_reg(0x87CB,0x54);
+	ov3640_write_reg(0x87CC,0x1F);
+	ov3640_write_reg(0x87CD,0xFE);
+	ov3640_write_reg(0x87CE,0xE4);
+	ov3640_write_reg(0x87CF,0x93);
+	ov3640_write_reg(0x87D0,0xA3);
+	ov3640_write_reg(0x87D1,0x60);
+	ov3640_write_reg(0x87D2,0x01);
+	ov3640_write_reg(0x87D3,0x0E);
+	ov3640_write_reg(0x87D4,0xCF);
+	ov3640_write_reg(0x87D5,0x54);
+	ov3640_write_reg(0x87D6,0xC0);
+	ov3640_write_reg(0x87D7,0x25);
+	ov3640_write_reg(0x87D8,0xE0);
+	ov3640_write_reg(0x87D9,0x60);
+	ov3640_write_reg(0x87DA,0xA8);
+	ov3640_write_reg(0x87DB,0x40);
+	ov3640_write_reg(0x87DC,0xB8);
+	ov3640_write_reg(0x87DD,0xE4);
+	ov3640_write_reg(0x87DE,0x93);
+	ov3640_write_reg(0x87DF,0xA3);
+	ov3640_write_reg(0x87E0,0xFA);
+	ov3640_write_reg(0x87E1,0xE4);
+	ov3640_write_reg(0x87E2,0x93);
+	ov3640_write_reg(0x87E3,0xA3);
+	ov3640_write_reg(0x87E4,0xF8);
+	ov3640_write_reg(0x87E5,0xE4);
+	ov3640_write_reg(0x87E6,0x93);
+	ov3640_write_reg(0x87E7,0xA3);
+	ov3640_write_reg(0x87E8,0xC8);
+	ov3640_write_reg(0x87E9,0xC5);
+	ov3640_write_reg(0x87EA,0x82);
+	ov3640_write_reg(0x87EB,0xC8);
+	ov3640_write_reg(0x87EC,0xCA);
+	ov3640_write_reg(0x87ED,0xC5);
+	ov3640_write_reg(0x87EE,0x83);
+	ov3640_write_reg(0x87EF,0xCA);
+	ov3640_write_reg(0x87F0,0xF0);
+	ov3640_write_reg(0x87F1,0xA3);
+	ov3640_write_reg(0x87F2,0xC8);
+	ov3640_write_reg(0x87F3,0xC5);
+	ov3640_write_reg(0x87F4,0x82);
+	ov3640_write_reg(0x87F5,0xC8);
+	ov3640_write_reg(0x87F6,0xCA);
+	ov3640_write_reg(0x87F7,0xC5);
+	ov3640_write_reg(0x87F8,0x83);
+	ov3640_write_reg(0x87F9,0xCA);
+	ov3640_write_reg(0x87FA,0xDF);
+	ov3640_write_reg(0x87FB,0xE9);
+	ov3640_write_reg(0x87FC,0xDE);
+	ov3640_write_reg(0x87FD,0xE7);
+	ov3640_write_reg(0x87FE,0x80);
+	ov3640_write_reg(0x87FF,0xBE);
+	ov3640_write_reg(0x8800,0xC0);
+	ov3640_write_reg(0x8801,0xE0);
+	ov3640_write_reg(0x8802,0xC0);
+	ov3640_write_reg(0x8803,0xF0);
+	ov3640_write_reg(0x8804,0xC0);
+	ov3640_write_reg(0x8805,0x83);
+	ov3640_write_reg(0x8806,0xC0);
+	ov3640_write_reg(0x8807,0x82);
+	ov3640_write_reg(0x8808,0xC0);
+	ov3640_write_reg(0x8809,0xD0);
+	ov3640_write_reg(0x880A,0x75);
+	ov3640_write_reg(0x880B,0xD0);
+	ov3640_write_reg(0x880C,0x00);
+	ov3640_write_reg(0x880D,0xC0);
+	ov3640_write_reg(0x880E,0x00);
+	ov3640_write_reg(0x880F,0xC0);
+	ov3640_write_reg(0x8810,0x01);
+	ov3640_write_reg(0x8811,0xC0);
+	ov3640_write_reg(0x8812,0x02);
+	ov3640_write_reg(0x8813,0xC0);
+	ov3640_write_reg(0x8814,0x03);
+	ov3640_write_reg(0x8815,0xC0);
+	ov3640_write_reg(0x8816,0x04);
+	ov3640_write_reg(0x8817,0xC0);
+	ov3640_write_reg(0x8818,0x05);
+	ov3640_write_reg(0x8819,0xC0);
+	ov3640_write_reg(0x881A,0x06);
+	ov3640_write_reg(0x881B,0xC0);
+	ov3640_write_reg(0x881C,0x07);
+	ov3640_write_reg(0x881D,0x90);
+	ov3640_write_reg(0x881E,0x37);
+	ov3640_write_reg(0x881F,0x08);
+	ov3640_write_reg(0x8820,0xE0);
+	ov3640_write_reg(0x8821,0xF5);
+	ov3640_write_reg(0x8822,0x08);
+	ov3640_write_reg(0x8823,0xE5);
+	ov3640_write_reg(0x8824,0x08);
+	ov3640_write_reg(0x8825,0x30);
+	ov3640_write_reg(0x8826,0xE3);
+	ov3640_write_reg(0x8827,0x28);
+	ov3640_write_reg(0x8828,0x85);
+	ov3640_write_reg(0x8829,0x3C);
+	ov3640_write_reg(0x882A,0x37);
+	ov3640_write_reg(0x882B,0x85);
+	ov3640_write_reg(0x882C,0x3D);
+	ov3640_write_reg(0x882D,0x38);
+	ov3640_write_reg(0x882E,0x85);
+	ov3640_write_reg(0x882F,0x3E);
+	ov3640_write_reg(0x8830,0x39);
+	ov3640_write_reg(0x8831,0x85);
+	ov3640_write_reg(0x8832,0x3F);
+	ov3640_write_reg(0x8833,0x3A);
+	ov3640_write_reg(0x8834,0x75);
+	ov3640_write_reg(0x8835,0x09);
+	ov3640_write_reg(0x8836,0x00);
+	ov3640_write_reg(0x8837,0x75);
+	ov3640_write_reg(0x8838,0x0A);
+	ov3640_write_reg(0x8839,0x00);
+	ov3640_write_reg(0x883A,0x12);
+	ov3640_write_reg(0x883B,0x08);
+	ov3640_write_reg(0x883C,0x89);
+	ov3640_write_reg(0x883D,0x8E);
+	ov3640_write_reg(0x883E,0x3C);
+	ov3640_write_reg(0x883F,0x8F);
+	ov3640_write_reg(0x8840,0x3D);
+	ov3640_write_reg(0x8841,0x75);
+	ov3640_write_reg(0x8842,0x09);
+	ov3640_write_reg(0x8843,0x00);
+	ov3640_write_reg(0x8844,0x75);
+	ov3640_write_reg(0x8845,0x0A);
+	ov3640_write_reg(0x8846,0x01);
+	ov3640_write_reg(0x8847,0x12);
+	ov3640_write_reg(0x8848,0x08);
+	ov3640_write_reg(0x8849,0x89);
+	ov3640_write_reg(0x884A,0x8E);
+	ov3640_write_reg(0x884B,0x3E);
+	ov3640_write_reg(0x884C,0x8F);
+	ov3640_write_reg(0x884D,0x3F);
+	ov3640_write_reg(0x884E,0xD2);
+	ov3640_write_reg(0x884F,0x09);
+	ov3640_write_reg(0x8850,0xE5);
+	ov3640_write_reg(0x8851,0x08);
+	ov3640_write_reg(0x8852,0x30);
+	ov3640_write_reg(0x8853,0xE1);
+	ov3640_write_reg(0x8854,0x08);
+	ov3640_write_reg(0x8855,0x90);
+	ov3640_write_reg(0x8856,0x3F);
+	ov3640_write_reg(0x8857,0x00);
+	ov3640_write_reg(0x8858,0xE0);
+	ov3640_write_reg(0x8859,0xF5);
+	ov3640_write_reg(0x885A,0x4B);
+	ov3640_write_reg(0x885B,0xE4);
+	ov3640_write_reg(0x885C,0xF0);
+	ov3640_write_reg(0x885D,0xE5);
+	ov3640_write_reg(0x885E,0x08);
+	ov3640_write_reg(0x885F,0x30);
+	ov3640_write_reg(0x8860,0xE0);
+	ov3640_write_reg(0x8861,0x06);
+	ov3640_write_reg(0x8862,0x90);
+	ov3640_write_reg(0x8863,0x3F);
+	ov3640_write_reg(0x8864,0x01);
+	ov3640_write_reg(0x8865,0xE5);
+	ov3640_write_reg(0x8866,0x40);
+	ov3640_write_reg(0x8867,0xF0);
+	ov3640_write_reg(0x8868,0x90);
+	ov3640_write_reg(0x8869,0x37);
+	ov3640_write_reg(0x886A,0x08);
+	ov3640_write_reg(0x886B,0xE5);
+	ov3640_write_reg(0x886C,0x08);
+	ov3640_write_reg(0x886D,0xF0);
+	ov3640_write_reg(0x886E,0xD0);
+	ov3640_write_reg(0x886F,0x07);
+	ov3640_write_reg(0x8870,0xD0);
+	ov3640_write_reg(0x8871,0x06);
+	ov3640_write_reg(0x8872,0xD0);
+	ov3640_write_reg(0x8873,0x05);
+	ov3640_write_reg(0x8874,0xD0);
+	ov3640_write_reg(0x8875,0x04);
+	ov3640_write_reg(0x8876,0xD0);
+	ov3640_write_reg(0x8877,0x03);
+	ov3640_write_reg(0x8878,0xD0);
+	ov3640_write_reg(0x8879,0x02);
+	ov3640_write_reg(0x887A,0xD0);
+	ov3640_write_reg(0x887B,0x01);
+	ov3640_write_reg(0x887C,0xD0);
+	ov3640_write_reg(0x887D,0x00);
+	ov3640_write_reg(0x887E,0xD0);
+	ov3640_write_reg(0x887F,0xD0);
+	ov3640_write_reg(0x8880,0xD0);
+	ov3640_write_reg(0x8881,0x82);
+	ov3640_write_reg(0x8882,0xD0);
+	ov3640_write_reg(0x8883,0x83);
+	ov3640_write_reg(0x8884,0xD0);
+	ov3640_write_reg(0x8885,0xF0);
+	ov3640_write_reg(0x8886,0xD0);
+	ov3640_write_reg(0x8887,0xE0);
+	ov3640_write_reg(0x8888,0x32);
+	ov3640_write_reg(0x8889,0xE5);
+	ov3640_write_reg(0x888A,0x0A);
+	ov3640_write_reg(0x888B,0x70);
+	ov3640_write_reg(0x888C,0x36);
+	ov3640_write_reg(0x888D,0xE5);
+	ov3640_write_reg(0x888E,0x09);
+	ov3640_write_reg(0x888F,0x75);
+	ov3640_write_reg(0x8890,0xF0);
+	ov3640_write_reg(0x8891,0x08);
+	ov3640_write_reg(0x8892,0xA4);
+	ov3640_write_reg(0x8893,0xFF);
+	ov3640_write_reg(0x8894,0x24);
+	ov3640_write_reg(0x8895,0x80);
+	ov3640_write_reg(0x8896,0x90);
+	ov3640_write_reg(0x8897,0x3A);
+	ov3640_write_reg(0x8898,0x00);
+	ov3640_write_reg(0x8899,0xF0);
+	ov3640_write_reg(0x889A,0x90);
+	ov3640_write_reg(0x889B,0x3A);
+	ov3640_write_reg(0x889C,0x03);
+	ov3640_write_reg(0x889D,0xE0);
+	ov3640_write_reg(0x889E,0xF5);
+	ov3640_write_reg(0x889F,0x0B);
+	ov3640_write_reg(0x88A0,0xEF);
+	ov3640_write_reg(0x88A1,0x24);
+	ov3640_write_reg(0x88A2,0x81);
+	ov3640_write_reg(0x88A3,0x90);
+	ov3640_write_reg(0x88A4,0x3A);
+	ov3640_write_reg(0x88A5,0x00);
+	ov3640_write_reg(0x88A6,0xF0);
+	ov3640_write_reg(0x88A7,0x90);
+	ov3640_write_reg(0x88A8,0x3A);
+	ov3640_write_reg(0x88A9,0x03);
+	ov3640_write_reg(0x88AA,0xE0);
+	ov3640_write_reg(0x88AB,0xFC);
+	ov3640_write_reg(0x88AC,0xE5);
+	ov3640_write_reg(0x88AD,0x09);
+	ov3640_write_reg(0x88AE,0x75);
+	ov3640_write_reg(0x88AF,0xF0);
+	ov3640_write_reg(0x88B0,0x08);
+	ov3640_write_reg(0x88B1,0xA4);
+	ov3640_write_reg(0x88B2,0xFF);
+	ov3640_write_reg(0x88B3,0x24);
+	ov3640_write_reg(0x88B4,0x82);
+	ov3640_write_reg(0x88B5,0x90);
+	ov3640_write_reg(0x88B6,0x3A);
+	ov3640_write_reg(0x88B7,0x00);
+	ov3640_write_reg(0x88B8,0xF0);
+	ov3640_write_reg(0x88B9,0x90);
+	ov3640_write_reg(0x88BA,0x3A);
+	ov3640_write_reg(0x88BB,0x03);
+	ov3640_write_reg(0x88BC,0xE0);
+	ov3640_write_reg(0x88BD,0xFD);
+	ov3640_write_reg(0x88BE,0xEF);
+	ov3640_write_reg(0x88BF,0x24);
+	ov3640_write_reg(0x88C0,0x83);
+	ov3640_write_reg(0x88C1,0x80);
+	ov3640_write_reg(0x88C2,0x3A);
+	ov3640_write_reg(0x88C3,0xE5);
+	ov3640_write_reg(0x88C4,0x0A);
+	ov3640_write_reg(0x88C5,0x64);
+	ov3640_write_reg(0x88C6,0x01);
+	ov3640_write_reg(0x88C7,0x70);
+	ov3640_write_reg(0x88C8,0x3C);
+	ov3640_write_reg(0x88C9,0xE5);
+	ov3640_write_reg(0x88CA,0x09);
+	ov3640_write_reg(0x88CB,0x75);
+	ov3640_write_reg(0x88CC,0xF0);
+	ov3640_write_reg(0x88CD,0x08);
+	ov3640_write_reg(0x88CE,0xA4);
+	ov3640_write_reg(0x88CF,0xFF);
+	ov3640_write_reg(0x88D0,0x24);
+	ov3640_write_reg(0x88D1,0x84);
+	ov3640_write_reg(0x88D2,0x90);
+	ov3640_write_reg(0x88D3,0x3A);
+	ov3640_write_reg(0x88D4,0x00);
+	ov3640_write_reg(0x88D5,0xF0);
+	ov3640_write_reg(0x88D6,0x90);
+	ov3640_write_reg(0x88D7,0x3A);
+	ov3640_write_reg(0x88D8,0x03);
+	ov3640_write_reg(0x88D9,0xE0);
+	ov3640_write_reg(0x88DA,0xF5);
+	ov3640_write_reg(0x88DB,0x0B);
+	ov3640_write_reg(0x88DC,0xEF);
+	ov3640_write_reg(0x88DD,0x24);
+	ov3640_write_reg(0x88DE,0x85);
+	ov3640_write_reg(0x88DF,0x90);
+	ov3640_write_reg(0x88E0,0x3A);
+	ov3640_write_reg(0x88E1,0x00);
+	ov3640_write_reg(0x88E2,0xF0);
+	ov3640_write_reg(0x88E3,0x90);
+	ov3640_write_reg(0x88E4,0x3A);
+	ov3640_write_reg(0x88E5,0x03);
+	ov3640_write_reg(0x88E6,0xE0);
+	ov3640_write_reg(0x88E7,0xFC);
+	ov3640_write_reg(0x88E8,0xE5);
+	ov3640_write_reg(0x88E9,0x09);
+	ov3640_write_reg(0x88EA,0x75);
+	ov3640_write_reg(0x88EB,0xF0);
+	ov3640_write_reg(0x88EC,0x08);
+	ov3640_write_reg(0x88ED,0xA4);
+	ov3640_write_reg(0x88EE,0xFF);
+	ov3640_write_reg(0x88EF,0x24);
+	ov3640_write_reg(0x88F0,0x86);
+	ov3640_write_reg(0x88F1,0x90);
+	ov3640_write_reg(0x88F2,0x3A);
+	ov3640_write_reg(0x88F3,0x00);
+	ov3640_write_reg(0x88F4,0xF0);
+	ov3640_write_reg(0x88F5,0x90);
+	ov3640_write_reg(0x88F6,0x3A);
+	ov3640_write_reg(0x88F7,0x03);
+	ov3640_write_reg(0x88F8,0xE0);
+	ov3640_write_reg(0x88F9,0xFD);
+	ov3640_write_reg(0x88FA,0xEF);
+	ov3640_write_reg(0x88FB,0x24);
+	ov3640_write_reg(0x88FC,0x87);
+	ov3640_write_reg(0x88FD,0x90);
+	ov3640_write_reg(0x88FE,0x3A);
+	ov3640_write_reg(0x88FF,0x00);
+	ov3640_write_reg(0x8900,0xF0);
+	ov3640_write_reg(0x8901,0x90);
+	ov3640_write_reg(0x8902,0x3A);
+	ov3640_write_reg(0x8903,0x03);
+	ov3640_write_reg(0x8904,0xE0);
+	ov3640_write_reg(0x8905,0xED);
+	ov3640_write_reg(0x8906,0xFE);
+	ov3640_write_reg(0x8907,0xEC);
+	ov3640_write_reg(0x8908,0xFB);
+	ov3640_write_reg(0x8909,0xEB);
+	ov3640_write_reg(0x890A,0xFF);
+	ov3640_write_reg(0x890B,0x22);
+	ov3640_write_reg(0x890C,0x85);
+	ov3640_write_reg(0x890D,0x3C);
+	ov3640_write_reg(0x890E,0x33);
+	ov3640_write_reg(0x890F,0x85);
+	ov3640_write_reg(0x8910,0x3D);
+	ov3640_write_reg(0x8911,0x34);
+	ov3640_write_reg(0x8912,0xE5);
+	ov3640_write_reg(0x8913,0x31);
+	ov3640_write_reg(0x8914,0xD3);
+	ov3640_write_reg(0x8915,0x94);
+	ov3640_write_reg(0x8916,0x02);
+	ov3640_write_reg(0x8917,0x40);
+	ov3640_write_reg(0x8918,0x4F);
+	ov3640_write_reg(0x8919,0xE5);
+	ov3640_write_reg(0x891A,0x3D);
+	ov3640_write_reg(0x891B,0x95);
+	ov3640_write_reg(0x891C,0x34);
+	ov3640_write_reg(0x891D,0xFF);
+	ov3640_write_reg(0x891E,0xE5);
+	ov3640_write_reg(0x891F,0x3C);
+	ov3640_write_reg(0x8920,0x95);
+	ov3640_write_reg(0x8921,0x33);
+	ov3640_write_reg(0x8922,0xFE);
+	ov3640_write_reg(0x8923,0x12);
+	ov3640_write_reg(0x8924,0x0D);
+	ov3640_write_reg(0x8925,0x27);
+	ov3640_write_reg(0x8926,0xD3);
+	ov3640_write_reg(0x8927,0xEF);
+	ov3640_write_reg(0x8928,0x94);
+	ov3640_write_reg(0x8929,0x40);
+	ov3640_write_reg(0x892A,0xEE);
+	ov3640_write_reg(0x892B,0x64);
+	ov3640_write_reg(0x892C,0x80);
+	ov3640_write_reg(0x892D,0x94);
+	ov3640_write_reg(0x892E,0x80);
+	ov3640_write_reg(0x892F,0x50);
+	ov3640_write_reg(0x8930,0x05);
+	ov3640_write_reg(0x8931,0x12);
+	ov3640_write_reg(0x8932,0x0D);
+	ov3640_write_reg(0x8933,0x4A);
+	ov3640_write_reg(0x8934,0x50);
+	ov3640_write_reg(0x8935,0x0A);
+	ov3640_write_reg(0x8936,0x85);
+	ov3640_write_reg(0x8937,0x3C);
+	ov3640_write_reg(0x8938,0x33);
+	ov3640_write_reg(0x8939,0x85);
+	ov3640_write_reg(0x893A,0x3D);
+	ov3640_write_reg(0x893B,0x34);
+	ov3640_write_reg(0x893C,0xE4);
+	ov3640_write_reg(0x893D,0xF5);
+	ov3640_write_reg(0x893E,0x32);
+	ov3640_write_reg(0x893F,0x22);
+	ov3640_write_reg(0x8940,0x05);
+	ov3640_write_reg(0x8941,0x32);
+	ov3640_write_reg(0x8942,0xE5);
+	ov3640_write_reg(0x8943,0x32);
+	ov3640_write_reg(0x8944,0xD3);
+	ov3640_write_reg(0x8945,0x94);
+	ov3640_write_reg(0x8946,0x02);
+	ov3640_write_reg(0x8947,0x40);
+	ov3640_write_reg(0x8948,0x43);
+	ov3640_write_reg(0x8949,0xE4);
+	ov3640_write_reg(0x894A,0xF5);
+	ov3640_write_reg(0x894B,0x31);
+	ov3640_write_reg(0x894C,0xF5);
+	ov3640_write_reg(0x894D,0x32);
+	ov3640_write_reg(0x894E,0x75);
+	ov3640_write_reg(0x894F,0x40);
+	ov3640_write_reg(0x8950,0x69);
+	ov3640_write_reg(0x8951,0xF5);
+	ov3640_write_reg(0x8952,0x47);
+	ov3640_write_reg(0x8953,0xF5);
+	ov3640_write_reg(0x8954,0x48);
+	ov3640_write_reg(0x8955,0x85);
+	ov3640_write_reg(0x8956,0x47);
+	ov3640_write_reg(0x8957,0x13);
+	ov3640_write_reg(0x8958,0x85);
+	ov3640_write_reg(0x8959,0x48);
+	ov3640_write_reg(0x895A,0x14);
+	ov3640_write_reg(0x895B,0x12);
+	ov3640_write_reg(0x895C,0x0B);
+	ov3640_write_reg(0x895D,0x86);
+	ov3640_write_reg(0x895E,0x12);
+	ov3640_write_reg(0x895F,0x0A);
+	ov3640_write_reg(0x8960,0x7D);
+	ov3640_write_reg(0x8961,0x90);
+	ov3640_write_reg(0x8962,0x3F);
+	ov3640_write_reg(0x8963,0x01);
+	ov3640_write_reg(0x8964,0xE5);
+	ov3640_write_reg(0x8965,0x40);
+	ov3640_write_reg(0x8966,0xF0);
+	ov3640_write_reg(0x8967,0x22);
+	ov3640_write_reg(0x8968,0xC3);
+	ov3640_write_reg(0x8969,0xE5);
+	ov3640_write_reg(0x896A,0x3D);
+	ov3640_write_reg(0x896B,0x95);
+	ov3640_write_reg(0x896C,0x44);
+	ov3640_write_reg(0x896D,0xFF);
+	ov3640_write_reg(0x896E,0xE5);
+	ov3640_write_reg(0x896F,0x3C);
+	ov3640_write_reg(0x8970,0x95);
+	ov3640_write_reg(0x8971,0x43);
+	ov3640_write_reg(0x8972,0xFE);
+	ov3640_write_reg(0x8973,0x12);
+	ov3640_write_reg(0x8974,0x0D);
+	ov3640_write_reg(0x8975,0x27);
+	ov3640_write_reg(0x8976,0xD3);
+	ov3640_write_reg(0x8977,0xEF);
+	ov3640_write_reg(0x8978,0x94);
+	ov3640_write_reg(0x8979,0x40);
+	ov3640_write_reg(0x897A,0xEE);
+	ov3640_write_reg(0x897B,0x64);
+	ov3640_write_reg(0x897C,0x80);
+	ov3640_write_reg(0x897D,0x94);
+	ov3640_write_reg(0x897E,0x80);
+	ov3640_write_reg(0x897F,0x50);
+	ov3640_write_reg(0x8980,0x05);
+	ov3640_write_reg(0x8981,0x12);
+	ov3640_write_reg(0x8982,0x0D);
+	ov3640_write_reg(0x8983,0x4A);
+	ov3640_write_reg(0x8984,0x50);
+	ov3640_write_reg(0x8985,0x03);
+	ov3640_write_reg(0x8986,0x05);
+	ov3640_write_reg(0x8987,0x31);
+	ov3640_write_reg(0x8988,0x22);
+	ov3640_write_reg(0x8989,0xE4);
+	ov3640_write_reg(0x898A,0xF5);
+	ov3640_write_reg(0x898B,0x31);
+	ov3640_write_reg(0x898C,0x22);
+	ov3640_write_reg(0x898D,0x7E);
+	ov3640_write_reg(0x898E,0x08);
+	ov3640_write_reg(0x898F,0xE5);
+	ov3640_write_reg(0x8990,0x18);
+	ov3640_write_reg(0x8991,0x33);
+	ov3640_write_reg(0x8992,0x92);
+	ov3640_write_reg(0x8993,0x01);
+	ov3640_write_reg(0x8994,0x90);
+	ov3640_write_reg(0x8995,0x30);
+	ov3640_write_reg(0x8996,0xB4);
+	ov3640_write_reg(0x8997,0xE5);
+	ov3640_write_reg(0x8998,0x20);
+	ov3640_write_reg(0x8999,0xF0);
+	ov3640_write_reg(0x899A,0x7F);
+	ov3640_write_reg(0x899B,0x0A);
+	ov3640_write_reg(0x899C,0xAD);
+	ov3640_write_reg(0x899D,0x07);
+	ov3640_write_reg(0x899E,0x1F);
+	ov3640_write_reg(0x899F,0xED);
+	ov3640_write_reg(0x89A0,0x70);
+	ov3640_write_reg(0x89A1,0xFA);
+	ov3640_write_reg(0x89A2,0xE5);
+	ov3640_write_reg(0x89A3,0x18);
+	ov3640_write_reg(0x89A4,0x25);
+	ov3640_write_reg(0x89A5,0xE0);
+	ov3640_write_reg(0x89A6,0xF5);
+	ov3640_write_reg(0x89A7,0x18);
+	ov3640_write_reg(0x89A8,0xD2);
+	ov3640_write_reg(0x89A9,0x00);
+	ov3640_write_reg(0x89AA,0x90);
+	ov3640_write_reg(0x89AB,0x30);
+	ov3640_write_reg(0x89AC,0xB4);
+	ov3640_write_reg(0x89AD,0xE5);
+	ov3640_write_reg(0x89AE,0x20);
+	ov3640_write_reg(0x89AF,0xF0);
+	ov3640_write_reg(0x89B0,0x7F);
+	ov3640_write_reg(0x89B1,0x0A);
+	ov3640_write_reg(0x89B2,0xAD);
+	ov3640_write_reg(0x89B3,0x07);
+	ov3640_write_reg(0x89B4,0x1F);
+	ov3640_write_reg(0x89B5,0xED);
+	ov3640_write_reg(0x89B6,0x70);
+	ov3640_write_reg(0x89B7,0xFA);
+	ov3640_write_reg(0x89B8,0xC2);
+	ov3640_write_reg(0x89B9,0x00);
+	ov3640_write_reg(0x89BA,0x90);
+	ov3640_write_reg(0x89BB,0x30);
+	ov3640_write_reg(0x89BC,0xB4);
+	ov3640_write_reg(0x89BD,0xE5);
+	ov3640_write_reg(0x89BE,0x20);
+	ov3640_write_reg(0x89BF,0xF0);
+	ov3640_write_reg(0x89C0,0xDE);
+	ov3640_write_reg(0x89C1,0xCD);
+	ov3640_write_reg(0x89C2,0x90);
+	ov3640_write_reg(0x89C3,0x30);
+	ov3640_write_reg(0x89C4,0xB1);
+	ov3640_write_reg(0x89C5,0xE0);
+	ov3640_write_reg(0x89C6,0x54);
+	ov3640_write_reg(0x89C7,0x7F);
+	ov3640_write_reg(0x89C8,0xF0);
+	ov3640_write_reg(0x89C9,0x7F);
+	ov3640_write_reg(0x89CA,0x05);
+	ov3640_write_reg(0x89CB,0xAE);
+	ov3640_write_reg(0x89CC,0x07);
+	ov3640_write_reg(0x89CD,0x1F);
+	ov3640_write_reg(0x89CE,0xEE);
+	ov3640_write_reg(0x89CF,0x70);
+	ov3640_write_reg(0x89D0,0xFA);
+	ov3640_write_reg(0x89D1,0xD2);
+	ov3640_write_reg(0x89D2,0x00);
+	ov3640_write_reg(0x89D3,0x90);
+	ov3640_write_reg(0x89D4,0x30);
+	ov3640_write_reg(0x89D5,0xB4);
+	ov3640_write_reg(0x89D6,0xE5);
+	ov3640_write_reg(0x89D7,0x20);
+	ov3640_write_reg(0x89D8,0xF0);
+	ov3640_write_reg(0x89D9,0x7F);
+	ov3640_write_reg(0x89DA,0x05);
+	ov3640_write_reg(0x89DB,0xAE);
+	ov3640_write_reg(0x89DC,0x07);
+	ov3640_write_reg(0x89DD,0x1F);
+	ov3640_write_reg(0x89DE,0xEE);
+	ov3640_write_reg(0x89DF,0x70);
+	ov3640_write_reg(0x89E0,0xFA);
+	ov3640_write_reg(0x89E1,0x90);
+	ov3640_write_reg(0x89E2,0x30);
+	ov3640_write_reg(0x89E3,0xB5);
+	ov3640_write_reg(0x89E4,0xE0);
+	ov3640_write_reg(0x89E5,0x54);
+	ov3640_write_reg(0x89E6,0x02);
+	ov3640_write_reg(0x89E7,0xFE);
+	ov3640_write_reg(0x89E8,0xC2);
+	ov3640_write_reg(0x89E9,0x00);
+	ov3640_write_reg(0x89EA,0x90);
+	ov3640_write_reg(0x89EB,0x30);
+	ov3640_write_reg(0x89EC,0xB4);
+	ov3640_write_reg(0x89ED,0xE5);
+	ov3640_write_reg(0x89EE,0x20);
+	ov3640_write_reg(0x89EF,0xF0);
+	ov3640_write_reg(0x89F0,0x90);
+	ov3640_write_reg(0x89F1,0x30);
+	ov3640_write_reg(0x89F2,0xB1);
+	ov3640_write_reg(0x89F3,0xE0);
+	ov3640_write_reg(0x89F4,0x44);
+	ov3640_write_reg(0x89F5,0x80);
+	ov3640_write_reg(0x89F6,0xF0);
+	ov3640_write_reg(0x89F7,0x7F);
+	ov3640_write_reg(0x89F8,0x05);
+	ov3640_write_reg(0x89F9,0xAD);
+	ov3640_write_reg(0x89FA,0x07);
+	ov3640_write_reg(0x89FB,0x1F);
+	ov3640_write_reg(0x89FC,0xED);
+	ov3640_write_reg(0x89FD,0x70);
+	ov3640_write_reg(0x89FE,0xFA);
+	ov3640_write_reg(0x89FF,0xBE);
+	ov3640_write_reg(0x8A00,0x02);
+	ov3640_write_reg(0x8A01,0x02);
+	ov3640_write_reg(0x8A02,0xC3);
+	ov3640_write_reg(0x8A03,0x22);
+	ov3640_write_reg(0x8A04,0xD3);
+	ov3640_write_reg(0x8A05,0x22);
+	ov3640_write_reg(0x8A06,0xC2);
+	ov3640_write_reg(0x8A07,0x8C);
+	ov3640_write_reg(0x8A08,0x75);
+	ov3640_write_reg(0x8A09,0x89);
+	ov3640_write_reg(0x8A0A,0x03);
+	ov3640_write_reg(0x8A0B,0xE4);
+	ov3640_write_reg(0x8A0C,0xF5);
+	ov3640_write_reg(0x8A0D,0xA8);
+	ov3640_write_reg(0x8A0E,0x90);
+	ov3640_write_reg(0x8A0F,0x31);
+	ov3640_write_reg(0x8A10,0x00);
+	ov3640_write_reg(0x8A11,0xE0);
+	ov3640_write_reg(0x8A12,0x54);
+	ov3640_write_reg(0x8A13,0xFE);
+	ov3640_write_reg(0x8A14,0xF0);
+	ov3640_write_reg(0x8A15,0xE0);
+	ov3640_write_reg(0x8A16,0x54);
+	ov3640_write_reg(0x8A17,0xFD);
+	ov3640_write_reg(0x8A18,0xF0);
+	ov3640_write_reg(0x8A19,0xA3);
+	ov3640_write_reg(0x8A1A,0xE4);
+	ov3640_write_reg(0x8A1B,0xF0);
+	ov3640_write_reg(0x8A1C,0x90);
+	ov3640_write_reg(0x8A1D,0x33);
+	ov3640_write_reg(0x8A1E,0xB0);
+	ov3640_write_reg(0x8A1F,0xF0);
+	ov3640_write_reg(0x8A20,0xA3);
+	ov3640_write_reg(0x8A21,0x04);
+	ov3640_write_reg(0x8A22,0xF0);
+	ov3640_write_reg(0x8A23,0xA3);
+	ov3640_write_reg(0x8A24,0xF0);
+	ov3640_write_reg(0x8A25,0x90);
+	ov3640_write_reg(0x8A26,0x33);
+	ov3640_write_reg(0x8A27,0x00);
+	ov3640_write_reg(0x8A28,0xE0);
+	ov3640_write_reg(0x8A29,0x44);
+	ov3640_write_reg(0x8A2A,0x02);
+	ov3640_write_reg(0x8A2B,0xF0);
+	ov3640_write_reg(0x8A2C,0xE0);
+	ov3640_write_reg(0x8A2D,0x54);
+	ov3640_write_reg(0x8A2E,0xBF);
+	ov3640_write_reg(0x8A2F,0xF0);
+	ov3640_write_reg(0x8A30,0xD2);
+	ov3640_write_reg(0x8A31,0x08);
+	ov3640_write_reg(0x8A32,0x12);
+	ov3640_write_reg(0x8A33,0x0C);
+	ov3640_write_reg(0x8A34,0xD6);
+	ov3640_write_reg(0x8A35,0x90);
+	ov3640_write_reg(0x8A36,0x30);
+	ov3640_write_reg(0x8A37,0xB2);
+	ov3640_write_reg(0x8A38,0xE0);
+	ov3640_write_reg(0x8A39,0x44);
+	ov3640_write_reg(0x8A3A,0x10);
+	ov3640_write_reg(0x8A3B,0xF0);
+	ov3640_write_reg(0x8A3C,0x90);
+	ov3640_write_reg(0x8A3D,0x30);
+	ov3640_write_reg(0x8A3E,0xB4);
+	ov3640_write_reg(0x8A3F,0xE0);
+	ov3640_write_reg(0x8A40,0xF5);
+	ov3640_write_reg(0x8A41,0x20);
+	ov3640_write_reg(0x8A42,0x90);
+	ov3640_write_reg(0x8A43,0x39);
+	ov3640_write_reg(0x8A44,0x01);
+	ov3640_write_reg(0x8A45,0x74);
+	ov3640_write_reg(0x8A46,0x35);
+	ov3640_write_reg(0x8A47,0xF0);
+	ov3640_write_reg(0x8A48,0x90);
+	ov3640_write_reg(0x8A49,0x39);
+	ov3640_write_reg(0x8A4A,0x00);
+	ov3640_write_reg(0x8A4B,0x74);
+	ov3640_write_reg(0x8A4C,0x20);
+	ov3640_write_reg(0x8A4D,0xF0);
+	ov3640_write_reg(0x8A4E,0x90);
+	ov3640_write_reg(0x8A4F,0x37);
+	ov3640_write_reg(0x8A50,0x00);
+	ov3640_write_reg(0x8A51,0x74);
+	ov3640_write_reg(0x8A52,0xFF);
+	ov3640_write_reg(0x8A53,0xF0);
+	ov3640_write_reg(0x8A54,0xA3);
+	ov3640_write_reg(0x8A55,0xF0);
+	ov3640_write_reg(0x8A56,0x90);
+	ov3640_write_reg(0x8A57,0x37);
+	ov3640_write_reg(0x8A58,0x00);
+	ov3640_write_reg(0x8A59,0xE0);
+	ov3640_write_reg(0x8A5A,0x54);
+	ov3640_write_reg(0x8A5B,0xF7);
+	ov3640_write_reg(0x8A5C,0xF0);
+	ov3640_write_reg(0x8A5D,0x90);
+	ov3640_write_reg(0x8A5E,0x31);
+	ov3640_write_reg(0x8A5F,0x0F);
+	ov3640_write_reg(0x8A60,0x74);
+	ov3640_write_reg(0x8A61,0x3F);
+	ov3640_write_reg(0x8A62,0xF0);
+	ov3640_write_reg(0x8A63,0xA3);
+	ov3640_write_reg(0x8A64,0xE4);
+	ov3640_write_reg(0x8A65,0xF0);
+	ov3640_write_reg(0x8A66,0xA3);
+	ov3640_write_reg(0x8A67,0x74);
+	ov3640_write_reg(0x8A68,0x3F);
+	ov3640_write_reg(0x8A69,0xF0);
+	ov3640_write_reg(0x8A6A,0xA3);
+	ov3640_write_reg(0x8A6B,0x74);
+	ov3640_write_reg(0x8A6C,0x01);
+	ov3640_write_reg(0x8A6D,0xF0);
+	ov3640_write_reg(0x8A6E,0x90);
+	ov3640_write_reg(0x8A6F,0x37);
+	ov3640_write_reg(0x8A70,0x00);
+	ov3640_write_reg(0x8A71,0xE0);
+	ov3640_write_reg(0x8A72,0x54);
+	ov3640_write_reg(0x8A73,0xFD);
+	ov3640_write_reg(0x8A74,0xF0);
+	ov3640_write_reg(0x8A75,0xE0);
+	ov3640_write_reg(0x8A76,0x54);
+	ov3640_write_reg(0x8A77,0xFE);
+	ov3640_write_reg(0x8A78,0xF0);
+	ov3640_write_reg(0x8A79,0x75);
+	ov3640_write_reg(0x8A7A,0xA8);
+	ov3640_write_reg(0x8A7B,0x01);
+	ov3640_write_reg(0x8A7C,0x22);
+	ov3640_write_reg(0x8A7D,0x85);
+	ov3640_write_reg(0x8A7E,0x40);
+	ov3640_write_reg(0x8A7F,0x0D);
+	ov3640_write_reg(0x8A80,0xE5);
+	ov3640_write_reg(0x8A81,0x0D);
+	ov3640_write_reg(0x8A82,0x12);
+	ov3640_write_reg(0x8A83,0x0C);
+	ov3640_write_reg(0x8A84,0x48);
+	ov3640_write_reg(0x8A85,0x0A);
+	ov3640_write_reg(0x8A86,0xAA);
+	ov3640_write_reg(0x8A87,0x00);
+	ov3640_write_reg(0x8A88,0x0A);
+	ov3640_write_reg(0x8A89,0xAC);
+	ov3640_write_reg(0x8A8A,0x46);
+	ov3640_write_reg(0x8A8B,0x0A);
+	ov3640_write_reg(0x8A8C,0xAA);
+	ov3640_write_reg(0x8A8D,0x47);
+	ov3640_write_reg(0x8A8E,0x0A);
+	ov3640_write_reg(0x8A8F,0xAC);
+	ov3640_write_reg(0x8A90,0x4A);
+	ov3640_write_reg(0x8A91,0x0A);
+	ov3640_write_reg(0x8A92,0xAA);
+	ov3640_write_reg(0x8A93,0x4B);
+	ov3640_write_reg(0x8A94,0x0A);
+	ov3640_write_reg(0x8A95,0xAA);
+	ov3640_write_reg(0x8A96,0x4E);
+	ov3640_write_reg(0x8A97,0x0A);
+	ov3640_write_reg(0x8A98,0xC7);
+	ov3640_write_reg(0x8A99,0x65);
+	ov3640_write_reg(0x8A9A,0x0A);
+	ov3640_write_reg(0x8A9B,0xC7);
+	ov3640_write_reg(0x8A9C,0x69);
+	ov3640_write_reg(0x8A9D,0x0A);
+	ov3640_write_reg(0x8A9E,0xAA);
+	ov3640_write_reg(0x8A9F,0x80);
+	ov3640_write_reg(0x8AA0,0x0A);
+	ov3640_write_reg(0x8AA1,0xB8);
+	ov3640_write_reg(0x8AA2,0xC6);
+	ov3640_write_reg(0x8AA3,0x0A);
+	ov3640_write_reg(0x8AA4,0xB8);
+	ov3640_write_reg(0x8AA5,0xCA);
+	ov3640_write_reg(0x8AA6,0x00);
+	ov3640_write_reg(0x8AA7,0x00);
+	ov3640_write_reg(0x8AA8,0x0A);
+	ov3640_write_reg(0x8AA9,0xAA);
+	ov3640_write_reg(0x8AAA,0x80);
+	ov3640_write_reg(0x8AAB,0x30);
+	ov3640_write_reg(0x8AAC,0x90);
+	ov3640_write_reg(0x8AAD,0x33);
+	ov3640_write_reg(0x8AAE,0xB3);
+	ov3640_write_reg(0x8AAF,0xE4);
+	ov3640_write_reg(0x8AB0,0xF0);
+	ov3640_write_reg(0x8AB1,0xA3);
+	ov3640_write_reg(0x8AB2,0xF0);
+	ov3640_write_reg(0x8AB3,0xA3);
+	ov3640_write_reg(0x8AB4,0xF0);
+	ov3640_write_reg(0x8AB5,0xA3);
+	ov3640_write_reg(0x8AB6,0x80);
+	ov3640_write_reg(0x8AB7,0x1E);
+	ov3640_write_reg(0x8AB8,0x90);
+	ov3640_write_reg(0x8AB9,0x33);
+	ov3640_write_reg(0x8ABA,0xB3);
+	ov3640_write_reg(0x8ABB,0xE4);
+	ov3640_write_reg(0x8ABC,0xF0);
+	ov3640_write_reg(0x8ABD,0xA3);
+	ov3640_write_reg(0x8ABE,0xF0);
+	ov3640_write_reg(0x8ABF,0xA3);
+	ov3640_write_reg(0x8AC0,0x74);
+	ov3640_write_reg(0x8AC1,0xFF);
+	ov3640_write_reg(0x8AC2,0xF0);
+	ov3640_write_reg(0x8AC3,0xA3);
+	ov3640_write_reg(0x8AC4,0xE4);
+	ov3640_write_reg(0x8AC5,0x80);
+	ov3640_write_reg(0x8AC6,0x0F);
+	ov3640_write_reg(0x8AC7,0x90);
+	ov3640_write_reg(0x8AC8,0x33);
+	ov3640_write_reg(0x8AC9,0xB3);
+	ov3640_write_reg(0x8ACA,0x74);
+	ov3640_write_reg(0x8ACB,0xFF);
+	ov3640_write_reg(0x8ACC,0xF0);
+	ov3640_write_reg(0x8ACD,0xA3);
+	ov3640_write_reg(0x8ACE,0x74);
+	ov3640_write_reg(0x8ACF,0x80);
+	ov3640_write_reg(0x8AD0,0xF0);
+	ov3640_write_reg(0x8AD1,0xA3);
+	ov3640_write_reg(0x8AD2,0xF0);
+	ov3640_write_reg(0x8AD3,0xA3);
+	ov3640_write_reg(0x8AD4,0x74);
+	ov3640_write_reg(0x8AD5,0xFF);
+	ov3640_write_reg(0x8AD6,0xF0);
+	ov3640_write_reg(0x8AD7,0x75);
+	ov3640_write_reg(0x8AD8,0x0E);
+	ov3640_write_reg(0x8AD9,0x01);
+	ov3640_write_reg(0x8ADA,0x80);
+	ov3640_write_reg(0x8ADB,0x03);
+	ov3640_write_reg(0x8ADC,0xE4);
+	ov3640_write_reg(0x8ADD,0xF5);
+	ov3640_write_reg(0x8ADE,0x0E);
+	ov3640_write_reg(0x8ADF,0x12);
+	ov3640_write_reg(0x8AE0,0x0D);
+	ov3640_write_reg(0x8AE1,0x13);
+	ov3640_write_reg(0x8AE2,0x22);
+	ov3640_write_reg(0x8AE3,0xE4);
+	ov3640_write_reg(0x8AE4,0xF5);
+	ov3640_write_reg(0x8AE5,0x4F);
+	ov3640_write_reg(0x8AE6,0x75);
+	ov3640_write_reg(0x8AE7,0x40);
+	ov3640_write_reg(0x8AE8,0x80);
+	ov3640_write_reg(0x8AE9,0x75);
+	ov3640_write_reg(0x8AEA,0x3B);
+	ov3640_write_reg(0x8AEB,0x32);
+	ov3640_write_reg(0x8AEC,0x75);
+	ov3640_write_reg(0x8AED,0x4C);
+	ov3640_write_reg(0x8AEE,0x1E);
+	ov3640_write_reg(0x8AEF,0xF5);
+	ov3640_write_reg(0x8AF0,0x35);
+	ov3640_write_reg(0x8AF1,0x75);
+	ov3640_write_reg(0x8AF2,0x36);
+	ov3640_write_reg(0x8AF3,0xC8);
+	ov3640_write_reg(0x8AF4,0x75);
+	ov3640_write_reg(0x8AF5,0x49);
+	ov3640_write_reg(0x8AF6,0x01);
+	ov3640_write_reg(0x8AF7,0x75);
+	ov3640_write_reg(0x8AF8,0x4A);
+	ov3640_write_reg(0x8AF9,0x5E);
+	ov3640_write_reg(0x8AFA,0x75);
+	ov3640_write_reg(0x8AFB,0x4D);
+	ov3640_write_reg(0x8AFC,0x03);
+	ov3640_write_reg(0x8AFD,0x75);
+	ov3640_write_reg(0x8AFE,0x4E);
+	ov3640_write_reg(0x8AFF,0x20);
+	ov3640_write_reg(0x8B00,0xF5);
+	ov3640_write_reg(0x8B01,0x41);
+	ov3640_write_reg(0x8B02,0x75);
+	ov3640_write_reg(0x8B03,0x42);
+	ov3640_write_reg(0x8B04,0x28);
+	ov3640_write_reg(0x8B05,0x90);
+	ov3640_write_reg(0x8B06,0x3F);
+	ov3640_write_reg(0x8B07,0x00);
+	ov3640_write_reg(0x8B08,0xE0);
+	ov3640_write_reg(0x8B09,0x30);
+	ov3640_write_reg(0x8B0A,0xE7);
+	ov3640_write_reg(0x8B0B,0x06);
+	ov3640_write_reg(0x8B0C,0xE0);
+	ov3640_write_reg(0x8B0D,0xF5);
+	ov3640_write_reg(0x8B0E,0x0D);
+	ov3640_write_reg(0x8B0F,0x12);
+	ov3640_write_reg(0x8B10,0x05);
+	ov3640_write_reg(0x8B11,0x7E);
+	ov3640_write_reg(0x8B12,0xE4);
+	ov3640_write_reg(0x8B13,0xF5);
+	ov3640_write_reg(0x8B14,0x4B);
+	ov3640_write_reg(0x8B15,0x90);
+	ov3640_write_reg(0x8B16,0x3F);
+	ov3640_write_reg(0x8B17,0x01);
+	ov3640_write_reg(0x8B18,0xE5);
+	ov3640_write_reg(0x8B19,0x40);
+	ov3640_write_reg(0x8B1A,0xF0);
+	ov3640_write_reg(0x8B1B,0xE4);
+	ov3640_write_reg(0x8B1C,0xF5);
+	ov3640_write_reg(0x8B1D,0x47);
+	ov3640_write_reg(0x8B1E,0xF5);
+	ov3640_write_reg(0x8B1F,0x48);
+	ov3640_write_reg(0x8B20,0xF5);
+	ov3640_write_reg(0x8B21,0x4F);
+	ov3640_write_reg(0x8B22,0x85);
+	ov3640_write_reg(0x8B23,0x47);
+	ov3640_write_reg(0x8B24,0x0D);
+	ov3640_write_reg(0x8B25,0x85);
+	ov3640_write_reg(0x8B26,0x48);
+	ov3640_write_reg(0x8B27,0x0E);
+	ov3640_write_reg(0x8B28,0xF5);
+	ov3640_write_reg(0x8B29,0x0F);
+	ov3640_write_reg(0x8B2A,0xF5);
+	ov3640_write_reg(0x8B2B,0x10);
+	ov3640_write_reg(0x8B2C,0x12);
+	ov3640_write_reg(0x8B2D,0x0B);
+	ov3640_write_reg(0x8B2E,0x41);
+	ov3640_write_reg(0x8B2F,0x50);
+	ov3640_write_reg(0x8B30,0x07);
+	ov3640_write_reg(0x8B31,0xE4);
+	ov3640_write_reg(0x8B32,0xF5);
+	ov3640_write_reg(0x8B33,0x40);
+	ov3640_write_reg(0x8B34,0xD2);
+	ov3640_write_reg(0x8B35,0xAF);
+	ov3640_write_reg(0x8B36,0x80);
+	ov3640_write_reg(0x8B37,0x02);
+	ov3640_write_reg(0x8B38,0xC2);
+	ov3640_write_reg(0x8B39,0xAF);
+	ov3640_write_reg(0x8B3A,0x90);
+	ov3640_write_reg(0x8B3B,0x3F);
+	ov3640_write_reg(0x8B3C,0x01);
+	ov3640_write_reg(0x8B3D,0xE5);
+	ov3640_write_reg(0x8B3E,0x40);
+	ov3640_write_reg(0x8B3F,0xF0);
+	ov3640_write_reg(0x8B40,0x22);
+	ov3640_write_reg(0x8B41,0x85);
+	ov3640_write_reg(0x8B42,0x0D);
+	ov3640_write_reg(0x8B43,0x11);
+	ov3640_write_reg(0x8B44,0x85);
+	ov3640_write_reg(0x8B45,0x0E);
+	ov3640_write_reg(0x8B46,0x12);
+	ov3640_write_reg(0x8B47,0xE5);
+	ov3640_write_reg(0x8B48,0x10);
+	ov3640_write_reg(0x8B49,0x24);
+	ov3640_write_reg(0x8B4A,0x32);
+	ov3640_write_reg(0x8B4B,0xFF);
+	ov3640_write_reg(0x8B4C,0xE4);
+	ov3640_write_reg(0x8B4D,0x35);
+	ov3640_write_reg(0x8B4E,0x0F);
+	ov3640_write_reg(0x8B4F,0xFE);
+	ov3640_write_reg(0x8B50,0xD3);
+	ov3640_write_reg(0x8B51,0xE5);
+	ov3640_write_reg(0x8B52,0x12);
+	ov3640_write_reg(0x8B53,0x9F);
+	ov3640_write_reg(0x8B54,0xE5);
+	ov3640_write_reg(0x8B55,0x11);
+	ov3640_write_reg(0x8B56,0x9E);
+	ov3640_write_reg(0x8B57,0x40);
+	ov3640_write_reg(0x8B58,0x1F);
+	ov3640_write_reg(0x8B59,0x74);
+	ov3640_write_reg(0x8B5A,0xE2);
+	ov3640_write_reg(0x8B5B,0x25);
+	ov3640_write_reg(0x8B5C,0x12);
+	ov3640_write_reg(0x8B5D,0xF5);
+	ov3640_write_reg(0x8B5E,0x12);
+	ov3640_write_reg(0x8B5F,0x74);
+	ov3640_write_reg(0x8B60,0xFF);
+	ov3640_write_reg(0x8B61,0x35);
+	ov3640_write_reg(0x8B62,0x11);
+	ov3640_write_reg(0x8B63,0xF5);
+	ov3640_write_reg(0x8B64,0x11);
+	ov3640_write_reg(0x8B65,0xF5);
+	ov3640_write_reg(0x8B66,0x13);
+	ov3640_write_reg(0x8B67,0x85);
+	ov3640_write_reg(0x8B68,0x12);
+	ov3640_write_reg(0x8B69,0x14);
+	ov3640_write_reg(0x8B6A,0x12);
+	ov3640_write_reg(0x8B6B,0x0B);
+	ov3640_write_reg(0x8B6C,0x86);
+	ov3640_write_reg(0x8B6D,0x40);
+	ov3640_write_reg(0x8B6E,0x01);
+	ov3640_write_reg(0x8B6F,0x22);
+	ov3640_write_reg(0x8B70,0x75);
+	ov3640_write_reg(0x8B71,0x13);
+	ov3640_write_reg(0x8B72,0x02);
+	ov3640_write_reg(0x8B73,0x12);
+	ov3640_write_reg(0x8B74,0x0C);
+	ov3640_write_reg(0x8B75,0xF9);
+	ov3640_write_reg(0x8B76,0x80);
+	ov3640_write_reg(0x8B77,0xCF);
+	ov3640_write_reg(0x8B78,0x85);
+	ov3640_write_reg(0x8B79,0x0F);
+	ov3640_write_reg(0x8B7A,0x13);
+	ov3640_write_reg(0x8B7B,0x85);
+	ov3640_write_reg(0x8B7C,0x10);
+	ov3640_write_reg(0x8B7D,0x14);
+	ov3640_write_reg(0x8B7E,0x12);
+	ov3640_write_reg(0x8B7F,0x0B);
+	ov3640_write_reg(0x8B80,0x86);
+	ov3640_write_reg(0x8B81,0x40);
+	ov3640_write_reg(0x8B82,0x01);
+	ov3640_write_reg(0x8B83,0x22);
+	ov3640_write_reg(0x8B84,0xD3);
+	ov3640_write_reg(0x8B85,0x22);
+	ov3640_write_reg(0x8B86,0xE5);
+	ov3640_write_reg(0x8B87,0x13);
+	ov3640_write_reg(0x8B88,0x54);
+	ov3640_write_reg(0x8B89,0x03);
+	ov3640_write_reg(0x8B8A,0xFC);
+	ov3640_write_reg(0x8B8B,0xAD);
+	ov3640_write_reg(0x8B8C,0x14);
+	ov3640_write_reg(0x8B8D,0xED);
+	ov3640_write_reg(0x8B8E,0xC4);
+	ov3640_write_reg(0x8B8F,0xF8);
+	ov3640_write_reg(0x8B90,0x54);
+	ov3640_write_reg(0x8B91,0x0F);
+	ov3640_write_reg(0x8B92,0xC8);
+	ov3640_write_reg(0x8B93,0x68);
+	ov3640_write_reg(0x8B94,0xFF);
+	ov3640_write_reg(0x8B95,0xEC);
+	ov3640_write_reg(0x8B96,0xC4);
+	ov3640_write_reg(0x8B97,0x54);
+	ov3640_write_reg(0x8B98,0xF0);
+	ov3640_write_reg(0x8B99,0x48);
+	ov3640_write_reg(0x8B9A,0xAB);
+	ov3640_write_reg(0x8B9B,0x07);
+	ov3640_write_reg(0x8B9C,0xFA);
+	ov3640_write_reg(0x8B9D,0x43);
+	ov3640_write_reg(0x8B9E,0x03);
+	ov3640_write_reg(0x8B9F,0x0D);
+	ov3640_write_reg(0x8BA0,0xEC);
+	ov3640_write_reg(0x8BA1,0x90);
+	ov3640_write_reg(0x8BA2,0x3F);
+	ov3640_write_reg(0x8BA3,0x05);
+	ov3640_write_reg(0x8BA4,0xF0);
+	ov3640_write_reg(0x8BA5,0xA3);
+	ov3640_write_reg(0x8BA6,0xE5);
+	ov3640_write_reg(0x8BA7,0x14);
+	ov3640_write_reg(0x8BA8,0xF0);
+	ov3640_write_reg(0x8BA9,0x45);
+	ov3640_write_reg(0x8BAA,0x13);
+	ov3640_write_reg(0x8BAB,0x70);
+	ov3640_write_reg(0x8BAC,0x03);
+	ov3640_write_reg(0x8BAD,0x7A);
+	ov3640_write_reg(0x8BAE,0x80);
+	ov3640_write_reg(0x8BAF,0xFB);
+	ov3640_write_reg(0x8BB0,0x8A);
+	ov3640_write_reg(0x8BB1,0x15);
+	ov3640_write_reg(0x8BB2,0x8B);
+	ov3640_write_reg(0x8BB3,0x16);
+	ov3640_write_reg(0x8BB4,0x12);
+	ov3640_write_reg(0x8BB5,0x0B);
+	ov3640_write_reg(0x8BB6,0xC5);
+	ov3640_write_reg(0x8BB7,0x40);
+	ov3640_write_reg(0x8BB8,0x01);
+	ov3640_write_reg(0x8BB9,0x22);
+	ov3640_write_reg(0x8BBA,0xE5);
+	ov3640_write_reg(0x8BBB,0x13);
+	ov3640_write_reg(0x8BBC,0x54);
+	ov3640_write_reg(0x8BBD,0x03);
+	ov3640_write_reg(0x8BBE,0xF5);
+	ov3640_write_reg(0x8BBF,0x1D);
+	ov3640_write_reg(0x8BC0,0x85);
+	ov3640_write_reg(0x8BC1,0x14);
+	ov3640_write_reg(0x8BC2,0x1E);
+	ov3640_write_reg(0x8BC3,0xD3);
+	ov3640_write_reg(0x8BC4,0x22);
+	ov3640_write_reg(0x8BC5,0xE4);
+	ov3640_write_reg(0x8BC6,0xF5);
+	ov3640_write_reg(0x8BC7,0x17);
+	ov3640_write_reg(0x8BC8,0x12);
+	ov3640_write_reg(0x8BC9,0x0C);
+	ov3640_write_reg(0x8BCA,0x6E);
+	ov3640_write_reg(0x8BCB,0x75);
+	ov3640_write_reg(0x8BCC,0x18);
+	ov3640_write_reg(0x8BCD,0x18);
+	ov3640_write_reg(0x8BCE,0x12);
+	ov3640_write_reg(0x8BCF,0x09);
+	ov3640_write_reg(0x8BD0,0x8D);
+	ov3640_write_reg(0x8BD1,0x40);
+	ov3640_write_reg(0x8BD2,0x02);
+	ov3640_write_reg(0x8BD3,0x80);
+	ov3640_write_reg(0x8BD4,0x14);
+	ov3640_write_reg(0x8BD5,0xE5);
+	ov3640_write_reg(0x8BD6,0x15);
+	ov3640_write_reg(0x8BD7,0xF5);
+	ov3640_write_reg(0x8BD8,0x18);
+	ov3640_write_reg(0x8BD9,0x12);
+	ov3640_write_reg(0x8BDA,0x09);
+	ov3640_write_reg(0x8BDB,0x8D);
+	ov3640_write_reg(0x8BDC,0x40);
+	ov3640_write_reg(0x8BDD,0x02);
+	ov3640_write_reg(0x8BDE,0x80);
+	ov3640_write_reg(0x8BDF,0x09);
+	ov3640_write_reg(0x8BE0,0xE5);
+	ov3640_write_reg(0x8BE1,0x16);
+	ov3640_write_reg(0x8BE2,0xF5);
+	ov3640_write_reg(0x8BE3,0x18);
+	ov3640_write_reg(0x8BE4,0x12);
+	ov3640_write_reg(0x8BE5,0x09);
+	ov3640_write_reg(0x8BE6,0x8D);
+	ov3640_write_reg(0x8BE7,0x40);
+	ov3640_write_reg(0x8BE8,0x05);
+	ov3640_write_reg(0x8BE9,0x12);
+	ov3640_write_reg(0x8BEA,0x0C);
+	ov3640_write_reg(0x8BEB,0xA3);
+	ov3640_write_reg(0x8BEC,0x80);
+	ov3640_write_reg(0x8BED,0x05);
+	ov3640_write_reg(0x8BEE,0x12);
+	ov3640_write_reg(0x8BEF,0x0C);
+	ov3640_write_reg(0x8BF0,0xA3);
+	ov3640_write_reg(0x8BF1,0xD3);
+	ov3640_write_reg(0x8BF2,0x22);
+	ov3640_write_reg(0x8BF3,0x05);
+	ov3640_write_reg(0x8BF4,0x17);
+	ov3640_write_reg(0x8BF5,0xE5);
+	ov3640_write_reg(0x8BF6,0x17);
+	ov3640_write_reg(0x8BF7,0xC3);
+	ov3640_write_reg(0x8BF8,0x94);
+	ov3640_write_reg(0x8BF9,0x0A);
+	ov3640_write_reg(0x8BFA,0x40);
+	ov3640_write_reg(0x8BFB,0xCC);
+	ov3640_write_reg(0x8BFC,0xC3);
+	ov3640_write_reg(0x8BFD,0x22);
+	ov3640_write_reg(0x8BFE,0x12);
+	ov3640_write_reg(0x8BFF,0x0A);
+	ov3640_write_reg(0x8C00,0x06);
+	ov3640_write_reg(0x8C01,0x12);
+	ov3640_write_reg(0x8C02,0x0A);
+	ov3640_write_reg(0x8C03,0xE3);
+	ov3640_write_reg(0x8C04,0x12);
+	ov3640_write_reg(0x8C05,0x06);
+	ov3640_write_reg(0x8C06,0xD6);
+	ov3640_write_reg(0x8C07,0x12);
+	ov3640_write_reg(0x8C08,0x02);
+	ov3640_write_reg(0x8C09,0x45);
+	ov3640_write_reg(0x8C0A,0x30);
+	ov3640_write_reg(0x8C0B,0x09);
+	ov3640_write_reg(0x8C0C,0xFA);
+	ov3640_write_reg(0x8C0D,0xE5);
+	ov3640_write_reg(0x8C0E,0x40);
+	ov3640_write_reg(0x8C0F,0x54);
+	ov3640_write_reg(0x8C10,0x03);
+	ov3640_write_reg(0x8C11,0xFF);
+	ov3640_write_reg(0x8C12,0xBF);
+	ov3640_write_reg(0x8C13,0x01);
+	ov3640_write_reg(0x8C14,0x05);
+	ov3640_write_reg(0x8C15,0x12);
+	ov3640_write_reg(0x8C16,0x00);
+	ov3640_write_reg(0x8C17,0x06);
+	ov3640_write_reg(0x8C18,0x80);
+	ov3640_write_reg(0x8C19,0x18);
+	ov3640_write_reg(0x8C1A,0xE5);
+	ov3640_write_reg(0x8C1B,0x40);
+	ov3640_write_reg(0x8C1C,0x64);
+	ov3640_write_reg(0x8C1D,0x4A);
+	ov3640_write_reg(0x8C1E,0x60);
+	ov3640_write_reg(0x8C1F,0x05);
+	ov3640_write_reg(0x8C20,0xE5);
+	ov3640_write_reg(0x8C21,0x40);
+	ov3640_write_reg(0x8C22,0xB4);
+	ov3640_write_reg(0x8C23,0xCA);
+	ov3640_write_reg(0x8C24,0x05);
+	ov3640_write_reg(0x8C25,0x12);
+	ov3640_write_reg(0x8C26,0x09);
+	ov3640_write_reg(0x8C27,0x0C);
+	ov3640_write_reg(0x8C28,0x80);
+	ov3640_write_reg(0x8C29,0x08);
+	ov3640_write_reg(0x8C2A,0xE5);
+	ov3640_write_reg(0x8C2B,0x40);
+	ov3640_write_reg(0x8C2C,0xB4);
+	ov3640_write_reg(0x8C2D,0x4E);
+	ov3640_write_reg(0x8C2E,0x03);
+	ov3640_write_reg(0x8C2F,0x12);
+	ov3640_write_reg(0x8C30,0x04);
+	ov3640_write_reg(0x8C31,0x97);
+	ov3640_write_reg(0x8C32,0xC2);
+	ov3640_write_reg(0x8C33,0x09);
+	ov3640_write_reg(0x8C34,0x80);
+	ov3640_write_reg(0x8C35,0xD1);
+	ov3640_write_reg(0x8C36,0xEF);
+	ov3640_write_reg(0x8C37,0x8D);
+	ov3640_write_reg(0x8C38,0xF0);
+	ov3640_write_reg(0x8C39,0xA4);
+	ov3640_write_reg(0x8C3A,0xA8);
+	ov3640_write_reg(0x8C3B,0xF0);
+	ov3640_write_reg(0x8C3C,0xCF);
+	ov3640_write_reg(0x8C3D,0x8C);
+	ov3640_write_reg(0x8C3E,0xF0);
+	ov3640_write_reg(0x8C3F,0xA4);
+	ov3640_write_reg(0x8C40,0x28);
+	ov3640_write_reg(0x8C41,0xCE);
+	ov3640_write_reg(0x8C42,0x8D);
+	ov3640_write_reg(0x8C43,0xF0);
+	ov3640_write_reg(0x8C44,0xA4);
+	ov3640_write_reg(0x8C45,0x2E);
+	ov3640_write_reg(0x8C46,0xFE);
+	ov3640_write_reg(0x8C47,0x22);
+	ov3640_write_reg(0x8C48,0xD0);
+	ov3640_write_reg(0x8C49,0x83);
+	ov3640_write_reg(0x8C4A,0xD0);
+	ov3640_write_reg(0x8C4B,0x82);
+	ov3640_write_reg(0x8C4C,0xF8);
+	ov3640_write_reg(0x8C4D,0xE4);
+	ov3640_write_reg(0x8C4E,0x93);
+	ov3640_write_reg(0x8C4F,0x70);
+	ov3640_write_reg(0x8C50,0x12);
+	ov3640_write_reg(0x8C51,0x74);
+	ov3640_write_reg(0x8C52,0x01);
+	ov3640_write_reg(0x8C53,0x93);
+	ov3640_write_reg(0x8C54,0x70);
+	ov3640_write_reg(0x8C55,0x0D);
+	ov3640_write_reg(0x8C56,0xA3);
+	ov3640_write_reg(0x8C57,0xA3);
+	ov3640_write_reg(0x8C58,0x93);
+	ov3640_write_reg(0x8C59,0xF8);
+	ov3640_write_reg(0x8C5A,0x74);
+	ov3640_write_reg(0x8C5B,0x01);
+	ov3640_write_reg(0x8C5C,0x93);
+	ov3640_write_reg(0x8C5D,0xF5);
+	ov3640_write_reg(0x8C5E,0x82);
+	ov3640_write_reg(0x8C5F,0x88);
+	ov3640_write_reg(0x8C60,0x83);
+	ov3640_write_reg(0x8C61,0xE4);
+	ov3640_write_reg(0x8C62,0x73);
+	ov3640_write_reg(0x8C63,0x74);
+	ov3640_write_reg(0x8C64,0x02);
+	ov3640_write_reg(0x8C65,0x93);
+	ov3640_write_reg(0x8C66,0x68);
+	ov3640_write_reg(0x8C67,0x60);
+	ov3640_write_reg(0x8C68,0xEF);
+	ov3640_write_reg(0x8C69,0xA3);
+	ov3640_write_reg(0x8C6A,0xA3);
+	ov3640_write_reg(0x8C6B,0xA3);
+	ov3640_write_reg(0x8C6C,0x80);
+	ov3640_write_reg(0x8C6D,0xDF);
+	ov3640_write_reg(0x8C6E,0xC2);
+	ov3640_write_reg(0x8C6F,0xAF);
+	ov3640_write_reg(0x8C70,0xD2);
+	ov3640_write_reg(0x8C71,0x01);
+	ov3640_write_reg(0x8C72,0xD2);
+	ov3640_write_reg(0x8C73,0x00);
+	ov3640_write_reg(0x8C74,0x90);
+	ov3640_write_reg(0x8C75,0x30);
+	ov3640_write_reg(0x8C76,0xB4);
+	ov3640_write_reg(0x8C77,0xE5);
+	ov3640_write_reg(0x8C78,0x20);
+	ov3640_write_reg(0x8C79,0xF0);
+	ov3640_write_reg(0x8C7A,0x7F);
+	ov3640_write_reg(0x8C7B,0x0A);
+	ov3640_write_reg(0x8C7C,0xAE);
+	ov3640_write_reg(0x8C7D,0x07);
+	ov3640_write_reg(0x8C7E,0x1F);
+	ov3640_write_reg(0x8C7F,0xEE);
+	ov3640_write_reg(0x8C80,0x70);
+	ov3640_write_reg(0x8C81,0xFA);
+	ov3640_write_reg(0x8C82,0xC2);
+	ov3640_write_reg(0x8C83,0x01);
+	ov3640_write_reg(0x8C84,0x90);
+	ov3640_write_reg(0x8C85,0x30);
+	ov3640_write_reg(0x8C86,0xB4);
+	ov3640_write_reg(0x8C87,0xE5);
+	ov3640_write_reg(0x8C88,0x20);
+	ov3640_write_reg(0x8C89,0xF0);
+	ov3640_write_reg(0x8C8A,0x7F);
+	ov3640_write_reg(0x8C8B,0x05);
+	ov3640_write_reg(0x8C8C,0xAE);
+	ov3640_write_reg(0x8C8D,0x07);
+	ov3640_write_reg(0x8C8E,0x1F);
+	ov3640_write_reg(0x8C8F,0xEE);
+	ov3640_write_reg(0x8C90,0x70);
+	ov3640_write_reg(0x8C91,0xFA);
+	ov3640_write_reg(0x8C92,0xC2);
+	ov3640_write_reg(0x8C93,0x00);
+	ov3640_write_reg(0x8C94,0x90);
+	ov3640_write_reg(0x8C95,0x30);
+	ov3640_write_reg(0x8C96,0xB4);
+	ov3640_write_reg(0x8C97,0xE5);
+	ov3640_write_reg(0x8C98,0x20);
+	ov3640_write_reg(0x8C99,0xF0);
+	ov3640_write_reg(0x8C9A,0x7F);
+	ov3640_write_reg(0x8C9B,0x05);
+	ov3640_write_reg(0x8C9C,0xAE);
+	ov3640_write_reg(0x8C9D,0x07);
+	ov3640_write_reg(0x8C9E,0x1F);
+	ov3640_write_reg(0x8C9F,0xEE);
+	ov3640_write_reg(0x8CA0,0x70);
+	ov3640_write_reg(0x8CA1,0xFA);
+	ov3640_write_reg(0x8CA2,0x22);
+	ov3640_write_reg(0x8CA3,0xC2);
+	ov3640_write_reg(0x8CA4,0x01);
+	ov3640_write_reg(0x8CA5,0x90);
+	ov3640_write_reg(0x8CA6,0x30);
+	ov3640_write_reg(0x8CA7,0xB4);
+	ov3640_write_reg(0x8CA8,0xE5);
+	ov3640_write_reg(0x8CA9,0x20);
+	ov3640_write_reg(0x8CAA,0xF0);
+	ov3640_write_reg(0x8CAB,0x7F);
+	ov3640_write_reg(0x8CAC,0x05);
+	ov3640_write_reg(0x8CAD,0xAE);
+	ov3640_write_reg(0x8CAE,0x07);
+	ov3640_write_reg(0x8CAF,0x1F);
+	ov3640_write_reg(0x8CB0,0xEE);
+	ov3640_write_reg(0x8CB1,0x70);
+	ov3640_write_reg(0x8CB2,0xFA);
+	ov3640_write_reg(0x8CB3,0xD2);
+	ov3640_write_reg(0x8CB4,0x00);
+	ov3640_write_reg(0x8CB5,0x90);
+	ov3640_write_reg(0x8CB6,0x30);
+	ov3640_write_reg(0x8CB7,0xB4);
+	ov3640_write_reg(0x8CB8,0xE5);
+	ov3640_write_reg(0x8CB9,0x20);
+	ov3640_write_reg(0x8CBA,0xF0);
+	ov3640_write_reg(0x8CBB,0x7F);
+	ov3640_write_reg(0x8CBC,0x05);
+	ov3640_write_reg(0x8CBD,0xAE);
+	ov3640_write_reg(0x8CBE,0x07);
+	ov3640_write_reg(0x8CBF,0x1F);
+	ov3640_write_reg(0x8CC0,0xEE);
+	ov3640_write_reg(0x8CC1,0x70);
+	ov3640_write_reg(0x8CC2,0xFA);
+	ov3640_write_reg(0x8CC3,0xD2);
+	ov3640_write_reg(0x8CC4,0x01);
+	ov3640_write_reg(0x8CC5,0x90);
+	ov3640_write_reg(0x8CC6,0x30);
+	ov3640_write_reg(0x8CC7,0xB4);
+	ov3640_write_reg(0x8CC8,0xE5);
+	ov3640_write_reg(0x8CC9,0x20);
+	ov3640_write_reg(0x8CCA,0xF0);
+	ov3640_write_reg(0x8CCB,0xD2);
+	ov3640_write_reg(0x8CCC,0xAF);
+	ov3640_write_reg(0x8CCD,0x7F);
+	ov3640_write_reg(0x8CCE,0x05);
+	ov3640_write_reg(0x8CCF,0xAE);
+	ov3640_write_reg(0x8CD0,0x07);
+	ov3640_write_reg(0x8CD1,0x1F);
+	ov3640_write_reg(0x8CD2,0xEE);
+	ov3640_write_reg(0x8CD3,0x70);
+	ov3640_write_reg(0x8CD4,0xFA);
+	ov3640_write_reg(0x8CD5,0x22);
+	ov3640_write_reg(0x8CD6,0x90);
+	ov3640_write_reg(0x8CD7,0x30);
+	ov3640_write_reg(0x8CD8,0xB2);
+	ov3640_write_reg(0x8CD9,0xE0);
+	ov3640_write_reg(0x8CDA,0x44);
+	ov3640_write_reg(0x8CDB,0x18);
+	ov3640_write_reg(0x8CDC,0xF0);
+	ov3640_write_reg(0x8CDD,0x90);
+	ov3640_write_reg(0x8CDE,0x30);
+	ov3640_write_reg(0x8CDF,0xB0);
+	ov3640_write_reg(0x8CE0,0xE0);
+	ov3640_write_reg(0x8CE1,0x44);
+	ov3640_write_reg(0x8CE2,0x03);
+	ov3640_write_reg(0x8CE3,0xF0);
+	ov3640_write_reg(0x8CE4,0xA3);
+	ov3640_write_reg(0x8CE5,0xE0);
+	ov3640_write_reg(0x8CE6,0x44);
+	ov3640_write_reg(0x8CE7,0xC0);
+	ov3640_write_reg(0x8CE8,0xF0);
+	ov3640_write_reg(0x8CE9,0x90);
+	ov3640_write_reg(0x8CEA,0x30);
+	ov3640_write_reg(0x8CEB,0xB4);
+	ov3640_write_reg(0x8CEC,0xE0);
+	ov3640_write_reg(0x8CED,0x44);
+	ov3640_write_reg(0x8CEE,0x0F);
+	ov3640_write_reg(0x8CEF,0xF0);
+	ov3640_write_reg(0x8CF0,0xE0);
+	ov3640_write_reg(0x8CF1,0x54);
+	ov3640_write_reg(0x8CF2,0xF7);
+	ov3640_write_reg(0x8CF3,0xF0);
+	ov3640_write_reg(0x8CF4,0xE0);
+	ov3640_write_reg(0x8CF5,0x44);
+	ov3640_write_reg(0x8CF6,0x04);
+	ov3640_write_reg(0x8CF7,0xF0);
+	ov3640_write_reg(0x8CF8,0x22);
+	ov3640_write_reg(0x8CF9,0xE4);
+	ov3640_write_reg(0x8CFA,0xFF);
+	ov3640_write_reg(0x8CFB,0xEF);
+	ov3640_write_reg(0x8CFC,0xC3);
+	ov3640_write_reg(0x8CFD,0x95);
+	ov3640_write_reg(0x8CFE,0x13);
+	ov3640_write_reg(0x8CFF,0x50);
+	ov3640_write_reg(0x8D00,0x11);
+	ov3640_write_reg(0x8D01,0x7D);
+	ov3640_write_reg(0x8D02,0x82);
+	ov3640_write_reg(0x8D03,0x7C);
+	ov3640_write_reg(0x8D04,0x00);
+	ov3640_write_reg(0x8D05,0xED);
+	ov3640_write_reg(0x8D06,0x1D);
+	ov3640_write_reg(0x8D07,0xAA);
+	ov3640_write_reg(0x8D08,0x04);
+	ov3640_write_reg(0x8D09,0x70);
+	ov3640_write_reg(0x8D0A,0x01);
+	ov3640_write_reg(0x8D0B,0x1C);
+	ov3640_write_reg(0x8D0C,0x4A);
+	ov3640_write_reg(0x8D0D,0x70);
+	ov3640_write_reg(0x8D0E,0xF6);
+	ov3640_write_reg(0x8D0F,0x0F);
+	ov3640_write_reg(0x8D10,0x80);
+	ov3640_write_reg(0x8D11,0xE9);
+	ov3640_write_reg(0x8D12,0x22);
+	ov3640_write_reg(0x8D13,0x30);
+	ov3640_write_reg(0x8D14,0x08);
+	ov3640_write_reg(0x8D15,0x10);
+	ov3640_write_reg(0x8D16,0xE5);
+	ov3640_write_reg(0x8D17,0x0E);
+	ov3640_write_reg(0x8D18,0x90);
+	ov3640_write_reg(0x8D19,0x33);
+	ov3640_write_reg(0x8D1A,0x00);
+	ov3640_write_reg(0x8D1B,0x60);
+	ov3640_write_reg(0x8D1C,0x05);
+	ov3640_write_reg(0x8D1D,0xE0);
+	ov3640_write_reg(0x8D1E,0x44);
+	ov3640_write_reg(0x8D1F,0x40);
+	ov3640_write_reg(0x8D20,0xF0);
+	ov3640_write_reg(0x8D21,0x22);
+	ov3640_write_reg(0x8D22,0xE0);
+	ov3640_write_reg(0x8D23,0x54);
+	ov3640_write_reg(0x8D24,0xBF);
+	ov3640_write_reg(0x8D25,0xF0);
+	ov3640_write_reg(0x8D26,0x22);
+	ov3640_write_reg(0x8D27,0xC3);
+	ov3640_write_reg(0x8D28,0xEE);
+	ov3640_write_reg(0x8D29,0x64);
+	ov3640_write_reg(0x8D2A,0x80);
+	ov3640_write_reg(0x8D2B,0x94);
+	ov3640_write_reg(0x8D2C,0x80);
+	ov3640_write_reg(0x8D2D,0x40);
+	ov3640_write_reg(0x8D2E,0x02);
+	ov3640_write_reg(0x8D2F,0x80);
+	ov3640_write_reg(0x8D30,0x07);
+	ov3640_write_reg(0x8D31,0xC3);
+	ov3640_write_reg(0x8D32,0xE4);
+	ov3640_write_reg(0x8D33,0x9F);
+	ov3640_write_reg(0x8D34,0xFF);
+	ov3640_write_reg(0x8D35,0xE4);
+	ov3640_write_reg(0x8D36,0x9E);
+	ov3640_write_reg(0x8D37,0xFE);
+	ov3640_write_reg(0x8D38,0x22);
+	ov3640_write_reg(0x8D39,0x01);
+	ov3640_write_reg(0x8D3A,0x50);
+	ov3640_write_reg(0x8D3B,0x00);
+	ov3640_write_reg(0x8D3C,0x01);
+	ov3640_write_reg(0x8D3D,0x24);
+	ov3640_write_reg(0x8D3E,0x00);
+	ov3640_write_reg(0x8D3F,0x01);
+	ov3640_write_reg(0x8D40,0x31);
+	ov3640_write_reg(0x8D41,0x00);
+	ov3640_write_reg(0x8D42,0x01);
+	ov3640_write_reg(0x8D43,0x32);
+	ov3640_write_reg(0x8D44,0x00);
+	ov3640_write_reg(0x8D45,0x02);
+	ov3640_write_reg(0x8D46,0x33);
+	ov3640_write_reg(0x8D47,0x00);
+	ov3640_write_reg(0x8D48,0x00);
+	ov3640_write_reg(0x8D49,0x00);
+	ov3640_write_reg(0x8D4A,0x90);
+	ov3640_write_reg(0x8D4B,0x30);
+	ov3640_write_reg(0x8D4C,0x1B);
+	ov3640_write_reg(0x8D4D,0xE0);
+	ov3640_write_reg(0x8D4E,0xFF);
+	ov3640_write_reg(0x8D4F,0x65);
+	ov3640_write_reg(0x8D50,0x50);
+	ov3640_write_reg(0x8D51,0x60);
+	ov3640_write_reg(0x8D52,0x04);
+	ov3640_write_reg(0x8D53,0x8F);
+	ov3640_write_reg(0x8D54,0x50);
+	ov3640_write_reg(0x8D55,0xD3);
+	ov3640_write_reg(0x8D56,0x22);
+	ov3640_write_reg(0x8D57,0xC3);
+	ov3640_write_reg(0x8D58,0x22);
+	ov3640_write_reg(0x3104,0x00);
+	check_sequence	= ENABLE;
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	ov3640_frame_interval_support
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Control the frame rate based on the user request 
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_frame_interval_support(cam_data *cam)
+{
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT32 frame_interval_based_on_mode	= DISABLE;
+			UINT32 usr_width	= cam->cam_sensor.frame_interval_frm_user->width;
+			UINT32 usr_height	= cam->cam_sensor.frame_interval_frm_user->height;
+			UINT32 pixel_format	= cam->cam_sensor.frame_interval_frm_user->pixel_format;
+
+			for(	frame_interval_based_on_mode	= DISABLE	;				\
+				frame_interval_based_on_mode	< cam->cam_sensor.total_frm_interval_support;	\
+				frame_interval_based_on_mode++)
+			{
+				if(	(usr_width <= cam->cam_sensor						\
+						.frm_interval_support[frame_interval_based_on_mode].width)	&&
+					(usr_height <= cam->cam_sensor						\
+						.frm_interval_support[frame_interval_based_on_mode].height))
+				{
+					break;
+				}
+			}
+
+			if(frame_interval_based_on_mode	>=cam->cam_sensor.total_frm_interval_support)
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+
+			memcpy(	cam->cam_sensor.frame_interval_frm_user,					\
+				&cam->cam_sensor.frm_interval_support[frame_interval_based_on_mode],		\
+				sizeof(struct v4l2_frmivalenum));
+			cam->cam_sensor.frame_interval_frm_user->width		= usr_width;
+			cam->cam_sensor.frame_interval_frm_user->height		= usr_height;
+			cam->cam_sensor.frame_interval_frm_user->pixel_format	= pixel_format;
+		}break;
+
+		case SET_DATA:
+		{
+		}break;
+
+		case QUERY_DATA:
+		{
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	ov3640_format_support
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Control the frame rate based on the user request 
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_format_support(cam_data *cam)
+{
+	UINT32 pix_fmt_count	= DISABLE;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT32 pixel_format	= cam->cam_sensor.fmt_frm_user->pixel_format;
+			if(cam->cam_sensor.fmt_frm_user->index	>= cam->cam_sensor.total_frms_support)
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+
+			for(	pix_fmt_count	= DISABLE;					\
+				pix_fmt_count < cam->cam_sensor.total_fmt_desc;			\
+				pix_fmt_count++)
+			{
+				if(cam->cam_sensor.fmt_frm_user->pixel_format == 		\
+						cam->cam_sensor.formats[pix_fmt_count].pixelformat)
+				{
+					break;
+				}
+			}
+
+			/*
+			 * Check for pixel format support. If the pixel format is not
+			 * supported! return the format is error value as Invalid data
+			 */
+
+			if(pix_fmt_count	>= (cam->cam_sensor.total_frms_support))
+			{
+
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+
+			memcpy(	cam->cam_sensor.fmt_frm_user,					\
+				&cam->cam_sensor.frms[cam->cam_sensor.fmt_frm_user->index],	\
+				sizeof(struct v4l2_frmsizeenum));
+			cam->cam_sensor.fmt_frm_user->pixel_format	= pixel_format;
+		}break;
+
+		case SET_DATA:
+		{
+		}break;
+
+		case QUERY_DATA:
+		{
+		}break;
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	ov3640_limit_pclk_max_limit
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Control the pclk rate based on the user request 
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_limit_pclk_max_limit(cam_data *cam)
+{
+	UINT8 regval_300e,rx_pll;
+	UINT8 regval_300f;
+	UINT8 freq_div,inDiv;
+	UINT8 freq_div_num	= 1;
+	UINT8 freq_div_den	= 1;
+	UINT8 inDiv_num		= 1;
+	UINT8 inDiv_den		= 1;
+
+	UINT8 regval_3010,sens_div,sens_div_val;
+	UINT8 regval_3011,clk;
+	UINT8 regval_304c,unknown;
+	UINT32 pclk	= SENS_MAX_PCLK_SUPPORT;
+
+	for(;sens_max_pclk < pclk;)
+	{
+		ov3640_read_reg(0x300e, &regval_300e);
+		ov3640_read_reg(0x300f, &regval_300f);
+		ov3640_read_reg(0x3010, &regval_3010);
+		ov3640_read_reg(0x3011, &regval_3011);
+		ov3640_read_reg(0x304c, &regval_304c);
+				
+		rx_pll		= (regval_300e & 0x3F);
+		freq_div	= (regval_300f & 0xC0) >> 6;	// [7:6]
+		switch(freq_div)
+		{
+			case 0:
+			{
+				freq_div_num	= 1;
+				freq_div_den	= 1;
+			}break;
+			case 1:
+			{
+				freq_div_num	= 3;
+				freq_div_den	= 2;
+			}break;
+			case 2:
+			{
+				freq_div_num	= 2;
+				freq_div_den	= 1;
+			}break;
+			case 3:
+			{
+				freq_div_num	= 3;
+				freq_div_den	= 1;
+			}break;
+		}
+
+		inDiv		= (regval_300f & 0x03);		// [1:0]
+		switch(inDiv)
+		{
+			case 0:
+			{
+				inDiv_num	= 1;
+				inDiv_den	= 1;
+			}break;
+			case 1:
+			{
+				inDiv_num	= 3;
+				inDiv_den	= 2;
+			}break;
+			case 2:
+			{
+				inDiv_num	= 2;
+				inDiv_den	= 1;
+			}break;
+			case 3:
+			{
+				inDiv_num	= 3;
+				inDiv_den	= 1;
+			}break;
+		}
+		sens_div	= (regval_3010 & 0x10) >> 4;
+		sens_div_val	= (sens_div == 0)?1:2;
+		clk		= (regval_3011 & 0x3F);
+		unknown		= (regval_304c & 0x1F);
+		
+		pclk		= (64 - rx_pll)*freq_div_num/freq_div_den*24000000/	\
+				  inDiv_num*inDiv_den/sens_div_val/(clk+1)/2/unknown;
+
+//		pclk		= (64-0x300e[5:0])*0x300f[7:6]*
+//					MCLK/0x300f[1:0]/0x3010[4]/(0x3011[5:0]+1)/2/0x304c[4:0];
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+		printk(KERN_DEBUG "----------------------------------------\n");
+		printk(KERN_DEBUG "rx_pll %d \n",rx_pll);
+		printk(KERN_DEBUG "freq_div_num %d \n",freq_div_num);
+		printk(KERN_DEBUG "freq_div_den %d \n",freq_div_den);
+		printk(KERN_DEBUG "inDiv_num %d \n",inDiv_num);
+		printk(KERN_DEBUG "inDiv_den %d \n",inDiv_den);
+		printk(KERN_DEBUG "sens_div_val %d \n",sens_div_val);
+		printk(KERN_DEBUG "clk %d \n",clk);
+		printk(KERN_DEBUG "unknown %d \n",unknown);
+		printk(KERN_DEBUG "Pclk value as per calaculation is %d \n",pclk);
+		printk(KERN_DEBUG "----------------------------------------\n");
+#endif
+		if(sens_max_pclk < pclk)
+		{
+			clk++;
+			ov3640_write_reg(0x3011 ,clk);
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	ov3640_frame_rate_ctrl
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Control the frame rate based on the user request 
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_frame_rate_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+
+	/*
+	 * Sensor Will take mclk from input ranges from 6Mhz t0 27 Mhz (V3640_COB_USA.pdf)
+	 */
+#if 0
+	UINT32 clk_set		= DISABLE;
+#endif
+	UINT8 regval_3011	= DISABLE;
+	UINT32 fps		= DISABLE;
+	UINT32 fps_need		= DISABLE;
+
+	if(cam->cam_sensor.s_parm.type	!= V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	{
+		TRACE_ERR_AND_RET(-EINVAL);
+	}
+
+	ov3640_read_reg(0x3011,&regval_3011);
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			if(	(cam->cam_sensor.fmt.fmt.pix.width < MODE_XGA_WIDTH) && 	\
+			(cam->cam_sensor.fmt.fmt.pix.height < MODE_XGA_HEIGHT))
+			{
+				fps		= 30 / (regval_3011 +1);
+			}else
+			{
+				fps		= 7 / (regval_3011 +1);
+			}
+			cam->cam_sensor.s_parm.parm.capture.timeperframe.denominator	= fps;
+			cam->cam_sensor.s_parm.parm.capture.timeperframe.numerator	= 1;
+		}break;
+
+		case SET_DATA:
+		{
+			if(	(cam->cam_sensor.fmt.fmt.pix.width < MODE_XGA_WIDTH) && 	\
+			(cam->cam_sensor.fmt.fmt.pix.height < MODE_XGA_HEIGHT))
+			{
+				fps		= 30 / (regval_3011 +1);
+				fps_need	= (cam->cam_sensor.s_parm.parm.capture.timeperframe.denominator/	\
+						cam->cam_sensor.s_parm.parm.capture.timeperframe.numerator);
+
+				if(fps_need	 > 30)
+				{
+					fps_need	= 30;
+				}	
+				regval_3011	= (30 / fps_need) -1;
+			}else
+			{
+				fps		= 7 / (regval_3011 +1);
+				fps_need	= (cam->cam_sensor.s_parm.parm.capture.timeperframe.denominator/	\
+							cam->cam_sensor.s_parm.parm.capture.timeperframe.numerator);
+				if(fps_need	 > 7)
+				{
+					fps_need	= 7;
+				}
+				regval_3011	= (7 / fps_need) -1;
+			}
+
+			ov3640_write_reg(0x3011,regval_3011);
+			ret_val	= ov3640_limit_pclk_max_limit(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);		
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+		}break;
+	}
+/*
+ * TODO :
+ * 	Fine tune the Mclk to acheive more accurate frame rate from the sensor
+ */
+
+#if 0
+	if(cam->modify_mclk_to_sensor)
+	{
+		ret_val	= cam->modify_mclk_to_sensor(cam,xclk,&clk_set);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);		
+		}
+	}
+#endif
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_15
+ *  Name	:	ov3640_sens_strobe
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	External flash light strobe signal control be enabled (or) disabled here 
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_sens_strobe(cam_data *cam)
+{
+	if((cam->ctrl.value) && (cam->cam_sensor.sens_strobe_en))
+	{
+		ov3640_write_reg(0x307A ,0x8F);	
+	}else
+	{
+		ov3640_write_reg(0x307A ,0x0F);	
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_16
+ *  Name	:	ov3640_focus
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Autofocus related feature available here
+ *  Comments	:  	Ov3640 truly module firmware supports
+ *  			1. Manual focus
+ *  			2. Absolute focus
+ *  			3. Relative focus
+ *  			4. Automatic continous focus
+ *  			5. Single Auto focus
+ ************************************************************************************************************/
+FNRESLT ov3640_focus(cam_data *cam)
+{
+	af_status reg_data;
+	UINT8 reg_value;
+	static INT32 restore_focus_absolute;
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_FOCUS_ABSOLUTE:
+				case V4L2_CID_FOCUS_RELATIVE:
+				{
+					ov3640_read_reg(0x3f01,&reg_data.reg_data);
+					if(reg_data.focus.mode != MODE_STEP_MODE)
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+					ov3640_read_reg(0x3f05,&reg_value);				
+					cam->ctrl.value	= (0x03 & reg_value) << 8;
+
+					ov3640_read_reg(0x3f06,&reg_value);
+					cam->ctrl.value|= (0xFF & reg_value);
+					restore_focus_absolute	= cam->ctrl.value;
+				}break;
+
+				case V4L2_CID_FOCUS_AUTO:
+				{
+					ov3640_read_reg(0x3f01,&reg_data.reg_data);
+					if(reg_data.focus.mode == MODE_CONTINOUS_FOCUS)
+					{
+						cam->ctrl.value = reg_data.focus.mode_step;
+					}else
+					{
+						cam->ctrl.value = DISABLE;
+					}
+				}break;
+
+				case V4L2_SENS_TRIG_FOCUS:
+				{
+					ov3640_read_reg(0x3f01,&reg_data.reg_data);
+					if(reg_data.focus.mode == MODE_SINGLE_FOCUS)
+					{
+						cam->ctrl.value = reg_data.focus.mode_step;
+					}else
+					{
+						cam->ctrl.value = DISABLE;
+					}
+				}break;
+				default:
+				{
+					TRACE_ERR_AND_RET(-EINVAL);	
+				}	
+			}		
+		}break;
+
+		case RESTORE_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_FOCUS_ABSOLUTE:
+				{
+					cam->ctrl.value	= restore_focus_absolute;
+				}break;
+			}
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			ov3640_write_reg(0x3f00,0x09);
+
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_FOCUS_ABSOLUTE:
+				{
+					ov3640_read_reg(0x3f01,&reg_data.reg_data);
+					if(reg_data.focus.mode != MODE_STEP_MODE)
+					{
+						ov3640_write_reg(0x3f00,0x08);
+						ov3640_write_reg(0x3f00,0x05);
+					}
+					ov3640_write_reg(0x3f05,STEP_ABSOLUTE | (0x3 & ((cam->ctrl.value) >> 8)));
+					ov3640_write_reg(0x3f06,(0xFF & cam->ctrl.value));
+					restore_focus_absolute	= cam->ctrl.value;
+				}break;
+
+				case V4L2_CID_FOCUS_RELATIVE:
+				{
+					ov3640_read_reg(0x3f01,&reg_data.reg_data);
+					if(reg_data.focus.mode != MODE_STEP_MODE)
+					{
+						ov3640_write_reg(0x3f00,0x08);
+						ov3640_write_reg(0x3f00,0x05);
+					}
+					if(cam->ctrl.value > 0)
+					{
+						ov3640_write_reg(0x3f05,STEP_FORWARD | (0x3 & ((cam->ctrl.value) >> 8)));
+						ov3640_write_reg(0x3f06,(0xFF & cam->ctrl.value));
+					}else
+					{
+						cam->ctrl.value = -cam->ctrl.value;
+						ov3640_write_reg(0x3f05,STEP_BACKWARD | (0x3 & ((cam->ctrl.value) >> 8)));
+						ov3640_write_reg(0x3f06,(0xFF & cam->ctrl.value));
+					}	
+				}break;
+				case V4L2_CID_FOCUS_AUTO:
+				{
+					ov3640_write_reg(0x3f00,0x08);
+					ov3640_write_reg(0x3f00,0x04);
+				}break;
+				case V4L2_SENS_TRIG_FOCUS:
+				{
+					ov3640_write_reg(0x3f00,0x08);
+					ov3640_write_reg(0x3f00,0x03);
+				}break;
+		
+				case V4L2_SENS_FCS_OLAY:
+				{
+					if(cam->ctrl.value)
+					{
+						ov3640_write_reg(0x3f00,0x01);
+					}else
+					{
+						ov3640_write_reg(0x3f00,0x02);
+					}
+
+				}break;
+
+				case V4L2_SENS_FOCUS_FREEZE:
+				{
+					ov3640_write_reg(0x3f00,0x06);					
+				}break;
+
+				case V4L2_SENS_FOCUS_UNFREEZE:
+				{
+					ov3640_write_reg(0x3f00,0x07);					
+				}break;
+
+				case V4L2_SENS_FOCUS_DISABLE:
+				{
+					ov3640_write_reg(0x3f00,0x08);					
+				}break;			
+			}		
+		}break;
+
+		case QUERY_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_FOCUS_ABSOLUTE:
+				{
+					cam->qctrl.id	= V4L2_CID_FOCUS_ABSOLUTE;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+					strncpy(cam->qctrl.name,"Manual focus",strlen("Manual focus"));
+					cam->qctrl.minimum = 0;
+					cam->qctrl.maximum = 1023;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+					cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+				}break;
+
+				case V4L2_CID_FOCUS_RELATIVE:
+				{
+					cam->qctrl.id	= V4L2_CID_FOCUS_RELATIVE;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+					strncpy(cam->qctrl.name,"Relative Manual focus",	\
+							strlen("Relative Manual focus"));
+					cam->qctrl.minimum = -1023;
+					cam->qctrl.maximum = 1023;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+					cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+				}break;
+
+				case V4L2_CID_FOCUS_AUTO:
+				{
+					cam->qctrl.id	= V4L2_CID_FOCUS_AUTO;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+					strncpy(cam->qctrl.name,"Autofocus",strlen("Autofocus"));
+					cam->qctrl.minimum = 0;
+					cam->qctrl.maximum = 1;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+				}break;
+
+				case V4L2_SENS_TRIG_FOCUS:
+				{
+					cam->qctrl.id	= V4L2_SENS_TRIG_FOCUS;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+					strncpy(cam->qctrl.name,"Single Auto focus",	\
+							strlen("Single Auto focus"));
+					cam->qctrl.minimum = 0;
+					cam->qctrl.maximum = 1;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+				}break;
+
+				case V4L2_SENS_FCS_OLAY:
+				{
+					cam->qctrl.id	= V4L2_SENS_FCS_OLAY;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+					strncpy(cam->qctrl.name,"Focus Overlay",strlen("Focus Overlay"));
+					cam->qctrl.minimum = 0;
+					cam->qctrl.maximum = 1;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+				}break;
+
+				case V4L2_SENS_FOCUS_DISABLE:
+				{
+					cam->qctrl.id	= V4L2_SENS_FOCUS_DISABLE;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+					strncpy(cam->qctrl.name,"Focus complete",strlen("Focus complete"));
+					cam->qctrl.minimum = 0;
+					cam->qctrl.maximum = 1;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+				}break;
+			}			
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	ov3640_color_pattern
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Color bar pattern available from the sensor
+ ************************************************************************************************************/
+FNRESLT ov3640_color_pattern(cam_data *cam)
+{
+	static UINT32 color_pattern		= TEST_PATTERN_DISABLE;
+	static INT32 restore_color_pattern	= TEST_PATTERN_DISABLE;
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= color_pattern;
+			restore_color_pattern	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_color_pattern;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= TEST_PATTERN_COLOR_BAR) && (cam->ctrl.value <= TEST_PATTERN_DISABLE))
+			{
+				color_pattern	= cam->ctrl.value;
+				switch (cam->ctrl.value)
+				{
+/*
+ * Color bar
+ */
+					case TEST_PATTERN_COLOR_BAR:
+					{
+						ov3640_write_reg(0x3300 ,0x08);
+					}break;
+
+					case TEST_PATTERN_DISABLE:
+					{
+						ov3640_write_reg(0x3300 ,0x13);
+						color_pattern	= TEST_PATTERN_DISABLE;
+					}
+				}
+				restore_color_pattern	= cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_TEST_PATTERN;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"Test pattern",strlen("Test pattern"));
+			cam->qctrl.minimum = TEST_PATTERN_COLOR_BAR;
+			cam->qctrl.maximum = TEST_PATTERN_DISABLE;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = TEST_PATTERN_DISABLE;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_17
+ *  Name	:	ov3640_i2c_client_xfer
+ *  Parameter1	:	INT32 addr	- Slave address (7-bit) address
+ *  Parameter2	:	PINT8 reg	- Ov3640 Register address base address
+ *  Parameter3	:	PINT8 buf	- Ov3640 Register data base address
+ *  Parameter4	:	INT32 num	- Number of data need to read/write in i2c transation
+ *  Parameter5	:	INT32 tran_flag	- 0- Write,1-read
+ *
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Perform read/write data through i2c bus
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_i2c_client_xfer(	INT32 addr, PINT8 reg, PINT8 buf, INT32 num,	\
+				INT32 tran_flag)
+{
+	struct i2c_msg msg[2];
+	FNRESLT ret_val;
+	INT32 ret;
+	cam_data *cam	= NULL;
+	UINT8 reg_addr_data[3];
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to get the camera base pointer \n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	if(cam->cam_sensor.client == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+/*
+ * FIXME:
+ * 	
+ * 	I2C Write:
+ *	 	In i2c msg[0] "address part in write is success" but if we put data in msg [1] 
+ * 		that is not properly sent to device.
+ *
+ * 		so in the msg[0] part itself the data also sent here.
+ *
+ * 	I2CRead:
+ * 		But in read No problem is found and working fine
+ */
+	if(tran_flag & I2C_FLAG_READ)
+	{
+		msg[0].addr	= addr;
+		msg[0].len	= 2;
+		msg[0].buf	= reg;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		msg[1].addr	= addr;
+		msg[1].len	= num;
+		msg[1].buf	= buf;
+		msg[1].flags	= tran_flag;
+
+		if (tran_flag & I2C_FLAG_READ)
+		{
+			msg[1].flags |= I2C_M_RD;
+		}else
+		{
+			msg[1].flags &= ~I2C_M_RD;
+		}
+
+		if (cam->cam_sensor.client->adapter == NULL)
+		{
+			printk(KERN_ERR "%s:adapter error\n", __func__);
+			return -1;
+		}
+
+		ret = i2c_transfer(cam->cam_sensor.client->adapter, msg, 2);
+		if (ret >= 0)
+		{
+			return SUCCESS;
+		}
+	}else
+	{
+		reg_addr_data[0]	= reg[0];
+		reg_addr_data[1]	= reg[1];
+		reg_addr_data[2]	= buf[0];
+
+		msg[0].addr	= addr;
+		msg[0].len	= 3;
+		msg[0].buf	= reg_addr_data;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		ret = i2c_transfer(cam->cam_sensor.client->adapter, msg, 1);
+		if (ret >= 0)
+		{
+			return SUCCESS;
+		}
+	}
+	printk(KERN_ERR "%s:i2c transfer error:%d\n", __func__, ret);
+	TRACE_ERR_AND_RET(FAIL);
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_18	
+ *  Name	:	ov3640_write_reg
+ *  Parameter1	:	UINT16 reg_address	- Ov3640 register address
+ *  Parameter2	:	UINT8 reg_data		- Ov3640 register data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	This function write the data in the mentioned register address of ov3640 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_write_reg(UINT16 reg_address,UINT8 reg_data)
+{
+	UINT8 retry_count	= 3;
+	UINT8 reg_addr[2];
+	UINT8 reg_data_bw	= reg_data;
+	UINT8 reg_data_aw	= 0;
+	FNRESLT ret_val;
+
+
+	reg_addr[0]	= 0xFF & (reg_address >> 8);
+	reg_addr[1]	= 0xFF & reg_address;
+	
+	for(;retry_count;retry_count--)
+	{
+		udelay(100);
+		ret_val	= ov3640_i2c_client_xfer(OV3640_I2C_ADDRESS,reg_addr, &reg_data_bw, 1, 0);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			return I2C_WRITE_FAIL;
+		}
+
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+		printk(KERN_DEBUG "write : addr=%x, val=%x ",reg_address, reg_data_bw);
+#endif
+		if(check_sequence == ENABLE)
+		{
+
+			if((reg_address != 0x3f00) && (reg_address != 0x3012))
+			{
+				udelay(100);
+				ret_val	= ov3640_read_reg(reg_address,&reg_data_aw);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					return I2C_WRITE_FAIL;
+				}
+			}else
+			{
+				reg_data_aw	= reg_data_bw;
+			}
+
+
+			if(reg_data_bw == reg_data_aw)
+			{
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+				printk(KERN_DEBUG "  SUCCESS \n");
+#endif
+				break;
+			}else
+			{
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+				printk(KERN_DEBUG "  FAIL    \n");
+#endif
+				if(retry_count != 1)
+				{
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+					printk(KERN_DEBUG "  RETRY 	:    ");
+#endif
+				}			
+			}
+		}else
+		{
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+			printk(KERN_DEBUG "\n");
+#endif
+		}
+	}
+	
+	return I2C_WRITE_SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_19	
+ *  Name	:	ov3640_read_reg
+ *  Parameter1	:	UINT16 reg_address	- Ov3640 register address
+ *  Parameter2	:	UPINT8 reg_data		- Ov3640 register data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	This function read the data in the mentioned register address of ov3640
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_read_reg(UINT16 reg_address,UPINT8 reg_data)
+{
+	UINT8 reg_addr[2];
+	reg_addr[0]	= 0xFF & (reg_address >> 8);
+	reg_addr[1]	= 0xFF & reg_address;
+
+	if (ov3640_i2c_client_xfer(OV3640_I2C_ADDRESS,reg_addr,reg_data, 1, 1) < 0)
+	{
+		printk("%s:read reg error: reg=%x, val=%x\n",__func__,reg_address ,*reg_data);
+		return -1;
+	}
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+	printk(KERN_DEBUG " read : addr=%x, val=%x",reg_address,*reg_data);
+#endif
+	udelay(100);
+
+	return I2C_WRITE_SUCCESS;
+
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_probe
+ *  Parameter1	:	struct i2c_client *client
+ *  Parameter2	:	const struct i2c_device_id *id
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	Configure the gpio levels for ov3640 driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+static INT32 ov3640_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	cam_data *cam	= NULL;
+	FNRESLT ret_val;
+
+	if (i2c_get_clientdata(client))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		goto exit;
+	}
+	
+/*
+ * 	set the client data 
+ */
+	cam->cam_sensor.client =	client;
+
+/*
+ * Make sure the mclk clock is enabled 
+ */
+
+/*
+ * Configure the gpio levels
+ */
+
+	gpio_request(RESET_GPIO,"ov3640");
+	gpio_request(STANDBY_GPIO,"ov3640");
+
+	gpio_direction_output(RESET_GPIO, true);
+	gpio_direction_output(STANDBY_GPIO, true);
+	/* Turn ON Omnivision sensor */
+	gpio_set_value(RESET_GPIO, ENABLE);
+	gpio_set_value(STANDBY_GPIO, DISABLE);
+	udelay(100);
+
+	/* RESET Omnivision sensor */
+	gpio_set_value(RESET_GPIO, DISABLE);
+	udelay(100);
+	gpio_set_value(RESET_GPIO, ENABLE);
+
+/*
+ *	TODO: Description for udelay(100)
+ *	 We faced poweron time delay with ov5642 on 15APR2010.
+ *	 So we hard coded 100 micro second delay on ov3640 also 
+ *	 to be on the Safer side.
+ *
+ *	 But this can be done better (If reading the register failed then put the
+ *	 delay and read again in the probing sequence only).
+ */
+	udelay(100);
+
+	return SUCCESS;
+	exit:
+	{
+		TRACE_ERR_AND_RET(-ENODEV);
+	}	
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_remove
+ *  Parameter1	:	struct i2c_client *client
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	remove routine of ov3640 i2c driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+static INT32 ov3640_remove(struct i2c_client *client)
+{
+	if (!client->adapter)
+	{
+		/* our client isn't attached */
+		TRACE_ERR_AND_RET(-ENODEV);
+	}	
+
+	i2c_set_clientdata(client, NULL);
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_init	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	ov3640 init part of code done here
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+#define OV3640_DRIVER_NAME	"ov3640"
+/*
+ * i2c driver init
+ */
+static const struct i2c_device_id ov3640_id[] =			\
+{
+	{ OV3640_DRIVER_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c_0, ov3640_id);
+
+FNRESLT ov3640_init(cam_data *cam)
+{
+	FNRESLT  ret_val;
+	UINT32	index			= DISABLE;
+	UINT32	fmt_index		= DISABLE;
+	UINT32	frame_rate_index	= DISABLE;
+	
+	cam->cam_sensor.i2c_driver.driver.name	= OV3640_DRIVER_NAME;
+	cam->cam_sensor.i2c_driver.driver.owner	= THIS_MODULE;
+	cam->cam_sensor.i2c_driver.probe	= ov3640_probe;
+	cam->cam_sensor.i2c_driver.remove	= __exit_p(ov3640_remove);
+	cam->cam_sensor.i2c_driver.id_table	= ov3640_id;
+
+
+
+	if(i2c_add_driver(&cam->cam_sensor.i2c_driver))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	if(cam->cam_sensor.find_device)
+	{
+		ret_val	= cam->cam_sensor.find_device(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			ov3640_exit(cam);
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+
+/*
+ * init the sensor capability
+ */
+	
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"RGB565",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_RGB565;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"UYVY, packed",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_UYVY;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"YUYV, packed",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_YUYV;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"BA81, BGBG",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_SBGGR8;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"YUV444, packed",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_YUV444;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+#if 0	
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"YUV420, packed",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_YUV420;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+#endif
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"RGB555",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_RGB555;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"BGR888",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_BGR32;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.total_fmt_desc	= index;
+
+/*
+ * init the sensor capable formats
+ */
+	cam->cam_sensor.frms[fmt_index].index			= fmt_index;
+//	cam->cam_sensor.frms[fmt_index].pixel_format		= All pixel formates supported;
+	cam->cam_sensor.frms[fmt_index].type			= V4L2_FRMSIZE_TYPE_STEPWISE;
+
+	cam->cam_sensor.frms[fmt_index].stepwise.min_width	= MIN_OV3640_WIDTH;
+	cam->cam_sensor.frms[fmt_index].stepwise.max_width	= MODE_XGA_WIDTH;
+	cam->cam_sensor.frms[fmt_index].stepwise.step_width	= 32;
+	cam->cam_sensor.frms[fmt_index].stepwise.min_height	= MIN_OV3640_HEIGHT;
+	cam->cam_sensor.frms[fmt_index].stepwise.max_height	= MODE_XGA_HEIGHT;
+	cam->cam_sensor.frms[fmt_index].stepwise.step_height	= 32;
+	fmt_index++;
+
+	cam->cam_sensor.frms[fmt_index].index			= fmt_index;
+//	cam->cam_sensor.frms[fmt_index].pixel_format		= All pixel formates supported;
+	cam->cam_sensor.frms[fmt_index].type			= V4L2_FRMSIZE_TYPE_DISCRETE;
+
+	cam->cam_sensor.frms[fmt_index].discrete.width		= MAX_OV3640_WIDTH;
+	cam->cam_sensor.frms[fmt_index].discrete.height		= MAX_OV3640_HEIGHT;
+	fmt_index++;
+	cam->cam_sensor.total_frms_support	= fmt_index;
+
+/*
+ * initialize the frame interval capability of the sensor
+ */
+	cam->cam_sensor.frm_interval_support[frame_rate_index].index			= frame_rate_index;
+//	cam->cam_sensor.frm_interval_support[frame_rate_index].pixel_format		= Support all formats;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].width			= MODE_XGA_WIDTH;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].height			= MODE_XGA_HEIGHT;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].type			= V4L2_FRMSIZE_TYPE_STEPWISE;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.min.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.min.denominator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.max.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.max.denominator	= SENS_MAX_FPS;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.step.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.step.denominator= 1;
+	frame_rate_index++;
+
+	cam->cam_sensor.frm_interval_support[frame_rate_index].index			= frame_rate_index;
+//	cam->cam_sensor.frm_interval_support[frame_rate_index].pixel_format		= Support all formats;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].width			= MAX_OV3640_WIDTH;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].height			= MAX_OV3640_HEIGHT;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].type			= V4L2_FRMSIZE_TYPE_STEPWISE;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.min.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.min.denominator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.max.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.max.denominator	= 7;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.step.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.step.denominator= 1;
+	frame_rate_index++;
+
+	cam->cam_sensor.total_frm_interval_support	= frame_rate_index;
+
+/*
+ * configure the sensor
+ */
+	ret_val	= ov3640_init_config(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+/*
+ * Dump autofocus firmware the sensor
+ */
+
+	if(cam->cam_sensor.auto_focus_init)
+	{
+		ret_val	= cam->cam_sensor.auto_focus_init(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{	
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+
+	cam->capture.s_parm.parm.capture.timeperframe.denominator	= 	\
+	cam->cam_sensor.s_parm.parm.capture.timeperframe.denominator 	= 30;
+	cam->capture.s_parm.parm.capture.timeperframe.numerator		=	\
+	cam->cam_sensor.s_parm.parm.capture.timeperframe.numerator	= 1;
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_detect_device
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_detect_device(cam_data *cam)
+{
+	FNRESLT ret_val;
+	UINT8 reg_data_aw	= 0x00;
+
+	ret_val	= ov3640_read_reg(0x300a,&reg_data_aw);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}	
+
+	if(reg_data_aw != OV3640_DEVICE_ID)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}else
+	{
+		printk(KERN_INFO "\nov3640 found: product id is 0x%02X \n",reg_data_aw);
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_exit
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_exit(cam_data *cam)
+{
+	i2c_del_driver(&cam->cam_sensor.i2c_driver);
+	memset(&cam->cam_sensor,0x00,sizeof(struct camera_sensor));
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_reset_config
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_reset_config(cam_data *cam)
+{
+	return SUCCESS;
+	
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	chk_pix_format_support
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT chk_pix_format_support(cam_data *cam)
+{
+	switch(cam->cam_sensor.fmt.fmt.pix.pixelformat)	
+	{
+		case V4L2_PIX_FMT_UYVY:
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_RGB555:
+		{
+			cam->cam_sensor.fmt.fmt.pix.bytesperline	= cam->cam_sensor.fmt.fmt.pix.width * 2;
+
+			cam->cam_sensor.fmt.fmt.pix.sizeimage		= cam->cam_sensor.fmt.fmt.pix.bytesperline *	\
+									cam->cam_sensor.fmt.fmt.pix.height;
+		}break;
+#if 0		
+		case V4L2_PIX_FMT_YUV420:
+		{
+			cam->cam_sensor.fmt.fmt.pix.bytesperline	= cam->cam_sensor.fmt.fmt.pix.width * 2;
+
+			cam->cam_sensor.fmt.fmt.pix.sizeimage		= cam->cam_sensor.fmt.fmt.pix.bytesperline *	\
+									cam->cam_sensor.fmt.fmt.pix.height *3/4;
+
+		}break;
+#endif
+		case V4L2_PIX_FMT_YUV444:
+		case V4L2_PIX_FMT_BGR32:
+		{
+			cam->cam_sensor.fmt.fmt.pix.bytesperline	= cam->cam_sensor.fmt.fmt.pix.width * 3;
+			cam->cam_sensor.fmt.fmt.pix.sizeimage		= cam->cam_sensor.fmt.fmt.pix.bytesperline *	\
+									cam->cam_sensor.fmt.fmt.pix.height;
+		}break;
+
+		case V4L2_PIX_FMT_SBGGR8:
+		{
+			cam->cam_sensor.fmt.fmt.pix.bytesperline	= cam->cam_sensor.fmt.fmt.pix.width;
+
+			cam->cam_sensor.fmt.fmt.pix.sizeimage		= cam->cam_sensor.fmt.fmt.pix.bytesperline *	\
+									cam->cam_sensor.fmt.fmt.pix.height;
+			
+		}break;
+		default:
+		{
+			printk(KERN_INFO "chk_pix_format_support Searching for %c%c%c%c\n",				\
+							(INT8)(0xFF&(cam->cam_sensor.fmt.fmt.pix.pixelformat)),	\
+							(INT8)(0xFF&(cam->cam_sensor.fmt.fmt.pix.pixelformat>>8)),	\
+							(INT8)(0xFF&(cam->cam_sensor.fmt.fmt.pix.pixelformat>>16)),	\
+							(INT8)(0xFF&(cam->cam_sensor.fmt.fmt.pix.pixelformat>>24)));
+
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_query_formats
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_query_formats(cam_data *cam)
+{
+	switch(cam->cam_sensor.qfmt.type)
+	{
+		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		{
+			if(	(cam->cam_sensor.qfmt.fmt.pix.width > MAX_OV3640_WIDTH)		|| 	\
+				(cam->cam_sensor.qfmt.fmt.pix.width < MIN_OV3640_WIDTH)		||	\
+				(cam->cam_sensor.qfmt.fmt.pix.height > MAX_OV3640_HEIGHT)	||	\
+				(cam->cam_sensor.qfmt.fmt.pix.height < MIN_OV3640_HEIGHT)
+			)
+			{
+					TRACE_ERR_AND_RET(FAIL);
+			}
+
+#if 0
+/*
+ * FIXME:
+ * 	From sensor uxga frame corruoption is happening,
+ * 	So we fixed in the driver to exclude the problemmatic dimension.
+ */
+				(((cam->cam_sensor.qfmt.fmt.pix.width > FRM_CRPT_OV3640_WIDTH)	||  	\
+				(cam->cam_sensor.qfmt.fmt.pix.height > FRM_CRPT_OV3640_HEIGHT))	&&	\
+				((cam->cam_sensor.qfmt.fmt.pix.width < MAX_OV3640_WIDTH)		||	\
+				(cam->cam_sensor.qfmt.fmt.pix.height < MAX_OV3640_HEIGHT))))
+			{
+				TRACE_ERR_AND_RET(FAIL);					
+			}
+#endif
+			switch(cam->cam_sensor.qfmt.fmt.pix.pixelformat)	
+			{
+				case V4L2_PIX_FMT_UYVY:
+				case V4L2_PIX_FMT_YUYV:
+				case V4L2_PIX_FMT_RGB565:
+				case V4L2_PIX_FMT_SBGGR8:
+				{
+					break;
+				}
+		
+				default:
+				{
+					printk(KERN_INFO "chk_pix_format_support Searching for %c%c%c%c\n",		\
+							(INT8)(0xFF&(cam->cam_sensor.qfmt.fmt.pix.pixelformat)),	\
+							(INT8)(0xFF&(cam->cam_sensor.qfmt.fmt.pix.pixelformat>>8)),	\
+							(INT8)(0xFF&(cam->cam_sensor.qfmt.fmt.pix.pixelformat>>16)),	\
+							(INT8)(0xFF&(cam->cam_sensor.qfmt.fmt.pix.pixelformat>>24)));
+
+					TRACE_ERR_AND_RET(FAIL);
+				}
+			}
+		}break;
+		default:
+		{
+			printk(KERN_DEBUG "Unsupported format type : %x \n",cam->cam_sensor.qfmt.type);
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_fix_supported_formats
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_fix_supported_formats(cam_data *cam)
+{
+	FNRESLT ret_val;
+
+	switch(cam->cam_sensor.fmt.type)
+	{
+		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		{
+/*
+ * FIXME:
+ * 	From sensor uxga frame corruoption is happening,
+ * 	So we fixed in the driver to exclude the problemmatic dimension.
+ */
+			if(											\
+				(((cam->cam_sensor.fmt.fmt.pix.width > MODE_XGA_WIDTH)		||  		\
+				(cam->cam_sensor.fmt.fmt.pix.height > MODE_XGA_HEIGHT))		&&		\
+				((cam->cam_sensor.fmt.fmt.pix.width < MAX_OV3640_WIDTH)		||		\
+				(cam->cam_sensor.fmt.fmt.pix.height < MAX_OV3640_HEIGHT))))
+			{
+				cam->cam_sensor.fmt.fmt.pix.width	= MAX_OV3640_WIDTH;
+				cam->cam_sensor.fmt.fmt.pix.height	= MAX_OV3640_HEIGHT;
+			}
+/*
+ * Fixing the sensor frame supported limits
+ */
+			cam->cam_sensor.fmt.fmt.pix.width		+=((cam->cam_sensor.fmt.fmt.pix.width%16)?
+										(16-(cam->cam_sensor.fmt.fmt.pix.width%16)):0);
+			if(cam->cam_sensor.fmt.fmt.pix.width	> MAX_OV3640_WIDTH)
+			{
+				cam->cam_sensor.fmt.fmt.pix.width	= MAX_OV3640_WIDTH;
+			}else if(cam->cam_sensor.fmt.fmt.pix.width < MIN_OV3640_WIDTH)
+			{
+				cam->cam_sensor.fmt.fmt.pix.width	= MIN_OV3640_WIDTH;
+			}
+			
+			if(cam->cam_sensor.fmt.fmt.pix.height > MAX_OV3640_HEIGHT)
+			{
+				cam->cam_sensor.fmt.fmt.pix.height	= MAX_OV3640_HEIGHT;
+			}else if(cam->cam_sensor.fmt.fmt.pix.height < MIN_OV3640_HEIGHT)
+			{
+				cam->cam_sensor.fmt.fmt.pix.height	= MIN_OV3640_HEIGHT;
+			}
+
+			ret_val	= chk_pix_format_support(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);					
+			}
+			return SUCCESS;
+		}break;
+#if 0
+		case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+		{
+			
+		}break;
+#endif		
+		default:
+		{
+			printk(KERN_DEBUG "Unsupported format type : %x \n",cam->cam_sensor.fmt.type);
+			TRACE_ERR_AND_RET(FAIL);					
+
+		}
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ ************************************************************************************************************/
+FNRESLT ov3640_register_access(cam_data *cam)
+{
+	FNRESLT ret_val;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT32 reg_address;
+			UINT8 reg_value;
+
+			reg_address	= (cam->ctrl.value & 0xFFFF0000)>>16;
+			ret_val	= ov3640_read_reg(reg_address,&reg_value);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				return ret_val;
+			}
+			cam->ctrl.value	= (0xFFFF0000 & (reg_address << 16)) | reg_value;
+		}break;
+
+		case SET_DATA:
+		{
+			UINT32 reg_address;
+			UINT8 reg_value;
+			FNRESLT ret_val;
+
+			reg_address	= (cam->ctrl.value & 0xFFFF0000)>>16;
+			reg_value	= (cam->ctrl.value & 0x000000FF);
+			ret_val	= ov3640_write_reg(reg_address,reg_value);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				return ret_val;
+			}
+		}
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	register_sensor_bus
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT register_sensor_bus(cam_data *cam)
+{
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	cam->cam_sensor.init			= ov3640_init;
+	cam->cam_sensor.exit			= ov3640_exit;
+	cam->cam_sensor.find_device		= ov3640_detect_device;
+
+	cam->cam_sensor.reset			= ov3640_reset_config;
+	cam->cam_sensor.config_dim		= ov3640_change_dim_config;
+	cam->cam_sensor.brightness		= ov3640_brightness;			
+	cam->cam_sensor.contrast		= ov3640_contrast;
+	cam->cam_sensor.saturation		= ov3640_saturation;
+	cam->cam_sensor.hue			= NULL;
+	cam->cam_sensor.whitebalance		= ov3640_white_balance;
+	cam->cam_sensor.colour_balance		= NULL;
+	cam->cam_sensor.exposure		= ov3640_exposure;
+	cam->cam_sensor.gain			= NULL;
+	cam->cam_sensor.v_flip			= ov3640_vertical_flip;
+	cam->cam_sensor.h_mirror		= ov3640_horizontal_mirror;
+	cam->cam_sensor.sharpness		= ov3640_sharpness;
+	cam->cam_sensor.sens_strobe		= ov3640_sens_strobe;
+	cam->cam_sensor.auto_focus_init		= ov3640_af_firmware_dump;
+	cam->cam_sensor.focus			= ov3640_focus;
+	cam->cam_sensor.test_color_pattern	= ov3640_color_pattern;
+	cam->cam_sensor.effects			= ov3640_effects;
+	cam->cam_sensor.antishake		= ov3640_antishake_firmware_ctrl;
+	cam->cam_sensor.frame_rate_ctrl		= ov3640_frame_rate_ctrl;
+	cam->cam_sensor.supported_formats	= ov3640_format_support;
+	cam->cam_sensor.frame_interval		= ov3640_frame_interval_support;
+
+	cam->cam_sensor.crop			= ov3640_crop;
+	cam->cam_sensor.fix_fmt_support		= ov3640_fix_supported_formats;
+	cam->cam_sensor.qfmt_support		= ov3640_query_formats;
+
+	cam->cam_sensor.reg_access		= ov3640_register_access;
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/ov3640/sens_ov3640.h linux-ths/drivers/media/video/ecam32/ov3640/sens_ov3640.h
--- linux-org/drivers/media/video/ecam32/ov3640/sens_ov3640.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/ov3640/sens_ov3640.h	2011-12-21 12:36:18.000000000 +0100
@@ -0,0 +1,136 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+#define RESET_GPIO			98
+
+#if (	defined(CONFIG_BOARD_e_CAM32_OMAP35x_MICRON)			| \
+	defined(CONFIG_BOARD_e_CAM32_DM37x))
+	#define STANDBY_GPIO		157
+#elif (defined(CONFIG_BOARD_e_CAM32_OMAP35x) | defined(CONFIG_BOARD_e_CAM32_OMAP_GSTIX))
+	#define STANDBY_GPIO		167
+#endif
+
+#define OV3640_DEVICE_ID		0x36
+/*
+ * I2C
+ */
+
+#define OV3640_I2C_ADDRESS		0x3C
+#define I2C_SLAVE_ADDRESS		OV3640_I2C_ADDRESS
+
+
+#define FRM_CRPT_OV3640_WIDTH		1280
+#define FRM_CRPT_OV3640_HEIGHT		1024
+
+#define MAX_OV3640_WIDTH		2048
+#define MAX_OV3640_HEIGHT		1536
+
+#define MIN_OV3640_WIDTH		 160
+#define MIN_OV3640_HEIGHT		 120
+
+#define MODE_XGA_WIDTH			1024
+#define MODE_XGA_HEIGHT			 768
+
+#define SENS_MAX_FPS			  30
+#define SENS_MAX_PCLK_SUPPORT	    56000000
+
+#define SENS_DEFAULT_WIDTH		MIN_OV3640_WIDTH
+#define SENS_DEFAULT_HEIGHT		MIN_OV3640_HEIGHT
+
+/*
+ * Auto focus status register
+ */
+#define STEP_FORWARD			(1 << 7)
+#define STEP_BACKWARD			(1 << 6)
+#define STEP_ABSOLUTE			(1 << 5)
+
+#define MODE_STEP_INSTRUCTION		0x00
+#define MODE_STEP_FOCUSING		0x01
+#define MODE_STEP_FOCUSED		0x02
+#define MODE_STEP_CAPTURE		0x03
+
+#define MODE_IDLE			0x00
+#define MODE_SINGLE_FOCUS		0x01
+#define MODE_CONTINOUS_FOCUS		0x02
+#define MODE_STEP_MODE			0x03
+
+typedef union _auto_focus_register_status
+{
+	UINT8 reg_data;
+	struct
+	{
+/*
+ * Mode Step
+ * 	0 0	- Instruction 
+ * 	0 1	- Focusing
+ * 	1 0 	- Focused
+ * 	1 1	- Capture	 
+ */
+		UINT8 mode_step	:2;
+/*
+ * Mode
+ * 	0 0 	- Idle Mode
+ * 	0 1 	- Single Focus Mode
+ * 	1 0 	- Continue Focus Mode
+ * 	1 1 	- Step Mode
+ */
+
+
+		UINT8 mode		:2;
+		UINT8 RESERVED		:1;
+		UINT8 capture_mask	:1;
+		UINT8 mode_chg_mask	:1;
+/*
+ * 	Step State 
+ * 	1	- Failed 
+ * 	0	- Success
+ */
+		UINT8 step_state	:1;
+	}focus;
+}af_status;
+
+enum __effects
+{
+	EFFECT_NORMAL,
+	EFFECT_SEPIA,
+	EFFECT_MONOCHROME,
+	EFFECT_NEGATIVE,
+	EFFECT_BLUISH,
+	EFFECT_GREENISH,
+	EFFECT_REDDISH,
+	EFFECT_YELLOWISH,
+};
+
+enum __test_pattern
+{
+	TEST_PATTERN_COLOR_BAR,
+	TEST_PATTERN_DISABLE,
+};
+
diff -Naur linux-org/drivers/media/video/ecam32/resource/include/error.h linux-ths/drivers/media/video/ecam32/resource/include/error.h
--- linux-org/drivers/media/video/ecam32/resource/include/error.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/include/error.h	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,259 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :         Error code management                                                *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 0.0.0.0   code development                                                         Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+/******************************************************************************
+ *  			GENDRAL ERROR TYPE DEFINITION
+ *				
+ *  Author	:	E-consystems
+ *
+ *
+ ******************************************************************************/
+
+#define TRACE_ERROR(ARG1) 											\
+{														\
+	trace_error(__FILE__,(PINT8)__FUNCTION__,__LINE__,ARG1);						\
+}
+
+#define TRACE_ERR_AND_RET(ARG1) 										\
+{														\
+	trace_error(__FILE__,(PINT8)__FUNCTION__,__LINE__,ARG1);						\
+	return ARG1;												\
+}
+
+/******************************************************************************
+ * 			Device structure register 
+ *
+ ******************************************************************************/
+
+#define REGISTER_DATA			0x00000001			
+#define UNREGISTER_CLEAR_ENTRY		0x00000002
+#define GET_REGISTERED_DATA		0x00000003
+
+#define NO_DATA				0x00000000
+#define RESET_TIME			0x00000001
+
+#define ERROR_BLOCK			0x00100000
+
+/******************************************************************************
+ *  				API RETURN TYPE Definition 
+ *				
+ *  Author		:	E-consystems
+ *
+ *  APPLICATION SPECIFIC SUCCESS      RANGE - (0x0000_0000 - 0x3FFF_FFFF)
+ *  =========================================================================
+ *
+ *
+ *  DRIVER SPECIFIC SUCCESS BASES     RANGE - (0x4000_0000 - 0x7FFF_FFFF)
+ *  =========================================================================
+ *  BASIC SUCCESS	:	0x7EE0_0000 - 0x7EEF_FFFF
+ *  I2C SUCCESS		:	0x7ED0_0000 - 0x7EDF_FFFF
+ *
+ *  ----------------------------------------------------------------------------
+ *
+ *
+ *  DRIVER SPECIFIC ERRORS            RANGE - (0x8000_0000 - 0xBFFF_FFFF)
+ *  =========================================================================
+ *  BASIC ERRORS	:	0x8000_0000 - 0x800F_FFFF
+ *  I2C ERROR		:	0x8010_0000 - 0x801F_FFFF
+ *  MEMORY ERROR	:	0x8020_0000 - 0x802F_FFFF
+ *
+ *  APPLICATION SPECIFIC ERRORS BASES:RANGE - (0xC000_0000 - 0xFF7F_FFFF)
+ *  =========================================================================
+ *  BASIC ERROR 	:	0xC000_0000 - 0xC00F_FFFF
+ *  READ ERROR		:	0xC010_0000 - 0xC01F_FFFF 
+ *  WRITE ERROR 	:	0xC020_0000 - 0xC02F_FFFF 
+ *  memory ERROR	:	0xC030_0000 - 0xC03F_FFFF
+ *  Ioctls ERROR	:	0xC040_0000 - 0xC04F_FFFF
+ *  =========================================================================
+ *
+ *
+ *  SPECIAL ERROR	:	0xFF80_0000 - 0xFFFF_FFFF
+ *
+ ******************************************************************************/
+
+
+enum __error_base_macro
+{
+	APP_BASE_SUC_START	= 0x00000000,
+	APP_BASE_SUC_END	= 0x3FFFFFFF,
+	DRI_BASE_SUC_START	= 0x40000000,
+	DRI_BASE_SUC_END	= 0x7FFFFFFF,
+
+	DRI_BASE_ERR_START	= 0x80000000,
+	DRI_BASIC_ERR		= DRI_BASE_ERR_START,
+	DRI_I2C_ERROR		= (DRI_BASIC_ERR + ERROR_BLOCK),
+	DRI_MEM_ERROR		= (DRI_I2C_ERROR + ERROR_BLOCK),
+
+	DRI_BASE_ERR_END	= 0xBFFFFFFF,
+
+	APP_BASE_ERR_START	= 0xC0000000,
+	APP_BASIC_ERR		= APP_BASE_ERR_START,
+	APP_READ_ERR		= (APP_BASIC_ERR	+ ERROR_BLOCK),
+	APP_WRITE_ERR		= (APP_READ_ERR		+ ERROR_BLOCK),
+	APP_MEMORY_ERR		= (APP_WRITE_ERR	+ ERROR_BLOCK),
+	APP_IOCTL_ERR		= (APP_MEMORY_ERR	+ ERROR_BLOCK),
+	APP_BASE_ERR_END	= 0xFF7FFFFF,
+
+	SPECIAL_ERROR_START	= 0xFF800000,
+	SPECIAL_ERROR_END	= 0xFFFFFFFF,
+};
+
+#define CHECK_IN_SUCCESS_LIMIT(x)			((x >= (FNRESLT)APP_BASE_SUC_START) && (x <= (FNRESLT)DRI_BASE_SUC_END))
+#define CHECK_IN_FAIL_LIMIT(x)				((x >= (FNRESLT)DRI_BASE_ERR_START ) && (x <= (FNRESLT)SPECIAL_ERROR_END))
+
+enum __error_base
+{
+/****************************************************************************
+ *
+ * 		Application Specific SUCCESS code definitions
+ *
+ ****************************************************************************/
+
+	SUCCESS				= APP_BASE_SUC_START,
+
+/****************************************************************************
+ *
+ * 		Driver Specific SUCCESS code definitions
+ *
+ ****************************************************************************/
+	I2C_INIT_SUCCESS		= DRI_BASE_SUC_START,
+	I2C_TX_EMPTY_SEND_SUCCESS,
+	I2C_WRITE_SUCCESS,
+	I2C_RX_FULL_SUCCESS,
+	I2C_READ_SUCCESS,
+	I2C_CAM_READ_REGISTER_SUCCESS,
+	I2C_PROTO_READ_ID_SUCCESS,
+	PAGE_0_REG_ACCESS_SUCCESS,
+	PAGE_1_REG_ACCESS_SUCCESS,
+	PAGE_2_REG_ACCESS_SUCCESS,
+	MT9D111_DUMP_ALL_SUCCESS,
+	MT9D111_SOFT_RESET_SUCCESS,
+	I2C_BUS_AVAILABLE,
+
+/****************************************************************************
+ *
+ * 		Driver Specific Error code definitions
+ *
+ ****************************************************************************/
+
+/*
+ * BASIC ERROR definition
+ */
+	DRIVER_MEMORY_NOT_AVAILABLE	= DRI_BASIC_ERR,
+
+/*
+ * I2C ERROR definition
+ */
+	I2C_INIT_FAIL			= DRI_I2C_ERROR,
+	I2C_TX_EMPTY_SEND_FAIL,
+	I2C_WRITE_FAIL,
+	I2C_RX_FULL_FAIL,
+	I2C_READ_FAIL,
+	I2C_CAM_READ_REGISTER_FAIL,
+	I2C_PROTO_READ_ID_FAIL,
+	PAGE_0_REG_ACCESS_FAIL,
+	PAGE_1_REG_ACCESS_FAIL,
+	PAGE_2_REG_ACCESS_FAIL,
+	MT9D111_SOFT_RESET_FAIL,
+	CLK_BYPASS_PLL_FAIL,
+	MCU_RESET_VALUE_FAIL,
+	RESET_EN_REG_VALUE_FAIL,
+	RESET_DIS_REG_VALUE_FAIL,
+	I2C_BUS_BUSY,
+
+/*
+ * Memory Error definition
+ */
+	MEM_KERN_OVERLAP		= DRI_MEM_ERROR,
+	
+/****************************************************************************
+ *
+ *			Application based error types
+ *
+ ****************************************************************************/
+
+/*
+ * BASIC ERROR definition
+ */
+
+	PORT_OPEN_FAILURE		= APP_BASIC_ERR,
+	FILE_OPEN_FAILURE,
+
+/*
+ * READ ERROR definition
+ */
+
+	READ_ERROR			= APP_READ_ERR,
+	LOOSING_BYTES_IN_READ,
+	LESS_NUM_BYTE_READ,
+	MORE_NUM_BYTE_READ,
+	LESS_NUMBER_BYTE_IN_PORT,
+	READ_FROM_DEVICE_FAIL,
+
+/*
+ * WRITE ERROR definition
+ */
+	WRITE_ERROR			= APP_WRITE_ERR,
+	LESS_NUM_BYTE_WRITE,
+	MORE_NUM_BYTE_WRITE,
+	FAILED_TO_WRITE_TO_PORT,
+
+
+/*
+ * MEMORY ERROR definition
+ */
+	MEMORY_ERROR			= APP_MEMORY_ERR,
+	ALLOCATION_MEMORY_FAILED,
+	MEMORY_NOT_VALID,
+
+/*
+ * IOCTLS ERROR definition
+ */
+	IOCTLS_ERROR			= APP_IOCTL_ERR,
+	DATA_FRM_PORT_NOT_VALID,
+	IOCTL_GET_DATA_FAILED,
+	IOCTL_LOGING_DATA_FAILED,
+
+/*
+ * Special type of Errors
+ */
+	CAPTURE_FORMAT_NOT_AVAILABLE	= SPECIAL_ERROR_START,
+	MAPPING_FAILED,
+	POINTER_NOT_REGISTERED,
+	ALLOCATION_MEMORY_FAILED_BASED_POINTER,
+
+
+	PORT_OPEN_ERROR			= -1,
+	FAIL				= -1,
+
+};
+
+
diff -Naur linux-org/drivers/media/video/ecam32/resource/include/fn_res_protype.h linux-ths/drivers/media/video/ecam32/resource/include/fn_res_protype.h
--- linux-org/drivers/media/video/ecam32/resource/include/fn_res_protype.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/include/fn_res_protype.h	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,72 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :         Error code management                                                *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 0.0.0.0   code development                                                         Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * *********************************************************************************************************
+ *
+ * 			FUNCTION PROTO TYPE USED IN THE RESOURCE PROJECT
+ *
+ * *********************************************************************************************************
+ */
+
+/*
+ * common.c
+ */
+
+PINT0 map_kernel_space(ULINT32 physaddr, UINT32 size);
+INT32 unmap_kernel_space(volatile PINT0 start, size_t length);
+FNRESLT printstring(IN UPINT8 string,IN UINT32 string_length);
+
+/*
+ * error.c
+ */
+
+FNRESLT_NONE trace_error(PINT8 file_name,PINT8 function_name,UINT32 line_no,UINT32 Error_num);
+
+/*
+ * memory_monitor.c
+ */
+
+PINT0 wrapper_memory_api(UPINT8 function_name,UINT32 lineno,UDPINT32 address,UINT32 size,UINT32 block,UINT32 status);
+FNRESLT check_pointer_availability(UPINT32 list_memory,UINT32 count,UPINT32 pointer,UPINT32 current_record);
+FNRESLT maintain_log(UPINT8 function_name,UINT32 lineno,UDPINT32 pointer,UINT32 allocation_memory_size,UINT32 block_size,UINT32 status);
+
+#if defined(CONFIG_DRIVER)
+/*
+ * phy_mem.c
+ */
+	FNRESLT list_all_phy_struct(INT0);
+	FNRESLT free_all_phy_struct(INT0);
+	FNRESLT free_phy_mem(UINT32 phy_addr);
+	FNRESLT get_free_phy_mem(UINT32 size,UPINT32 phy_addr,UPINT32 vir_addr);
+	FNRESLT init_phy_mem(INT0);
+	FNRESLT exit_phy_mem(INT0);
+
+#endif
diff -Naur linux-org/drivers/media/video/ecam32/resource/include/Headerfile.h linux-ths/drivers/media/video/ecam32/resource/include/Headerfile.h
--- linux-org/drivers/media/video/ecam32/resource/include/Headerfile.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/include/Headerfile.h	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,218 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :      Gendral Header file incluton                                            *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 0.0.0.0   code development                                                         Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * Custom header file
+ */
+#include "typedef.h"
+
+
+/*
+ * Application Part Header 
+ */
+
+
+#ifdef CONFIG_APPLICATION
+/*
+ * Standard Header file
+ */
+
+	#ifdef HAVE_CONFIG_H
+		#include <config.h>
+	#endif
+
+	#include <stdio.h>
+	#include <stdlib.h>
+	#include <string.h>
+	#include <fcntl.h>
+	#include <termios.h>
+	#include <unistd.h>
+
+	#include <sys/types.h>
+	#include <sys/stat.h>
+	#include <sys/time.h>
+	#include <sys/ioctl.h>
+	#include <sys/mman.h>
+
+/*
+ * include custom header file
+ */
+	#ifdef HAVE_IOCTL_DEF 
+		#include "ioctls_def.h"
+	#endif
+#endif
+
+/*
+ * Driver Part Header file 
+ */
+#ifdef CONFIG_DRIVER
+	#include <linux/init.h>
+	#include <linux/module.h>
+	#include <linux/kernel.h> 		// printk() 
+	#include <linux/slab.h> 		// kmalloc() 
+	#include <linux/fs.h> 			// everything\ldots{} 
+	#include <linux/errno.h> 		// error codes 
+	#include <linux/types.h> 		// size_t 
+	#include <linux/proc_fs.h>
+	#include <linux/fcntl.h>		// O_ACCMODE 
+	#include <linux/ioport.h>
+	#include <asm/system.h>			// cli(), *_flags 
+	#include <asm/uaccess.h>		// copy_from/to_user 
+	#include <asm/io.h>			// inb, outb 
+	#include <linux/interrupt.h>
+	#include <linux/types.h>
+	#include <asm/types.h>
+	#include <linux/delay.h>		// for udelay()
+	#include <asm/delay.h>
+	#include <linux/unistd.h>
+	#include <linux/device.h>
+	#include <asm/dma.h>
+	#include <linux/version.h>
+	#include <linux/i2c.h>
+	#include <linux/platform_device.h>
+	#include <linux/clk.h>
+	#include <linux/page-flags.h>
+	#include <linux/mm.h>
+
+	#ifdef USE_KERNEL_MEMORY_MANAGE
+		#include "kernel/phy_mem.h"
+	#endif
+
+	#ifdef USE_KERNEL_THREAD
+		#include <linux/kthread.h>
+		#include <linux/mutex.h>
+	#endif
+
+	#ifdef KERNEL_ARM_PXA270
+		#include <asm/arch/pxa-regs.h>
+		#include <asm/arch/irqs.h>
+		#include <asm-arm/arch-pxa/dma.h>
+		#include <asm-arm/page.h>
+
+		#ifdef CONFIG_KERNEL_2_6_15_2
+			#include <linux/config.h>
+		#else
+			#include <linux/autoconf.h>
+		#endif
+
+	#endif
+
+	#ifdef KERNEL_ARM_OMAP
+		#ifdef KERNEL_ARM_OMAP3530
+		#endif
+	#endif
+
+	#ifdef KERNEL_ARM_IMX31
+		#ifdef CONFIG_KERNEL_2_6_19_2
+		#endif
+
+		#ifdef CONFIG_KERNEL_2_6_22
+			#include <asm/arch/mx31_pins.h>
+			
+			#ifndef __MACH_MX31_IOMUX_H__
+				#define __MACH_MX31_IOMUX_H__
+			#endif
+			#include <asm/arch/mxc_i2c.h>
+			#include <asm/arch/pmic_power.h>
+			
+		#endif
+	#endif
+#endif
+
+/*
+ * boot loader part header file
+ */
+#if defined(CONFIG_BOOT_LOADER)
+	#if defined(CONFIG_BOOT_UBOOT_1_1_3)
+		#include <common.h>
+		#include <command.h>
+		#include <asm/io.h>
+		#include <asm/arch/hardware.h> 
+		#include <asm/sizes.h>
+		#include <malloc.h>
+
+	#endif
+#endif
+
+/*
+ * custom definition here
+ */
+#define OUT
+#define IN
+
+#define DISABLE		0x0
+#define ENABLE		0x1
+
+
+/*
+ * include custom header file
+ */
+#include "error.h"
+
+#ifdef CONFIG_USE_MEMORY_MONITOR
+	#include "memory_monitor.h"
+
+	#define malloc(alloc_size) 									\
+			wrapper_memory_api((UPINT8)__FUNCTION__,__LINE__,				\
+			NULL,alloc_size,1,MALLOC_MEMORY)
+
+	#define calloc(alloc_size,alloc_block) 								\
+			wrapper_memory_api((UPINT8)__FUNCTION__,__LINE__,				\
+			NULL,alloc_size,alloc_block,CALLOC_MEMORY);
+
+	#define realloc(ptr,alloc_size) 								\
+			wrapper_memory_api((UPINT8)__FUNCTION__,__LINE__,				\
+			(UDPINT32)&ptr,alloc_size,1,REALLOC_MEMORY);
+
+	#define free(address) 										\
+			wrapper_memory_api((UPINT8)__FUNCTION__,__LINE__,				\
+			(UDPINT32)&address,0,0,FREE_MEMORY);
+#endif
+
+#include "fn_res_protype.h"
+
+#if defined(CONFIG_RETURN_APPLICATION_DEBUG)
+	#define return  										\
+	{												\
+		TRACE_ERROR(ret_val);									\
+		#if defined(CONFIG_APPLICATION_TRACE)							\
+		{											\
+		}											\
+		#endif											\
+	}return	
+#endif
+
+#define ENABLED			0x01
+#define DISABLED		0x00
+
+#define SET_ADDRESS 		0x01
+#define GET_ADDRESS 		0x02
+#define MAKE_ADDRESS_INVALID	0x04
+#define CREATE_ADDRESS		0x08
diff -Naur linux-org/drivers/media/video/ecam32/resource/include/kernel/phy_mem.h linux-ths/drivers/media/video/ecam32/resource/include/kernel/phy_mem.h
--- linux-org/drivers/media/video/ecam32/resource/include/kernel/phy_mem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/include/kernel/phy_mem.h	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,54 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        Memory Management in kernel level                                     *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+#ifndef __PHY_MEM_
+#define __PHY_MEM_
+
+#define GET_MEM_NODE				0x01
+#define SET_MEM_NODE				0x02
+
+#define ENABLE					0x1
+#define DISABLE					0x0
+
+struct dma_memory
+{
+	struct dma_memory *next;
+
+	UINT32 size;
+
+	UINT32 virtual_address;
+	UINT32 address_start;
+
+	UINT32 address_end;
+
+	struct dma_memory *back;
+};
+
+#endif
diff -Naur linux-org/drivers/media/video/ecam32/resource/include/typedef.h linux-ths/drivers/media/video/ecam32/resource/include/typedef.h
--- linux-org/drivers/media/video/ecam32/resource/include/typedef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/include/typedef.h	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,117 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems.                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        Defined variable types                                                *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 0.0.0.0   code development                                                         Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*		
+ *		Char
+ */
+
+typedef char			INT8;
+typedef unsigned char		UINT8;
+typedef signed char		SINT8;
+
+typedef char*			PINT8;
+typedef unsigned char*		UPINT8;
+typedef signed char*		SPINT8;
+
+typedef char**			DPINT8;
+typedef unsigned char**		UDPINT8;
+typedef signed char**		SDPINT8;
+typedef const char*		CPINT8;
+
+typedef UINT8			BOOL;
+
+/*
+ * 		Int
+ */
+typedef int			INT32;
+typedef unsigned int		UINT32;
+typedef signed int		SINT32;
+
+typedef int*			PINT32;
+typedef unsigned int*		UPINT32;
+typedef signed int*		SPINT32;
+
+typedef int**			DPINT32;
+typedef unsigned int**		UDPINT32;
+typedef signed int**		SDPINT32;
+
+typedef volatile unsigned int	UVINT32;
+typedef INT32			FNRESLT;
+
+
+/*
+ *	Long
+ */
+
+typedef long			LINT32;
+typedef unsigned long		ULINT32;
+/*
+ *	long long int
+ */
+typedef long long int		INT64;
+typedef long long int*		PINT64;
+typedef unsigned long long int	UINT64;
+typedef unsigned long long int* UPINT64;
+
+/*
+ *		short
+ */
+typedef short			INT16;
+typedef unsigned short		UINT16;
+typedef signed short		SINT16;
+
+typedef short*			PINT16;
+typedef unsigned short*		UPINT16;
+typedef signed short*		SPINT16;
+
+typedef short**			DPINT16;
+typedef unsigned short**	UDPINT16;
+typedef signed short**		SDPINT16;
+
+typedef volatile unsigned short	UVINT16;
+
+
+/*
+ *		void
+ */
+typedef void			INT0;
+typedef void*			PINT0;
+typedef void**			DPINT0;
+typedef INT0			FNRESLT_NONE;
+
+typedef unsigned short 		WORD;
+typedef unsigned int		DWORD;
+typedef int 			LONG;
+
+/*
+ * 		float
+ */
+
+
diff -Naur linux-org/drivers/media/video/ecam32/resource/src/error.c linux-ths/drivers/media/video/ecam32/resource/src/error.c
--- linux-org/drivers/media/video/ecam32/resource/src/error.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/src/error.c	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,384 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :          Error code management                                               *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ *
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * Header file inclution part
+ */
+
+#include "../../inc_header.h"
+#ifdef CONFIG_APPLICATION
+	#define printf(x...) printf(x)
+	#define KERN_DEBUG ""
+#endif
+#ifdef CONFIG_DRIVER
+	#define printf(x...) printk(KERN_DEBUG x)	
+#endif	
+/******************************************************************************
+ *  				 Function 
+ *				
+ *  Name	:	trace_error
+ *  Author	:	E-consystems
+ *  Parameter1	:	UINT32 - Error number
+ *  Returns	:	NONE
+ *  Description	:	error from various device are classified into groups and 
+ *  			debugged over here 
+ *  Comments	:  				 	
+ ******************************************************************************/
+#define TEP(file_name,function_name,line_no,Error_number,Error_number_in_string,Reason_in_string) 			\
+															\
+	case Error_number:												\
+	{														\
+		printf(KERN_DEBUG "-------------------------------------------------------------------------------\n");	\
+		printf(KERN_ERR   "ERROR!\n");										\
+		printf(KERN_DEBUG "From            : %s\n",MODULE_NAME);						\
+		printf(KERN_DEBUG "File            : %s\n",file_name);							\
+		printf(KERN_ERR   "Function        : %s\n",function_name);						\
+		printf(KERN_ERR   "Line number     : %u\n",line_no);							\
+		printf(KERN_DEBUG "Error name      : %s\n",Error_number_in_string);					\
+		printf(KERN_DEBUG "Error number Dec: %lld Hex: 0x%X \n",(INT64)Error_number,(INT32)Error_number);	\
+		printf(KERN_ERR   "Reason          : %s\n",Reason_in_string);						\
+		printf(KERN_DEBUG "------------------------------------------------------------------------------\n");	\
+		break;													\
+	}	
+
+#define TEP_DEFAULT(file_name,function_name,line_no,Error_number_in_string,Reason_in_string) 				\
+															\
+	default :													\
+	{														\
+		printf(KERN_DEBUG "------------------------------------------------------------------------------\n");	\
+		printf(KERN_ERR   "ERROR!\n");										\
+		printf(KERN_DEBUG "From            : %s\n",MODULE_NAME);						\
+		printf(KERN_DEBUG "File            : %s\n",file_name);							\
+		printf(KERN_ERR   "Function        : %s\n",function_name);						\
+		printf(KERN_ERR   "Line number     : %u\n",line_no);							\
+		printf(KERN_ERR   "Reason          : %s\n",Reason_in_string);						\
+		printf(KERN_DEBUG "------------------------------------------------------------------------------\n");	\
+		break;													\
+	}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	trace_error 
+ *  Parameter1	:	PINT8 file_name 
+ *  Parameter2	:	PINT8 function_name 
+ *  Parameter3	:	UINT32 line_no
+ *  Parameter4	:	UINT32 Error_num
+ *  
+ *  Returns	:	FNRESLT_NONE
+ *  Description	: 	
+ *  Comments	:  	Based on the error Number, Debug prints will be called.
+ ************************************************************************************************************/
+FNRESLT_NONE trace_error(PINT8 file_name,PINT8 function_name,UINT32 line_no,UINT32 Error_num)
+{
+	switch(Error_num)
+	{
+/*
+ * Success return Values
+ */
+		TEP(file_name,function_name,line_no,SUCCESS,"SUCCESS",							\
+				"Got a positive feedback from the module just debug lines");
+/*
+ * Special type of Errors
+ */
+#if 0
+		TEP(file_name,function_name,line_no,-EPERM,"EPERM",							\
+				"Operation not permitted ");
+#endif
+
+#if defined(CONFIG_KERNEL_ERR_INCLUDED)
+		TEP(file_name,function_name,line_no,-ENOENT,"ENOENT",							\
+				"No such file or directory ");
+		TEP(file_name,function_name,line_no,-ESRCH,"ESRCH",							\
+				"No such process");
+		TEP(file_name,function_name,line_no,-EINTR,"EINTR",							\
+				"Interrupted system call");
+		TEP(file_name,function_name,line_no,-EIO,"EIO",								\
+				"I/O error");
+		TEP(file_name,function_name,line_no,-ENXIO,"ENXIO",							\
+				"No such device or address");
+		TEP(file_name,function_name,line_no,-E2BIG,"E2BIG",							\
+				"Argument list too long");
+		TEP(file_name,function_name,line_no,-ENOEXEC,"ENOEXEC",							\
+				"Exec format error ");
+		TEP(file_name,function_name,line_no,-EBADF,"EBADF",							\
+				"Bad file number");
+		TEP(file_name,function_name,line_no,-ECHILD,"ECHILD",							\
+				"No child processes");
+		TEP(file_name,function_name,line_no,-EAGAIN,"EAGAIN",							\
+				"Try again");
+		TEP(file_name,function_name,line_no,-ENOMEM,"ENOMEM",							\
+				"Out of memory");
+		TEP(file_name,function_name,line_no,-EACCES,"EACCES",							\
+				"Permission denied");
+		TEP(file_name,function_name,line_no,-EFAULT,"EFAULT",							\
+				"Bad address");
+		TEP(file_name,function_name,line_no,-ENOTBLK,"ENOTBLK",							\
+				"Block device required");
+		TEP(file_name,function_name,line_no,-EBUSY,"EBUSY",							\
+				"Device or resource busy");
+		TEP(file_name,function_name,line_no,-EEXIST,"EEXIST",							\
+				"File exists");
+		TEP(file_name,function_name,line_no,-EXDEV,"EXDEV",							\
+				"Cross-device link");
+		TEP(file_name,function_name,line_no,-ENODEV,"ENODEV",							\
+				"No such device");
+		TEP(file_name,function_name,line_no,-ENOTDIR,"ENOTDIR",							\
+				"Not a directory");
+		TEP(file_name,function_name,line_no,-EISDIR,"EISDIR",							\
+				"Is a directory");
+		TEP(file_name,function_name,line_no,-EINVAL,"EINVAL",							\
+				"Invalid argument");
+		TEP(file_name,function_name,line_no,-ENFILE,"ENFILE",							\
+				"File table overflow");
+		TEP(file_name,function_name,line_no,-EMFILE,"EMFILE",							\
+				"Too many open files");
+		TEP(file_name,function_name,line_no,-ENOTTY,"ENOTTY",							\
+				"Not a typewriter");
+		TEP(file_name,function_name,line_no,-ETXTBSY,"ETXTBSY",							\
+				"Text file busy");
+		TEP(file_name,function_name,line_no,-EFBIG,"EFBIG",							\
+				"File too large");
+		TEP(file_name,function_name,line_no,-ENOSPC,"ENOSPC",							\
+				"No space left on device");
+		TEP(file_name,function_name,line_no,-ESPIPE,"ESPIPE",							\
+				"Illegal seek");
+		TEP(file_name,function_name,line_no,-EROFS,"EROFS",							\
+				"Read-only file system");
+		TEP(file_name,function_name,line_no,-EMLINK,"EMLINK",							\
+				"Too many links");
+		TEP(file_name,function_name,line_no,-EPIPE,"EPIPE",							\
+				"Broken pipe");
+		TEP(file_name,function_name,line_no,-EDOM,"EDOM",							\
+				"Math argument out of domain of func");
+		TEP(file_name,function_name,line_no,-ERANGE,"ERANGE",							\
+				"Math result not representable");
+#endif
+/*
+ *
+ * BASIC ERROR definition
+ */
+
+		TEP(file_name,function_name,line_no,FAIL,"1. PORT_OPEN_ERROR 2. FAIL 3.EPERM",				\
+				"1. unknown cause of failure								\
+			\n\t\t 2. Failed to open the port may be driver is not properly inserted or file not found	\
+			\n\t\t 3. Operation not permitted");
+
+		TEP(file_name,function_name,line_no,PORT_OPEN_FAILURE,"PORT_OPEN_FAILURE",				\
+				"Cannot open the port, Driver is not properly inserted or device entry missing");
+
+		TEP(file_name,function_name,line_no,FILE_OPEN_FAILURE,"FILE_OPEN_FAILURE",				\
+				"Unable to open the file. Check the file presence");
+/*
+ * READ ERROR definition
+ */
+
+		TEP(file_name,function_name,line_no,LOOSING_BYTES_IN_READ,"LOOSING_BYTES_IN_READ",			\
+				"Some other device or thread reading the character form the allocated port ");
+
+		TEP(file_name,function_name,line_no,LESS_NUM_BYTE_READ,"LESS_NUM_BYTE_READ",				\
+				"less number of bytes read from the device from the checked one");
+
+		TEP(file_name,function_name,line_no,MORE_NUM_BYTE_READ,"MORE_NUM_BYTE_READ",				\
+				"More number of bytes read from the device from the checked one");
+
+		TEP(file_name,function_name,line_no,LESS_NUMBER_BYTE_IN_PORT,"LESS_NUMBER_BYTE_IN_PORT",		\
+				"In Port less number of bytes than expected one");
+/*
+ * WRITE ERROR definition
+ */
+
+		TEP(file_name,function_name,line_no,LESS_NUM_BYTE_WRITE,"LESS_NUM_BYTE_WRITE",				\
+				"less number of bytes Writted to the device");
+
+		TEP(file_name,function_name,line_no,MORE_NUM_BYTE_WRITE,"MORE_NUM_BYTE_WRITE",				\
+				"more number of bytes Writted to the device");
+
+		TEP(file_name,function_name,line_no,FAILED_TO_WRITE_TO_PORT,"FAILED_TO_WRITE_TO_PORT",			\
+				"Failed to write to device please try after some time");
+
+/*
+ * MEMORY ERROR definition
+ */
+		TEP(file_name,function_name,line_no,ALLOCATION_MEMORY_FAILED,"ALLOCATION_MEMORY_FAILED",		\
+				"Memory needed by the application not available under run time");
+		TEP(file_name,function_name,line_no,MEMORY_NOT_VALID,"MEMORY_NOT_VALID",				\
+				"Memory wish to access is invalid.. please try with valid memory");
+
+
+/*
+ * IOCTLS ERROR definition
+ */
+		TEP(file_name,function_name,line_no,DATA_FRM_PORT_NOT_VALID,"DATA_FRM_PORT_NOT_VALID",			\
+				"Not a vaid data from the ioctl");
+
+		TEP(file_name,function_name,line_no,IOCTL_GET_DATA_FAILED,"IOCTL_GET_DATA_FAILED",			\
+				"Getting data from ioctl failed please check the file descriptor");
+
+/*
+ * SPECIAL_APLICATION_ERROR definition
+ */
+
+		TEP(file_name,function_name,line_no,CAPTURE_FORMAT_NOT_AVAILABLE,"CAPTURE_FORMAT_NOT_AVAILABLE",	\
+				"Zoom value is too high so the output value is more than the available one");
+
+		TEP(file_name,function_name,line_no,MAPPING_FAILED,"MAPPING_FAILED",					\
+				"Mapping kernel space area to user space area failed");
+
+
+
+/******************************************************************************
+ *
+ * 		Driver Specific Error code definitions
+ *
+ ******************************************************************************/
+
+
+/*
+ * I2C definition
+ */
+		TEP(file_name,function_name,line_no,I2C_INIT_SUCCESS,"I2C_INIT_SUCCESS",				\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_TX_EMPTY_SEND_SUCCESS,"I2C_TX_EMPTY_SEND_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_WRITE_SUCCESS,"I2C_WRITE_SUCCESS",				\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_RX_FULL_SUCCESS,"I2C_RX_FULL_SUCCESS",				\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_READ_SUCCESS,"I2C_READ_SUCCESS",				\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_CAM_READ_REGISTER_SUCCESS,"I2C_CAM_READ_REGISTER_SUCCESS",	\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_PROTO_READ_ID_SUCCESS,"I2C_PROTO_READ_ID_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_0_REG_ACCESS_SUCCESS,"PAGE_0_REG_ACCESS_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_1_REG_ACCESS_SUCCESS,"PAGE_1_REG_ACCESS_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_2_REG_ACCESS_SUCCESS,"PAGE_2_REG_ACCESS_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,MT9D111_DUMP_ALL_SUCCESS,"MT9D111_DUMP_ALL_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,MT9D111_SOFT_RESET_SUCCESS,"MT9D111_SOFT_RESET_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_INIT_FAIL,"I2C_INIT_FAIL",					\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_TX_EMPTY_SEND_FAIL,"I2C_TX_EMPTY_SEND_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_WRITE_FAIL,"I2C_WRITE_FAIL",					\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_RX_FULL_FAIL,"I2C_RX_FULL_FAIL",				\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_READ_FAIL,"I2C_READ_FAIL",					\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_CAM_READ_REGISTER_FAIL,"I2C_CAM_READ_REGISTER_FAIL",		\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_PROTO_READ_ID_FAIL,"I2C_PROTO_READ_ID_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_0_REG_ACCESS_FAIL,"PAGE_0_REG_ACCESS_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_1_REG_ACCESS_FAIL,"PAGE_1_REG_ACCESS_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_2_REG_ACCESS_FAIL,"PAGE_2_REG_ACCESS_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,MT9D111_SOFT_RESET_FAIL,"MT9D111_SOFT_RESET_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,CLK_BYPASS_PLL_FAIL,"CLK_BYPASS_PLL_FAIL",				\
+				"");
+
+		TEP(file_name,function_name,line_no,MCU_RESET_VALUE_FAIL,"MCU_RESET_VALUE_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,RESET_EN_REG_VALUE_FAIL,"RESET_EN_REG_VALUE_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,RESET_DIS_REG_VALUE_FAIL,"RESET_DIS_REG_VALUE_FAIL",		\
+				"");
+/*
+ * Memory Error definition
+ */
+
+		TEP(file_name,function_name,line_no,MEM_KERN_OVERLAP,"MEM_KERN_OVERLAP",				\
+				"Kernel memory region is getting overlaped with the reserved memory region");
+
+
+/*
+ *
+ * Basic error types
+ */
+
+		TEP(file_name,function_name,line_no,DRIVER_MEMORY_NOT_AVAILABLE,"DRIVER_MEMORY_NOT_AVAILABLE",		\
+				"Memory size wish to allocate is not available, please increase the memory size");
+
+
+#if 0
+
+
+		TEP(file_name,function_name,line_no,,"",								\
+				"");
+
+		TEP(file_name,function_name,line_no,,"",								\
+				"");
+
+		TEP(file_name,function_name,line_no,,"",								\
+				"");
+#endif
+/*
+ * Unknown error 
+ */
+		TEP_DEFAULT(file_name,function_name,line_no,"UN KNOWN ERROR",						\
+				"An unidentified error is happening.. please report to code developer!");
+	}
+}
+
diff -Naur linux-org/drivers/media/video/ecam32/resource/src/kernel/phy_mem.c linux-ths/drivers/media/video/ecam32/resource/src/kernel/phy_mem.c
--- linux-org/drivers/media/video/ecam32/resource/src/kernel/phy_mem.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/src/kernel/phy_mem.c	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,602 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        Memory Management in kernel level                                     *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * Include Header file
+ */
+
+#include "../../../inc_header.h"
+
+/*
+ * Global variables
+ */
+static DEFINE_MUTEX(phy_memory_mutex);
+static UINT32 phy_addr_start	= DISABLE;
+static UINT32 phy_addr_end	= DISABLE;
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT get_mem_node(struct dma_memory **phy_mem ,UINT8 cond)
+{
+	static UINT32 phy_mem_res;
+
+	switch(cond)
+	{
+		case GET_MEM_NODE:
+		{
+			if(phy_mem == NULL)
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+	
+			if(phy_mem_res)
+			{
+				*phy_mem	= (struct dma_memory *)phy_mem_res;
+			}
+		}break;
+	
+		case SET_MEM_NODE:
+		{
+			phy_mem_res = (UINT32)*phy_mem;
+		}break;
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT list_all_phy_struct()
+{
+	struct dma_memory *phy_mem	= NULL;
+	struct dma_memory *phy_mem_next	= NULL;
+	FNRESLT ret_val;
+	UINT32 i;
+
+	ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+
+	printk("\n\n\nMem.no             Memstart                    Memend            Virtual address       Size\n");
+	for(i	= 0;phy_mem;i++)
+	{
+		phy_mem_next = phy_mem->next;
+		printk("%d                 0x%x                  0x%x        0x%x         0x%x          0x%x  0x%x\n",	\
+			i,(UINT32)phy_mem->address_start,(UINT32)phy_mem->address_end,(UINT32)phy_mem->virtual_address,	\
+			(UINT32)phy_mem->size,(UINT32)phy_mem,(UINT32)phy_mem_next);
+		phy_mem	= phy_mem_next;
+	}
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(list_all_phy_struct);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+
+FNRESLT get_free_phy_mem(UINT32 size,UPINT32 phy_addr,UPINT32 vir_addr)
+{
+	UINT32 addr_start		= phy_addr_start;
+	UINT32 addr_end			= phy_addr_end;
+	UINT32 mem_fnode_st;
+	UINT8 mem_fnode_flag		= DISABLE;
+
+	FNRESLT ret_val;
+
+	struct dma_memory *phy_mem	= NULL;
+	struct dma_memory *phy_mem_next	= NULL;
+	struct dma_memory *phy_new;
+	UINT32 case_link;
+
+	mutex_lock(&phy_memory_mutex);
+	{
+
+		ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			{
+			}mutex_unlock(&phy_memory_mutex);
+
+			return ret_val;
+		}
+
+//-----------------------------------------------------------------------------------------------------
+		if(addr_start&0xFFF)
+		{
+			addr_start	= addr_start + (0x1000 - (addr_start&0xFFF));
+		}
+//-----------------------------------------------------------------------------------------------------
+
+		if(phy_mem)
+		{
+			mem_fnode_st		= phy_mem->address_start -1;
+			if((mem_fnode_st > addr_start) && ((mem_fnode_st - addr_start) > size))
+			{
+				mem_fnode_flag = ENABLE;
+			}
+		}
+
+		for(;(phy_mem != NULL) && (mem_fnode_flag == DISABLE);)
+		{
+	
+			phy_mem_next		= phy_mem->next;
+			addr_start		= phy_mem->address_end +1;
+		
+			if(phy_mem_next)
+			{
+				addr_end	= phy_mem_next->address_start;
+			}else
+			{
+				addr_end	= phy_addr_end;
+			}
+//-----------------------------------------------------------------------------------------------------
+			if(addr_start&0xFFF)
+			{
+				addr_start	= addr_start + (0x1000 - (addr_start&0xFFF));
+			}
+//-----------------------------------------------------------------------------------------------------
+			if((addr_end > addr_start) && ((addr_end - addr_start) > size))
+			{
+				break;
+			}else if(phy_mem_next)
+			{
+				phy_mem		= phy_mem_next;
+			}else
+			{
+				list_all_phy_struct();
+				TRACE_ERR_AND_RET(FAIL);
+			}
+		}
+
+		if(mem_fnode_flag)
+		{	
+			case_link	= 4;
+		}else 
+		{
+			if(phy_mem)
+			{
+				if((phy_mem) && (phy_mem->next))
+				{
+				case_link	= 1;
+				}else
+				{
+					case_link	= 2;
+				}
+
+			}else
+			{
+				case_link	= 3;
+			}
+		}
+
+		phy_new	= kmalloc(sizeof(struct dma_memory),GFP_KERNEL);		
+		if(phy_new == NULL)
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+		memset(phy_new,0x00,sizeof(struct dma_memory));
+	
+		switch(case_link)
+		{
+			case 4:
+			{
+				phy_mem->back		= phy_new;
+				phy_new->back		= NULL;
+				phy_new->next		= phy_mem;
+				get_mem_node(&phy_new,SET_MEM_NODE);
+			
+			}break;
+			case 3:
+			{
+				phy_mem			= phy_new;
+				phy_mem->next		= NULL;
+				phy_mem->back		= NULL;
+				get_mem_node(&phy_mem,SET_MEM_NODE);
+
+				break;
+			}
+			case 2:
+			{
+				phy_new->next		= NULL;
+				phy_new->back		= phy_mem;
+				phy_mem->next		= phy_new;
+				break;
+			}
+			case 1:
+			{
+				phy_new->next		= phy_mem->next;
+				phy_new->back		= phy_mem;
+				phy_mem->next->back	= phy_new;
+				phy_mem->next		= phy_new;
+				break;
+			}
+		}
+	
+		phy_new->address_start			= addr_start;
+		phy_new->address_end			= phy_new->address_start+size-1;
+		phy_new->size				= size;
+		phy_new->virtual_address		= (UINT32)ioremap(addr_start,size);
+
+		if(vir_addr)
+		{
+			*vir_addr			= phy_new->virtual_address;
+		}
+
+		if(phy_addr)
+		{
+			*phy_addr			= phy_new->address_start;
+		}
+	}mutex_unlock(&phy_memory_mutex);
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(get_free_phy_mem);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	INT0
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT get_adress(UPINT32 phy_addr,UPINT32 vir_addr, UPINT32 addr)
+{
+	FNRESLT ret_val;
+	struct dma_memory *phy_mem	= NULL;
+
+	*addr	= DISABLE;
+
+	mutex_lock(&phy_memory_mutex);
+	{
+		ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			{
+			}mutex_unlock(&phy_memory_mutex);
+
+			return ret_val;
+		}
+
+		for(;phy_mem;)
+		{
+			if(phy_addr)
+			{
+				if(phy_addr	== (UPINT32)phy_mem->address_start)
+				{
+					*addr	= phy_mem->virtual_address;
+					break;
+				}
+			}
+			if(vir_addr)
+			{
+				if(vir_addr	== (UPINT32)phy_mem->virtual_address)
+				{
+					*addr	= phy_mem->address_start;				
+					break;
+				}
+			}
+
+			phy_mem		= phy_mem->next;
+		}
+
+		if(*addr	== DISABLE)
+		{
+			printk(KERN_ERR"\n" KERN_ERR "Memory Invalid : physical memory not allocated from phy_mem\n");
+			list_all_phy_struct();
+			{
+			}mutex_unlock(&phy_memory_mutex);
+
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}mutex_unlock(&phy_memory_mutex);
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(get_adress);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	INT0
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+
+FNRESLT free_phy_mem(UINT32 phy_addr)
+{
+	struct dma_memory *phy_mem	= NULL;
+	struct dma_memory *phy_mem_last	= NULL;
+	FNRESLT ret_val;
+
+	mutex_lock(&phy_memory_mutex);
+	{
+		ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			{
+			}mutex_unlock(&phy_memory_mutex);
+			
+			return ret_val;
+		}
+
+
+		for(;phy_mem;)
+		{
+			if(phy_addr	== phy_mem->address_start)
+			{
+				break;
+			}else
+			{
+				phy_mem		= phy_mem->next;
+			}
+		}
+		if(phy_mem)
+		{
+	
+			if(phy_mem->next)
+			{
+				phy_mem->next->back	= phy_mem->back;
+				phy_mem_last		= phy_mem->next;
+			}
+
+			if(phy_mem->back)
+			{
+				phy_mem->back->next	= phy_mem->next;
+				iounmap((PINT0)phy_mem->virtual_address);
+				kfree(phy_mem);
+			}else
+			{
+			
+				ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					{
+					}mutex_unlock(&phy_memory_mutex);
+	
+					return ret_val;
+				}
+
+				iounmap((PINT0)phy_mem->virtual_address);
+				kfree(phy_mem);
+
+				if(phy_mem_last)
+				{
+					phy_mem	= phy_mem_last;
+					ret_val	= get_mem_node(&phy_mem,SET_MEM_NODE);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						{
+						}mutex_unlock(&phy_memory_mutex);
+
+						return ret_val;
+					}
+	
+				}else
+				{
+					phy_mem	= NULL;			
+					ret_val	= get_mem_node(&phy_mem,SET_MEM_NODE);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						{
+						}mutex_unlock(&phy_memory_mutex);
+						return ret_val;
+					}
+				}
+			}
+
+		}else
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}mutex_unlock(&phy_memory_mutex);
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(free_phy_mem);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	INT0
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT free_all_phy_struct()
+{
+	struct dma_memory *phy_mem	= NULL;
+	struct dma_memory *phy_mem_next	= NULL;
+	FNRESLT ret_val;
+
+	mutex_lock(&phy_memory_mutex);
+	{
+		ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			{
+			}mutex_unlock(&phy_memory_mutex);
+			return ret_val;
+		}
+
+		for(;phy_mem;)
+		{
+			phy_mem_next = phy_mem->next;
+
+			iounmap((PINT0)phy_mem->virtual_address);
+			kfree(phy_mem);
+
+			phy_mem	= phy_mem_next;
+		}
+
+		phy_mem	= NULL;
+		ret_val	= get_mem_node(&phy_mem,SET_MEM_NODE);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			{
+			}mutex_unlock(&phy_memory_mutex);
+
+			return ret_val;
+		}
+	
+	}mutex_unlock(&phy_memory_mutex);
+
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(free_all_phy_struct);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT init_phy_mem()
+{
+	UINT32 phys_end_kernel;
+
+	if((phy_addr_start	== DISABLE) && (phy_addr_end == DISABLE))
+	{
+		phy_addr_start	= PHY_MEM_START;
+		phy_addr_end	= PHY_MEM_END;
+
+	}
+/*
+ * Find the kernel memory range
+ */
+	phys_end_kernel = (UINT32)virt_to_phys((PINT0)PAGE_OFFSET) +(num_physpages << PAGE_SHIFT);
+	if(phys_end_kernel > phy_addr_start)
+	{
+		printk(KERN_INFO "\n");
+		printk(KERN_INFO "Memory overlap detected between camera reserved memory and kernel memory\n");
+		printk(KERN_INFO "phy_addr_start  0x%x \n",phy_addr_start);
+		printk(KERN_INFO "phy_addr_end    0x%x \n",phy_addr_end);
+		printk(KERN_INFO "phys_end_kernel 0x%x \n",phys_end_kernel);
+		printk(KERN_INFO "\n");
+
+#ifndef CONFIG_ALLOW_DRIVER_PHY_MEMORY_OVERLAP
+ 		TRACE_ERR_AND_RET(MEM_KERN_OVERLAP);
+#endif
+	}
+
+	printk(KERN_INFO "Using Reserved memory for " MODULE_NAME "\n");
+	printk(KERN_INFO "From Start address - 0x%08x \n",phy_addr_start);
+	printk(KERN_INFO "To End address - 0x%08x \n",phy_addr_end);
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT exit_phy_mem()
+{
+	FNRESLT ret_val;
+	ret_val	= free_all_phy_struct();
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+module_param(phy_addr_start,int, 0444);
+module_param(phy_addr_end,int, 0444);
diff -Naur linux-org/drivers/media/video/ecam32/stcf03/stcf03_flash.c linux-ths/drivers/media/video/ecam32/stcf03/stcf03_flash.c
--- linux-org/drivers/media/video/ecam32/stcf03/stcf03_flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/stcf03/stcf03_flash.c	2011-11-02 11:31:56.000000000 +0100
@@ -0,0 +1,613 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ *
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+#include "../inc_header.h"
+/*
+ * local variables
+ */
+static INT32 torch_lum_value;
+static INT32 flash_lum_value;
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	flash_i2c_client_xfer
+ *  Parameter1	:	INT32 addr
+ *  Parameter2	:	UPINT8 reg
+ *  Parameter3	:	PINT8 buf
+ *  Parameter4	:	INT32 num
+ *  Parameter5	:	INT32 tran_flag
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT flash_i2c_client_xfer(INT32 addr, UPINT8 reg, PINT8 buf, INT32 num, INT32 tran_flag)
+{
+
+	struct i2c_msg msg[2];
+	FNRESLT ret_val;
+	INT32 ret;
+	cam_data *cam	= NULL;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);	
+	}
+
+/*
+ * FIXME:
+ * 	
+ * 	I2C Write:
+ *	 	In i2c msg[0] "address part in write is success" but if we put data in msg [1] 
+ * 		that is not properly sent to device.
+ *
+ * 		so in the msg[0] part itself the data also sent here.
+ *
+ * 	I2CRead:
+ * 		But in read No problem is found and working fine
+ */
+
+	if(tran_flag & I2C_FLAG_READ)
+	{
+
+		msg[0].addr	= addr;
+		msg[0].len	= 1;
+		msg[0].buf	= reg;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		msg[1].addr	= addr;
+		msg[1].len	= num;
+		msg[1].buf	= buf;
+		msg[1].flags	= tran_flag;
+
+		if (tran_flag & I2C_FLAG_READ)
+		{
+			msg[1].flags |= I2C_M_RD;
+		}else
+		{
+			msg[1].flags &= ~I2C_M_RD;
+		}
+
+		if (cam->cam_flash.client->adapter == NULL)
+		{
+			printk("%s:adapter error\n", __func__);
+			return -1;
+		}
+
+		ret = i2c_transfer(cam->cam_flash.client->adapter, msg, 2);
+		if (ret >= 0)
+		{
+			/* printk("%s:i2c transfer num:%d\n", __func__, ret); */
+			return SUCCESS;
+		}
+
+	}else
+	{
+		UINT8 reg_addr_data[2];
+		
+		reg_addr_data[0] = *reg;
+		reg_addr_data[1] = *buf;
+		
+		msg[0].addr	= addr;
+		msg[0].len	= 2;
+		msg[0].buf	= reg_addr_data;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		ret = i2c_transfer(cam->cam_flash.client->adapter, msg, 1);
+		if (ret >= 0)
+		{
+			/* printk("%s:i2c transfer num:%d\n", __func__, ret); */
+			return SUCCESS;
+		}
+	}
+	printk("%s:i2c transfer error:%d\n", __func__, ret);
+	return FAIL;
+
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_write
+ *  Parameter1	:	UINT8 reg
+ *  Parameter2	:	UINT8 data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_write(UINT8 reg,UINT8 data)
+{
+	printk(KERN_DEBUG "stcf03: write : Address : %x Data %x \n",reg,data);
+
+	if (flash_i2c_client_xfer(STCF03_SLAVE_ADDRESS,&reg,&data, 0, 0) < 0)
+	{
+		printk("Flash write failed :%s: reg=%x",__func__, reg);
+		return FAIL;
+	}	
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_read
+ *  Parameter1	:	UINT8 reg
+ *  Parameter2	:	UPINT8 data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_read(UINT8 reg,UPINT8 data)
+{
+	if (flash_i2c_client_xfer(STCF03_SLAVE_ADDRESS,&reg, data, 1, 1) < 0)
+	{
+		printk("Flash write failed :%s: reg=%x",__func__, reg);
+		return FAIL;
+	}
+	printk(KERN_DEBUG "stcf03: read : Address : %x Data %x \n",reg,*data);
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_probe
+ *  Parameter1	:	struct i2c_client *client
+ *  Parameter2	:	const struct i2c_device_id *id
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	Configure the gpio levels for ov3640 driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+static INT32 __init stcf03_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	cam_data *cam	= NULL;
+	FNRESLT ret_val;
+
+	if (i2c_get_clientdata(client))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		goto exit;
+	}
+	
+/*
+ * 	set the client data 
+ */
+	cam->cam_flash.client =	client;
+
+	return 0;
+	exit:
+	{
+		return -EINVAL;
+	}	
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_remove
+ *  Parameter1	:	struct i2c_client *client
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	remove routine of ov3640 i2c driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+static INT32 __exit stcf03_remove(struct i2c_client *client)
+{
+	if (!client->adapter)
+		return -ENODEV;	/* our client isn't attached */
+
+	i2c_set_clientdata(client, NULL);
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_init
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_init(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * i2c driver init
+ */
+	static const struct i2c_device_id stcf03_id[] =			\
+	{
+		{ STCF03_DRIVER_NAME, 0 },
+		{ },
+	};
+	MODULE_DEVICE_TABLE(i2c, stcf03_id);
+	
+	cam->cam_flash.i2c.driver.name	= STCF03_DRIVER_NAME;
+	cam->cam_flash.i2c.driver.owner	= THIS_MODULE;
+	cam->cam_flash.i2c.probe	= stcf03_probe;
+	cam->cam_flash.i2c.remove	= __exit_p(stcf03_remove);
+	cam->cam_flash.i2c.id_table	= stcf03_id;
+
+	if(i2c_add_driver(&cam->cam_flash.i2c))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	if(cam->cam_flash.client	== NULL)
+	{
+		ret_val	= cam->cam_flash.exit(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+		return SUCCESS;
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_exit
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_exit(cam_data *cam)
+{
+	if(cam->cam_flash.client)
+	{
+		stcf03_write(0x00,0x00);		
+	}
+
+	i2c_del_driver(&cam->cam_flash.i2c);
+	memset(&cam->cam_flash,0x00,sizeof(struct _flash_driver));
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_flash
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_flash(cam_data *cam)
+{
+	FNRESLT ret_val;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= cam->cam_sensor.sens_strobe_en;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 1))
+			{
+				if(cam->ctrl.value)
+				{
+/*
+ * Flash (or) Torch can be enabled, So proper routine to disable torch
+ */
+					cam->cmd	= SET_DATA;
+					cam->ctrl.value	= DISABLE;
+					ret_val = cam->cam_flash.torch(cam);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+
+					cam->cam_sensor.sens_strobe_en	= ENABLE;
+					ret_val = stcf03_write(0x00,0xCF);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+				}else
+				{
+					cam->cam_sensor.sens_strobe_en	= DISABLE;
+				}
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_FLASH;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"flash ctrl",strlen("flash ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_torch
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_torch(cam_data *cam)
+{
+	FNRESLT ret_val;
+	static UINT32 torch_value;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= torch_value;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 1))
+			{
+				if(cam->ctrl.value)
+				{
+/*
+ * Flash (or) Torch can be enabled, So proper routine to disable flash
+ */
+					cam->cmd	= SET_DATA;
+					cam->ctrl.value	= DISABLE;
+					ret_val = cam->cam_flash.flash(cam);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+
+					torch_value	= ENABLE;
+					ret_val=stcf03_write(0x00,0xAF);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+				}else
+				{
+					if(cam->cam_sensor.sens_strobe_en	== DISABLE)
+					{
+						ret_val = stcf03_write(0x00,0x00);
+						if(CHECK_IN_FAIL_LIMIT(ret_val))
+						{
+							TRACE_ERR_AND_RET(FAIL);
+						}
+					}
+					torch_value	= DISABLE;
+				}
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_TORCH;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"torch ctrl",strlen("torch ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+		}break;
+	}
+	return SUCCESS;
+
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_lum_ctrl
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_flash_lum_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= flash_lum_value;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 15))
+			{
+				ret_val	= stcf03_write(0x01,(0xF0 & torch_lum_value) | (0xF & cam->ctrl.value));
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(FAIL);
+				}
+				flash_lum_value	= cam->ctrl.value;
+			}
+
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_FLASH_LUM;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"flash lum ctrl",strlen("flash lum ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 15;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_lum_ctrl
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_torch_lum_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= torch_lum_value;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 15))
+			{
+				ret_val = stcf03_write(0x01,(0x0F & flash_lum_value) | ((0xF & cam->ctrl.value)<<4));
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(FAIL);
+				}
+				torch_lum_value	= cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_TORCH_LUM;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"torch lum ctrl",strlen("torch lum ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 15;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	register_flash_driver
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT register_flash_driver(cam_data *cam)
+{
+	cam->cam_flash.init		= stcf03_init;
+	cam->cam_flash.exit		= stcf03_exit;
+	cam->cam_flash.flash		= stcf03_flash;
+	cam->cam_flash.torch		= stcf03_torch;
+	cam->cam_flash.flash_lum_ctrl	= stcf03_flash_lum_ctrl;
+	cam->cam_flash.torch_lum_ctrl	= stcf03_torch_lum_ctrl;
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/stcf03/stcf03_flash.h linux-ths/drivers/media/video/ecam32/stcf03/stcf03_flash.h
--- linux-org/drivers/media/video/ecam32/stcf03/stcf03_flash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/stcf03/stcf03_flash.h	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,50 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :     OMAP Camera development                                                  *
+ *   MODULE NAME           :     OV3640                                                                   *
+ *   MODULE VERSION        :     VER 1.0                                                                  *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ *
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+#define STCF03_DRIVER_NAME	"stcf03"
+
+/*
+ * Slave address
+ */
+
+#define STCF03_SLAVE_ADDRESS	0x30
+
+/*
+ * Function protype
+ */
+FNRESLT register_flash_driver(cam_data *cam);
diff -Naur linux-org/drivers/media/video/ecam32/svn_revision.h linux-ths/drivers/media/video/ecam32/svn_revision.h
--- linux-org/drivers/media/video/ecam32/svn_revision.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/svn_revision.h	2011-12-27 10:32:46.000000000 +0100
@@ -0,0 +1,4 @@
+#define PRODUCT_NAME "e-CAM32_OMAP_GSTIX"
+#define SVN_REVISION "356"
+#define SVN_DATE "2011-12-27"
+#define SVN_TIME "13:59:38"
diff -Naur linux-org/drivers/media/video/ecam32/v4l2_driver_base.c linux-ths/drivers/media/video/ecam32/v4l2_driver_base.c
--- linux-org/drivers/media/video/ecam32/v4l2_driver_base.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/v4l2_driver_base.c	2011-07-30 11:13:20.000000000 +0200
@@ -0,0 +1,170 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	v4l2_base_struct
+ *  Parameter1	:	cam_data **cam	- pointer need to register
+ *  Parameter2	:	UINT8 option	- set or get the address
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT v4l2_base_struct(cam_data **cam,UINT8 option)
+{
+
+/*
+ * SET_ADDRESS 
+ * GET_ADDRESS 
+ * MAKE_ADDRESS_INVALID
+ */
+	static UINT32 g_cam_st_addr;
+
+	if(cam == NULL)
+	{
+		TRACE_ERROR(MEMORY_NOT_VALID);	
+		return MEMORY_NOT_VALID;
+	}
+
+	if(option == SET_ADDRESS)
+	{
+		g_cam_st_addr =(UINT32)*cam;
+	}else if(option == GET_ADDRESS)
+	{
+		if(g_cam_st_addr)
+		{
+			*cam	= (cam_data *)g_cam_st_addr;
+		}else
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}else if(option == MAKE_ADDRESS_INVALID)
+	{
+		g_cam_st_addr =0;
+		kfree(*cam);
+	}else
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+		
+	return SUCCESS;
+}
+EXPORT_SYMBOL(v4l2_base_struct);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	init_v4l2_base_struct	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_v4l2_base_struct(cam_data *cam)
+{
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	static struct v4l2_file_operations omap_v4l_fops = 	\
+	{
+		.owner		= THIS_MODULE,
+		.ioctl		= omap_v4l2_ioctl,
+//		.poll		= ,
+		.mmap		= omap_mmap,
+		.open		= omap_v4l2_open,
+		.release	= omap_v4l2_close,
+		.read		= omap_v4l2_read,
+
+	};
+#else
+	static struct file_operations omap_v4l_fops = 	\
+	{
+		.owner		= THIS_MODULE,
+		.ioctl		= omap_v4l2_ioctl,
+//		.poll		= ,
+		.mmap		= omap_mmap,
+		.open		= omap_v4l2_open,
+		.release	= omap_v4l2_close,
+		.read		= omap_v4l2_read,
+
+	};
+
+#endif
+	static struct video_device omap_v4l_template =		\
+	{
+		.minor		= -1,
+		.fops		= &omap_v4l_fops,
+		.ioctl_ops	= NULL,
+
+		.name		= "omap camera",
+//		.type		= 0,
+//		.type2		= VID_TYPE_CAPTURE,
+		.release	= video_device_release,
+	};
+
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	cam->video_dev		= video_device_alloc();
+	if (cam->video_dev == NULL)
+	{
+		return ALLOCATION_MEMORY_FAILED;
+	}
+
+	*(cam->video_dev)	= omap_v4l_template;
+	video_set_drvdata(cam->video_dev, cam);
+	cam->video_dev->minor	= -1;
+
+
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/v4l2_driver_base.h linux-ths/drivers/media/video/ecam32/v4l2_driver_base.h
--- linux-org/drivers/media/video/ecam32/v4l2_driver_base.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/v4l2_driver_base.h	2011-10-20 15:50:52.000000000 +0200
@@ -0,0 +1,254 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+#ifndef __BUF_MANAGE_H
+#define __BUF_MANAGE_H
+
+#define __link_node(base_ptr, new_node) 			\
+{								\
+	if(base_ptr == NULL)					\
+	{							\
+		base_ptr	= new_node;			\
+	}else							\
+	{							\
+		typeof(*base_ptr) *tmp = base_ptr;		\
+		for(;tmp->next;)				\
+		{						\
+			tmp	= tmp->next;			\
+		}						\
+		tmp->next	= new_node;			\
+	}							\
+}
+
+#define __update_base(base_ptr)					\
+{								\
+	base_ptr	= (base_ptr)?base_ptr->next:NULL;	\
+}
+
+#endif
+
+/*
+ * Global definitions
+ */
+#define MAX_FRAME_SUPPORT			10
+#define MAX_PIX_FORMAT_SUPPORTED		10
+#define MACRO_MAX_DISCREATE_FROMAT_SUPPORT	10
+
+enum __commands
+{
+	GET_DATA	= 1,
+	SET_DATA,
+	QUERY_DATA,
+	RESTORE_DATA,
+};
+
+typedef struct __cam_base_data
+{
+	struct video_device			*video_dev;
+
+	struct v4l2_capability			v4l2_cap;		// capture capability
+	struct v4l2_control			ctrl;			// ctrl based
+	struct v4l2_input 			vinp;
+	union
+	{
+		UINT8			task_state;
+		struct
+		{
+			UINT8			still	:1;
+			UINT8			capture	:1;
+		}bit;
+	}task;
+
+	struct
+	{
+		struct v4l2_format		v2f;			// v4l2 format 
+		struct v4l2_crop		crop;			// crop structure
+		struct v4l2_streamparm 		s_parm;			// stream parameter  
+
+//		struct v4l2_requestbuffers 	req_buf;
+		SINT32				available_buf;		// This will represet the Number of buffer
+									// chain can be formed in the qbuf - dqbuf process
+
+		INT32				using_buf;		// This will represet the current buffer 
+									// used by ccdc unit
+
+		INT32				valid_buf;		// This will mention the current valid buffer
+
+		UINT64				buffer_sequence;	// Total number of effective buffer delivered be
+									// available in this byte.
+		wait_queue_head_t 		capture_frame_complete;
+
+		struct __capture_dq_buf
+		{
+			struct __capture_dq_buf *next;
+
+			UINT32			width;
+			UINT32			height;
+			UINT32			size;
+
+			struct v4l2_buffer	buffer;			// physical address to be
+									// updated in m.offset
+		}frame[MAX_FRAME_SUPPORT];
+
+		struct __capture_dq_buf *Need_to_be_filled;
+		struct __capture_dq_buf *filled;
+		struct __capture_dq_buf *processing;
+	}capture;
+
+	struct
+	{
+		UINT8				wait_queue_head_t_dma_frame_complete_still;
+
+		wait_queue_head_t 		dma_frame_complete_still;
+		UINT32				frame_count;
+
+		UINT32				phy_addr;
+		UINT32				vir_addr;
+	}still;
+
+	cam_interface_pin_config		*pin;
+	isp_reg_bit_access			*isp;
+
+/*
+ * Place the platform specific content here
+ */
+	struct platform_driver omap3isp_driver;
+	struct device *dev;
+
+/*
+ * camera irq routine will be obtained from platform data
+ */
+	struct platform_device 			*pdev;
+	struct resource				*mem;
+	UINT32					irq;
+
+	UINT8					clk_enable;
+	struct clk 				*cam_mclk;
+	struct clk 				*cam_ick;
+	struct clk 				*cam_dpll4;
+/*
+ * S_CTRL, G_CTRL and QUERY_CTRL use this flag as base
+ */
+	UINT8	cmd;
+	struct v4l2_queryctrl qctrl;
+	
+/*
+ * Board specific function callbacks
+ */
+	FNRESLT (*modify_mclk_to_sensor)	(struct __cam_base_data *cam,UINT32 clk_need,UPINT32 clk_set); 
+
+/*
+ * sensor specific 
+ */
+	struct camera_sensor
+	{
+/*
+ * platform specific data
+ */
+		struct i2c_driver i2c_driver;
+		
+		UINT32 total_fmt_desc;
+		struct v4l2_fmtdesc formats[MAX_PIX_FORMAT_SUPPORTED];
+		struct v4l2_cropcap cropcap;
+		struct v4l2_crop scrop;
+		struct v4l2_streamparm s_parm;
+
+		UINT32 total_frms_support;
+		struct v4l2_frmsizeenum frms[MACRO_MAX_DISCREATE_FROMAT_SUPPORT],*fmt_frm_user;
+
+		UINT32 total_frm_interval_support;
+		struct v4l2_frmivalenum frm_interval_support[MACRO_MAX_DISCREATE_FROMAT_SUPPORT],*frame_interval_frm_user;
+
+		struct i2c_client 			*client;
+
+		FNRESLT (*find_device) 			(struct __cam_base_data *cam); 
+		FNRESLT (*init) 			(struct __cam_base_data *cam); 
+		FNRESLT (*reset) 			(struct __cam_base_data *cam); 
+		FNRESLT (*config_dim) 			(struct __cam_base_data *cam);
+		FNRESLT (*brightness) 			(struct __cam_base_data *cam);
+		FNRESLT (*contrast) 			(struct __cam_base_data *cam);
+		FNRESLT (*saturation) 			(struct __cam_base_data *cam);
+		FNRESLT (*hue) 				(struct __cam_base_data *cam);
+		FNRESLT (*whitebalance) 		(struct __cam_base_data *cam);
+		FNRESLT (*colour_balance) 		(struct __cam_base_data *cam);
+		FNRESLT (*exposure) 			(struct __cam_base_data *cam);
+		FNRESLT (*gain) 			(struct __cam_base_data *cam);
+		FNRESLT (*v_flip) 			(struct __cam_base_data *cam);
+		FNRESLT (*h_mirror) 			(struct __cam_base_data *cam);
+		FNRESLT (*sharpness) 			(struct __cam_base_data *cam);
+
+		UINT8	sens_strobe_en;
+		FNRESLT (*sens_strobe) 			(struct __cam_base_data *cam);
+		FNRESLT (*test_color_pattern) 		(struct __cam_base_data *cam);
+
+		FNRESLT (*auto_focus_init) 		(struct __cam_base_data *cam);
+		FNRESLT (*focus) 			(struct __cam_base_data *cam);
+		FNRESLT (*effects) 			(struct __cam_base_data *cam);
+		FNRESLT (*antishake) 			(struct __cam_base_data *cam);
+
+		FNRESLT (*frame_rate_ctrl) 		(struct __cam_base_data *cam);
+		FNRESLT (*supported_formats) 		(struct __cam_base_data *cam);
+		FNRESLT (*frame_interval) 		(struct __cam_base_data *cam);
+
+		FNRESLT (*lens_correction) 		(struct __cam_base_data *cam);
+
+		FNRESLT (*crop) 			(struct __cam_base_data *cam);
+		FNRESLT (*exit)				(struct __cam_base_data *cam); 
+
+		FNRESLT (*reg_access) 			(struct __cam_base_data *cam);
+
+/*
+ * Query sensor
+ */
+		struct v4l2_format			fmt,qfmt;	 
+		FNRESLT (*qfmt_support) 		(struct __cam_base_data *cam);
+		FNRESLT (*fix_fmt_support) 		(struct __cam_base_data *cam);
+
+	}cam_sensor;
+
+/*
+ * Flash specific feature
+ */
+
+	struct _flash_driver
+	{
+		struct i2c_driver 			i2c;
+		struct i2c_client 			*client;
+
+		FNRESLT (*init)				(struct __cam_base_data *cam); 
+		FNRESLT (*flash)			(struct __cam_base_data *cam);
+		FNRESLT (*flash_lum_ctrl)		(struct __cam_base_data *cam);
+		FNRESLT (*torch)			(struct __cam_base_data *cam);
+		FNRESLT (*torch_lum_ctrl)		(struct __cam_base_data *cam);
+		FNRESLT (*exit)				(struct __cam_base_data *cam); 
+	}cam_flash;
+
+}cam_data;
diff -Naur linux-org/drivers/media/video/Kconfig linux-ths/drivers/media/video/Kconfig
--- linux-org/drivers/media/video/Kconfig	2012-07-10 08:15:02.000000000 +0200
+++ linux-ths/drivers/media/video/Kconfig	2012-07-10 13:04:53.000000000 +0200
@@ -963,6 +963,18 @@
 	  over a bus like PCI or USB. For example some i2c camera connected
 	  directly to the data bus of an SoC.
 
+config SOC_CAMERA_ECAM32
+	tristate "ECAM32 camera support (EXPERIMENTAL)"
+	depends on SOC_CAMERA && I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API && EXPERIMENTAL
+	help
+	  Driver for an ECAM32 camera controller.
+
+config SOC_CAMERA_ECAM32_DEBUG
+	bool "ECAM32 Camera debug messages"
+	depends on SOC_CAMERA_ECAM32
+	help
+	  Enable debug messages on ECAM32 camera driver.
+
 config SOC_CAMERA_IMX074
 	tristate "imx074 support"
 	depends on SOC_CAMERA && I2C
diff -Naur linux-org/drivers/media/video/Makefile linux-ths/drivers/media/video/Makefile
--- linux-org/drivers/media/video/Makefile	2012-07-10 08:15:02.000000000 +0200
+++ linux-ths/drivers/media/video/Makefile	2012-07-10 13:05:37.000000000 +0200
@@ -82,6 +82,7 @@
 obj-$(CONFIG_VIDEO_ADP1653)	+= adp1653.o
 obj-$(CONFIG_VIDEO_AS3645A)	+= as3645a.o
 
+obj-$(CONFIG_SOC_CAMERA_ECAM32)     += ecam32/
 obj-$(CONFIG_SOC_CAMERA_IMX074)		+= imx074.o
 obj-$(CONFIG_SOC_CAMERA_MT9M001)	+= mt9m001.o
 obj-$(CONFIG_SOC_CAMERA_MT9M111)	+= mt9m111.o
@@ -146,7 +147,7 @@
 
 obj-$(CONFIG_VIDEO_VIA_CAMERA) += via-camera.o
 
-obj-$(CONFIG_VIDEO_OMAP3)	+= omap3isp/
+obj-$(CONFIG_VIDEO_OMAP3)       += omap3isp/
 
 obj-$(CONFIG_USB_ZR364XX)       += zr364xx.o
 obj-$(CONFIG_USB_STKWEBCAM)     += stkwebcam.o
