diff -Naur linux-org/drivers/media/video/ecam32/auto_conf.h linux-ths/drivers/media/video/ecam32/auto_conf.h
--- linux-org/drivers/media/video/ecam32/auto_conf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/auto_conf.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,96 @@
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                              e_CAM32_OMAP_GSTIX
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_BOARD_e_CAM32_OMAP_GSTIX
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                                Memory related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+/*
+ * e_CAM50_OMAP_GSTIX
+ *
+ *
+ * Modified version:
+ * etc/rc5.d/S30gstti-init
+ *
+ * # Start Addr    Size    Description
+ * # -------------------------------------------
+ * # 0x80000000    93 MB   Linux
+ * # 0x85700000     6 MB   e-con camera
+ * # 0x86300000    16 MB   CMEM
+ * # 0x87300000    13 MB   CODEC SERVER
+ * # 0x88000000   128 MB   RAM starts if available is 256 MB ram
+ *
+ * Boot arguments used
+ * -------------------
+ * setenv mmcargs 'setenv bootargs console=${console} vram=${vram} mem=87M@0x80000000 mem=128M@0x88000000 omapfb.mode=dvi:${dvimode} omapfb.debug=y omapdss.def_disp=${defaultdisplay} root=/dev/mmcblk0p2 rw rootfstype=ext3 rootwait i2c_bus=3,100'
+ */
+
+#define CONFIG_RAM_SIZE_IN_MB			256
+#define CONFIG_CMEM_DRIVER_AVAILABLE
+#define CONFIG_ALLOW_DRIVER_PHY_MEMORY_OVERLAP
+
+#define PHY_MEM_HIGH_ALLOCATE_IN_MB		6	
+
+#if (CONFIG_RAM_SIZE_IN_MB == 128)
+
+	#if defined(CONFIG_CMEM_DRIVER_AVAILABLE)
+		#define PHY_MEM_END		0x862FFFFF	// start address is 0x8570_0000  @ 12M
+	#else
+		#define PHY_MEM_END		0x87FFFFFF
+	#endif
+	
+#elif (CONFIG_RAM_SIZE_IN_MB == 256)
+
+	#if defined(CONFIG_CMEM_DRIVER_AVAILABLE)
+		#define PHY_MEM_END		0x862FFFFF	// start address is 0x8570_0000  @ 12M
+	#else
+		#define PHY_MEM_END		0x8FFFFFFF
+	#endif
+
+#endif
+#define PHY_MEM_START				(PHY_MEM_END - ((PHY_MEM_HIGH_ALLOCATE_IN_MB * 1024 * 1024)-1))
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Driver related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define STILL_IMAGE_CAPTURE_FRAME_NUMBER	3
+#define CONFIG_USE_TI_RESIZER			DISABLE
+#define CONFIG_ISP_DATA_LINE_SHIFT		DISABLE
+#define CONFIG_ISP_SLV0_DISCARD_COUNT		0
+#define CONFIG_SENS_MCLK			0
+#undef CONFIG_CTRL_FRAME_RATE_FRM_SENSOR
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Sensor related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_USE_OV3640_SENSOR
+#define CONFIG_OV3640_DEFAULT_FLIP		DISABLE	
+#define CONFIG_OV3640_DEFAULT_MIRROR		DISABLE
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Flash related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_USE_LM3553_FLASH
+/*
+ * FIXME:
+ * 	When Flash lumination value is set more than 40 then board re-boots at snap mode.
+ */
+#define CONIFG_LM3553_FLASH_MAX_LUM_VALUE		40
+
+
+
diff -Naur linux-org/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/auto_conf.h linux-ths/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/auto_conf.h
--- linux-org/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/auto_conf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/auto_conf.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,96 @@
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                              e_CAM32_OMAP_GSTIX
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_BOARD_e_CAM32_OMAP_GSTIX
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                                Memory related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+/*
+ * e_CAM50_OMAP_GSTIX
+ *
+ *
+ * Modified version:
+ * etc/rc5.d/S30gstti-init
+ *
+ * # Start Addr    Size    Description
+ * # -------------------------------------------
+ * # 0x80000000    93 MB   Linux
+ * # 0x85700000     6 MB   e-con camera
+ * # 0x86300000    16 MB   CMEM
+ * # 0x87300000    13 MB   CODEC SERVER
+ * # 0x88000000   128 MB   RAM starts if available is 256 MB ram
+ *
+ * Boot arguments used
+ * -------------------
+ * setenv mmcargs 'setenv bootargs console=${console} vram=${vram} mem=87M@0x80000000 mem=128M@0x88000000 omapfb.mode=dvi:${dvimode} omapfb.debug=y omapdss.def_disp=${defaultdisplay} root=/dev/mmcblk0p2 rw rootfstype=ext3 rootwait i2c_bus=3,100'
+ */
+
+#define CONFIG_RAM_SIZE_IN_MB			256
+#define CONFIG_CMEM_DRIVER_AVAILABLE
+#define CONFIG_ALLOW_DRIVER_PHY_MEMORY_OVERLAP
+
+#define PHY_MEM_HIGH_ALLOCATE_IN_MB		6	
+
+#if (CONFIG_RAM_SIZE_IN_MB == 128)
+
+	#if defined(CONFIG_CMEM_DRIVER_AVAILABLE)
+		#define PHY_MEM_END		0x862FFFFF	// start address is 0x8570_0000  @ 12M
+	#else
+		#define PHY_MEM_END		0x87FFFFFF
+	#endif
+	
+#elif (CONFIG_RAM_SIZE_IN_MB == 256)
+
+	#if defined(CONFIG_CMEM_DRIVER_AVAILABLE)
+		#define PHY_MEM_END		0x862FFFFF	// start address is 0x8570_0000  @ 12M
+	#else
+		#define PHY_MEM_END		0x8FFFFFFF
+	#endif
+
+#endif
+#define PHY_MEM_START				(PHY_MEM_END - ((PHY_MEM_HIGH_ALLOCATE_IN_MB * 1024 * 1024)-1))
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Driver related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define STILL_IMAGE_CAPTURE_FRAME_NUMBER	3
+#define CONFIG_USE_TI_RESIZER			DISABLE
+#define CONFIG_ISP_DATA_LINE_SHIFT		DISABLE
+#define CONFIG_ISP_SLV0_DISCARD_COUNT		0
+#define CONFIG_SENS_MCLK			0
+#undef CONFIG_CTRL_FRAME_RATE_FRM_SENSOR
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Sensor related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_USE_OV3640_SENSOR
+#define CONFIG_OV3640_DEFAULT_FLIP		DISABLE	
+#define CONFIG_OV3640_DEFAULT_MIRROR		DISABLE
+
+/*
+ * ------------------------------------------------------------------------------------------------------------
+ *                                             Flash related
+ * ------------------------------------------------------------------------------------------------------------
+ */
+
+#define CONFIG_USE_LM3553_FLASH
+/*
+ * FIXME:
+ * 	When Flash lumination value is set more than 40 then board re-boots at snap mode.
+ */
+#define CONIFG_LM3553_FLASH_MAX_LUM_VALUE		40
+
+
+
diff -Naur linux-org/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/Makefile linux-ths/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/Makefile
--- linux-org/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/Board/e-CAM32_OMAP_GSTIX/Makefile	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,13 @@
+v4l2_driver-objs	:=	init_module.o isp.o omap_hwr_base.o 				\
+				ov3640/sens_ov3640.o  v4l2_driver_base.o                  \
+				omap_camera_interface.o omap_v4l2_fops_base.o  			\
+				isp.o omap_v4l2_ioctl_fops.o i2c.o				\
+				lm3553/lm3553_flash.o exit_module.o					\
+				resource/src/error.o resource/src/kernel/phy_mem.o
+
+obj-m			+=v4l2_driver.o
+
+omap:
+	make -C $(KERNEL_PATH) M=$(PWD) ARCH=arm CROSS_COMPILE=$(CROSS_COMPILE) modules
+clean:
+	make -C $(KERNEL_PATH) M=$(PWD) ARCH=arm CROSS_COMPILE=$(CROSS_COMPILE) clean
diff -Naur linux-org/drivers/media/video/ecam32/exit_module.c linux-ths/drivers/media/video/ecam32/exit_module.c
--- linux-org/drivers/media/video/ecam32/exit_module.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/exit_module.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,238 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * Include Header file
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	all_clk_disable	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT all_clk_disable(cam_data *cam)
+{
+	if(!(IS_ERR(cam->cam_mclk)))
+	{
+		clk_disable(cam->cam_mclk);
+	}
+
+	if(!(IS_ERR(cam->cam_ick)))
+	{
+		clk_disable(cam->cam_ick);
+	}
+
+	if(!(IS_ERR(cam->cam_dpll4)))
+	{
+		clk_disable(cam->cam_dpll4);
+	}
+	cam->clk_enable	= DISABLE;
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	all_clk_unregister
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT all_clk_unregister(cam_data *cam)
+{
+	if(!(IS_ERR(cam->cam_ick)))
+	{
+		clk_put(cam->cam_ick);
+	}
+
+	if(!(IS_ERR(cam->cam_mclk)))
+	{
+		clk_put(cam->cam_mclk);
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	free_all_irq
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT free_all_irq(cam_data *cam)
+{
+	free_irq(cam->irq,cam);
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	isp_remove
+ *  Parameter1	:	struct platform_device *pdev
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+INT32 isp_remove(struct platform_device *pdev)
+{
+
+	FNRESLT ret_val;
+	cam_data *cam;
+/*
+ * register the camera base pointer
+ */
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	if(cam->cam_sensor.exit)
+	{
+		ret_val	= cam->cam_sensor.exit(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+
+	if(cam->cam_flash.exit)
+	{
+		ret_val	= cam->cam_flash.exit(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+
+	ret_val	= disable_isp_irq0(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+		
+	}
+
+	ret_val	= free_all_irq(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+		
+	}
+
+	ret_val	= all_clk_disable(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= all_clk_unregister(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= exit_omap_hwr(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	video_unregister_device(cam->video_dev);
+//	video_device_release(cam->video_dev);
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE_00
+ *  Name	:	omap_v4l2_camera_driver_exit
+ *  Parameter1	:	INT0
+ *  Returns	:	INT0
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+static void __exit omap_v4l2_camera_driver_exit(void)
+{
+	FNRESLT ret_val;
+	cam_data *cam;
+
+/*
+ * TODO:
+ * 	Release the hardware resource properly
+ */
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to get the camera base address\n");
+		return ;		
+	}
+
+	platform_driver_unregister(&cam->omap3isp_driver);
+
+	printk(KERN_INFO MODULE_NAME ":unregistering v4l2 camera driver\n");
+
+	cam->video_dev	= NULL;
+	v4l2_base_struct(&cam,MAKE_ADDRESS_INVALID);
+
+	return ;
+}
+module_exit(omap_v4l2_camera_driver_exit);
diff -Naur linux-org/drivers/media/video/ecam32/fn_protype.h linux-ths/drivers/media/video/ecam32/fn_protype.h
--- linux-org/drivers/media/video/ecam32/fn_protype.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/fn_protype.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,151 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * init_moudle.c
+ */
+FNRESLT all_clk_enable(cam_data *cam);
+/*
+ * isp.c
+ */
+irqreturn_t omap34xx_isp_isr(INT32 irq,PINT0 _isp);
+FNRESLT init_cam_isp_ccdc(cam_data *cam);
+FNRESLT exit_cam_isp_ccdc(cam_data *cam);
+FNRESLT isp_set_xclk(cam_data *cam,UINT32 xclk, UINT8 xclksel, UPINT32 current_xclk);
+FNRESLT isp_reset(cam_data *cam);
+FNRESLT isp_configure(cam_data *cam);
+FNRESLT enable_ccdc(cam_data *cam);
+FNRESLT isp_prg_sdram_addr(cam_data *cam);
+FNRESLT program_dummy_isp_sdram_addr(cam_data *cam);
+FNRESLT disable_ccdc(cam_data *cam);
+
+FNRESLT enable_isp_irq0(cam_data *cam);
+FNRESLT disable_isp_irq0(cam_data *cam);
+
+
+
+/*
+ * v4l2_driver_base.c
+ */
+FNRESLT v4l2_base_struct(cam_data **cam,UINT8 option);
+FNRESLT init_v4l2_base_struct(cam_data *cam);
+
+/*
+ * sens_ov3640.c
+ */
+FNRESLT ov3640_exit(cam_data *cam);
+FNRESLT sensor_driver_init(cam_data *cam);
+FNRESLT ov3640_write_reg(UINT16 reg_address,UINT8 reg_data);
+FNRESLT ov3640_limit_pclk_max_limit(cam_data *cam);
+FNRESLT ov3640_read_reg(UINT16 reg_address,UPINT8 reg_data);
+
+/*
+ * sens_ov5642.c
+ */
+FNRESLT ov5642_write_reg(UINT16 reg_address,UINT8 reg_data);
+FNRESLT ov5642_read_reg(UINT16 reg_address,UPINT8 reg_data);
+FNRESLT ov5642_flip_mirror_logic(cam_data *cam,UINT32 logic);
+
+/*
+ * sens_ov10630.c
+ */
+FNRESLT ov10630_write_reg(UINT16 reg_address,UINT8 reg_data);
+FNRESLT ov10630_read_reg(UINT16 reg_address,UPINT8 reg_data);
+
+/*
+ * sens_ov10633.c
+ */
+FNRESLT ov10633_write_reg(UINT16 reg_address,UINT8 reg_data);
+FNRESLT ov10633_read_reg(UINT16 reg_address,UPINT8 reg_data);
+
+/*
+ * lm355 flash support.c
+ */
+FNRESLT lm3553_exit(cam_data *cam);
+
+/*
+ * omap_hwr_base.c
+ */
+FNRESLT init_omap_hwr(cam_data *cam);
+FNRESLT exit_omap_hwr(cam_data *cam);
+
+/*
+ * omap_camera_interface.c
+ */
+
+FNRESLT init_cam_interface(cam_data *cam);
+FNRESLT exit_cam_interface(cam_data *cam);
+
+/*
+ * omap_v4l2_fops_base.c
+ */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	INT32 omap_v4l2_open(struct file *file);
+	INT32 omap_v4l2_close(struct file *file);
+	LINT32 omap_v4l2_ioctl(struct file *file,UINT32 cmd,ULINT32 arg);
+	LINT32 omap_v4l2_do_ioctl(struct file *file,UINT32 ioctlnr,PINT0 arg);
+
+#else
+	INT32 omap_v4l2_open(struct inode *inode,struct file *file);
+	INT32 omap_v4l2_close(struct inode *inode,struct file *file);
+	LINT32 omap_v4l2_ioctl( struct inode *inode, struct file *file,UINT32 cmd,ULINT32 arg);
+	LINT32 omap_v4l2_do_ioctl(struct inode *inode, struct file *file,UINT32 ioctlnr,PINT0 arg);
+#endif
+INT32 omap_v4l2_read(struct file *file, INT8 *buf, size_t count, loff_t * ppos);
+INT32 omap_mmap(struct file *file, struct vm_area_struct *vma);
+
+/*
+ * gendral
+ */
+
+FNRESLT register_sensor_bus(cam_data *cam);
+
+/*
+ * omap_v4l2_ioctl_fops.c
+ */
+FNRESLT omap_v4l2_capability(cam_data *cam,struct v4l2_capability *cap);
+FNRESLT omap_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f);
+FNRESLT omap_v4l2_g_fmt(cam_data *cam, struct v4l2_format *f);
+FNRESLT omap_v4l2_ctrl(cam_data *cam);
+
+FNRESLT omap_v4l2_req_buf(cam_data *cam,struct v4l2_requestbuffers *req);
+FNRESLT omap_v4l2_query_buf(cam_data *cam,struct v4l2_buffer *buf);
+FNRESLT omap_v4l2_queue_buf(cam_data *cam,struct v4l2_buffer *buf);
+FNRESLT omap_v4l2_dqueue_buf(cam_data *cam,struct v4l2_buffer *buf);
+FNRESLT omap_v4l2_stream_on(cam_data *cam,INT32 *type);
+FNRESLT omap_v4l2_stream_off(cam_data *cam,INT32 *type);
+FNRESLT omap_v4l2_enum_fmt(cam_data *cam,struct v4l2_fmtdesc *fmt);
+
+/*
+ * exit_module.c
+ */
+INT32 isp_remove(struct platform_device *pdev);
+FNRESLT all_clk_disable(cam_data *cam);
diff -Naur linux-org/drivers/media/video/ecam32/i2c.c linux-ths/drivers/media/video/ecam32/i2c.c
--- linux-org/drivers/media/video/ecam32/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/i2c.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,32 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+
diff -Naur linux-org/drivers/media/video/ecam32/i2c.h linux-ths/drivers/media/video/ecam32/i2c.h
--- linux-org/drivers/media/video/ecam32/i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/i2c.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,33 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+#define	I2C_IDBR_MODE			0x01
+#define I2C_FLAG_READ			0x01
+
diff -Naur linux-org/drivers/media/video/ecam32/inc_header.h linux-ths/drivers/media/video/ecam32/inc_header.h
--- linux-org/drivers/media/video/ecam32/inc_header.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/inc_header.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,121 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :        VER 3.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.1   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ * 3.0       Flash support added  
+ *==========================================================================================================
+ */
+/*
+ * include configuration code for selecting sensor and flash driver code
+ */
+#include "auto_conf.h"
+
+
+/*
+ * Define the Include header file Macro
+ */
+#define MODULE_NAME	"V4l2 driver module"
+
+#define CONFIG_DRIVER
+#define USE_KERNEL_THREAD
+#define KERNEL_ARM_OMAP
+#define KERNEL_ARM_OMAP3530
+#define USE_KERNEL_MEMORY_MANAGE
+#define CONFIG_KERNEL_ERR_INCLUDED
+
+#include "resource/include/Headerfile.h"
+
+/*
+ * driver specific header files
+ */
+
+#include <media/v4l2-dev.h>
+#include <mach/gpio.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
+
+#ifndef gpio_get_value
+#define gpio_get_value    __gpio_get_value
+#endif
+
+#ifndef gpio_set_value
+#define gpio_set_value  __gpio_set_value
+#endif
+
+#ifndef gpio_cansleep     
+#define gpio_cansleep     __gpio_cansleep
+#endif
+
+#endif
+
+#include <media/v4l2-ioctl.h>
+
+/*
+ * Include module specific code here
+ */
+#include "omap_camera_interface.h"
+#include "isp.h"
+#include "v4l2_driver_base.h"
+#include "omap_v4l2.h"
+#include "i2c.h"
+
+
+/*
+ * include the sensor file
+ */
+#if defined (CONFIG_USE_OV5642_SENSOR)
+	#include "ov5642/sens_ov5642.h"
+#elif defined (CONFIG_USE_OV3640_SENSOR)
+	#include "ov3640/sens_ov3640.h"
+#elif defined (CONFIG_USE_OV10630_SENSOR)
+	#include "ov10630/sens_ov10630.h"
+#elif defined (CONFIG_USE_OV10633_SENSOR)
+	#include "ov10633/sens_ov10633.h"
+#else
+	#warning "Sensor related driver file not selected"
+#endif
+
+/*
+ * include Flash related header file
+ */
+
+#if defined(CONFIG_USE_LM3553_FLASH)
+	#include "lm3553/lm3553_flash.h"
+#elif defined(CONFIG_USE_STCF03_FLASH)
+	#include "stcf03/stcf03_flash.h"
+#else
+	#warning "Flash related driver file not selected"
+#endif
+
+/*
+ * Tracking maintenance 
+ */
+#include "svn_revision.h"
+/*
+ * Include function protype here
+ */
+
+#include "fn_protype.h"
diff -Naur linux-org/drivers/media/video/ecam32/init_module.c linux-ths/drivers/media/video/ecam32/init_module.c
--- linux-org/drivers/media/video/ecam32/init_module.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/init_module.c	2012-07-19 09:01:09.356585187 +0200
@@ -0,0 +1,542 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/*
+ * Global variables
+ */
+
+static INT32 video_nr = -1;
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	init_plat_res
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_plat_res(cam_data *cam)
+{
+/*
+ * Allocate the memory region in the isp
+ */
+
+	if(cam->pdev == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+		
+	cam->mem = platform_get_resource(cam->pdev, IORESOURCE_MEM, 0);
+	if (!cam->mem)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * FIXME :
+ * 	Unable to request the memory region
+ */
+#if 0
+	if (!request_mem_region(cam->mem->start, MAP_ISP_REGION,cam->pdev->name))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+#endif
+	/* map the region */
+	cam->isp = (isp_reg_bit_access*)ioremap_nocache(cam->mem->start,MAP_ISP_REGION);
+	if (cam->isp	== NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	init_plat_irq
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_plat_irq(cam_data *cam)
+{
+#if (CONFIG_USE_TI_RESIZER == DISABLE)
+	cam->irq	= platform_get_irq(cam->pdev, 0);
+	if (cam->irq <= 0)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+#endif
+	cam->irq	= INT_34XX_CAM_IRQ;
+	if (request_irq(cam->irq, omap34xx_isp_isr, IRQF_SHARED,
+				"e-cam camera isp",cam))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	init_hwr_clock
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_hwr_clock(cam_data *cam)
+{
+	struct device_driver camera_drv =	\
+	{
+		.name = "camera"
+	};
+
+	struct device camera_dev = 		\
+	{
+		.driver = &camera_drv,
+	};
+	
+	cam->cam_ick = clk_get(&camera_dev, "cam_ick");
+	if (IS_ERR(cam->cam_ick))
+	{
+//		ret_err = PTR_ERR(isp_obj.cam_ick);
+		TRACE_ERR_AND_RET(FAIL);		
+
+	}
+	cam->cam_mclk = clk_get(&camera_dev, "cam_mclk");
+	if (IS_ERR(cam->cam_mclk))
+	{
+//		ret_err = PTR_ERR(cam->cam_mclk);
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	cam->cam_dpll4 = clk_get(&camera_dev, "dpll4_m4x2_ck");
+	if (IS_ERR(cam->cam_dpll4))
+	{
+//		ret_err = PTR_ERR(cam->cam_dpll4);
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	all_clk_enable
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT all_clk_enable(cam_data *cam)
+{
+	INT32 ret_err = DISABLE;
+
+	if(cam->clk_enable	== DISABLE)
+	{
+		cam->clk_enable	= ENABLE;
+	}else
+	{
+		return SUCCESS;
+	}
+	
+	ret_err = clk_enable(cam->cam_mclk);
+	if(ret_err)
+	{
+		goto err;
+	}
+
+	ret_err = clk_enable(cam->cam_ick);
+	if(ret_err)
+	{
+		clk_disable(cam->cam_mclk);
+		goto err;
+	}
+
+	ret_err = clk_enable(cam->cam_dpll4);
+	if(ret_err)
+	{
+		clk_disable(cam->cam_ick);
+		clk_disable(cam->cam_mclk);
+		goto err;
+	}
+	return SUCCESS;
+
+	err:
+	{
+		cam->clk_enable	= DISABLE;
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	init_cam_struct
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_cam_struct(cam_data *cam)
+{
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	
+	cam->capture.v2f.fmt.pix.width		= SENS_DEFAULT_WIDTH;
+	cam->capture.v2f.fmt.pix.height		= SENS_DEFAULT_HEIGHT;
+	cam->capture.v2f.type			= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	cam->capture.v2f.fmt.pix.pixelformat	= V4L2_PIX_FMT_UYVY;
+
+/*
+ * init S_PARM type
+ */
+	cam->capture.s_parm.type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+/*
+ * init the wait queue
+ */
+
+	init_waitqueue_head(&cam->still.dma_frame_complete_still);
+	init_waitqueue_head(&cam->capture.capture_frame_complete);	
+	
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	isp_probe_late_init
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT isp_probe_late_init(cam_data *cam)
+{
+	FNRESLT ret_val;
+	INT32 ret;
+
+/*
+ * initialize the camera structre
+ */
+
+	ret_val	= init_v4l2_base_struct(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to initialize camera device\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * Get the platform resource
+ */
+#if (CONFIG_USE_TI_RESIZER == DISABLE)
+	ret_val	= init_plat_res(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+#endif
+	ret_val	= init_plat_irq(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+/*
+ * TODO: initialize the hardware 
+ *
+ */
+/*
+ * initialize the camera structure
+ */
+	ret_val	= init_cam_struct(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+/*
+ * Configure the camera interface lines
+ */
+
+	ret_val	= init_hwr_clock(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	ret_val	= all_clk_enable(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	ret_val	= init_omap_hwr(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to initialize omap hardware device\n");
+		TRACE_ERR_AND_RET(ret_val);
+	}
+/*
+ * 	initialize the sensor 
+ */
+
+	ret_val	= register_sensor_bus(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	if(cam->cam_sensor.init)
+	{
+		ret_val	= cam->cam_sensor.init(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			return ret_val;
+		}
+	}
+
+/*
+ * register the flash driver
+ */
+	ret_val	= register_flash_driver(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+
+	if(cam->cam_flash.init)
+	{
+		ret_val	= cam->cam_flash.init(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			return ret_val;
+		}
+	}
+/*
+ * register the video device
+ */
+	ret	= video_register_device(cam->video_dev, VFL_TYPE_GRABBER, video_nr);
+	if (ret	== FAIL)
+	{
+		video_device_release(cam->video_dev);
+		cam->video_dev	= NULL;
+
+		v4l2_base_struct(&cam,MAKE_ADDRESS_INVALID);
+		printk(KERN_ERR "video_register_device failed\n");
+		TRACE_ERR_AND_RET(ret_val);
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	isp_probe
+ *  Parameter1	:	struct platform_device *pdev
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+static INT32 isp_probe(struct platform_device *pdev)
+{
+
+	FNRESLT ret_val;
+	cam_data *cam;
+/*
+ * register the camera base pointer
+ */
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	cam->pdev	= pdev;
+	
+/*
+ * register the driver content into platform
+ */
+	platform_set_drvdata(pdev, cam);
+
+/*
+ * Have a device structure copy in the driver
+ */
+	cam->dev = &pdev->dev;
+
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE
+ *  Name	:	cam_driver_init
+ *  Parameter1	:	INT0
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+static __init INT32 cam_driver_init(INT0)
+{
+#if (CONFIG_USE_TI_RESIZER == DISABLE)
+	INT32 plat_ret;
+#endif
+	FNRESLT ret_val;
+
+	cam_data *cam	= NULL;
+/*
+ * Print the Tracking information of application
+ */
+
+	printk(KERN_INFO "-------------------------------------------------\n");
+	printk(KERN_INFO "PRODUCT_NAME       : %s\n", PRODUCT_NAME);
+	printk(KERN_INFO "SVN_REVISION       : %s\n", SVN_REVISION);
+	printk(KERN_INFO "SVN_DATE           : %s\n", SVN_DATE);
+	printk(KERN_INFO "SVN_TIME           : %s\n", SVN_TIME);
+	printk(KERN_INFO "THS_VERSIONID      : %s\n", THS_VERSION_ID);
+	printk(KERN_INFO "Driver Module info : "MODULE_NAME"\n");
+	printk(KERN_INFO "Build Time stamp   : "__TIMESTAMP__"\n");
+	printk(KERN_INFO "-------------------------------------------------\n");
+
+	if ((cam = kmalloc(sizeof(cam_data), GFP_KERNEL)) == NULL)
+	{
+		printk(KERN_ERR "Failed to allocate memory to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * Clear the memory 
+ */
+	memset(cam, 0, sizeof(cam_data));
+
+	ret_val	= v4l2_base_struct(&cam,SET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * init the reserved memory for camera 
+ */
+
+	ret_val	= init_phy_mem();
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+#if (CONFIG_USE_TI_RESIZER == DISABLE)
+	cam->omap3isp_driver.probe		= isp_probe;
+	cam->omap3isp_driver.remove		= isp_remove;
+	cam->omap3isp_driver.driver.name	= "omap3isp";
+
+	plat_ret = platform_driver_register(&cam->omap3isp_driver);
+	if (plat_ret)
+	{
+		TRACE_ERR_AND_RET(plat_ret);
+	}
+#endif
+	ret_val	= isp_probe_late_init(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+	return SUCCESS;
+
+	exit:
+	{
+		platform_driver_unregister(&cam->omap3isp_driver);
+		
+		ret_val	= v4l2_base_struct(&cam,MAKE_ADDRESS_INVALID);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			printk(KERN_ERR "Failed to register the camera device\n");
+			TRACE_ERR_AND_RET(FAIL);
+		}
+		TRACE_ERR_AND_RET(FAIL);
+	}
+}
+
+module_init(cam_driver_init);
+
+module_param(video_nr, int, 0444);
+MODULE_AUTHOR("e-consystems india pvt. lmt");
+MODULE_DESCRIPTION("V4L2 capture driver for omap based cameras");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("video");
diff -Naur linux-org/drivers/media/video/ecam32/isp.c linux-ths/drivers/media/video/ecam32/isp.c
--- linux-org/drivers/media/video/ecam32/isp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/isp.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,765 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+static UINT32 cam_mclk	= CONFIG_SENS_MCLK;
+module_param(cam_mclk,int, 0444);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	ISR ROUTINE				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	omap34xx_isp_isr	
+ *  Parameter1	:	INT32 irq
+ *  Parameter2	:	PINT0 _cam	- private data number
+ *  Returns	:	irq - handled information
+ *  Description	: 	interrupt service routine 
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+irqreturn_t omap34xx_isp_isr(INT32 irq,PINT0 _cam)
+{
+	cam_data *cam	= _cam;
+	FNRESLT ret_val;
+	static UINT32 using_dummy_buffer	= DISABLE;
+	static UINT32 fill_dummy_buf		= DISABLE;
+	union
+	{
+		UVINT32 ISP_IRQ0ENABLE;
+		struct isp_irq bit;
+	}isp_status;
+	isp_status.ISP_IRQ0ENABLE				= (cam->isp->isp_main.reg.isp_irq0status.ISP_IRQ0STATUS & CCDC_VD0);
+	cam->isp->isp_main.reg.isp_irq0status.ISP_IRQ0STATUS	= isp_status.ISP_IRQ0ENABLE;
+	cam->isp->isp_main.reg.isp_irq1status.ISP_IRQ1STATUS	= cam->isp->isp_main.reg.isp_irq1status.ISP_IRQ1STATUS;
+
+	if(isp_status.bit.ccdc_vd0_irq			== ENABLED)
+	{
+		if(cam->task.bit.still	== ENABLE)
+		{
+			cam->still.frame_count++;
+			if(cam->still.frame_count >= STILL_IMAGE_CAPTURE_FRAME_NUMBER)
+			{
+				wake_up_interruptible(&cam->still.dma_frame_complete_still);
+				cam->still.wait_queue_head_t_dma_frame_complete_still	= ENABLE;
+			}
+		}else if(cam->task.bit.capture	== ENABLE)
+		{
+
+#if (!defined(CONFIG_CTRL_FRAME_RATE_FRM_SENSOR))
+			static UINT32 frame_skip_count;
+			static UINT32 capture_frame_rate;
+			static UINT32 current_fps	= SENS_MAX_FPS;
+			static struct timeval timestamp_rec;
+			struct timeval timestamp;
+			static INT32 frame_rate_denominator = SENS_MAX_FPS;
+
+			if(frame_rate_denominator != cam->capture.s_parm.parm.capture.timeperframe.denominator)
+			{
+				frame_skip_count	= DISABLE;
+				frame_rate_denominator	= cam->capture.s_parm.parm.capture.timeperframe.denominator;
+			}
+
+			do_gettimeofday(&timestamp);
+
+			if(timestamp_rec.tv_sec	== DISABLE && timestamp_rec.tv_usec == DISABLE)
+			{
+				do_gettimeofday(&timestamp_rec);
+			}
+
+			if (timestamp.tv_sec > timestamp_rec.tv_sec)
+			{
+				current_fps		= capture_frame_rate;
+				capture_frame_rate	= DISABLE;
+				timestamp_rec		= timestamp;
+			}
+			capture_frame_rate++;
+#endif 
+
+ /*
+ * Process the completed buffer
+  */
+			if(using_dummy_buffer	== DISABLE)
+			{
+				if(cam->capture.processing)
+				{
+					__link_node(cam->capture.filled, cam->capture.processing);
+					do_gettimeofday(&cam->capture.processing->buffer.timestamp);
+					cam->capture.processing->buffer.flags	|= V4L2_BUF_FLAG_DONE;
+					cam->capture.valid_buf++;
+				}
+			}
+
+			if(fill_dummy_buf	== DISABLE)
+			{
+
+/*
+ * Process the next processing buffer
+ */
+				cam->capture.processing			= cam->capture.Need_to_be_filled;
+				if(cam->capture.processing)
+				{
+					__update_base(cam->capture.Need_to_be_filled);
+					using_dummy_buffer	= DISABLE;
+				}else
+				{
+					if((cam->capture.filled) && (cam->capture.filled->next))
+					{
+						cam->capture.processing		= cam->capture.filled;
+					}
+
+					if(cam->capture.processing)
+					{
+						__update_base(cam->capture.filled);
+						cam->capture.valid_buf--;
+						using_dummy_buffer	= DISABLE;
+					}else
+					{
+						cam->capture.processing	= &cam->capture.frame[cam->capture.available_buf-1];
+						using_dummy_buffer	= ENABLE;
+					}
+				}
+			}else
+			{
+				cam->capture.processing	= &cam->capture.frame[cam->capture.available_buf-1];
+				using_dummy_buffer	= ENABLE;
+			}
+
+			if(cam->capture.valid_buf)
+			{
+				wake_up_interruptible(&cam->capture.capture_frame_complete);
+			}
+
+			cam->capture.processing->next		= NULL;
+			ret_val	= isp_prg_sdram_addr(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				
+			}
+
+#ifndef CONFIG_CTRL_FRAME_RATE_FRM_SENSOR
+			frame_skip_count	+= ((1000000*cam->capture.s_parm.parm.capture.			\
+							timeperframe.denominator)/current_fps);
+			if(frame_skip_count > 1000000)
+			{
+				frame_skip_count -=1000000;
+				fill_dummy_buf	= DISABLE;
+			}else
+			{
+				fill_dummy_buf	= ENABLE;
+			}
+#endif
+		}
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	isp_set_xclk
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	xclk		- Needed mclk given to sensor
+ *  Parameter3	:	xclksel		- Needed xclk mode in the omap
+*  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	Sets the mclk provided to the sensor
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT isp_set_xclk(cam_data *cam,UINT32 xclk, UINT8 xclksel, UPINT32 current_xclk)
+{
+#define CM_CAM_MCLK_HZ			216000000
+#define ISPTCTRL_CTRL_DIV_BYPASS	0x1F
+
+	UINT32 divisor;
+	UINT32 currentxclk;
+
+	if (xclk >= CM_CAM_MCLK_HZ)
+	{
+		divisor = ISPTCTRL_CTRL_DIV_BYPASS;
+		currentxclk = CM_CAM_MCLK_HZ;
+	}else if (xclk >= 2)
+	{
+		divisor = CM_CAM_MCLK_HZ / xclk;
+		if (divisor >= ISPTCTRL_CTRL_DIV_BYPASS)
+			divisor = ISPTCTRL_CTRL_DIV_BYPASS - 1;
+		currentxclk = CM_CAM_MCLK_HZ / divisor;
+	}else
+	{
+		divisor = xclk;
+		currentxclk = 0;
+	}
+
+	switch (xclksel)
+	{
+		case 0:
+		{
+			cam->isp->isp_main.reg.tctrl_ctrl.bit.diva	= divisor;
+		}break;
+
+		case 1:
+		{
+			cam->isp->isp_main.reg.tctrl_ctrl.bit.divb	= divisor;
+		}break;
+
+		default:
+		{
+			return FAIL;
+		}
+	}
+
+	if(current_xclk)
+	{
+		*current_xclk	= currentxclk;
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	mclk_to_sensor
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	option		- command to perform 
+ *  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Function callback exposed to other layers.
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT mclk_to_sensor(cam_data *cam,UINT32 xclk,UPINT32 clk_set)
+{
+	FNRESLT ret_val;
+
+	ret_val	= isp_set_xclk(cam,xclk,0,clk_set);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	omap_isp_base_struct
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	option		- command to perform 
+ *  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	maintain the base pointer of pin configuration.
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT omap_isp_base_struct(cam_data *cam,UINT8 option)
+{
+
+/*
+ * SET_ADDRESS 
+ * GET_ADDRESS 
+ * MAKE_ADDRESS_INVALID
+ * CREATE_ADDRESS
+ */
+	static UINT32 g_cam_isp;
+
+	if(cam == NULL)
+	{
+		TRACE_ERROR(MEMORY_NOT_VALID);	
+		return MEMORY_NOT_VALID;
+	}
+	switch(option)
+	{
+		case SET_ADDRESS:
+		{
+			g_cam_isp =(UINT32)cam->isp;			
+		}break;
+		case GET_ADDRESS:
+		{
+			cam->isp	= (isp_reg_bit_access*)g_cam_isp;
+		}break;
+		case MAKE_ADDRESS_INVALID:
+		{
+			if(cam->isp	== NULL)
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+			iounmap(cam->isp);
+			cam->isp	= NULL;
+			g_cam_isp	= DISABLE;
+		}break;
+		case CREATE_ADDRESS:
+		{
+			cam->isp	= ioremap(BADDR_ISP,MAP_ISP_REGION);
+			if(cam->isp	== NULL)
+			{
+				printk(KERN_ERR "Unable to remap the isp registers\n");
+				TRACE_ERR_AND_RET(FAIL);
+			}			
+		}break;
+		default:
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	reset the isp and ccdc interface
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT isp_reset(cam_data *cam)
+{
+	UINT32 time_out	= 10;
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	
+/*
+ * Clear all the status register and irq registers
+ */
+	cam->isp->isp_main.reg.isp_irq0enable.ISP_IRQ0ENABLE	= DISABLE;
+	cam->isp->isp_main.reg.isp_irq0status.ISP_IRQ0STATUS	= cam->isp->isp_main.reg.isp_irq0status.ISP_IRQ0STATUS;
+
+	cam->isp->isp_main.reg.isp_irq1enable.ISP_IRQ1ENABLE	= DISABLE;
+	cam->isp->isp_main.reg.isp_irq1status.ISP_IRQ1STATUS	= cam->isp->isp_main.reg.isp_irq1status.ISP_IRQ1STATUS;
+
+/*
+ * Enable the soft reset
+ */
+	cam->isp->isp_main.reg.isp_sysconfig.bit.soft_reset	= ENABLE;
+
+/*
+ * Check the reset is done 
+ */
+	for(;time_out--;)
+	{
+		if(cam->isp->isp_main.reg.isp_sysstatus.bit.reset_done	== ENABLE)
+		{
+			break;
+		}
+		mdelay(100);
+	}
+
+	cam->isp->isp_main.reg.isp_sysconfig.bit.midle_mode	= ENABLE;
+	cam->isp->isp_main.reg.isp_sysconfig.bit.auto_idle	= DISABLE;
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	program the ccdc sdram address.
+ *  Comments	:  	In the programed sdram address the new frame from the sensor be filled.
+ ************************************************************************************************************/
+
+FNRESLT program_dummy_isp_sdram_addr(cam_data *cam)
+ {
+	if(cam->capture.available_buf	<= DISABLE)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	cam->isp->isp_ccdc.reg.CCDC_SDR_ADDR	= cam->capture.frame[cam->capture.available_buf].buffer.m.offset;
+ 	return SUCCESS;
+ }
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	program the ccdc sdram address.
+ *  Comments	:  	In the programed sdram address the new frame from the sensor be filled.
+ ************************************************************************************************************/
+FNRESLT isp_prg_sdram_addr(cam_data *cam)
+{
+	static struct timeval timestamp;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+	struct tm timecode;
+#endif
+
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * Take the current time stamp
+ */
+	do_gettimeofday(&timestamp);
+
+	if(cam->task.bit.still	== ENABLE)
+	{
+		cam->isp->isp_ccdc.reg.CCDC_SDR_ADDR	= cam->still.phy_addr;
+	}else if(cam->task.bit.capture == ENABLE)
+	{
+		cam->isp->isp_ccdc.reg.CCDC_SDR_ADDR			= cam->capture.processing->buffer.m.offset;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
+		time_to_tm(cam->capture.processing->buffer.timestamp.tv_sec,DISABLE, &timecode);
+		cam->capture.processing->buffer.timecode.seconds	= timecode.tm_sec;
+		cam->capture.processing->buffer.timecode.minutes	= timecode.tm_min;
+		cam->capture.processing->buffer.timecode.hours		= timecode.tm_hour;
+#if (SENS_MAX_FPS <= 30)
+		cam->capture.processing->buffer.timecode.type		= V4L2_TC_TYPE_30FPS;
+#else
+		cam->capture.processing->buffer.timecode.type		= V4L2_TC_TYPE_60FPS;
+#endif
+		cam->capture.processing->buffer.timecode.flags		= V4L2_TC_FLAG_COLORFRAME;
+		cam->capture.processing->buffer.timecode.frames		= cam->capture.buffer_sequence;
+#endif
+		cam->capture.processing->buffer.sequence		= cam->capture.buffer_sequence;
+
+	}
+	
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	disable the irq0 interrupt
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT disable_isp_irq0(cam_data *cam)
+{
+	cam->isp->isp_main.reg.isp_irq0enable.ISP_IRQ0ENABLE	= DISABLE;
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Configure the isp side
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT isp_configure(cam_data *cam)
+{
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	cam->isp->isp_main.reg.isp_ctrl.ISP_CTRL		= DISABLE;
+	cam->isp->isp_main.reg.isp_ctrl.bit.ccdc_clk_en		= ENABLE;
+	cam->isp->isp_main.reg.isp_ctrl.bit.par_bridge		= ISPM_ISP_CTRL_MEM_ORDER_MSB_LSB;
+
+	cam->isp->isp_main.reg.isp_ctrl.bit.par_ser_clk_sel	= DISABLE;
+	cam->isp->isp_main.reg.isp_ctrl.bit.ccdc_ram_en		= ENABLE;
+	cam->isp->isp_main.reg.isp_ctrl.bit.sync_detect		= ISPM_ISP_CTRL_SYNC_DETECT_VS_FALL;
+#if (CONFIG_ISP_DATA_LINE_SHIFT == ENABLE)
+	cam->isp->isp_main.reg.isp_ctrl.bit.shift		= ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_0_CAM13_0;
+#elif (CONFIG_ISP_DATA_LINE_SHIFT == DISABLE)
+	cam->isp->isp_main.reg.isp_ctrl.bit.shift		= ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_2_CAM11_0;
+#endif
+
+//	cam->isp->isp_main.reg.isp_ctrl.bit.sbl_wr1_ram_en	= DISABLE;
+//	cam->isp->isp_main.reg.isp_ctrl.bit.sbl_rd_ram_en	= DISABLE;
+
+	/*
+	 * Pixel clock polority
+	 * 1. From camera side Falling edge the data will be put into the bus.
+	 *    In omap side at raising edge the data will be taken form sampling.
+	 */
+
+	cam->isp->isp_main.reg.isp_ctrl.bit.par_clk_pol		= DISABLE;	
+	cam->isp->isp_ccdc.reg.ccdc_hsize_off.bit.lnofst	= cam->capture.v2f.fmt.pix.bytesperline;
+
+	cam->isp->isp_ccdc.reg.ccdc_cfg.bit.vdlc		= ENABLE;
+
+	cam->isp->isp_ccdc.reg.ccdc_syn_mode.bit.vdhden		= ENABLE;
+	cam->isp->isp_ccdc.reg.ccdc_syn_mode.bit.datsiz		= 0x0;
+	cam->isp->isp_ccdc.reg.ccdc_syn_mode.bit.inpmod		= ISP_CCDC_CCDC_SYNC_MODE_IMPMOD_YUV_16BIT;
+	cam->isp->isp_ccdc.reg.ccdc_syn_mode.bit.wen		= ENABLE;
+	cam->isp->isp_ccdc.reg.ccdc_syn_mode.bit.exwen		= DISABLE;
+	cam->isp->isp_ccdc.reg.ccdc_horz_info.bit.nph		= cam->capture.v2f.fmt.pix.width -1;
+
+	cam->isp->isp_ccdc.reg.ccdc_vert_start.bit.slv0		= CONFIG_ISP_SLV0_DISCARD_COUNT;
+	cam->isp->isp_ccdc.reg.ccdc_vert_start.bit.slv1		= DISABLE;
+
+	switch(cam->cam_sensor.fmt.fmt.pix.pixelformat)	
+	{
+		case V4L2_PIX_FMT_YUV420:
+		{
+			cam->isp->isp_ccdc.reg.ccdc_vert_lines.bit.nlv	= (cam->capture.v2f.fmt.pix.height*3/4) -1;
+		}break;
+
+		default:
+		{
+			cam->isp->isp_ccdc.reg.ccdc_vert_lines.bit.nlv	= cam->capture.v2f.fmt.pix.height -1;
+		}break;
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	After configuration isp irq0 is enabled
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT enable_isp_irq0(cam_data *cam)
+{
+	cam->isp->isp_ccdc.reg.ccdc_vdint.bit.vdint0		= cam->capture.v2f.fmt.pix.height -1;
+	cam->isp->isp_main.reg.isp_irq0enable.ISP_IRQ0ENABLE	= DISABLE;
+	cam->isp->isp_main.reg.isp_irq0enable.bit.ccdc_vd0_irq	= ENABLE;
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	enable the ccdc unit.
+ *  Comments	:  	Once ccdc unit is enabled it will copy the frame into programmed sdram address.
+ ************************************************************************************************************/
+FNRESLT enable_ccdc(cam_data *cam)
+{
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	cam->isp->isp_ccdc.reg.ccdc_pcr.bit.enable		= ENABLE;
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	disable_ccdc
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	disable ccdc unit
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT disable_ccdc(cam_data *cam)
+{
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	cam->isp->isp_ccdc.reg.ccdc_pcr.bit.enable		= DISABLE;
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	init_cam_isp_ccdc
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+  *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	init routine of ccdc done here
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_cam_isp_ccdc(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * Validate the input
+ */
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+/*
+ * map the physical address of isp registers 
+ * to kernel virtual address
+ */
+#if (CONFIG_USE_TI_RESIZER == ENABLE)
+	ret_val	= omap_isp_base_struct(cam,CREATE_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to map the camera isp registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+#endif
+	ret_val	= omap_isp_base_struct(cam,SET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to map the camera isp registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	if(cam_mclk)
+	{
+		ret_val	= isp_set_xclk(cam,cam_mclk,0,NULL);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);		
+		}
+	}
+/*
+ * Call back function for changing the mclk is assinged here
+ */
+	cam->modify_mclk_to_sensor	= mclk_to_sensor;
+	
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_V4L2_BASE	
+ *  Name	:	exit_cam_isp_ccdc
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Perform cleanup routine done here
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT exit_cam_isp_ccdc(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * Validate the input
+ */
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * unmap the kernel space and 
+ * Perform cleaning of structure
+ */
+
+	ret_val	= omap_isp_base_struct(cam,MAKE_ADDRESS_INVALID);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to unmap the camera isp registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/isp.h linux-ths/drivers/media/video/ecam32/isp.h
--- linux-org/drivers/media/video/ecam32/isp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/isp.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,716 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * Values for the isp structure members
+ */
+#define ISPM_ISP_CTRL_MEM_ORDER_MSB_LSB			3
+#define ISPM_ISP_CTRL_MEM_ORDER_LSB_MSB			2
+
+#define ISP_CCDC_CCDC_SYNC_MODE_IMPMOD_RAW_DATA		0
+#define ISP_CCDC_CCDC_SYNC_MODE_IMPMOD_YUV_16BIT	1
+
+#define ISPM_ISP_CTRL_SYNC_DETECT_HS_FALL		0
+#define ISPM_ISP_CTRL_SYNC_DETECT_HS_RISE		1
+#define ISPM_ISP_CTRL_SYNC_DETECT_VS_FALL		2
+#define ISPM_ISP_CTRL_SYNC_DETECT_VS_RISE		3
+
+#define ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_0_CAM13_0	0
+#define ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_2_CAM11_0	1
+#define ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_4_CAM9_0	2
+#define ISPM_ISP_CTRL_BIT_SHIFT_CAMEXT13_6_CAM7_0	3
+
+/*
+ * structure definition
+ */
+
+#define MAP_ISP_REGION			0x2000	
+#define BADDR_ISP			0x480BC000
+#define BADDR_ISP_CBUFF			0x480BC100
+#define BADDR_ISP_CCDC			0x480BC600
+#define BADDR_ISP_HIST			0x480BCA00
+#define BADDR_ISP_H3A			0x480BCC00
+#define BADDR_ISP_PREVIEW		0x480BCE00
+#define BADDR_ISP_RESIZER		0x480BD000
+#define BADDR_ISP_SBL			0x480BD200
+#define BADDR_ISP_SBL_END		0x480BD300
+
+enum isp_irqevents
+{
+	CSIA = 0x01,
+	CSIB = 0x10,
+	CCDC_VD0 = 0x100,
+	CCDC_VD1 = 0x200,
+	CCDC_VD2 = 0x400,
+	CCDC_ERR = 0x800,
+	H3A_AWB_DONE = 0x2000,
+	H3A_AF_DONE = 0x1000,
+	HIST_DONE = 0x10000,
+	PREV_DONE = 0x100000,
+	LSC_DONE = 0x20000,
+	LSC_PRE_COMP = 0x40000,
+	LSC_PRE_ERR = 0x80000,
+	RESZ_DONE = 0x1000000,
+	SBL_OVF = 0x2000000,
+	MMU_ERR = 0x10000000,
+	OCP_ERR = 0x20000000,
+	HS_VS = 0x80000000
+};
+
+struct isp_irq
+{
+	UVINT32 reserved0				:8;
+	UVINT32 ccdc_vd0_irq				:1;
+	UVINT32 ccdc_vd1_irq				:1;
+	UVINT32 ccdc_vd2_irq				:1;
+	UVINT32 ccdc_err_irq				:1;
+	UVINT32 h3a_af_done_irq				:1;
+	UVINT32 h3a_awb_done_irq			:1;
+	UVINT32 reserved1				:2;
+	UVINT32 hist_done_irq				:1;
+	UVINT32 ccdc_lsc_done				:1;
+	UVINT32 ccdc_lsc_prefectch_completed		:1;
+	UVINT32 ccdc_lsc_prefectch_error		:1;
+	UVINT32 prv_done_irq				:1;
+	UVINT32 cbuff_irq				:1;
+	UVINT32 reserved2				:2;
+	UVINT32 rsz_done_irq				:1;
+	UVINT32 ovf_irq					:1;
+	UVINT32 reserved3				:2;
+	UVINT32 mmu_err_irq				:1;
+	UVINT32 ocp_err_irq				:1;
+	UVINT32 sec_err_irq				:1;
+	UVINT32 hs_vs_irq				:1;					
+};
+
+/*
+ * Module Name Base address (hex) Size
+ * ISP            0x480B C000          512 bytes
+ * ISP_CBUFF      0x480B C100          256 bytes
+ * ISP_CCDC       0x480B C600          512 bytes
+ * ISP_HIST       0x480B CA00          512 bytes
+ * ISP_H3A        0x480B CC00          512 bytes
+ * ISP_PREVIEW    0x480B CE00          512 bytes
+ * ISP_RESIZER    0x480B D000          512 bytes
+ * ISP_SBL        0x480B D200          512 bytes
+ */
+
+typedef struct __isp_reg_bit_access
+{
+	union
+	{
+/*
+ * 
+ * Register Name       Type Register   Address     Physical     Section
+ *                          Width      Offset     Address
+ *                          (Bits)
+ * ISP_SYSCONFIG        RW     32    0x0000 0004 0x480B C004 Section 1.6.2.1
+ * ISP_SYSSTATUS         R     32    0x0000 0008 0x480B C008 Section 1.6.2.2
+ * ISP_IRQ0ENABLE       RW     32    0x0000 000C 0x480B C00C Section 1.6.2.3
+ * ISP_IRQ0STATUS       RW     32    0x0000 0010 0x480B C010 Section 1.6.2.4
+ * ISP_IRQ1ENABLE       RW     32    0x0000 0014 0x480B C014 Section 1.6.2.5
+ * ISP_IRQ1STATUS       RW     32    0x0000 0018 0x480B C018 Section 1.6.2.6
+ * TCTRL_GRESET_LENGTH  RW     32    0x0000 0030 0x480B C030 Section 1.6.2.7
+ * TCTRL_PSTRB_REPLAY   RW     32    0x0000 0034 0x480B C034 Section 1.6.2.8
+ * ISP_CTRL             RW     32    0x0000 0040 0x480B C040 Section 1.6.2.9
+ * ISP_SECURE           RW     32    0x0000 0044 0x480B C044 Section 1.6.2.10
+ * TCTRL_CTRL           RW     32    0x0000 0050 0x480B C050 Section 1.6.2.11
+ * TCTRL_FRAME          RW     32    0x0000 0054 0x480B C054 Section 1.6.2.12
+ * TCTRL_PSTRB_DELAY    RW     32    0x0000 0058 0x480B C058 Section 1.6.2.13
+ * TCTRL_STRB_DELAY     RW     32    0x0000 005C 0x480B C05C Section 1.6.2.14
+ * TCTRL_SHUT_DELAY     RW     32    0x0000 0060 0x480B C060 Section 1.6.2.15
+ * TCTRL_PSTRB_LENGTH   RW     32    0x0000 0064 0x480B C064 Section 1.6.2.16
+ * TCTRL_STRB_LENGTH    RW     32    0x0000 0068 0x480B C068 Section 1.6.2.17
+ * TCTRL_SHUT_LENGTH    RW     32    0x0000 006C 0x480B C06C Section 1.6.2.18
+ */
+
+		UVINT32 ISP[((BADDR_ISP_CBUFF-BADDR_ISP)/4)];
+		struct
+		{	
+			UVINT32 ISP_VER;			// 0x0000 0000
+			union
+			{
+				UVINT32 ISP_SYSCONFIG;		// 0x0000 0004
+				struct
+				{
+					UVINT32 auto_idle		:1;
+					UVINT32 soft_reset		:1;
+					UVINT32 reserved1		:10;
+					UVINT32 midle_mode		:2;
+				}bit;
+			}isp_sysconfig;
+			
+			union
+			{
+				UVINT32 ISP_SYSSTATUS;		// 0x0000 0008
+				struct
+				{
+					UVINT32 reset_done		:1;
+				}bit;
+			}isp_sysstatus;
+			
+			union
+			{
+				UVINT32 ISP_IRQ0ENABLE;		// 0x0000 000C
+				struct isp_irq bit;
+			}isp_irq0enable;
+
+			union 
+			{
+				UVINT32 ISP_IRQ0STATUS;		// 0x0000 0010
+				struct isp_irq bit;
+
+			}isp_irq0status;
+
+			union
+			{
+				UVINT32 ISP_IRQ1ENABLE;		// 0x0000 0014
+				struct isp_irq bit;
+
+			}isp_irq1enable;
+
+			union
+			{
+				UVINT32 ISP_IRQ1STATUS;		// 0x0000 0018
+				struct isp_irq bit;
+			}isp_irq1status;
+
+			UVINT32 RESERVED0[5];
+			union
+			{
+				UVINT32 TCTRL_GRESET_LENGTH;	// 0x0000 0030
+				struct
+				{
+					UVINT32 length			:24;
+					UVINT32 reserved		:8;
+				}bit;
+			}tctrl_greset_length;
+			UVINT32 TCTRL_PSTRB_REPLAY;		// 0x0000 0034
+			UVINT32 RESERVED1[2];
+			
+			union
+			{
+				UVINT32 ISP_CTRL;		// 0x0000 0040
+				struct
+				{
+					UVINT32 par_ser_clk_sel		:2;
+					UVINT32 par_bridge		:2;
+					UVINT32 par_clk_pol		:1;
+					UVINT32 reserved0		:1;
+					UVINT32 shift			:2;
+					UVINT32 ccdc_clk_en		:1;
+					UVINT32 cbuff_autogating	:1;
+					UVINT32 h3a_clk_en		:1;
+					UVINT32 hist_clk_en		:1;
+					UVINT32 prv_clk_en		:1;
+					UVINT32 rsz_clk_en		:1;
+					UVINT32 sync_detect		:2;
+					UVINT32 ccdc_ram_en		:1;
+					UVINT32 prev_ram_en		:1;
+					UVINT32 sbl_rd_ram_en		:1;
+					UVINT32 sbl_wr1_ram_en		:1;
+					UVINT32 sbl_wr0_ram_en		:1;
+					UVINT32 sbl_autoidle		:1;
+					UVINT32 reserved1		:6;
+					UVINT32 sbl_shared_rportb	:1;
+					UVINT32 ccdc_wen_pol		:1;
+					UVINT32 jpeg_flush		:1;
+					UVINT32 flush			:1;
+				}bit;
+			}isp_ctrl;
+
+			UVINT32 ISP_SECURE;			// 0x0000 0044
+			UVINT32 RESERVED2[2];
+			union
+			{			
+				UVINT32 TCTRL_CTRL;		// 0x0000 0050
+				struct
+				{
+					UVINT32 diva			:5;
+					UVINT32 divb			:5;
+					UVINT32 divc			:9;
+					UVINT32 reserved0		:2;
+					UVINT32 shuten			:1;
+					UVINT32 pstrben			:1;
+					UVINT32 strben			:1;
+					UVINT32 shutpol			:1;
+					UVINT32 reserved1		:1;
+					UVINT32 strbpstrbpol		:1;
+					UVINT32 insel			:2;
+					UVINT32 greseten		:1;
+					UVINT32 gresetpol		:1;
+					UVINT32 gresetdir		:1;
+				}bit;
+			}tctrl_ctrl;
+			
+			UVINT32 TCTRL_FRAME;			// 0x0000 0054
+			UVINT32 TCTRL_PSTRB_DELAY;		// 0x0000 0058
+			UVINT32 TCTRL_STRB_DELAY;		// 0x0000 005C
+			UVINT32 TCTRL_SHUT_DELAY;		// 0x0000 0060
+			UVINT32 TCTRL_PSTRB_LENGTH;		// 0x0000 0064
+			UVINT32 TCTRL_STRB_LENGTH;		// 0x0000 0068
+			UVINT32 TCTRL_SHUT_LENGTH;		// 0x0000 006C
+		}reg;
+	}isp_main;
+
+	union
+	{
+/*
+ * CBUFF_SYSCONFIG       RW 32      0x0000 0010             0x480B C110             Section 1.6.3.1
+ * CBUFF_SYSSTATUS        R 32      0x0000 0014             0x480B C114             Section 1.6.3.2
+ * CBUFF_IRQSTATUS       RW 32      0x0000 0018             0x480B C118             Section 1.6.3.3
+ * CBUFF_IRQENABLE       RW 32      0x0000 001C             0x480B C11C             Section 1.6.3.4
+ * CBUFFx_CTRL (1)       RW 32      0x0000 0020 + (0x4 * x) 0x480B C120 + (0x4 * x) Section 1.6.3.5
+ * CBUFFx_STATUS (1)      R 32      0x0000 0030 + (0x4 * x) 0x480B C130 + (0x4 * x) Section 1.6.3.6
+ * CBUFFx_START (1)      RW 32      0x0000 0040 + (0x4 * x) 0x480B C140 + (0x4 * x) Section 1.6.3.7
+ * CBUFFx_END (1)        RW 32      0x0000 0050 + (0x4 * x) 0x480B C150 + (0x4 * x) Section 1.6.3.8
+ * CBUFFx_WINDOWSIZE (1) RW 32      0x0000 0060 + (0x4 * x) 0x480B C160 + (0x4 * x) Section 1.6.3.9
+ * CBUFFx_THRESHOLD (1)  RW 32      0x0000 0070 + (0x4 * x) 0x480B C170 + (0x4 * x) Section 1.6.3.10
+ */
+
+		UVINT32 ISP_CBUFF[((BADDR_ISP_CCDC-BADDR_ISP_CBUFF)/4)];
+	}isp_cbuff;
+	
+	union
+	{
+/*
+ * Register Name        Type Register        Address                 Physical            Section
+ *                          Width           Offset                 Address
+ *                          (Bits)
+ * CCDC_PID               R     32         0x0000 0000             0x480B C600        Section 1.6.4.1
+ * CCDC_PCR              RW     32         0x0000 0004             0x480B C604        Section 1.6.4.2
+ * CCDC_SYN_MODE         RW     32         0x0000 0008             0x480B C608        Section 1.6.4.3
+ * CCDC_HD_VD_WID        RW     32         0x0000 000C             0x480B C60C        Section 1.6.4.4
+ * CCDC_PIX_LINES        RW     32         0x0000 0010             0x480B C610        Section 1.6.4.5
+ * CCDC_HORZ_INFO        RW     32         0x0000 0014             0x480B C614        Section 1.6.4.6
+ * CCDC_VERT_START       RW     32         0x0000 0018             0x480B C618        Section 1.6.4.7
+ * CCDC_VERT_LINES       RW     32         0x0000 001C             0x480B C61C        Section 1.6.4.8
+ * CCDC_CULLING          RW     32         0x0000 0020             0x480B C620        Section 1.6.4.9
+ * CCDC_HSIZE_OFF        RW     32         0x0000 0024             0x480B C624        Section 1.6.4.10
+ * CCDC_SDOFST           RW     32         0x0000 0028             0x480B C628        Section 1.6.4.11
+ * CCDC_SDR_ADDR         RW     32         0x0000 002C             0x480B C62C        Section 1.6.4.12
+ * CCDC_CLAMP            RW     32         0x0000 0030             0x480B C630        Section 1.6.4.13
+ * CCDC_DCSUB            RW     32         0x0000 0034             0x480B C634        Section 1.6.4.14
+ * CCDC_COLPTN           RW     32         0x0000 0038             0x480B C638        Section 1.6.4.15
+ * CCDC_BLKCMP           RW     32         0x0000 003C             0x480B C63C        Section 1.6.4.16
+ * CCDC_FPC              RW     32         0x0000 0040             0x480B C640        Section 1.6.4.17
+ * CCDC_FPC_ADDR         RW     32         0x0000 0044             0x480B C644        Section 1.6.4.18
+ * CCDC_VDINT            RW     32         0x0000 0048             0x480B C648        Section 1.6.4.19
+ * CCDC_ALAW             RW     32         0x0000 004C             0x480B C64C        Section 1.6.4.20
+ * CCDC_REC656IF         RW     32         0x0000 0050             0x480B C650        Section 1.6.4.21
+ * CCDC_CFG              RW     32         0x0000 0054             0x480B C654        Section 1.6.4.22
+ * CCDC_FMTCFG           RW     32         0x0000 0058             0x480B C658        Section 1.6.4.23
+ * CCDC_FMT_HORZ         RW     32         0x0000 005C             0x480B C65C        Section 1.6.4.24
+ * CCDC_FMT_VERT         RW     32         0x0000 0060             0x480B C660        Section 1.6.4.25
+ * CCDC_FMT_ADDRx(1)     RW     32         0x0000 0064 + (0x4 * x) 0x480B C664 + (0x4 * x) Section 1.6.4.26
+ * CCDC_PRGEVEN0         RW     32         0x0000 0084             0x480B C684        Section 1.6.4.27
+ * CCDC_PRGEVEN1         RW     32         0x0000 0088             0x480B C688        Section 1.6.4.28
+ * CCDC_PRGODD0          RW     32         0x0000 008C             0x480B C68C        Section 1.6.4.29
+ * CCDC_PRGODD1          RW     32         0x0000 0090             0x480B C690        Section 1.6.4.30
+ * CCDC_VP_OUT           RW     32         0x0000 0094             0x480B C694        Section 1.6.4.31
+ * CCDC_LSC_CONFIG       RW     32         0x0000 0098             0x480B C698        Section 1.6.4.32
+ * CCDC_LSC_INITIAL      RW     32         0x0000 009C             0x480B C69C        Section 1.6.4.33
+ * CCDC_LSC_TABLE_BASE   RW     32         0x0000 00A0             0x480B C6A0        Section 1.6.4.34
+ * CCDC_LSC_TABLE_OFFSET RW     32         0x0000 00A4             0x480B C6A4        Section 1.6.4.35
+ */
+
+		UVINT32 ISP_CCDC[((BADDR_ISP_HIST-BADDR_ISP_CCDC)/4)];
+		struct
+		{
+			UVINT32 CCDC_PID;			// 0x0000 0000
+			union
+			{
+				UVINT32 CCDC_PCR;		// 0x0000 0004
+				struct
+				{
+					UVINT32 enable				:1;
+					UVINT32 busy				:1;
+				}bit;
+			}ccdc_pcr;
+
+			union
+			{
+				UVINT32 CCDC_SYN_MODE;		// 0x0000 0008
+				struct
+				{
+					UVINT32 vdhdout				:1;
+					UVINT32 fldout				:1;
+					UVINT32 vdpol				:1;
+					UVINT32 hdpol				:1;
+					UVINT32 fldpol				:1;
+					UVINT32 exwen				:1;
+					UVINT32 datapol				:1;
+					UVINT32 fldmode				:1;
+					UVINT32 datsiz				:3;
+					UVINT32 pack8				:1;
+					UVINT32 inpmod				:2;
+					UVINT32 lpf				:1;
+					UVINT32 fldstat				:1;
+					UVINT32 vdhden				:1;
+					UVINT32 wen				:1;
+					UVINT32 vp2str				:1;
+					UVINT32 sdr2rsz				:1;
+				}bit;
+			}ccdc_syn_mode;
+
+			UVINT32 CCDC_HD_VD_WID;			// 0x0000 000C
+			UVINT32 CCDC_PIX_LINES;			// 0x0000 0010
+
+			union
+			{
+				UVINT32 CCDC_HORZ_INFO;		// 0x0000 0014
+				struct
+				{
+					UVINT32 nph				:15;
+					UVINT32 reserved0			:1;
+					UVINT32 sph				:15;
+					UVINT32 reserved1			:1;
+				}bit;
+			}ccdc_horz_info;
+
+			union
+			{
+				UVINT32 CCDC_VERT_START;	// 0x0000 0018
+				struct
+				{
+					UVINT32 slv1				:15;
+					UVINT32 reserved0			:1;
+					UVINT32 slv0				:15;
+					UVINT32 reserved1			:1;
+				}bit;
+			}ccdc_vert_start;
+		
+			union
+			{
+				UVINT32 CCDC_VERT_LINES;	// 0x0000 001C
+				struct
+				{
+					UVINT32 nlv				:15;
+				}bit;
+			}ccdc_vert_lines;
+			UVINT32 CCDC_CULLING;			// 0x0000 0020
+
+			union
+			{
+				UVINT32 CCDC_HSIZE_OFF;		// 0x0000 0024
+				struct
+				{
+					UVINT32 lnofst				:16;
+				}bit;
+			}ccdc_hsize_off;
+
+			UVINT32 CCDC_SDOFST;			// 0x0000 0028
+			UVINT32 CCDC_SDR_ADDR;			// 0x0000 002C
+			UVINT32 CCDC_CLAMP;			// 0x0000 0030
+			UVINT32 CCDC_DCSUB;			// 0x0000 0034
+			UVINT32 CCDC_COLPTN;			// 0x0000 0038
+			UVINT32 CCDC_BLKCMP;			// 0x0000 003C
+			UVINT32 CCDC_FPC;			// 0x0000 0040
+			UVINT32 CCDC_FPC_ADDR;			// 0x0000 0044
+
+			union
+			{
+				UVINT32 CCDC_VDINT;		// 0x0000 0048
+				struct
+				{
+					UVINT32 vdint1				:15;
+					UVINT32 reserved0			:1;
+					UVINT32 vdint0				:15;
+				}bit;
+			}ccdc_vdint;
+
+			UVINT32 CCDC_ALAW;			// 0x0000 004C
+			UVINT32 CCDC_REC656IF;			// 0x0000 0050
+
+			union
+			{
+				UVINT32 CCDC_CFG;		// 0x0000 0054 
+				struct
+				{
+					UVINT32 reserved0			:5;
+					UVINT32 bw565				:1;
+					UVINT32 fidmd				:2;
+					UVINT32 wenlog				:1;
+					UVINT32 reserved1			:2;
+					UVINT32 y8pos				:1;
+					UVINT32 bswb				:1;
+					UVINT32 msbinvi				:1;
+					UVINT32 reserved2			:1;
+					UVINT32 vdlc				:1;
+				}bit;
+			}ccdc_cfg;
+
+			UVINT32 CCDC_FMTCFG;			// 0x0000 0058
+			UVINT32 CCDC_FMT_HORZ;			// 0x0000 005C
+			UVINT32 CCDC_FMT_VERT;			// 0x0000 0060
+			UVINT32 CCDC_FMT_ADDRx;			// 0x0000 0064
+			UVINT32 CCDC_PRGEVEN0;			// 0x0000 0084
+			UVINT32 CCDC_PRGEVEN1;			// 0x0000 0088
+			UVINT32 CCDC_PRGODD0;			// 0x0000 008C
+			UVINT32 CCDC_PRGODD1;			// 0x0000 0090
+			UVINT32 CCDC_VP_OUT;			// 0x0000 0094 
+			UVINT32 CCDC_LSC_CONFIG;		// 0x0000 0098
+			UVINT32 CCDC_LSC_INITIAL;		// 0x0000 009C
+			UVINT32 CCDC_LSC_TABLE_BASE;		// 0x0000 00A0
+			UVINT32 CCDC_LSC_TABLE_OFFSET;		// 0x0000 00A4 
+		}reg;
+	}isp_ccdc;
+	
+	union
+	{
+/*
+ * Register Name     Type Register        Address                 Physical            Section
+ *                        Width           Offset                 Address
+ *                       (Bits)
+ * HIST_PID            R     32         0x0000 0000             0x480B CA00        Section 1.6.5.1
+ * HIST_PCR           RW     32         0x0000 0004             0x480B CA04        Section 1.6.5.2
+ * HIST_CNT           RW     32         0x0000 0008             0x480B CA08        Section 1.6.5.3
+ * HIST_WB_GAIN       RW     32         0x0000 000C             0x480B CA0C         Section 1.6.5.4
+ * HIST_Rn_HORZ (1)   RW     32         0x0000 0010 + (0x8 * x) 0x480B CA10 + (0x8 * x) Section 1.6.5.5
+ * HIST_Rn_VERT (1)   RW     32         0x0000 0014 + (0x8 * x) 0x480B CA14 + (0x8 * x) Section 1.6.5.6
+ * HIST_ADDR          RW     32         0x0000 0030             0x480B CA30        Section 1.6.5.7
+ * HIST_DATA          RW     32         0x0000 0034             0x480B CA34        Section 1.6.5.8
+ * HIST_RADD          RW     32         0x0000 0038             0x480B CA38        Section 1.6.5.9
+ * HIST_RADD_OFF      RW     32         0x0000 003C             0x480B CA3C         Section 1.6.5.10
+ * HIST_H_V_INFO      RW     32         0x0000 0040             0x480B CA40        Section 1.6.5.11
+ */
+
+		UVINT32 ISP_HIST[((BADDR_ISP_H3A-BADDR_ISP_HIST)/4)];
+		
+	}isp_hist;
+
+	union
+	{
+/*
+ * Register Name  Type Register   Address     Physical     Section
+ *                    Width      Offset     Address
+ *                   (Bits)
+ * H3A_PID          R     32    0x0000 0000 0x480B CC00 Section 1.6.6.1
+ * H3A_PCR         RW     32    0x0000 0004 0x480B CC04 Section 1.6.6.2
+ * H3A_AFPAX1      RW     32    0x0000 0008 0x480B CC08 Section 1.6.6.3
+ * H3A_AFPAX2      RW     32    0x0000 000C 0x480B CC0C Section 1.6.6.4
+ * H3A_AFPAXSTART  RW     32    0x0000 0010 0x480B CC10 Section 1.6.6.5
+ * H3A_AFIIRSH     RW     32    0x0000 0014 0x480B CC14 Section 1.6.6.6
+ * H3A_AFBUFST     RW     32    0x0000 0018 0x480B CC18 Section 1.6.6.7
+ * H3A_AFCOEF010   RW     32    0x0000 001C 0x480B CC1C Section 1.6.6.8
+ * H3A_AFCOEF032   RW     32    0x0000 0020 0x480B CC20 Section 1.6.6.9
+ * H3A_AFCOEF054   RW     32    0x0000 0024 0x480B CC24 Section 1.6.6.10
+ * H3A_AFCOEF076   RW     32    0x0000 0028 0x480B CC28 Section 1.6.6.11
+ * H3A_AFCOEF098   RW     32    0x0000 002C 0x480B CC2C Section 1.6.6.12
+ * H3A_AFCOEF0010  RW     32    0x0000 0030 0x480B CC30 Section 1.6.6.13
+ * H3A_AFCOEF110   RW     32    0x0000 0034 0x480B CC34 Section 1.6.6.14
+ * H3A_AFCOEF132   RW     32    0x0000 0038 0x480B CC38 Section 1.6.6.15
+ * H3A_AFCOEF154   RW     32    0x0000 003C 0x480B CC3C Section 1.6.6.16
+ * H3A_AFCOEF176   RW     32    0x0000 0040 0x480B CC40 Section 1.6.6.17
+ * H3A_AFCOEF198   RW     32    0x0000 0044 0x480B CC44 Section 1.6.6.18
+ * H3A_AFCOEF1010  RW     32    0x0000 0048 0x480B CC48 Section 1.6.6.19
+ * H3A_AEWWIN1     RW     32    0x0000 004C 0x480B CC4C Section 1.6.6.20
+ * H3A_AEWINSTART  RW     32    0x0000 0050 0x480B CC50 Section 1.6.6.21
+ * H3A_AEWINBLK    RW     32    0x0000 0054 0x480B CC54 Section 1.6.6.22
+ * H3A_AEWSUBWIN   RW     32    0x0000 0058 0x480B CC58 Section 1.6.6.23
+ * H3A_AEWBUFST    RW     32    0x0000 005C 0x480B CC5C Section 1.6.6.24
+ */
+
+		UVINT32 ISP_H3A[((BADDR_ISP_PREVIEW-BADDR_ISP_H3A)/4)];
+		
+	}isp_h3a;
+
+	union
+	{
+/*
+ * Register Name  Type Register   Address     Physical     Section
+ *                   Width      Offset     Address
+ *                  (Bits)
+ * PRV_PID           R 32      0x0000 0000             0x480B CE00        Section 1.6.7.1
+ * PRV_PCR          RW 32      0x0000 0004             0x480B CE04        Section 1.6.7.2
+ * PRV_HORZ_INFO    RW 32      0x0000 0008             0x480B CE08        Section 1.6.7.3
+ * PRV_VERT_INFO    RW 32      0x0000 000C             0x480B CE0C        Section 1.6.7.4
+ * PRV_RSDR_ADDR    RW 32      0x0000 0010             0x480B CE10        Section 1.6.7.5
+ * PRV_RADR_OFFSET  RW 32      0x0000 0014             0x480B CE14        Section 1.6.7.6
+ * PRV_DSDR_ADDR    RW 32      0x0000 0018             0x480B CE18        Section 1.6.7.7
+ * PRV_DRKF_OFFSET  RW 32      0x0000 001C             0x480B CE1C        Section 1.6.7.8
+ * PRV_WSDR_ADDR    RW 32      0x0000 0020             0x480B CE20        Section 1.6.7.9
+ * PRV_WADD_OFFSET  RW 32      0x0000 0024             0x480B CE24        Section 1.6.7.10
+ * PRV_AVE          RW 32      0x0000 0028             0x480B CE28        Section 1.6.7.11
+ * PRV_HMED         RW 32      0x0000 002C             0x480B CE2C        Section 1.6.7.12
+ * PRV_NF           RW 32      0x0000 0030             0x480B CE30        Section 1.6.7.13
+ * PRV_WB_DGAIN     RW 32      0x0000 0034             0x480B CE34        Section 1.6.7.14
+ * PRV_WBGAIN       RW 32      0x0000 0038             0x480B CE38        Section 1.6.7.15
+ * PRV_WBSEL        RW 32      0x0000 003C             0x480B CE3C        Section 1.6.7.16
+ * PRV_CFA          RW 32      0x0000 0040             0x480B CE40        Section 1.6.7.17
+ * PRV_BLKADJOFF    RW 32      0x0000 0044             0x480B CE44        Section 1.6.7.18
+ * PRV_RGB_MAT1     RW 32      0x0000 0048             0x480B CE48        Section 1.6.7.19
+ * PRV_RGB_MAT2     RW 32      0x0000 004C             0x480B CE4C        Section 1.6.7.20
+ * PRV_RGB_MAT3     RW 32      0x0000 0050             0x480B CE50        Section 1.6.7.21
+ * PRV_RGB_MAT4     RW 32      0x0000 0054             0x480B CE54        Section 1.6.7.22
+ * PRV_RGB_MAT5     RW 32      0x0000 0058             0x480B CE58        Section 1.6.7.23
+ * PRV_RGB_OFF1     RW 32      0x0000 005C             0x480B CE5C        Section 1.6.7.24
+ * PRV_RGB_OFF2     RW 32      0x0000 0060             0x480B CE60        Section 1.6.7.25
+ * PRV_CSC0         RW 32      0x0000 0064             0x480B CE64        Section 1.6.7.26
+ * PRV_CSC1         RW 32      0x0000 0068             0x480B CE68        Section 1.6.7.27
+ * PRV_CSC2         RW 32      0x0000 006C             0x480B CE6C        Section 1.6.7.28
+ * PRV_CSC_OFFSET   RW 32      0x0000 0070             0x480B CE70        Section 1.6.7.29
+ * PRV_CNT_BRT      RW 32      0x0000 0074             0x480B CE74        Section 1.6.7.30
+ * PRV_CSUP         RW 32      0x0000 0078             0x480B CE78        Section 1.6.7.31
+ * PRV_SETUP_YC     RW 32      0x0000 007C             0x480B CE7C        Section 1.6.7.32
+ * PRV_SET_TBL_ADDR RW 32      0x0000 0080             0x480B CE80        Section 1.6.7.33
+ * PRV_SET_TBL_DATA RW 32      0x0000 0084             0x480B CE84        Section 1.6.7.34
+ * PRV_CDC_THRx (1) RW 32      0x0000 0090 + (0x4 * x) 0x480B CE90 + (0x4 * x) Section 1.6.7.35
+ */
+
+		UVINT32 ISP_PRV[((BADDR_ISP_RESIZER-BADDR_ISP_PREVIEW)/4)];
+		
+	}isp_pview;
+
+	union
+	{
+/*
+ * Register Name  Type Register   Address     Physical     Section
+ *                   Width      Offset     Address
+ *                  (Bits)
+ * RSZ_PID         R 32 0x0000 0000 0x480B D000 Section 1.6.8.1
+ * RSZ_PCR        RW 32 0x0000 0004 0x480B D004 Section 1.6.8.2
+ * RSZ_CNT        RW 32 0x0000 0008 0x480B D008 Section 1.6.8.3
+ * RSZ_OUT_SIZE   RW 32 0x0000 000C 0x480B D00C Section 1.6.8.4
+ * RSZ_IN_START   RW 32 0x0000 0010 0x480B D010 Section 1.6.8.5
+ * RSZ_IN_SIZE    RW 32 0x0000 0014 0x480B D014 Section 1.6.8.6
+ * RSZ_SDR_INADD  RW 32 0x0000 0018 0x480B D018 Section 1.6.8.7
+ * RSZ_SDR_INOFF  RW 32 0x0000 001C 0x480B D01C Section 1.6.8.8
+ * RSZ_SDR_OUTADD RW 32 0x0000 0020 0x480B D020 Section 1.6.8.9
+ * RSZ_SDR_OUTOFF RW 32 0x0000 0024 0x480B D024 Section 1.6.8.10
+ * RSZ_HFILT10    RW 32 0x0000 0028 0x480B D028 Section 1.6.8.11
+ * RSZ_HFILT32    RW 32 0x0000 002C 0x480B D02C Section 1.6.8.12
+ * RSZ_HFILT54    RW 32 0x0000 0030 0x480B D030 Section 1.6.8.13
+ * RSZ_HFILT76    RW 32 0x0000 0034 0x480B D034 Section 1.6.8.14
+ * RSZ_HFILT98    RW 32 0x0000 0038 0x480B D038 Section 1.6.8.15
+ * RSZ_HFILT1110  RW 32 0x0000 003C 0x480B D03C Section 1.6.8.16
+ * RSZ_HFILT1312  RW 32 0x0000 0040 0x480B D040 Section 1.6.8.17
+ * RSZ_HFILT1514  RW 32 0x0000 0044 0x480B D044 Section 1.6.8.18
+ * RSZ_HFILT1716  RW 32 0x0000 0048 0x480B D048 Section 1.6.8.19
+ * RSZ_HFILT1918  RW 32 0x0000 004C 0x480B D04C Section 1.6.8.20
+ * RSZ_HFILT2120  RW 32 0x0000 0050 0x480B D050 Section 1.6.8.21
+ * RSZ_HFILT2322  RW 32 0x0000 0054 0x480B D054 Section 1.6.8.22
+ * RSZ_HFILT2524  RW 32 0x0000 0058 0x480B D058 Section 1.6.8.23
+ * RSZ_HFILT2726  RW 32 0x0000 005C 0x480B D05C Section 1.6.8.24
+ * RSZ_HFILT2928  RW 32 0x0000 0060 0x480B D060 Section 1.6.8.25
+ * RSZ_HFILT3130  RW 32 0x0000 0064 0x480B D064 Section 1.6.8.26
+ * RSZ_VFILT10    RW 32 0x0000 0068 0x480B D068 Section 1.6.8.27
+ * RSZ_VFILT32    RW 32 0x0000 006C 0x480B D06C Section 1.6.8.28
+ * RSZ_VFILT54    RW 32 0x0000 0070 0x480B D070 Section 1.6.8.29
+ * RSZ_VFILT76    RW 32 0x0000 0074 0x480B D074 Section 1.6.8.30
+ * RSZ_VFILT98    RW 32 0x0000 0078 0x480B D078 Section 1.6.8.31
+ * RSZ_VFILT1110  RW 32 0x0000 007C 0x480B D07C Section 1.6.8.32
+ * RSZ_VFILT1312  RW 32 0x0000 0080 0x480B D080 Section 1.6.8.33
+ * RSZ_VFILT1514  RW 32 0x0000 0084 0x480B D084 Section 1.6.8.34
+ * RSZ_VFILT1716  RW 32 0x0000 0088 0x480B D088 Section 1.6.8.35
+ * RSZ_VFILT1918  RW 32 0x0000 008C 0x480B D08C Section 1.6.8.36
+ * RSZ_VFILT2120  RW 32 0x0000 0090 0x480B D090 Section 1.6.8.37
+ * RSZ_VFILT2322  RW 32 0x0000 0094 0x480B D094 Section 1.6.8.38
+ * RSZ_VFILT2524  RW 32 0x0000 0098 0x480B D098 Section 1.6.8.39
+ * RSZ_VFILT2726  RW 32 0x0000 009C 0x480B D09C Section 1.6.8.40
+ * RSZ_VFILT2928  RW 32 0x0000 00A0 0x480B D0A0 Section 1.6.8.41
+ * RSZ_VFILT3130  RW 32 0x0000 00A4 0x480B D0A4 Section 1.6.8.42
+ * RSZ_YENH       RW 32 0x0000 00A8 0x480B D0A8 Section 1.6.8.43
+ */
+
+		UVINT32 ISP_RSZ[((BADDR_ISP_SBL-BADDR_ISP_RESIZER)/4)];
+		
+	}isp_rsize;
+
+	union
+	{
+
+/*
+ * Register Name  Type Register   Address     Physical     Section
+ *                   Width      Offset     Address
+ *                  (Bits)
+ * SBL_PID             R 32 0x0000 0000 0x480B D200 Section 1.6.9.1
+ * SBL_PCR            RW 32 0x0000 0004 0x480B D204 Section 1.6.9.2
+ * SBL_GLB_REG_0       R 32 0x0000 0008 0x480B D208 Section 1.6.9.3
+ * SBL_GLB_REG_1       R 32 0x0000 000C 0x480B D20C Section 1.6.9.4
+ * SBL_GLB_REG_2       R 32 0x0000 0010 0x480B D210 Section 1.6.9.5
+ * SBL_GLB_REG_3       R 32 0x0000 0014 0x480B D214 Section 1.6.9.6
+ * SBL_GLB_REG_4       R 32 0x0000 0018 0x480B D218 Section 1.6.9.7
+ * SBL_GLB_REG_5       R 32 0x0000 001C 0x480B D21C Section 1.6.9.8
+ * SBL_GLB_REG_6       R 32 0x0000 0020 0x480B D220 Section 1.6.9.9
+ * SBL_GLB_REG_7       R 32 0x0000 0024 0x480B D224 Section 1.6.9.10
+ * SBL_CCDC_WR_0       R 32 0x0000 0028 0x480B D228 Section 1.6.9.11
+ * SBL_CCDC_WR_1       R 32 0x0000 002C 0x480B D22C Section 1.6.9.12
+ * SBL_CCDC_WR_2       R 32 0x0000 0030 0x480B D230 Section 1.6.9.13
+ * SBL_CCDC_WR_3       R 32 0x0000 0034 0x480B D234 Section 1.6.9.14
+ * SBL_CCDC_FP_RD_0    R 32 0x0000 0038 0x480B D238 Section 1.6.9.15
+ * SBL_CCDC_FP_RD_1    R 32 0x0000 003C 0x480B D23C Section 1.6.9.16
+ * SBL_PRV_RD_0        R 32 0x0000 0040 0x480B D240 Section 1.6.9.17
+ * SBL_PRV_RD_1        R 32 0x0000 0044 0x480B D244 Section 1.6.9.18
+ * SBL_PRV_RD_2        R 32 0x0000 0048 0x480B D248 Section 1.6.9.19
+ * SBL_PRV_RD_3        R 32 0x0000 004C 0x480B D24C Section 1.6.9.20
+ * SBL_PRV_WR_0        R 32 0x0000 0050 0x480B D250 Section 1.6.9.21
+ * SBL_PRV_WR_1        R 32 0x0000 0054 0x480B D254 Section 1.6.9.22
+ * SBL_PRV_WR_2        R 32 0x0000 0058 0x480B D258 Section 1.6.9.23
+ * SBL_PRV_WR_3        R 32 0x0000 005C 0x480B D25C Section 1.6.9.24
+ * SBL_PRV_DK_RD_0     R 32 0x0000 0060 0x480B D260 Section 1.6.9.25
+ * SBL_PRV_DK_RD_1     R 32 0x0000 0064 0x480B D264 Section 1.6.9.26
+ * SBL_PRV_DK_RD_2     R 32 0x0000 0068 0x480B D268 Section 1.6.9.27
+ * SBL_PRV_DK_RD_3     R 32 0x0000 006C 0x480B D26C Section 1.6.9.28
+ * SBL_RSZ_RD_0        R 32 0x0000 0070 0x480B D270 Section 1.6.9.29
+ * SBL_RSZ_RD_1        R 32 0x0000 0074 0x480B D274 Section 1.6.9.30
+ * SBL_RSZ_RD_2        R 32 0x0000 0078 0x480B D278 Section 1.6.9.31
+ * SBL_RSZ_RD_3        R 32 0x0000 007C 0x480B D27C Section 1.6.9.32
+ * SBL_RSZ1_WR_0       R 32 0x0000 0080 0x480B D280 Section 1.6.9.33
+ * SBL_RSZ1_WR_1       R 32 0x0000 0084 0x480B D284 Section 1.6.9.34
+ * SBL_RSZ1_WR_2       R 32 0x0000 0088 0x480B D288 Section 1.6.9.35
+ * SBL_RSZ1_WR_3       R 32 0x0000 008C 0x480B D28C Section 1.6.9.36
+ * SBL_RSZ2_WR_0       R 32 0x0000 0090 0x480B D290 Section 1.6.9.37
+ * SBL_RSZ2_WR_1       R 32 0x0000 0094 0x480B D294 Section 1.6.9.38
+ * SBL_RSZ2_WR_2       R 32 0x0000 0098 0x480B D298 Section 1.6.9.39
+ * SBL_RSZ2_WR_3       R 32 0x0000 009C 0x480B D29C Section 1.6.9.40
+ * SBL_RSZ3_WR_0       R 32 0x0000 00A0 0x480B D2A0 Section 1.6.9.41
+ * SBL_RSZ3_WR_1       R 32 0x0000 00A4 0x480B D2A4 Section 1.6.9.42
+ * SBL_RSZ3_WR_2       R 32 0x0000 00A8 0x480B D2A8 Section 1.6.9.43
+ * SBL_RSZ3_WR_3       R 32 0x0000 00AC 0x480B D2AC Section 1.6.9.44
+ * SBL_RSZ4_WR_0       R 32 0x0000 00B0 0x480B D2B0 Section 1.6.9.45
+ * SBL_RSZ4_WR_1       R 32 0x0000 00B4 0x480B D2B4 Section 1.6.9.46
+ * SBL_RSZ4_WR_2       R 32 0x0000 00B8 0x480B D2B8 Section 1.6.9.47
+ * SBL_RSZ4_WR_3       R 32 0x0000 00BC 0x480B D2BC Section 1.6.9.48
+ * SBL_HIST_RD_0       R 32 0x0000 00C0 0x480B D2C0 Section 1.6.9.49
+ * SBL_HIST_RD_1       R 32 0x0000 00C4 0x480B D2C4 Section 1.6.9.50
+ * SBL_H3A_AF_WR_0     R 32 0x0000 00C8 0x480B D2C8 Section 1.6.9.51
+ * SBL_H3A_AF_WR_1     R 32 0x0000 00CC 0x480B D2CC Section 1.6.9.52
+ * SBL_H3A_AEAWB_WR_0  R 32 0x0000 00D0 0x480B D2D0 Section 1.6.9.53
+ * SBL_H3A_AEAWB_WR_1  R 32 0x0000 00D4 0x480B D2D4 Section 1.6.9.54
+ * SBL_SDR_REQ_EXP    RW 32 0x0000 00F8 0x480B D2F8 Section 1.6.9.55
+ */
+		UVINT32 ISP_SBL[((BADDR_ISP_SBL_END-BADDR_ISP_SBL)/4)];
+		
+	}isp_sbl;
+
+}isp_reg_bit_access;
+
diff -Naur linux-org/drivers/media/video/ecam32/KNOWN_BUGS linux-ths/drivers/media/video/ecam32/KNOWN_BUGS
--- linux-org/drivers/media/video/ecam32/KNOWN_BUGS	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/KNOWN_BUGS	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,68 @@
+					BUGS AVAILABLE
+					##############
+
+# - completed, * - Not completed
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+BUGS:
+^^^^^
+#1.  I2C arbitation lost is happening when bulk amount of registers are being dumped into the sensor.
+*1-1 Fixed by adding 100 micro second delay between each write in the i2c code.
+
+Implementation : 
+^^^^^^^^^^^^^^^^
+#1. Driver cleanup functions in the module exit code are currently not implemented.
+*2. Available IOCTLS enumerate in the driver currently not implemented.
+#3. IOCTL - CTRL not implemented
+#4. CAPTURE routine using (QBUF - DQBUF) not implemented
+#4-1. Need to test capture routine
+
+#5. Getting memory from __get_free pages producing Low memory warinig from the kernel 
+#	Need to implement e-con specific memory implementation 
+
+#6. Memory hard coded in inc_header.h which is used in phy_mem.c (This should be double checked by performing 
+#	parse the kernel boot args and get the memory free information and feed into driver).
+*6-1. Need to test work done on point 6.
+	
+#7. G_CTRL - ioctl should expose the ctrl limit to the user
+#	VIDIOC_QUERYCTRL
+#	example :
+#		Brightness means
+#		min		- -2
+#		max		- +2
+#		step size	- +1
+
+*8. poll function need to implement
+*8-1. select function need to implement
+#8-2. mmap function need to implement
+
+*9. Proper return value represents the error state must be sent from the driver.
+
+#10. Current driver will send colour format as YUYV. Need to make it as UYVY
+
+#11. Validation is needed in performing the supported colour formats available in the sensor.
+
+#12 Negotiate with the available dimention with the sensor and tell the format dimension supported by camera to user. S_FMT /G_FMT
+
+*13 Implementation of
+	crop			-	VIDIOC_CROPCAP,VIDIOC_G_CROP, VIDIOC_S_CROP
+	VIDIOC_ENUM_FMT		-	VIDIOC_ENUM_FMT,VIDIOC_ENUM_FRAMESIZES,VIDIOC_ENUM_FRAMEINTERVALS
+
+*14 Need to handle signal CTRL+C in the driver and break the capture accordingly.
+
+*15 Image Dimensions should be rounding off to nearest supported size of byte aglinment of (4) 
+
+*16 From sensor uxga frame corruoption is happening, So we fixed in the driver to exclude the problemmatic dimension.
+
+NOTE:
+Minimum ioctls needed to procced by mplayer
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Needed ioctl is 23		- VIDIOC_G_STD
+Needed ioctl is 21		- VIDIOC_G_PARM
+Needed ioctl is 25		- VIDIOC_ENUMSTD
+#Needed ioctl is 26		- VIDIOC_ENUMINPUT
+#Needed ioctl is 38		- VIDIOC_G_INPUT
+#Needed ioctl is 2		- VIDIOC_ENUM_FMT
+
+IMPLEMENTATION
+^^^^^^^^^^^^^^
+*1. Current driver is implemented in old style of v4l2 driver.
diff -Naur linux-org/drivers/media/video/ecam32/lm3553/lm3553_flash.c linux-ths/drivers/media/video/ecam32/lm3553/lm3553_flash.c
--- linux-org/drivers/media/video/ecam32/lm3553/lm3553_flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/lm3553/lm3553_flash.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,635 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ *
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+#include "../inc_header.h"
+
+/*
+ * Global Variables
+ */
+static INT32	detect_flash_sequence	= DISABLE;
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	flash_i2c_client_xfer
+ *  Parameter1	:	INT32 addr
+ *  Parameter2	:	UPINT8 reg
+ *  Parameter3	:	PINT8 buf
+ *  Parameter4	:	INT32 num
+ *  Parameter5	:	INT32 tran_flag
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT flash_i2c_client_xfer(INT32 addr, UPINT8 reg, PINT8 buf, INT32 num, INT32 tran_flag)
+{
+
+	struct i2c_msg msg[2];
+	FNRESLT ret_val;
+	INT32 ret;
+	cam_data *cam	= NULL;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);	
+	}
+
+	if(cam->cam_flash.client	== NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);	
+	}
+
+/*
+ * FIXME:
+ * 	
+ * 	I2C Write:
+ *	 	In i2c msg[0] "address part in write is success" but if we put data in msg [1] 
+ * 		that is not properly sent to device.
+ *
+ * 		so in the msg[0] part itself the data also sent here.
+ *
+ * 	I2CRead:
+ * 		But in read No problem is found and working fine
+ */
+
+	if(tran_flag & I2C_FLAG_READ)
+	{
+
+		msg[0].addr	= addr;
+		msg[0].len	= 1;
+		msg[0].buf	= reg;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		msg[1].addr	= addr;
+		msg[1].len	= num;
+		msg[1].buf	= buf;
+		msg[1].flags	= tran_flag;
+
+		if (tran_flag & I2C_FLAG_READ)
+		{
+			msg[1].flags |= I2C_M_RD;
+		}else
+		{
+			msg[1].flags &= ~I2C_M_RD;
+		}
+
+		if ((cam->cam_flash.client == NULL) || (cam->cam_flash.client->adapter == NULL))
+		{
+			printk("%s:adapter error\n", __func__);
+			return -1;
+		}
+
+		ret = i2c_transfer(cam->cam_flash.client->adapter, msg, 2);
+		if (ret >= 0)
+		{
+			/* printk("%s:i2c transfer num:%d\n", __func__, ret); */
+			return SUCCESS;
+		}
+
+	}else
+	{
+		UINT8 reg_addr_data[2];
+		
+		reg_addr_data[0] = *reg;
+		reg_addr_data[1] = *buf;
+		
+		msg[0].addr	= addr;
+		msg[0].len	= 2;
+		msg[0].buf	= reg_addr_data;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		ret = i2c_transfer(cam->cam_flash.client->adapter, msg, 1);
+		if (ret >= 0)
+		{
+			/* printk("%s:i2c transfer num:%d\n", __func__, ret); */
+			return SUCCESS;
+		}
+	}
+
+	if(detect_flash_sequence)
+	{
+		printk("%s:i2c transfer error:%d\n", __func__, ret);
+		TRACE_ERR_AND_RET(ret);
+	}else
+	{
+		return ret;
+	}
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_write
+ *  Parameter1	:	UINT8 reg
+ *  Parameter2	:	UINT8 data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_write(UINT8 reg,UINT8 data)
+{
+	if (flash_i2c_client_xfer(LM3553_SLAVE_ADDRESS,&reg,&data, 0, 0) < 0)
+	{
+		if(detect_flash_sequence)
+		{
+			printk("Flash write failed :%s: reg=%x",__func__, reg);
+			TRACE_ERR_AND_RET(FAIL);
+		}else
+		{
+			return FAIL;
+		}
+	}	
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_read
+ *  Parameter1	:	UINT8 reg
+ *  Parameter2	:	UPINT8 data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_read(UINT8 reg,UPINT8 data)
+{
+	if (flash_i2c_client_xfer(LM3553_SLAVE_ADDRESS,&reg, data, 1, 1) < 0)
+	{
+		printk("Flash write failed :%s: reg=%x",__func__, reg);
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_probe
+ *  Parameter1	:	struct i2c_client *client
+ *  Parameter2	:	const struct i2c_device_id *id
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	Configure the gpio levels for ov3640 driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+static INT32 __init lm3553_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	cam_data *cam	= NULL;
+	FNRESLT ret_val;
+
+	if (i2c_get_clientdata(client))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		goto exit;
+	}
+	
+/*
+ * 	set the client data 
+ */
+	cam->cam_flash.client =	client;
+
+	return SUCCESS;
+	exit:
+	{
+		TRACE_ERR_AND_RET(-EINVAL);
+	}	
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_remove
+ *  Parameter1	:	struct i2c_client *client
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	remove routine of ov3640 i2c driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+static INT32 __exit lm3553_remove(struct i2c_client *client)
+{
+	if (!client->adapter)
+	{
+		TRACE_ERR_AND_RET(-ENODEV);	/* our client isn't attached */
+	}
+
+	i2c_set_clientdata(client, NULL);
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_init
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+/*
+ * i2c driver init
+ */
+	static const struct i2c_device_id lm3553_id[] =			\
+	{
+		{ LM3553_DRIVER_NAME, 0 },
+		{ },
+	};
+	MODULE_DEVICE_TABLE(i2c_1, lm3553_id);
+
+FNRESLT lm3553_init(cam_data *cam)
+{
+	FNRESLT ret_val;
+	
+	cam->cam_flash.i2c.driver.name	= LM3553_DRIVER_NAME;
+	cam->cam_flash.i2c.driver.owner	= THIS_MODULE;
+	cam->cam_flash.i2c.probe	= lm3553_probe;
+	cam->cam_flash.i2c.remove	= __exit_p(lm3553_remove);
+	cam->cam_flash.i2c.id_table	= lm3553_id;
+
+	if(i2c_add_driver(&cam->cam_flash.i2c))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	if(cam->cam_flash.client	== NULL)
+	{
+		ret_val	= lm3553_exit(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+		return SUCCESS;
+	}
+/*
+ * Set the lum time value = 1400 milli seconds
+ */
+	ret_val	= lm3553_write(0xC0,0xFE);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_INFO "lm3553 flash ic not found \n");
+
+		ret_val	= lm3553_exit(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+		return SUCCESS;
+	}
+
+	detect_flash_sequence	= ENABLE;
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_exit
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_exit(cam_data *cam)
+{
+	i2c_del_driver(&cam->cam_flash.i2c);
+	memset(&cam->cam_flash,0x00,sizeof(struct _flash_driver));
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_torch_lum_ctrl
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_torch_lum_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+	static INT32 lm3553_torch_lum_ctrl_value;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= lm3553_torch_lum_ctrl_value;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 31))
+			{
+				ret_val	= lm3553_write(0xA0,((0x80)|(0x1F & cam->ctrl.value)));
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(FAIL);
+				}
+				lm3553_torch_lum_ctrl_value	= cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_TORCH_LUM;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"torch lum ctrl",strlen("torch lum ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 31;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+	return SUCCESS;
+
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_flash_lum_ctrl
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_flash_lum_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+	static INT32 lm3553_flash_lum_value;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= lm3553_flash_lum_value;
+		}break;
+
+		case SET_DATA:
+		{
+/*
+ * FIXME:
+ *  As per LM3553.pdf the maximum value for flash is 127. 
+ *  But this is currently limited to board specific dependent configuration
+ *  Due to some hardware related issue faced in specific products.
+ */
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= CONIFG_LM3553_FLASH_MAX_LUM_VALUE))
+			{
+				ret_val	= lm3553_write(0xB0,((0x80)|(0x7F & cam->ctrl.value)));
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(FAIL);
+				}
+				lm3553_flash_lum_value	= cam->ctrl.value;
+			}
+
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_FLASH_LUM;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"flash lum ctrl",strlen("flash lum ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = CONIFG_LM3553_FLASH_MAX_LUM_VALUE;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_flash
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_flash(cam_data *cam)
+{
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= cam->cam_sensor.sens_strobe_en;
+		}break;
+
+		case SET_DATA:
+		{
+/*
+ * FIXME:
+ * 	As per the LM3553 data sheet truth table the flash mode 
+ * 	works with command of 0x10 0x1B. But we are not able to get the flash,
+ * 	so we are performing shutdown mode and enable strobe signal of sensor
+ * 	to sync with image
+ */
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 1))
+			{
+				if(cam->ctrl.value)
+				{
+					cam->cam_sensor.sens_strobe_en	= ENABLE;
+#if 0
+					ret_val	= lm3553_write(0x10,0x18);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+#endif
+				}else
+				{
+					cam->cam_sensor.sens_strobe_en	= DISABLE;
+				}
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_FLASH;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"flash ctrl",strlen("flash ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+		}break;
+	}
+	return SUCCESS;
+
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	lm3553_torch
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT lm3553_torch(cam_data *cam)
+{
+	FNRESLT ret_val;
+	static UINT32 lm3553_torch_value;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= lm3553_torch_value;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 1))
+			{
+				if(cam->ctrl.value)
+				{
+					lm3553_torch_value	= ENABLE;
+					ret_val=lm3553_write(0x10,0x1A);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+				}else
+				{
+					lm3553_torch_value	= DISABLE;
+					ret_val=lm3553_write(0x10,0x18);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+				}
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_TORCH;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"torch ctrl",strlen("torch ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+		}break;
+	}
+	return SUCCESS;
+}
+
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	register_flash_driver
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT register_flash_driver(cam_data *cam)
+{
+	cam->cam_flash.init		= lm3553_init;
+	cam->cam_flash.flash		= lm3553_flash;
+	cam->cam_flash.torch		= lm3553_torch;
+	cam->cam_flash.flash_lum_ctrl	= lm3553_flash_lum_ctrl;
+	cam->cam_flash.torch_lum_ctrl	= lm3553_torch_lum_ctrl;
+	cam->cam_flash.exit		= lm3553_exit;
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/lm3553/lm3553_flash.h linux-ths/drivers/media/video/ecam32/lm3553/lm3553_flash.h
--- linux-org/drivers/media/video/ecam32/lm3553/lm3553_flash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/lm3553/lm3553_flash.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,52 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :     OMAP Camera development                                                  *
+ *   MODULE NAME           :     OV3640                                                                   *
+ *   MODULE VERSION        :     VER 1.0                                                                  *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ *
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#define LM3553_DRIVER_NAME	"lm3553"
+
+/*
+ * Slave address
+ */
+
+#define LM3553_SLAVE_ADDRESS	0x53
+
+/*
+ * Function protype
+ */
+FNRESLT register_flash_driver(cam_data *cam);
+
diff -Naur linux-org/drivers/media/video/ecam32/make_command.sh linux-ths/drivers/media/video/ecam32/make_command.sh
--- linux-org/drivers/media/video/ecam32/make_command.sh	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/make_command.sh	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,291 @@
+BOARD_NAME="clean"
+CONFIG_BUILD_ALL="0"
+
+function setup_environment
+{
+	echo "-----------------------------------------------------------------------------------------"
+	echo "                        Configure Build for $BOARD_NAME		                       "
+	echo "-----------------------------------------------------------------------------------------"
+
+	if [ Board/$BOARD_NAME/auto_conf.h -nt auto_conf.h ]; then
+		cp Board/$BOARD_NAME/auto_conf.h ./
+		touch Board/$BOARD_NAME/auto_conf.h
+	fi
+
+	if [ Board/$BOARD_NAME/auto_conf.h -ot auto_conf.h ]; then
+		cp Board/$BOARD_NAME/auto_conf.h ./
+		touch Board/$BOARD_NAME/auto_conf.h
+	fi
+	cp Board/$BOARD_NAME/Makefile ./
+
+	svn update -q
+
+	SVN_REVISION=`svn info | grep 'Revision' | cut -d ' ' -f 2`
+	SVN_DATE=`svn info | grep 'Date' | cut -d ' ' -f 4`
+	SVN_TIME=`svn info | grep 'Date' | cut -d ' ' -f 5`
+
+	if [ -z $SVN_REVISION ]; then
+		echo "Warning! Please use svn version of source copy."
+	else
+		echo "#define PRODUCT_NAME \"$BOARD_NAME\""  > tmp.h
+		echo "#define SVN_REVISION \"$SVN_REVISION\"" >> tmp.h
+		echo "#define SVN_DATE \"$SVN_DATE\"" >> tmp.h
+		echo "#define SVN_TIME \"$SVN_TIME\"" >> tmp.h
+
+		cmp -s tmp.h svn_revision.h
+		RET_VAL=$?
+		if [ $RET_VAL -eq 0 ]; then
+			rm tmp.h
+		else
+			mv tmp.h svn_revision.h
+		fi
+	fi
+}
+
+function make_check_error
+{
+	if [ $? = "0" ]; then
+		echo "                                                                                         "
+		echo "                          Build completed successfully                                   "
+		echo "-----------------------------------------------------------------------------------------"
+		return 0
+	else
+		echo "                                                                                         "
+		echo "                              :-( Build Failed :-(                                       "
+		echo "-----------------------------------------------------------------------------------------"
+		return 1
+	fi
+}
+
+if [ -z $1 ]; then
+	echo "==============================================================================================================="
+	echo "Please select any one of the parameter as first argument in this shell script"
+	echo " clean                               = Clean the build environment for you"
+
+	echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
+	echo " e-CAM50_OMAP_GSTIX                  = gumstix 5MP using ov5642 in j5 connector of processor board"
+	echo " e-CAM50_CU35x_GSTIX                 = gumstix 5MP using ov5642 custom lens setup module in j5 connector of processor board"
+	echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
+	echo " e-CAM50_OMAP35x                     = omap35x 5MP using ov5642 A1 connector of omap3-evm-revG Board"
+	echo " e-CAM50_OMAP35x_Linux_2.6.32        = omap35x 5MP using ov5642 A1 connector of omap3-evm-revG Board"
+	echo " e-CAM50_CU35x                       = omap35x 5MP using ov5642 custom lens in Micron connector"
+	echo " e-CAM50_OMAP35x_MICRON_JAMEERR      = omap evm rev-G using ov5642 in Micron connector"
+	echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
+	echo " e-CAM50_DM37x                       = DM37x 5MP using ov5642 in Micron connector of omap3-evm-revG Board"
+	echo " e-CAM50_CU37x                       = DM37x 5MP using ov5642 custom lens in Micron connector"
+	echo "---------------------------------------------------------------------------------------------------------------"
+	echo " e-CAM32_OMAP_GSTIX                  = gumstix 3MP using ov3640 in j5 connector of processor board"
+	echo " e-CAM32_OMAP35x                     = omap35x 3MP using ov3640 A1 connector of omap3-evm-revG Board"
+	echo " e-CAM32_OMAP35x_MICRON              = omap35x 3MP using ov3640 in Micron connector of omap3-evm-revG Board"
+	echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
+	echo " e-CAM32_DM37x                       = DM37x 3MP using ov3640 in Micron connector of omap3-evm-revG Board"
+	echo "---------------------------------------------------------------------------------------------------------------"
+	echo " DEP_e-CAM1M_CU35x                   = omap evm rev-G using ov10630 in Micron connector"
+	echo " e-CAM1M_CU35x                       = omap evm rev-G using ov10633 in Micron connector"
+	echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
+	echo " e-CAM1M_DM37x                       = DM37x omap evm rev-G using ov10630 in Micron connector"
+	echo "---------------------------------------------------------------------------------------------------------------"
+	echo " build_all                           = Check the integraty of the development with all the boards "
+	echo "---------------------------------------------------------------------------------------------------------------"
+	echo ""
+	echo "Example :"
+	echo ". ./make_command.sh clean"
+	echo "==============================================================================================================="
+else
+	if [ $1 = "clean" ]; then
+		rm -rf `find ./ -name "*.o" -o -name "*.o.cmd" -o -name "*.ko"  \
+			-o -name "*.sh.swp" -o -name ".tmp_versions" 		\
+			-o -name "*.ko.cmd" -o -name "*.mod.*" 			\
+			-o -name "*.||der" -o -name "*.symvers"			\
+			-o -name "*.*.swo" -o -name ".*.o.d" 			\
+			-o -name "*.order" -o -name "tags"`
+	else
+		if [ $1 = "build_all" ]; then
+			 CONFIG_BUILD_ALL="1"
+		fi
+		if [ $1 = "e-CAM50_OMAP_GSTIX" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_OMAP_GSTIX"
+			setup_environment
+			echo "Select the kernel version"
+			echo "1 -> 2.6.32-psp-102g"
+			echo "2 -> 2.6.34-r100 "
+			read KERNEL_VERSION
+
+			if [ $KERNEL_VERSION = "1" ]; then
+				export KERNEL_PATH_SELECTED=/media/hdd1/svn/camera_products/e-CAM50_OMAP_GSTIX/linux-omap-psp-2.6.32-r102g 
+			else
+				export KERNEL_PATH_SELECTED=/media/hdd1/svn/camera_products/e-CAM50_OMAP_GSTIX/linux-omap3-2.6.34-r100
+			fi
+			make	KERNEL_PATH=$KERNEL_PATH_SELECTED \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_CU35x_GSTIX" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_CU35x_GSTIX"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_CU35x_GSTIX/linux-omap3-2.6.34-r100 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_OMAP35x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_OMAP35x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_OMAP35x/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_OMAP35x_Linux_2.6.32" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_OMAP35x_Linux_2.6.32"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_OMAP35x/linux-03.00.01.06 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_CU35x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_CU35x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_CU5642_MOD/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_OMAP35x_MICRON_JAMEERR" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_OMAP35x_MICRON_JAMEERR"
+			setup_environment
+			make KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_CU5642_MOD/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_DM37x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_DM37x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_DM37x/linux-03.00.01.06 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/omap37x/AM35x-OMAP35x-PSP-SDK-03.00.01.06/tool-chain/arm-2009q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM50_CU37x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM50_CU37x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM50_CU37x/linux-03.00.01.06 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/omap37x/AM35x-OMAP35x-PSP-SDK-03.00.01.06/tool-chain/arm-2009q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM32_OMAP_GSTIX" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM32_OMAP_GSTIX"
+			setup_environment
+			echo "Select the kernel version"
+			echo "1 -> 2.6.34 "
+			echo "2 -> 2.6.39 "
+			read KERNEL_VERSION
+
+			if [ $KERNEL_VERSION = "1" ]; then
+				export KERNEL_PATH_SELECTED=/media/hdd1/svn/camera_products/e-CAM32_OMAP_GSTIX/gumstix_ov3640_kernel/linux-omap3-2.6.34-r81 
+			else
+				export KERNEL_PATH_SELECTED=/media/hdd1/svn/camera_products/e-CAM32_OMAP_GSTIX/linux-omap3-2.6.39-r102
+			fi
+			make	KERNEL_PATH=$KERNEL_PATH_SELECTED \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM32_OMAP35x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM32_OMAP35x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM32_OMAP35x/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM32_OMAP35x_MICRON" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM32_OMAP35x_MICRON"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM32_OMAP35x_MICRON/linux-02.01.03.11/ \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM32_DM37x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM32_DM37x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM32_DM37x/linux-03.00.01.06 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/omap37x/AM35x-OMAP35x-PSP-SDK-03.00.01.06/tool-chain/arm-2009q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "DEP_e-CAM1M_CU35x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="DEP_e-CAM1M_CU35x"
+			setup_environment
+			make KERNEL_PATH=/media/hdd1/svn/camera_products/DEP_e-CAM1M_CU35x/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM1M_CU35x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM1M_CU35x"
+			setup_environment
+			make KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM1M_CU35x/linux-02.01.03.11 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/toolchain/arm-2008q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+
+		if [ $1 = "e-CAM1M_DM37x" ] || [ $CONFIG_BUILD_ALL = "1" ]; then
+			BOARD_NAME="e-CAM1M_DM37x"
+			setup_environment
+			make 	KERNEL_PATH=/media/hdd1/svn/camera_products/e-CAM1M_DM37x/linux-03.00.01.06 \
+				CROSS_COMPILE=/media/hdd1/svn/sdk/omap37x/AM35x-OMAP35x-PSP-SDK-03.00.01.06/tool-chain/arm-2009q1/bin/arm-none-linux-gnueabi-
+			make_check_error
+			if [ $? = "1" ]; then
+				return $?
+			fi
+		fi
+	fi
+ fi
diff -Naur linux-org/drivers/media/video/ecam32/Makefile linux-ths/drivers/media/video/ecam32/Makefile
--- linux-org/drivers/media/video/ecam32/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/Makefile	2012-07-12 14:19:43.000000000 +0200
@@ -0,0 +1,12 @@
+# Makefile for ecam32 v4l2 driver
+
+ccflags-$(CONFIG_VIDEO_ECAM32_DEBUG) += -DDEBUG
+
+v4l2_driver-objs	:=	init_module.o isp.o omap_hwr_base.o 				\
+				ov3640/sens_ov3640.o  v4l2_driver_base.o                  \
+				omap_camera_interface.o omap_v4l2_fops_base.o  			\
+				isp.o omap_v4l2_ioctl_fops.o i2c.o				\
+				lm3553/lm3553_flash.o exit_module.o					\
+				resource/src/error.o resource/src/kernel/phy_mem.o
+
+obj-$(CONFIG_VIDEO_ECAM32) += v4l2_driver.o
diff -Naur linux-org/drivers/media/video/ecam32/module_id.h linux-ths/drivers/media/video/ecam32/module_id.h
--- linux-org/drivers/media/video/ecam32/module_id.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/module_id.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,65 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * omap_camera_interface.c
+ */
+#define OMAP_CAM_INTERFACE_01
+#define OMAP_CAM_INTERFACE_02
+#define OMAP_CAM_INTERFACE_03
+#define OMAP_CAM_INTERFACE_04
+
+/*
+ * sens_ov3640.c
+ */
+#define SENS_OV3640_01		"ov3640_init_config"
+#define SENS_OV3640_02		"configure_dimention_change"
+#define SENS_OV3640_03		"ov3640_change_dim_config"
+#define SENS_OV3640_04		"ov3640_brightness"
+#define SENS_OV3640_05		"ov3640_exposure"
+#define SENS_OV3640_06		"ov3640_sharpness"
+#define SENS_OV3640_07		"ov3640_effects"
+#define SENS_OV3640_08		"ov3640_saturation"
+#define SENS_OV3640_09		"ov3640_contrast"
+#define SENS_OV3640_10		"planckian_locus_lookuptable"
+#define SENS_OV3640_11		"ov3640_white_balance"
+#define SENS_OV3640_12		"ov3640_vertical_flip"
+#define SENS_OV3640_13		"ov3640_horizontal_mirror"
+#define SENS_OV3640_14		"ov3640_af_firmware_dump"
+#define SENS_OV3640_15		"ov3640_sens_strobe"
+#define SENS_OV3640_16		"ov3640_focus"
+#define SENS_OV3640_17		"ov3640_i2c_client_xfer"
+#define SENS_OV3640_18		"ov3640_write_reg"
+#define SENS_OV3640_19		"ov3640_read_reg"
+#define SENS_OV3640_20		"ov3640_crop"
+
+ov3640_probe
+#define OMAP_V4L2_BASE
+#define OMAP_V4L2_BASE_00
diff -Naur linux-org/drivers/media/video/ecam32/omap_camera_interface.c linux-ths/drivers/media/video/ecam32/omap_camera_interface.c
--- linux-org/drivers/media/video/ecam32/omap_camera_interface.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_camera_interface.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,356 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.1   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ * 0.0.1.1
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: OMAP_CAM_INTERFACE_01	
+ *  Name	:	omap_pin_base_struct
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Parameter2	:	UINT8 option	- command to the current function to perfom the mentioned task.
+ *  						CREATE_ADDRESS
+ *						SET_ADDRESS
+ *						GET_ADDRESS
+ *						MAKE_ADDRESS_INVALID
+ *
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative error be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	stores the omap pin base structure pointer
+ *  			and returns the base pointer when a request of GET_ADDRESS 
+ *  			command be obtained from the calling functions 
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_pin_base_struct(cam_data *cam,UINT8 option)
+{
+	static UINT32 g_cam_interface;
+
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(MEMORY_NOT_VALID);
+	}
+	switch(option)
+	{
+		case SET_ADDRESS:
+		{
+			g_cam_interface =(UINT32)cam->pin;			
+		}break;
+
+		case GET_ADDRESS:
+		{
+			cam->pin	= (cam_interface_pin_config*)g_cam_interface;
+		}break;
+
+		case MAKE_ADDRESS_INVALID:
+		{
+			if(cam->pin	== NULL)
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+			iounmap(cam->pin);
+			cam->pin	= NULL;
+			g_cam_interface	= DISABLE;
+		}break;
+		case CREATE_ADDRESS:
+		{
+			cam->pin	= ioremap(REG_CONTROL_PADCONF_CAM_HS,4*1024);
+			if(cam->pin	== NULL)
+			{
+				printk(KERN_ERR "Unable to remap the padconfig registers\n");
+				TRACE_ERR_AND_RET(FAIL);
+			}			
+		}break;
+		default:
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	OMAP_CAM_INTERFACE_02
+ *  Name	:	configure_cam_interface
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative error be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	:	Confgure the interface lines between sensor and ccdc unit as camera interface lines  	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT configure_cam_interface(cam_data *cam)
+{
+/*
+ * Validate the input
+ */
+	if(cam == NULL || cam->pin == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+/*
+ * perform operation
+ */	
+	cam->pin->bit_hs_vs.bit.cam_hs.MUXMODE				= DISABLE;
+	cam->pin->bit_hs_vs.bit.cam_hs.INPUTENABLE			= ENABLE;
+	cam->pin->bit_hs_vs.bit.cam_hs.PULLUDENABLE			= ENABLE;
+	cam->pin->bit_hs_vs.bit.cam_hs.PULLTYPESELECT			= ENABLE;
+
+	cam->pin->bit_hs_vs.bit.cam_vs.MUXMODE				= DISABLE;
+	cam->pin->bit_hs_vs.bit.cam_vs.INPUTENABLE			= ENABLE;
+	cam->pin->bit_hs_vs.bit.cam_vs.PULLUDENABLE			= ENABLE;
+	cam->pin->bit_hs_vs.bit.cam_vs.PULLTYPESELECT			= ENABLE;
+
+	cam->pin->bit_xclka_pclk.bit.cam_xclka.MUXMODE			= DISABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_xclka.INPUTENABLE		= ENABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_xclka.PULLUDENABLE		= DISABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_xclka.PULLTYPESELECT		= DISABLE;
+
+	cam->pin->bit_xclka_pclk.bit.cam_pclk.MUXMODE			= DISABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_pclk.INPUTENABLE		= ENABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_pclk.PULLUDENABLE		= ENABLE;
+	cam->pin->bit_xclka_pclk.bit.cam_pclk.PULLTYPESELECT		= ENABLE;
+
+	cam->pin->bit_fld_d0.bit.cam_d0.MUXMODE				= DISABLE;
+	cam->pin->bit_fld_d0.bit.cam_d0.INPUTENABLE			= ENABLE;
+	cam->pin->bit_fld_d0.bit.cam_d0.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_fld_d0.bit.cam_d0.PULLTYPESELECT			= DISABLE;
+
+
+	cam->pin->bit_d1_d2.bit.cam_d1.MUXMODE				= DISABLE;
+	cam->pin->bit_d1_d2.bit.cam_d1.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d1_d2.bit.cam_d1.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d1_d2.bit.cam_d1.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d1_d2.bit.cam_d2.MUXMODE				= DISABLE;
+	cam->pin->bit_d1_d2.bit.cam_d2.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d1_d2.bit.cam_d2.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d1_d2.bit.cam_d2.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d3_d4.bit.cam_d3.MUXMODE				= DISABLE;
+	cam->pin->bit_d3_d4.bit.cam_d3.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d3_d4.bit.cam_d3.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d3_d4.bit.cam_d3.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d3_d4.bit.cam_d4.MUXMODE				= DISABLE;
+	cam->pin->bit_d3_d4.bit.cam_d4.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d3_d4.bit.cam_d4.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d3_d4.bit.cam_d4.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d5_d6.bit.cam_d5.MUXMODE				= DISABLE;
+	cam->pin->bit_d5_d6.bit.cam_d5.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d5_d6.bit.cam_d5.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d5_d6.bit.cam_d5.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d5_d6.bit.cam_d6.MUXMODE				= DISABLE;
+	cam->pin->bit_d5_d6.bit.cam_d6.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d5_d6.bit.cam_d6.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d5_d6.bit.cam_d6.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d7_d8.bit.cam_d7.MUXMODE				= DISABLE;
+	cam->pin->bit_d7_d8.bit.cam_d7.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d7_d8.bit.cam_d7.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d7_d8.bit.cam_d7.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d7_d8.bit.cam_d8.MUXMODE				= DISABLE;
+	cam->pin->bit_d7_d8.bit.cam_d8.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d7_d8.bit.cam_d8.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d7_d8.bit.cam_d8.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d9_d10.bit.cam_d9.MUXMODE				= DISABLE;
+	cam->pin->bit_d9_d10.bit.cam_d9.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d9_d10.bit.cam_d9.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d9_d10.bit.cam_d9.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d9_d10.bit.cam_d10.MUXMODE			= DISABLE;
+	cam->pin->bit_d9_d10.bit.cam_d10.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d9_d10.bit.cam_d10.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_d9_d10.bit.cam_d10.PULLTYPESELECT			= DISABLE;
+
+	cam->pin->bit_d11_xclkb.bit.cam_d11.MUXMODE			= DISABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_d11.INPUTENABLE			= ENABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_d11.PULLUDENABLE		= DISABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_d11.PULLTYPESELECT		= DISABLE;
+
+	cam->pin->bit_d11_xclkb.bit.cam_xclkb.MUXMODE			= DISABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_xclkb.INPUTENABLE		= ENABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_xclkb.PULLUDENABLE		= DISABLE;
+	cam->pin->bit_d11_xclkb.bit.cam_xclkb.PULLTYPESELECT		= DISABLE;
+/*
+ * Reset
+ */
+	cam->pin->bit_fld_d0.bit.cam_fld.MUXMODE			= 4;
+	cam->pin->bit_fld_d0.bit.cam_fld.INPUTENABLE			= DISABLE;
+	cam->pin->bit_fld_d0.bit.cam_fld.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_fld_d0.bit.cam_fld.PULLTYPESELECT			= DISABLE;
+
+/*
+ * power down
+ */
+#if (STANDBY_GPIO == 167)
+/*
+ * GPIO 167
+ */
+	cam->pin->bit_wen_strobe.bit.cam_wen.MUXMODE			= 4;
+	cam->pin->bit_wen_strobe.bit.cam_wen.INPUTENABLE		= DISABLE;
+	cam->pin->bit_wen_strobe.bit.cam_wen.PULLUDENABLE		= DISABLE;
+	cam->pin->bit_wen_strobe.bit.cam_wen.PULLTYPESELECT		= DISABLE;
+#elif (STANDBY_GPIO == 157)
+/*
+ * GPIO 157
+ */
+	cam->pin->bit_cklr.bit.mcbsp1_fsr.MUXMODE			= 4;
+	cam->pin->bit_cklr.bit.mcbsp1_fsr.INPUTENABLE			= DISABLE;
+	cam->pin->bit_cklr.bit.mcbsp1_fsr.PULLUDENABLE			= DISABLE;
+	cam->pin->bit_cklr.bit.mcbsp1_fsr.PULLTYPESELECT		= DISABLE;
+#endif
+/*
+ * I2C
+ */
+	cam->pin->bit_i2c2_i2c3.bit.i2c3_scl.MUXMODE			= DISABLE;
+	cam->pin->bit_i2c2_i2c3.bit.i2c3_scl.INPUTENABLE		= ENABLE;
+	cam->pin->bit_i2c2_i2c3.bit.i2c3_scl.PULLUDENABLE		= ENABLE;
+	cam->pin->bit_i2c2_i2c3.bit.i2c3_scl.PULLTYPESELECT		= ENABLE;
+
+	cam->pin->bit_i2c3_hdq_sio.bit.i2c3_sda.MUXMODE			= DISABLE;
+	cam->pin->bit_i2c3_hdq_sio.bit.i2c3_sda.INPUTENABLE		= ENABLE;
+	cam->pin->bit_i2c3_hdq_sio.bit.i2c3_sda.PULLUDENABLE		= ENABLE;
+	cam->pin->bit_i2c3_hdq_sio.bit.i2c3_sda.PULLTYPESELECT		= ENABLE;
+	return SUCCESS;
+}
+
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: OMAP_CAM_INTERFACE_03
+ *  Name	:	init_cam_interface
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative error be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	init the camera interface configuration.
+ *  Comments	:  	Each .c code have init and exit functions calling the init_xxx will initlize the 
+ *  			the local variables and structure variable in the main structure.
+ ************************************************************************************************************/
+FNRESLT init_cam_interface(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * Validate the input
+ */
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= omap_pin_base_struct(cam,CREATE_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to map the camera interface registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	ret_val	= omap_pin_base_struct(cam,SET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to map the camera interface registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+/*
+ * Configured the camera interface
+ */
+	ret_val	= configure_cam_interface(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to map the camera interface registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: OMAP_CAM_INTERFACE_04
+ *  Name	:	exit_cam_interface
+ *  Parameter1	:	INT0
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative error be returned
+ *  					  Note: For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	exit part of code in the camera interface configuration.
+ *  Comments	:  	Each .c code have init and exit functions calling the init_xxx will initlize the 
+ *  			the local variables and structure variable in the main structure.
+ *  			
+ ************************************************************************************************************/
+FNRESLT exit_cam_interface(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * Validate the input
+ */
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= omap_pin_base_struct(cam,MAKE_ADDRESS_INVALID);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to unmap the camera interface registers\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/omap_camera_interface.h linux-ths/drivers/media/video/ecam32/omap_camera_interface.h
--- linux-org/drivers/media/video/ecam32/omap_camera_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_camera_interface.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,230 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * 	CONTROL_PADCONF_CAM_HS[15:0]     0x4800 210C   cam_hs  		       gpio_94  hw_dbg0  safe_mode
+ * 	CONTROL_PADCONF_CAM_HS[31:16]    0x4800 210C   cam_vs   	       gpio_95  hw_dbg1  safe_mode
+ * 	CONTROL_PADCONF_CAM_XCLKA[15:0]  0x4800 2110   cam_xclka	       gpio_96           safe_mode
+ * 	CONTROL_PADCONF_CAM_XCLKA[31:16] 0x4800 2110   cam_pclk                gpio_97  hw_dbg2  safe_mode
+ * 	CONTROL_PADCONF_CAM_FLD[15:0]    0x4800 2114   cam_fld  cam_global_res gpio_98  hw_dbg3  safe_mode
+ * 	CONTROL_PADCONF_CAM_FLD[31:16]   0x4800 2114   cam_d0      csi2_dx2    gpio_99           safe_mode
+ * 	CONTROL_PADCONF_CAM_D1[15:0]     0x4800 2118   cam_d1      csi2_dy2    gpio_100          safe_mode
+ * 	CONTROL_PADCONF_CAM_D1[31:16]    0x4800 2118   cam_d2                  gpio_101 hw_dbg4  safe_mode
+ * 	CONTROL_PADCONF_CAM_D3[15:0]     0x4800 211C   cam_d3                  gpio_102 hw_dbg5  safe_mode
+ * 	CONTROL_PADCONF_CAM_D3[31:16]    0x4800 211C   cam_d4                  gpio_103 hw_dbg6  safe_mode
+ * 	CONTROL_PADCONF_CAM_D5[15:0]     0x4800 2120   cam_d5                  gpio_104 hw_dbg7  safe_mode
+ * 	CONTROL_PADCONF_CAM_D5[31:16]    0x4800 2120   cam_d6                  gpio_105          safe_mode
+ * 	CONTROL_PADCONF_CAM_D7[15:0]     0x4800 2124   cam_d7                  gpio_106          safe_mode
+ * 	CONTROL_PADCONF_CAM_D7[31:16]    0x4800 2124   cam_d8                  gpio_107          safe_mode
+ * 	CONTROL_PADCONF_CAM_D9[15:0]     0x4800 2128   cam_d9                  gpio_108          safe_mode
+ * 	CONTROL_PADCONF_CAM_D9[31:16]    0x4800 2128  cam_d10                  gpio_109 hw_dbg8  safe_mode
+ * 	CONTROL_PADCONF_CAM_D11[15:0]    0x4800 212C  cam_d11                  gpio_110 hw_dbg9  safe_mode
+ * 	CONTROL_PADCONF_CAM_D11[31:16]   0x4800 212C cam_xclkb                 gpio_111          safe_mode
+ * 	CONTROL_PADCONF_CAM_WEN[15:0]    0x4800 2130  cam_wen     cam_shutter  gpio_167 hw_dbg10 safe_mode
+ * 	CONTROL_PADCONF_CAM_WEN[31:16]   0x4800 2130 cam_strobe                gpio_126 hw_dbg11
+ */
+
+#define REG_CONTROL_PADCONF_CAM_HS 		0x4800210C
+
+
+#define REG_CONTROL_PADCONF_CAM_WEN		0x48002130
+#define REG_CONTROL_PADCONF_MCBSP4_DX 		0x48002188 
+
+#define REG_CONTROL_PADCONF_MCBSP1_CLKR		0x4800218C
+
+#define REG_CONTROL_PADCONF_I2C1_SDA		0x480021BC
+
+#define REG_CONTROL_PADCONF_I2C2_SDA		0x480021C0
+
+/*
+ * =============================================================================================================
+ * 					I2C LINES
+ * =============================================================================================================
+ *
+ *	CONTROL_PADCONF_I2C2_SDA[31:16] 0x4800 21C0  i2c3_scl                  gpio_184          safe_mode
+ *	CONTROL_PADCONF_I2C3_SDA[15:0]  0x4800 21C4  i2c3_sda                  gpio_185          safe_mode
+ * =============================================================================================================
+ */
+
+struct pad_config_value
+{
+	UVINT16 MUXMODE			:3;
+	UVINT16 PULLUDENABLE		:1;
+ 	UVINT16 PULLTYPESELECT		:1;
+	UVINT16 RESERVED		:3;
+	UVINT16 INPUTENABLE		:1;
+	UVINT16 OFFENABLE		:1;
+	UVINT16 OFFOUTENABLE		:1;
+	UVINT16 OFFOUTVALUE		:1;
+	UVINT16 OFFPULLUDENABLE		:1;
+	UVINT16 OFFPULLTYPE		:1;
+	UVINT16 WAKEUPENABLE		:1;
+	UVINT16 WAKEUPEVENT		:1;
+};
+
+typedef struct cam_interface
+{
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_HS;
+		struct
+		{
+			struct pad_config_value cam_hs;
+			struct pad_config_value cam_vs;
+		}bit;
+	}bit_hs_vs;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_XCLKA;
+		struct
+		{
+			struct pad_config_value cam_xclka;
+			struct pad_config_value cam_pclk;
+		}bit;
+	}bit_xclka_pclk;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_FLD;
+		struct
+		{
+			struct pad_config_value cam_fld;
+			struct pad_config_value cam_d0;
+		}bit;
+	}bit_fld_d0;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D1;
+		struct
+		{
+			struct pad_config_value cam_d1;
+			struct pad_config_value cam_d2;
+		}bit;
+
+	}bit_d1_d2;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D3;
+		struct
+		{
+			struct pad_config_value cam_d3;
+			struct pad_config_value cam_d4;
+		}bit;
+
+	}bit_d3_d4;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D5;
+		struct
+		{
+			struct pad_config_value cam_d5;
+			struct pad_config_value cam_d6;
+		}bit;
+
+	}bit_d5_d6;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D7;
+		struct
+		{
+			struct pad_config_value cam_d7;
+			struct pad_config_value cam_d8;
+		}bit;
+
+	}bit_d7_d8;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D9;
+		struct
+		{
+			struct pad_config_value cam_d9;
+			struct pad_config_value cam_d10;
+		}bit;
+
+	}bit_d9_d10;
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_D11;
+		struct
+		{
+			struct pad_config_value cam_d11;
+			struct pad_config_value cam_xclkb;
+		}bit;
+
+	}bit_d11_xclkb;
+
+	union
+	{
+		UVINT32 CONTROL_PADCONF_CAM_WEN;
+		struct
+		{
+			struct pad_config_value cam_wen;
+			struct pad_config_value cam_strobe;
+		}bit;
+
+	}bit_wen_strobe;
+
+	UVINT32	RESERVED1[(REG_CONTROL_PADCONF_MCBSP4_DX-REG_CONTROL_PADCONF_CAM_WEN)/4];
+	union
+	{
+		UVINT32 CONTROL_PADCONF_MCBSP1_CLKR;
+		struct
+		{
+			struct pad_config_value mcbsp1_clkr;
+			struct pad_config_value mcbsp1_fsr;
+		}bit;
+
+	}bit_cklr;
+	UVINT32	RESERVED2[(REG_CONTROL_PADCONF_I2C1_SDA-REG_CONTROL_PADCONF_MCBSP1_CLKR)/4];
+
+	union
+	{
+		UVINT32 CONTROL_PADCONF_I2C2_SDA;
+		struct
+		{
+			struct pad_config_value i2c2_sda;
+			struct pad_config_value i2c3_scl;
+		}bit;
+
+	}bit_i2c2_i2c3;
+
+	union
+	{
+		UVINT32 CONTROL_PADCONF_I2C3_SDA;
+		struct
+		{
+			struct pad_config_value i2c3_sda;
+			struct pad_config_value hdq_sio;
+		}bit;
+
+	}bit_i2c3_hdq_sio;
+
+}cam_interface_pin_config;
+
diff -Naur linux-org/drivers/media/video/ecam32/omap_hwr_base.c linux-ths/drivers/media/video/ecam32/omap_hwr_base.c
--- linux-org/drivers/media/video/ecam32/omap_hwr_base.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_hwr_base.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,117 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	init_omap_hwr
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_omap_hwr(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * Configure the camera interface
+ */
+	ret_val	= init_cam_interface(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+/*
+ * Configure the isp registers
+ */
+	ret_val	= init_cam_isp_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	exit_omap_hwr
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT exit_omap_hwr(cam_data *cam)
+{
+	FNRESLT ret_val;
+
+/*
+ * Free all camera interface
+ */
+	ret_val	= exit_cam_interface(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+
+/*
+ * Free isp registers
+ */
+	ret_val	= exit_cam_isp_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+
+	return SUCCESS;
+}
+
diff -Naur linux-org/drivers/media/video/ecam32/omap_v4l2_fops_base.c linux-ths/drivers/media/video/ecam32/omap_v4l2_fops_base.c
--- linux-org/drivers/media/video/ecam32/omap_v4l2_fops_base.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_v4l2_fops_base.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,842 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_open	
+ *  Parameter1	:	struct file *file
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	perform open operation of v4l2 
+ *  Comments	:  	
+ ************************************************************************************************************/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	INT32 omap_v4l2_open(struct file *file)
+#else
+	INT32 omap_v4l2_open(struct inode *inode,struct file *file)
+#endif
+{
+	INT32 err = 0;
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam;
+	FNRESLT ret_val;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to get base node of camera device\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+	
+	if (cam	== NULL)
+	{
+		printk(KERN_ERR "Internal error, cam_data not found!\n");
+		TRACE_ERR_AND_RET(-EBADF);
+	}
+	file->private_data = dev;
+
+	strcpy(cam->v4l2_cap.driver, "omap_v4l2");
+	cam->v4l2_cap.version		= KERNEL_VERSION(0, 1, 11);
+	cam->v4l2_cap.capabilities 	=	V4L2_CAP_VIDEO_CAPTURE	|	\
+						V4L2_CAP_READWRITE	|	\
+						V4L2_CAP_STREAMING;
+
+	cam->v4l2_cap.card[0]		= '\0';
+	cam->v4l2_cap.bus_info[0]	= '\0';
+
+	return err;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_close
+ *  Parameter1	:	struct file *file
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	INT32 omap_v4l2_close(struct file *file)
+#else
+	INT32 omap_v4l2_close(struct inode *inode,struct file *file)
+#endif
+{
+	INT32 err = 0;
+	FNRESLT ret_val;
+
+	cam_data *cam;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to get base node of camera device\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	if (cam	== NULL)
+	{
+		printk(KERN_ERR "Internal error, cam_data not found!\n");
+		return -EBADF;
+	}
+
+	ret_val	= omap_v4l2_stream_off(cam,NULL);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	cam->cmd	= SET_DATA;
+	cam->ctrl.id	= V4L2_SENS_FLASH_FLASH;
+	cam->ctrl.value	= DISABLE;
+
+	if(cam->cam_flash.flash)
+	{
+		ret_val = cam->cam_flash.flash(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(ret_val);
+		}
+	}
+
+	cam->cmd	= SET_DATA;
+	cam->ctrl.id	= V4L2_SENS_FLASH_TORCH;
+	cam->ctrl.value	= DISABLE;
+
+	if(cam->cam_flash.flash)
+	{
+		ret_val = cam->cam_flash.torch(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(ret_val);
+		}
+	}
+	return err;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	cam_get_pages
+ *  Parameter1	:	UPINT32 vir_addr	- Virtual of available physical address available
+ *  Parameter2	:	UINT32 size		- size of memory free and available
+ *  Parameter3	:	UPINT32 phy_addr	- Physical address of memory available from the kernel
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	get the free memory available from the kernel.  				
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT cam_get_pages(UPINT32 vir_addr,UINT32 size,UPINT32 phy_addr)
+{
+	ULINT32 adr;
+
+	*vir_addr	= (UINT32)__get_free_pages(GFP_KERNEL |					\
+						GFP_DMA,get_order(size));
+	if(*vir_addr == DISABLE)
+	{
+		printk(KERN_INFO "Memory not sufficient ...\n");
+		return FAIL;
+	}
+
+        adr = (ULINT32)*vir_addr;
+        size = PAGE_SIZE << (get_order(size));
+	for(;size > 0;)
+	{
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	*phy_addr	= (UINT32)virt_to_phys((PINT0)*vir_addr);
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	cam_free_pages
+ *  Parameter1	:	UINT32 addr		- Virtural address of allocated physical pages
+ *  Parameter2	:	UINT32 bufsize		- buffer size
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	Free the memory region allocated by cam_get_pages
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT cam_free_pages(UINT32 addr, UINT32 bufsize)
+{
+        UINT32 size, ad = addr;
+
+        size = PAGE_SIZE << (get_order(bufsize));
+        if (!addr)
+	{
+                TRACE_ERR_AND_RET(FAIL);
+	}
+
+        while (size > 0)
+	{
+                ClearPageReserved(virt_to_page(addr));
+                addr += PAGE_SIZE;
+                size -= PAGE_SIZE;
+        }
+
+        free_pages(ad, get_order(bufsize));
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_read
+ *  Parameter1	:	struct file *file
+ *  Parameter2	:	INT8 *buf
+ *  Parameter3	:	size_t count
+ *  Parameter4	:	loff_t * ppos
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned	
+ *  Description	: 	perform read operation of camera driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+INT32 omap_v4l2_read(struct file *file, INT8 *buf, size_t count, loff_t * ppos)
+{
+
+//	struct video_device *dev = video_devdata(file);
+	FNRESLT ret_val;
+	cam_data *cam = NULL;
+	INT32 err;
+	UINT32 wait_event_ret_val	= DISABLE;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	if(cam->task.bit.capture	== ENABLE)
+	{
+		TRACE_ERR_AND_RET(-EBUSY);	
+	}
+
+	cam->task.bit.still	= ENABLE;
+
+/*
+ * reset the isp 
+ */
+
+	ret_val	= isp_reset(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	ret_val	= isp_configure(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+/*
+ * Get the memory from the kernel
+ */
+
+	ret_val	= get_free_phy_mem(cam->capture.v2f.fmt.pix.sizeimage,&cam->still.phy_addr,&cam->still.vir_addr);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	ret_val	= isp_prg_sdram_addr(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	cam->still.frame_count	= DISABLE;
+	cam->still.wait_queue_head_t_dma_frame_complete_still	= DISABLE;
+
+/*
+ * Enable sensor strobe
+ */
+	if(cam->cam_sensor.sens_strobe)
+	{
+		cam->ctrl.id	= V4L2_SENS_FLASH_STROBE;
+		cam->ctrl.value	= ENABLE;
+		ret_val	= cam->cam_sensor.sens_strobe(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			goto exit;
+		}
+	}
+
+
+	ret_val	= enable_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	ret_val	= enable_isp_irq0(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+/*
+ * Wait for interrupt from the isp interrupt service routine
+ */
+	if(cam->still.wait_queue_head_t_dma_frame_complete_still	== DISABLE)
+	{
+		wait_event_ret_val	= wait_event_interruptible_timeout(cam->still.dma_frame_complete_still,		\
+					      cam->still.frame_count >= STILL_IMAGE_CAPTURE_FRAME_NUMBER,		\
+						20 * HZ);
+	}
+	
+/*
+ * Disable sensor strobe
+ */
+	if(cam->cam_sensor.sens_strobe)
+	{
+		cam->ctrl.id	= V4L2_SENS_FLASH_STROBE;
+		cam->ctrl.value	= DISABLE;
+		ret_val	= cam->cam_sensor.sens_strobe(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			goto exit;
+		}
+
+	}
+
+	ret_val	= disable_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	ret_val	= disable_isp_irq0(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	if(wait_event_ret_val == DISABLE)
+	{
+		cam->task.bit.still = DISABLE;
+
+		printk(KERN_DEBUG "wait_event_interruptible_timeout %s %d \n",__FUNCTION__,__LINE__);	
+		printk(KERN_ERR "omap_v4l_read timeout - Frame count %d\n",cam->still.frame_count);
+	
+		ret_val	= free_phy_mem(cam->still.phy_addr);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			goto exit;
+		}
+		return -ETIME;
+	}
+	err = copy_to_user(buf,(UPINT8)cam->still.vir_addr, cam->capture.v2f.fmt.pix.sizeimage);
+
+	ret_val	= free_phy_mem(cam->still.phy_addr);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		goto exit;
+	}
+
+	cam->task.bit.still	= DISABLE;
+
+	return cam->capture.v2f.fmt.pix.sizeimage;
+
+	exit:
+	{
+		cam->task.bit.still	= DISABLE;
+		return 0;
+	}
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_mmap
+ *  Parameter1	:	struct file *file
+ *  Parameter2	:	struct vm_area_struct *vma
+ *  Returns	:	INT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned	
+ *  Description	: 	perform mmap operation 
+ *  Comments	:  	
+ ************************************************************************************************************/
+INT32 omap_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	ULINT32 size;
+	INT32 res = DISABLE;
+
+	pr_debug("pgoff=0x%lx, start=0x%lx, end=0x%lx\n",vma->vm_pgoff, vma->vm_start, vma->vm_end);
+
+	size = vma->vm_end - vma->vm_start;
+
+/*
+ * 
+ * By introducing the Page_shared macro in vma->vm_page_prot can able to increase the frame frame.
+ * Advantages and Disadvantages are discussed here.
+ *
+ * Advantage:
+ *  1. Able to show good frame rate 30fps at 720p.
+ *
+ * Disadvantage:
+ *  1. While lines visible in the recorded video 
+ *
+ * TODO:
+ *  Need to implement mmu unit for camera (or) make use of DSS unit user buffer pointer concept.
+ *  vma->vm_page_prot = PAGE_SHARED;
+ */
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	if (remap_pfn_range(vma, vma->vm_start,vma->vm_pgoff, size, vma->vm_page_prot))
+	{
+		printk(KERN_ERR "omap_mmap: remap_pfn_range failed\n");
+		res = -ENOBUFS;
+		goto omap_mmap_exit;
+	}
+
+	vma->vm_flags |= VM_RESERVED;
+	omap_mmap_exit:
+	{
+		return res;
+	}
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_do_ioctl
+ *  Parameter1	:	struct file *file
+ *  Parameter2	:	UINT32 ioctlnr
+ *  Parameter3	:	PINT0 arg
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	process ioctl commands here
+ *  Comments	:  	
+ ************************************************************************************************************/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	LINT32 omap_v4l2_do_ioctl(struct file *file,UINT32 ioctlnr,PINT0 arg)
+#else
+	LINT32 omap_v4l2_do_ioctl(struct inode *inode, struct file *file,UINT32 ioctlnr,PINT0 arg)
+#endif
+{
+	FNRESLT ret_val;
+	cam_data *cam = NULL;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+//	printk(KERN_ERR MODULE_NAME ": IOCTL Number is :%d\n",_IOC_NR(ioctlnr));
+
+	switch (ioctlnr)
+	{
+		case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap = arg;
+			ret_val = omap_v4l2_capability(cam,cap);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}	
+	
+		}break;
+
+		case VIDIOC_S_FMT:
+		{
+			struct v4l2_format *sf = arg;
+			ret_val = omap_v4l2_s_fmt(cam, sf);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}	
+		}break;
+
+		case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *gf = arg;
+			ret_val = omap_v4l2_g_fmt(cam, gf);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}	
+		}break;
+
+		case VIDIOC_G_CTRL:
+		{
+			cam->cmd	= GET_DATA;
+			memcpy(&cam->ctrl,arg,sizeof(struct v4l2_control));
+
+			ret_val	= omap_v4l2_ctrl(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+			memcpy(arg,&cam->ctrl,sizeof(struct v4l2_control));
+		}break;
+
+		case VIDIOC_S_CTRL:
+		{
+			cam->cmd	= SET_DATA;
+			memcpy(&cam->ctrl,arg,sizeof(struct v4l2_control));
+
+			ret_val	= omap_v4l2_ctrl(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+		}break;
+
+		case VIDIOC_QUERYCTRL:
+		{
+			struct v4l2_queryctrl *qctrl	= arg;
+			memset(&cam->qctrl,0x00,sizeof(struct v4l2_queryctrl));
+			cam->cmd	= QUERY_DATA;
+
+			cam->ctrl.id	= qctrl->id;
+			
+			ret_val	= omap_v4l2_ctrl(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				cam->qctrl.flags	= V4L2_CTRL_FLAG_DISABLED;
+				memcpy(qctrl,&cam->qctrl,sizeof(struct v4l2_queryctrl));
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+			memcpy(qctrl,&cam->qctrl,sizeof(struct v4l2_queryctrl));
+		}break;
+//--------------------------------------------------------------------------------------------------
+		case VIDIOC_REQBUFS:
+		{
+			ret_val	= omap_v4l2_req_buf(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_QUERYBUF:
+		{
+			ret_val	= omap_v4l2_query_buf(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_QBUF:
+		{
+			ret_val	= omap_v4l2_queue_buf(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_DQBUF:
+		{
+			ret_val	= omap_v4l2_dqueue_buf(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_STREAMON:
+		{
+			ret_val	= omap_v4l2_stream_on(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_STREAMOFF:
+		{
+			ret_val	= omap_v4l2_stream_off(cam, arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+		}break;
+
+		case VIDIOC_ENUMINPUT:
+		{
+			struct v4l2_input *vinp_arg	= arg;
+			if(vinp_arg->index	== 0)
+			{
+				strlcpy(cam->vinp.name, "camera", sizeof(cam->vinp.name));
+				cam->vinp.type = V4L2_INPUT_TYPE_CAMERA;
+				
+				strlcpy(vinp_arg->name, "camera", sizeof(vinp_arg->name));
+				vinp_arg->type = V4L2_INPUT_TYPE_CAMERA;
+
+			}else
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+		}break;
+		case VIDIOC_G_INPUT:
+		{
+			int *index	= arg;
+			*index	= 0;
+		}break;
+
+		case VIDIOC_ENUM_FMT:
+		{
+			ret_val	= omap_v4l2_enum_fmt(cam,arg);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+
+		}break;
+
+		case VIDIOC_ENUMSTD:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);
+		}break;
+
+		case VIDIOC_S_INPUT:
+		{
+			printk("FUNCTION %s FILE %s LINE %d\n",__func__,__FILE__,__LINE__);
+		}break;
+
+		case VIDIOC_G_STD:
+		{
+			v4l2_std_id *std	=  arg;
+			*std	= V4L2_STD_PAL;
+		}break;
+
+		case VIDIOC_TRY_FMT:
+		{
+			struct v4l2_format *cam_try_fmt = arg;
+			memcpy(&cam->cam_sensor.qfmt,cam_try_fmt,sizeof(struct v4l2_format));
+			if(cam->cam_sensor.qfmt_support)
+			{
+				ret_val	= cam->cam_sensor.qfmt_support(cam);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(ret_val);
+				}
+			}else
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+		}break;
+
+		case VIDIOC_G_PARM:
+		{
+			struct v4l2_streamparm *s_parm	= arg;
+
+#if defined(CONFIG_CTRL_FRAME_RATE_FRM_SENSOR)
+			memcpy(&cam->cam_sensor.s_parm,s_parm,sizeof(struct v4l2_streamparm));
+			cam->cmd	= GET_DATA;
+
+			if(cam->cam_sensor.frame_rate_ctrl)
+			{
+				ret_val	= cam->cam_sensor.frame_rate_ctrl(cam);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(ret_val);
+				}
+
+			}
+#else
+			if(s_parm->type	== V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			{
+				/* do nothing */
+			}
+#endif
+			else
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+#if defined (CONFIG_CTRL_FRAME_RATE_FRM_SENSOR)
+			memcpy(s_parm,&cam->cam_sensor.s_parm,sizeof(struct v4l2_streamparm));
+#else
+			memcpy(s_parm,&cam->capture.s_parm,sizeof(struct v4l2_streamparm));
+#endif
+		}break;
+
+		case VIDIOC_S_PARM:
+		{
+			struct v4l2_streamparm *s_parm	= arg;
+
+#if defined(CONFIG_CTRL_FRAME_RATE_FRM_SENSOR)
+			memcpy(&cam->cam_sensor.s_parm,s_parm,sizeof(struct v4l2_streamparm));
+			cam->cmd	= SET_DATA;
+
+			if(cam->cam_sensor.frame_rate_ctrl)
+			{
+				ret_val	= cam->cam_sensor.frame_rate_ctrl(cam);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(ret_val);
+				}
+			}
+#else
+			memcpy(&cam->capture.s_parm,s_parm,sizeof(struct v4l2_streamparm));
+			if(cam->capture.s_parm.type	!= V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+
+			if (cam->capture.s_parm.parm.capture.timeperframe.denominator > SENS_MAX_FPS)
+			{
+				cam->capture.s_parm.parm.capture.timeperframe.denominator	= SENS_MAX_FPS;
+			}			
+
+#endif			
+		}break;
+
+		case VIDIOC_ENUM_FRAMESIZES:
+		{
+			cam->cmd	= GET_DATA;
+			cam->cam_sensor.fmt_frm_user	= arg;
+
+			if(cam->cam_sensor.supported_formats)
+			{
+				ret_val	= cam->cam_sensor.supported_formats(cam);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(ret_val);
+				}
+			}else
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+		}break;
+
+		case VIDIOC_ENUM_FRAMEINTERVALS:
+		{
+			cam->cmd		= GET_DATA;
+			cam->cam_sensor.frame_interval_frm_user	= arg;
+
+			if(cam->cam_sensor.frame_interval)
+			{
+				ret_val	= cam->cam_sensor.frame_interval(cam);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(ret_val);
+				}
+
+			}else
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+		}break;
+
+#if 0
+
+		case VIDIOC_CROPCAP:
+		{
+///			struct v4l2_cropcap *crp_cap;
+			printk("FUNCTION %s FILE %s LINE %d\n",__func__,__FILE__,__LINE__);
+		}break;
+
+		case VIDIOC_S_CROP:
+		{
+			printk("FUNCTION %s FILE %s LINE %d\n",__func__,__FILE__,__LINE__);
+		}break;
+
+		case VIDIOC_G_CROP:
+		{
+			printk("FUNCTION %s FILE %s LINE %d\n",__func__,__FILE__,__LINE__);
+		}break;
+
+		case VIDIOC_S_STD:
+		{
+			printk("FUNCTION %s FILE %s LINE %d\n",__func__,__FILE__,__LINE__);
+		}break;
+
+#endif		
+//--------------------------------------------------------------------------------------------------
+		default:
+		{
+			printk(KERN_ERR MODULE_NAME "Ioctl currently not implemented IOCTL Number is :%d\n",_IOC_NR(ioctlnr));
+			TRACE_ERR_AND_RET(-EINVAL);
+		}
+	}
+	return SUCCESS;
+
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_ioctl
+ *  Parameter1	:	struct file *file
+ *  Parameter2	:	UINT32 cmd
+ *  Parameter3	:	ULINT32 arg
+ *
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	LINT32 omap_v4l2_ioctl( struct file *file,UINT32 cmd,ULINT32 arg)
+#else
+	LINT32 omap_v4l2_ioctl( struct inode *inode, struct file *file,UINT32 cmd,ULINT32 arg)
+#endif
+{
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	return video_usercopy(file, cmd, arg, omap_v4l2_do_ioctl);
+#else
+	return video_usercopy(inode, file, cmd, arg, omap_v4l2_do_ioctl);
+#endif
+}
diff -Naur linux-org/drivers/media/video/ecam32/omap_v4l2.h linux-ths/drivers/media/video/ecam32/omap_v4l2.h
--- linux-org/drivers/media/video/ecam32/omap_v4l2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_v4l2.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,55 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+#define V4L2_SENS_TRIG_FOCUS			(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_SENS_FCS_OLAY			(V4L2_CID_PRIVATE_BASE + 2)
+
+#define V4L2_SENS_FLASH				(V4L2_CID_PRIVATE_BASE + 3)
+#define V4L2_SENS_FLASH_LUM			(V4L2_CID_PRIVATE_BASE + 4)
+#define V4L2_SENS_FLASH_TORCH			(V4L2_CID_PRIVATE_BASE + 5)
+#define V4L2_SENS_FLASH_FLASH			(V4L2_CID_PRIVATE_BASE + 6)
+#define V4L2_SENS_FLASH_STROBE			(V4L2_CID_PRIVATE_BASE + 7)
+
+#define V4L2_SENS_EFFECTS			(V4L2_CID_PRIVATE_BASE + 8)
+#define V4L2_SENS_FOCUS_DISABLE			(V4L2_CID_PRIVATE_BASE + 9)
+
+#define V4L2_SENS_FLASH_FLASH_LUM		(V4L2_CID_PRIVATE_BASE + 10)
+#define V4L2_SENS_FLASH_TORCH_LUM		(V4L2_CID_PRIVATE_BASE + 11)
+#define V4L2_SENS_ANTISHAKE			(V4L2_CID_PRIVATE_BASE + 12)
+#define V4L2_SENS_ANTISHAKE_STATUS		(V4L2_CID_PRIVATE_BASE + 13)
+
+#define V4L2_SENS_TEST_PATTERN			(V4L2_CID_PRIVATE_BASE + 14)
+
+#define V4L2_SENS_FOCUS_FREEZE			(V4L2_CID_PRIVATE_BASE + 15)
+#define V4L2_SENS_FOCUS_UNFREEZE		(V4L2_CID_PRIVATE_BASE + 16)
+
+#define V4L2_SENS_REGISTER			(V4L2_CID_PRIVATE_BASE + 17)
diff -Naur linux-org/drivers/media/video/ecam32/omap_v4l2_ioctl_fops.c linux-ths/drivers/media/video/ecam32/omap_v4l2_ioctl_fops.c
--- linux-org/drivers/media/video/ecam32/omap_v4l2_ioctl_fops.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/omap_v4l2_ioctl_fops.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,715 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_capability
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_capability *cap
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_capability(cam_data *cam,struct v4l2_capability *cap)
+{
+	memcpy(cap,&cam->v4l2_cap,sizeof(struct v4l2_capability));
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_s_fmt
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_format *f
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
+{
+	FNRESLT ret_val;
+	
+	if(f->type		== V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	{
+		if((cam->task.bit.capture	== ENABLE) || (cam->task.bit.still	== ENABLE))
+		{
+			TRACE_ERR_AND_RET(-EBUSY);
+		}
+
+		if(cam->cam_sensor.fix_fmt_support)
+		{
+			memcpy(&cam->cam_sensor.fmt,f,sizeof(struct v4l2_format));
+			ret_val	= cam->cam_sensor.fix_fmt_support(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{	
+				TRACE_ERR_AND_RET(FAIL);
+			}
+		}
+		memcpy(&cam->capture.v2f,&cam->cam_sensor.fmt,sizeof(struct v4l2_format));
+		memcpy(f,&cam->cam_sensor.fmt,sizeof(struct v4l2_format));
+/*
+ * configure the sensor
+ */
+		if(cam->cam_sensor.config_dim)
+		{
+			ret_val	= cam->cam_sensor.config_dim(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				return ret_val;
+			}
+		}
+	}else
+	{
+		printk(KERN_INFO "Searching for f->type %d\n",f->type);
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_g_fmt
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_format *f
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT omap_v4l2_g_fmt(cam_data *cam, struct v4l2_format *f)
+{
+	if(f->type		== V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	{
+		memcpy(f,&cam->capture.v2f,sizeof(struct v4l2_format));
+	}else
+	{
+		return FAIL;
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_ctrl
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT omap_v4l2_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+  	typedef FNRESLT (*camera_register_dump) (cam_data *cam);
+	camera_register_dump sensor_register_dump	= NULL;
+
+	switch (cam->ctrl.id)
+	{
+		case V4L2_CID_BRIGHTNESS:
+		case V4L2_CID_BLACK_LEVEL:
+		{
+			sensor_register_dump = cam->cam_sensor.brightness;
+		}break;
+
+		case V4L2_CID_CONTRAST:
+		{
+			sensor_register_dump = cam->cam_sensor.contrast;
+		
+		}break;
+
+		case V4L2_CID_SATURATION:
+		{
+			sensor_register_dump = cam->cam_sensor.saturation;
+		
+		}break;
+
+		case V4L2_CID_HUE:
+		{
+			sensor_register_dump = cam->cam_sensor.hue;
+		
+		}break;
+
+		case V4L2_CID_AUTO_WHITE_BALANCE:
+		case V4L2_CID_DO_WHITE_BALANCE:
+		case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+		{
+			sensor_register_dump = cam->cam_sensor.whitebalance;
+		
+		}break;
+
+
+		case V4L2_CID_RED_BALANCE:
+		case V4L2_CID_BLUE_BALANCE:
+		case V4L2_CID_GAMMA:
+		{
+			sensor_register_dump = cam->cam_sensor.colour_balance;
+		
+		}break;
+
+		case V4L2_CID_EXPOSURE:
+		{
+			sensor_register_dump = cam->cam_sensor.exposure;
+
+		}break;
+
+		case V4L2_CID_AUTOGAIN:
+		case V4L2_CID_GAIN:
+		{
+			sensor_register_dump = cam->cam_sensor.gain;
+
+		}break;
+
+		case V4L2_CID_HFLIP:
+		{
+			sensor_register_dump = cam->cam_sensor.h_mirror;
+
+		}break;
+
+		case V4L2_CID_VFLIP:
+		{
+			sensor_register_dump = cam->cam_sensor.v_flip;
+
+		}break;
+
+		case V4L2_CID_SHARPNESS:
+		{
+			sensor_register_dump = cam->cam_sensor.sharpness;
+
+		}break;
+		
+		case V4L2_CID_FOCUS_ABSOLUTE:
+		case V4L2_CID_FOCUS_RELATIVE:
+		case V4L2_CID_FOCUS_AUTO:
+		case V4L2_SENS_TRIG_FOCUS:
+		case V4L2_SENS_FOCUS_DISABLE:
+		case V4L2_SENS_FCS_OLAY:
+		{
+			sensor_register_dump = cam->cam_sensor.focus;
+		}break;
+/*
+ * Sensor related private controls
+ */
+		case V4L2_SENS_ANTISHAKE:
+ 		case V4L2_SENS_ANTISHAKE_STATUS:
+ 		{
+ 			sensor_register_dump = cam->cam_sensor.antishake;
+ 		}break;
+
+		case V4L2_SENS_TEST_PATTERN:
+		{
+ 			sensor_register_dump = cam->cam_sensor.test_color_pattern;
+		}break;
+
+/*
+ * Private control
+ */
+		case V4L2_SENS_FLASH_STROBE:
+		{
+			cam->cam_sensor.sens_strobe_en	= (cam->ctrl.value)?ENABLE:DISABLE;
+			sensor_register_dump = cam->cam_sensor.sens_strobe;
+		}break;
+
+		case V4L2_SENS_EFFECTS:
+		{
+			sensor_register_dump = cam->cam_sensor.effects;
+		}break;
+
+/*
+ * Flash private controls
+ */
+		case V4L2_SENS_FLASH_FLASH:
+		{
+			sensor_register_dump = cam->cam_flash.flash;
+		}break;
+
+		case V4L2_SENS_FLASH_TORCH:
+		{
+			sensor_register_dump = cam->cam_flash.torch;
+		}break;
+
+		case V4L2_SENS_FLASH_FLASH_LUM:
+		{
+			sensor_register_dump = cam->cam_flash.flash_lum_ctrl;
+		}break;
+
+		case V4L2_SENS_FLASH_TORCH_LUM:
+		{
+			sensor_register_dump = cam->cam_flash.torch_lum_ctrl;
+		}break;
+/*
+ * Sensor read and Write routines
+ */
+		case V4L2_SENS_REGISTER:
+		{
+			sensor_register_dump	= cam->cam_sensor.reg_access; 
+		}break;
+#if 0
+		case V4L2_READ_MEM_MAP:
+		{
+			cam->ctrl.value	= cam->still.buf.phy_buf_addr;
+		}break;
+
+		case V4L2_READ_SKIP_USER_CPY:
+		{
+			if(cam->cam_sensor.get_data_frm_sensor	== ENABLE)
+			{
+				cam->ctrl.value	= cam->still.read_ctrl.bit.skip_copy_to_user;
+			}else
+			{
+				if(cam->ctrl.value)
+				{
+					cam->still.read_ctrl.bit.skip_copy_to_user	= ENABLE;
+				}else
+				{
+					cam->still.read_ctrl.bit.skip_copy_to_user	= DISABLE;
+				}
+			}
+		}break;
+#endif
+
+	}
+
+	if(sensor_register_dump)
+	{
+		ret_val	= sensor_register_dump(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	
+	}else
+	{
+		TRACE_ERR_AND_RET(-EINVAL);
+	}
+	
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_req_buf
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_requestbuffers *req
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_req_buf(cam_data *cam,struct v4l2_requestbuffers *req)
+{
+	UINT32 i;
+	FNRESLT ret_val;
+
+	if(cam->task.bit.capture	== ENABLE)
+	{
+		TRACE_ERR_AND_RET(-EBUSY);
+	}
+
+	if (	(req->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) || 				\
+		(req->memory != V4L2_MEMORY_MMAP))
+	{
+		TRACE_ERR_AND_RET(-EINVAL);
+	}
+
+	if(req->count > (MAX_FRAME_SUPPORT-1))
+	{
+		req->count			= MAX_FRAME_SUPPORT -1;
+		cam->capture.available_buf	= MAX_FRAME_SUPPORT;
+	}
+/*
+ * Free the allocated buffers
+ */
+
+	for(i = 0;i < MAX_FRAME_SUPPORT;i++)
+	{
+		if(cam->capture.frame[i].buffer.m.offset)
+		{
+			ret_val	= free_phy_mem(cam->capture.frame[i].buffer.m.offset);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+			cam->capture.frame[i].buffer.m.offset		= DISABLE;
+		}
+	}
+/*
+ * request and allocate the buffer needed by the user
+ * Ask for the dummy buffer and make empty copy when there is no queued buffer (skip the frame)
+ */
+
+	for(i = 0;i <= req->count;i++)
+	{
+		ret_val	= get_free_phy_mem(	cam->capture.v2f.fmt.pix.sizeimage,
+						(UPINT32)&cam->capture.frame[i].buffer.m.offset,NULL);
+
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			break;
+		}
+
+		cam->capture.frame[i].buffer.index	= i;
+		cam->capture.frame[i].buffer.flags	= V4L2_BUF_FLAG_MAPPED;
+		cam->capture.frame[i].buffer.type	= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cam->capture.frame[i].buffer.length	= PAGE_ALIGN(cam->capture.v2f.fmt.pix.sizeimage);
+		cam->capture.frame[i].buffer.memory	= V4L2_MEMORY_MMAP;
+		cam->capture.frame[i].width		= cam->capture.v2f.fmt.pix.width;
+		cam->capture.frame[i].height		= cam->capture.v2f.fmt.pix.height;
+	}
+
+	if(req->count	== i)
+	{
+		req->count			= i;
+		cam->capture.available_buf	= i+1;
+	}else
+	{
+		req->count			= i-1;
+		cam->capture.available_buf	= i;
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_query_buf
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_buffer *buf
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_query_buf(cam_data *cam,struct v4l2_buffer *buf)
+{
+
+	if(buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	{
+		printk(KERN_ERR " pxa_cam VIDIOC_QUERYBUF buffer type not supported\n");
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	if (buf->index < 0 || buf->index > cam->capture.available_buf)
+	{
+		printk(KERN_ERR "omap_v4l2_buffer_status buffers not allocated 	\
+				buf index %d buffer available %d\n",buf->index,cam->capture.available_buf);
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	memcpy(buf, &(cam->capture.frame[buf->index].buffer), sizeof(struct v4l2_buffer));
+	
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_queue_buf
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_buffer *buf
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_queue_buf(cam_data *cam,struct v4l2_buffer *buf)
+{
+	UINT32 index		= buf->index;
+
+	if ((cam->capture.frame[index].buffer.flags & 0x7) == V4L2_BUF_FLAG_MAPPED)
+	{
+		cam->capture.frame[index].buffer.flags |= V4L2_BUF_FLAG_QUEUED;
+		__link_node(cam->capture.Need_to_be_filled,&cam->capture.frame[index]);
+	}else if(cam->capture.frame[index].buffer.flags & V4L2_BUF_FLAG_QUEUED)
+	{
+		printk(KERN_ERR "VIDIOC_QBUF: buffer already queued\n");
+	}else if(cam->capture.frame[index].buffer.flags & V4L2_BUF_FLAG_DONE)
+	{
+		printk(KERN_DEBUG "VIDIOC_QBUF: buffer overwrite doned\n");
+	}else
+	{
+		printk(KERN_DEBUG "VIDIOC_QBUF: buffer must be mapped before queued\n");
+		return FAIL;
+	}			
+	buf->flags = cam->capture.frame[index].buffer.flags;
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_dqueue_buf
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_buffer *buf
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_dqueue_buf(cam_data *cam,struct v4l2_buffer *buf)
+{
+	UINT32 wait_event_ret_val;
+
+	struct __capture_dq_buf *current_buf;
+/*
+ * Clear the driver used flags
+ */
+	wait_event_ret_val	= wait_event_interruptible_timeout(	cam->capture.capture_frame_complete,		\
+					     				(cam->capture.valid_buf	>= ENABLE),		\
+									15 * HZ);
+
+	if(wait_event_ret_val == DISABLE)
+	{
+		TRACE_ERR_AND_RET(-EBUSY);
+	}
+
+	if(cam->capture.filled)
+	{
+		current_buf				= cam->capture.filled;
+		__update_base(cam->capture.filled);
+		current_buf->next			= NULL;
+		current_buf->buffer.flags	       &= ~(V4L2_BUF_FLAG_DONE |V4L2_BUF_FLAG_QUEUED);
+		buf->bytesused				= cam->capture.v2f.fmt.pix.sizeimage;
+		buf->index				= current_buf->buffer.index;
+		buf->flags				= current_buf->buffer.flags;
+		buf->m					= current_buf->buffer.m;
+		buf->timestamp				= current_buf->buffer.timestamp;
+		cam->capture.valid_buf--;
+		return SUCCESS;
+
+	}else
+ 	{
+		TRACE_ERR_AND_RET(-EBUSY);
+ 	}
+ 	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_stream_on
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	INT32 *type
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_stream_on(cam_data *cam,INT32 *type)
+{
+	FNRESLT ret_val;
+
+	if(cam->task.bit.capture	== ENABLE)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+/*
+ * reset the isp 
+ */
+
+	ret_val	= isp_reset(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= isp_configure(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= program_dummy_isp_sdram_addr(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= enable_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= enable_isp_irq0(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	cam->task.bit.capture	= ENABLE;
+ 
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_stream_off
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	INT32 *type
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_stream_off(cam_data *cam,INT32 *type)
+{
+	FNRESLT	ret_val;
+	UINT32	i;
+
+	ret_val	= disable_ccdc(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	ret_val	= disable_isp_irq0(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+/*
+ * Free the allocated buffers
+ */
+
+	for(i = 0;i < MAX_FRAME_SUPPORT;i++)
+	{
+		if(cam->capture.frame[i].buffer.m.offset)
+		{
+			ret_val	= free_phy_mem(cam->capture.frame[i].buffer.m.offset);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(ret_val);
+			}
+			cam->capture.frame[i].buffer.m.offset		= DISABLE;
+		}
+		memset(&cam->capture.frame[i],DISABLE,sizeof(struct __capture_dq_buf));
+	}
+
+	cam->task.bit.capture		= DISABLE;
+	cam->capture.valid_buf		= DISABLE;
+	cam->capture.available_buf	= DISABLE;
+
+	cam->capture.Need_to_be_filled	= NULL;
+	cam->capture.filled		= NULL;
+	cam->capture.processing		= NULL;
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	omap_v4l2_enum_fmt
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	struct v4l2_fmtdesc *fmt
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT omap_v4l2_enum_fmt(cam_data *cam,struct v4l2_fmtdesc *fmt)
+{
+	if(cam->cam_sensor.total_fmt_desc <= fmt->index)
+	{
+		TRACE_ERR_AND_RET(-EINVAL);
+	}
+	
+	if(fmt->type	!= cam->cam_sensor.formats[fmt->index].type)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	memcpy(fmt,&cam->cam_sensor.formats[fmt->index],sizeof(struct v4l2_fmtdesc));
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/ov3640/sens_ov3640.c linux-ths/drivers/media/video/ecam32/ov3640/sens_ov3640.c
--- linux-org/drivers/media/video/ecam32/ov3640/sens_ov3640.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/ov3640/sens_ov3640.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,9988 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.1   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ * 0.0.1.1
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "../inc_header.h"
+
+static UINT32 sens_drive_strength	= DISABLE;
+module_param(sens_drive_strength,int, 0444);
+
+static UINT32 sens_max_pclk		= SENS_MAX_PCLK_SUPPORT;
+module_param(sens_max_pclk,int, 0444);
+
+#define WRITE_BIT(NO_OF_BITS,SHIFT_VAL,REG_VAL,WRITE_VAL) 	\
+	((~(((1<<(NO_OF_BITS))-1)<<(SHIFT_VAL)) & (REG_VAL)) | ((WRITE_VAL) << SHIFT_VAL))
+
+#define WRITE_REG_WITH_OVT_MAST(reg,value,mask) 			\
+{									\
+	UINT8 read_value;						\
+	ov3640_read_reg(reg,&read_value);				\
+	ov3640_write_reg(reg,((read_value & (~mask))| value));		\
+}
+
+#define READ_REG_WITH_OVT_MASK(reg,value,mask)				\
+{									\
+	ov3640_read_reg(reg,value);					\
+	*(value)	= mask & (*value);				\
+}
+
+UINT32 check_sequence = ENABLE;
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_01	
+ *  Name	:	ov3640_init_config
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	:	configure the ov3640 sensor to its default register settings mode	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_init_config(cam_data *cam)
+{
+	FNRESLT ret_val;
+
+	ov3640_write_reg(0x3012 ,0x80);
+	ov3640_write_reg(0x304d ,0x45);
+	ov3640_write_reg(0x30a7 ,0x5e);
+	ov3640_write_reg(0x3087 ,0x16);
+	ov3640_write_reg(0x309C ,0x1a);
+	ov3640_write_reg(0x30a2 ,0xe4);
+	ov3640_write_reg(0x30aa ,0x42);
+	ov3640_write_reg(0x30b0 ,0xff);
+	ov3640_write_reg(0x30b1 ,0xff);
+	/*
+	 * Maximise the drive strength to 4x level
+	 * Note:
+	 *    1x level = 0x10 is default
+	 *    4x level = 0x13 
+	 */
+	if(sens_drive_strength	> 0)
+	{
+		ov3640_write_reg(0x30b2 ,WRITE_BIT(2,0,0x10,sens_drive_strength-1));
+	}else
+	{
+		ov3640_write_reg(0x30b2 ,0x10);
+	}
+
+	ov3640_write_reg(0x300e ,0x32);
+	ov3640_write_reg(0x300f ,0x21);
+	ov3640_write_reg(0x3010 ,0x20);
+	ov3640_write_reg(0x304c ,0x82);
+	ov3640_write_reg(0x3011 ,0x04);
+	ret_val	= ov3640_limit_pclk_max_limit(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+	ov3640_write_reg(0x30d7 ,0x10);
+
+	ov3640_write_reg(0x30d9 ,0x0d);
+	ov3640_write_reg(0x30db ,0x08);
+	ov3640_write_reg(0x3016 ,0x82);
+
+	ov3640_write_reg(0x3018 ,0x38);
+	ov3640_write_reg(0x3019 ,0x30);
+	ov3640_write_reg(0x301a ,0x61);
+	ov3640_write_reg(0x307d ,0x00);
+	ov3640_write_reg(0x3087 ,0x02);
+	ov3640_write_reg(0x3082 ,0x20);
+
+	ov3640_write_reg(0x3015 ,0x12);
+	ov3640_write_reg(0x3014 ,0x0c);
+	ov3640_write_reg(0x3013 ,0xf7);
+
+	ov3640_write_reg(0x303c ,0x08);
+	ov3640_write_reg(0x303d ,0x18);
+	ov3640_write_reg(0x303e ,0x06);
+	ov3640_write_reg(0x303F ,0x0c);
+	ov3640_write_reg(0x3030 ,0x62);	
+	ov3640_write_reg(0x3031 ,0x26);
+	ov3640_write_reg(0x3032 ,0xe6);
+	ov3640_write_reg(0x3033 ,0x6e);
+	ov3640_write_reg(0x3034 ,0xea);
+	ov3640_write_reg(0x3035 ,0xae);
+	ov3640_write_reg(0x3036 ,0xa6);
+	ov3640_write_reg(0x3037 ,0x6a);
+
+	ov3640_write_reg(0x3104 ,0x02);
+	ov3640_write_reg(0x3105 ,0xfd);
+	ov3640_write_reg(0x3106 ,0x00);
+	ov3640_write_reg(0x3107 ,0xff);
+
+	ov3640_write_reg(0x3300 ,0x13);
+	ov3640_write_reg(0x3301 ,0xde);
+
+	ov3640_write_reg(0x3302 ,0xcf);
+
+	ov3640_write_reg(0x3312 ,0x26);
+	ov3640_write_reg(0x3314 ,0x42);
+	ov3640_write_reg(0x3313 ,0x2b);
+	ov3640_write_reg(0x3315 ,0x42);
+	ov3640_write_reg(0x3310 ,0xd0);
+	ov3640_write_reg(0x3311 ,0xbd);
+	ov3640_write_reg(0x330c ,0x18);
+	ov3640_write_reg(0x330d ,0x18);
+	ov3640_write_reg(0x330e ,0x56);
+	ov3640_write_reg(0x330f ,0x5c);
+	ov3640_write_reg(0x330b ,0x1c);
+	ov3640_write_reg(0x3306 ,0x5c);
+	ov3640_write_reg(0x3307 ,0x11);
+
+	ov3640_write_reg(0x336a ,0x52);
+	ov3640_write_reg(0x3370 ,0x44);
+	ov3640_write_reg(0x3376 ,0x40);
+	ov3640_write_reg(0x3300 ,0x13);
+
+	ov3640_write_reg(0x30b8 ,0x20);
+	ov3640_write_reg(0x30b9 ,0x17);
+	ov3640_write_reg(0x30ba ,0x04);
+	ov3640_write_reg(0x30bb ,0x08);
+
+	ov3640_write_reg(0x3500 ,0x00);
+	ov3640_write_reg(0x3507 ,0x06);
+	ov3640_write_reg(0x350a ,0x4f);
+	ov3640_write_reg(0x3610 ,0x60);
+
+	ov3640_write_reg(0x3100 ,0x32);
+	ov3640_write_reg(0x363d ,0x60);
+
+	ov3640_write_reg(0x3301 ,0xde);
+	ov3640_write_reg(0x3304 ,0x00);
+	ov3640_write_reg(0x3400 ,0x00);
+	ov3640_write_reg(0x3404 ,0x00);
+	ov3640_write_reg(0x3600 ,0xc0);
+
+	ov3640_write_reg(0x3011 ,0x04);
+	ov3640_write_reg(0x304c ,0x81);
+	ret_val	= ov3640_limit_pclk_max_limit(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	ov3640_write_reg(0x335f ,0x68);
+	ov3640_write_reg(0x3360 ,0x18);
+	ov3640_write_reg(0x3361 ,0x0c);
+	ov3640_write_reg(0x3362 ,0x46);
+	ov3640_write_reg(0x3363 ,0x48);
+	ov3640_write_reg(0x3364 ,0xb4);
+
+	ov3640_write_reg(0x3012 ,0x00);
+	ov3640_write_reg(0x3020 ,0x01);
+	ov3640_write_reg(0x3021 ,0x1d);
+	ov3640_write_reg(0x3022 ,0x00);
+	ov3640_write_reg(0x3023 ,0x0a);
+	ov3640_write_reg(0x3024 ,0x08);
+	ov3640_write_reg(0x3025 ,0x18);
+	ov3640_write_reg(0x3026 ,0x06);
+	ov3640_write_reg(0x3027 ,0x0c);
+	ov3640_write_reg(0x302a ,0x06);
+	ov3640_write_reg(0x302b ,0x20);
+	ov3640_write_reg(0x3075 ,0x44);
+	ov3640_write_reg(0x300d ,0x00);
+	ov3640_write_reg(0x30d7 ,0x10);
+	ov3640_write_reg(0x3069 ,0x44);
+	ov3640_write_reg(0x303e ,0x01);
+	ov3640_write_reg(0x303f ,0x80);
+
+	ov3640_write_reg(0x3302 ,0xef);
+	ov3640_write_reg(0x335f ,0x68);
+	ov3640_write_reg(0x3360 ,0x18);
+	ov3640_write_reg(0x3361 ,0x0c);
+
+	ov3640_write_reg(0x3404 ,0x02);
+	ov3640_write_reg(0x3100 ,0x02);
+
+
+	return SUCCESS;
+}
+
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION					MODULE ID	: SENS_OV3640_02	
+ *  Name	:	configure_dimention_change
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Configure the mode of streaming (QXGA (or) XGA) based on the Image dimension  
+ *  			request given by driver.
+ *
+ *  Comments	:  	Ov3640 supports two modes XGA and QXGA 
+ *
+ *  			In XGA mode upto maximum of 30 fps be acheived.
+ *  			In QXGA mode upto maximum of 15 fps be acheived.
+ ************************************************************************************************************/
+FNRESLT configure_dimention_change(cam_data *cam)
+{
+	static INT32 width,height,old_logic_case;
+	UINT32 logic_case;
+	FNRESLT ret_val;
+
+	if(	(cam->cam_sensor.fmt.fmt.pix.width <= MODE_XGA_WIDTH) && 	\
+		(cam->cam_sensor.fmt.fmt.pix.height <= MODE_XGA_HEIGHT))
+	{
+		logic_case	= 1;
+	}else
+	{
+		logic_case	= 2;
+	}
+
+
+	if(	 old_logic_case == logic_case)
+	{
+		return SUCCESS;
+	}else
+	{
+		old_logic_case	= logic_case;
+		width		= cam->cam_sensor.fmt.fmt.pix.width;
+		height		= cam->cam_sensor.fmt.fmt.pix.height;
+	}
+	
+
+	switch(logic_case)
+	{
+		case 1:
+		{
+			ov3640_write_reg(0x3012, 0x10);
+			ov3640_write_reg(0x3023, 0x06);
+			ov3640_write_reg(0x3026, 0x03);
+			ov3640_write_reg(0x3027, 0x04);
+
+			ov3640_write_reg(0x302a, 0x03);
+			ov3640_write_reg(0x302b, 0x10);
+			ov3640_write_reg(0x3075, 0x24);
+			ov3640_write_reg(0x300d, 0x01);
+			ov3640_write_reg(0x30d7, 0x90);
+			ov3640_write_reg(0x3069, 0x04);
+			ov3640_write_reg(0x303e, 0x00);
+			ov3640_write_reg(0x303f, 0xc0);
+			ov3640_write_reg(0x3302, 0xef);
+			ov3640_write_reg(0x335f, 0x34);
+			ov3640_write_reg(0x3360, 0x0c);
+			ov3640_write_reg(0x3361, 0x04);
+			ov3640_write_reg(0x3362, 0x34);
+			ov3640_write_reg(0x3363, 0x08);
+			ov3640_write_reg(0x3364, 0x04);
+			ov3640_write_reg(0x3403, 0x42);
+			ov3640_write_reg(0x3088, 0x04);
+			ov3640_write_reg(0x3089, 0x00);
+			ov3640_write_reg(0x308a, 0x03);
+			ov3640_write_reg(0x308b, 0x00);
+			ov3640_write_reg(0x300e, 0x32);
+			ov3640_write_reg(0x300f, 0x21);
+			ov3640_write_reg(0x3010, 0x20);
+			ov3640_write_reg(0x304c, 0x82);
+			ov3640_write_reg(0x3011, 0x00);
+			ret_val	= ov3640_limit_pclk_max_limit(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);		
+			}
+		}break;
+
+		case 2:
+		default:
+		{
+			ov3640_write_reg(0x3100 ,0x32);
+			ov3640_write_reg(0x363d ,0x60);
+
+			ov3640_write_reg(0x3301 ,0xde);
+			ov3640_write_reg(0x3304 ,0x00);
+			ov3640_write_reg(0x3400 ,0x00);
+			ov3640_write_reg(0x3404 ,0x00);
+			ov3640_write_reg(0x3600 ,0xc0);
+
+			ov3640_write_reg(0x3011 ,0x01);
+			ov3640_write_reg(0x304c ,0x81);
+			ret_val	= ov3640_limit_pclk_max_limit(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+
+			ov3640_write_reg(0x335f ,0x68);
+			ov3640_write_reg(0x3360 ,0x18);
+			ov3640_write_reg(0x3361 ,0x0c);
+			ov3640_write_reg(0x3362 ,0x46);
+			ov3640_write_reg(0x3363 ,0x48);
+			ov3640_write_reg(0x3364 ,0xb4);
+
+			ov3640_write_reg(0x3012 ,0x00);
+			ov3640_write_reg(0x3020 ,0x01);
+			ov3640_write_reg(0x3021 ,0x1d);
+			ov3640_write_reg(0x3022 ,0x00);
+			ov3640_write_reg(0x3023 ,0x0a);
+			ov3640_write_reg(0x3024 ,0x08);
+			ov3640_write_reg(0x3025 ,0x18);
+			ov3640_write_reg(0x3026 ,0x06);
+			ov3640_write_reg(0x3027 ,0x0c);
+			ov3640_write_reg(0x302a ,0x06);
+			ov3640_write_reg(0x302b ,0x20);
+			ov3640_write_reg(0x3075 ,0x44);
+			ov3640_write_reg(0x300d ,0x00);
+			ov3640_write_reg(0x30d7 ,0x10);
+			ov3640_write_reg(0x3069 ,0x44);
+			ov3640_write_reg(0x303e ,0x01);
+			ov3640_write_reg(0x303f ,0x80);
+
+			ov3640_write_reg(0x3302 ,0xef);
+			ov3640_write_reg(0x335f ,0x68);
+			ov3640_write_reg(0x3360 ,0x18);
+			ov3640_write_reg(0x3361 ,0x0c);
+
+			ov3640_write_reg(0x3404 ,0x02);
+			ov3640_write_reg(0x3100 ,0x02);
+			break;
+		}
+	}
+
+	ov3640_write_reg(0x3100 ,0x02);
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	restore_camera_config
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	:
+ ************************************************************************************************************/
+FNRESLT restore_camera_config(cam_data *cam)
+{
+	FNRESLT	ret_val;
+	UINT32 i;
+
+	typedef FNRESLT (*camera_register_dump) (cam_data *cam);
+	struct __restore_data
+	{
+		INT32 restore_id;
+		camera_register_dump restore_fnptr;
+	};
+
+	struct __restore_data restore[]	= 	 						
+	{	 										
+		{V4L2_CID_BRIGHTNESS,			cam->cam_sensor.brightness},		
+		{V4L2_CID_CONTRAST,			cam->cam_sensor.contrast},		
+		{V4L2_CID_SATURATION,			cam->cam_sensor.saturation},		
+		{V4L2_CID_HUE,				cam->cam_sensor.hue},			
+		{V4L2_CID_WHITE_BALANCE_TEMPERATURE,	cam->cam_sensor.whitebalance},		
+//		{V4L2_CID_EXPOSURE,			cam->cam_sensor.exposure},		
+		{V4L2_CID_VFLIP,			cam->cam_sensor.v_flip},		
+		{V4L2_CID_HFLIP,			cam->cam_sensor.h_mirror},		
+		{V4L2_CID_SHARPNESS,			cam->cam_sensor.sharpness},		
+//		{V4L2_CID_FOCUS_ABSOLUTE,		cam->cam_sensor.focus},			
+		{V4L2_SENS_TEST_PATTERN,		cam->cam_sensor.test_color_pattern},	
+		{V4L2_SENS_EFFECTS,			cam->cam_sensor.effects},		
+	};
+
+
+	for(i=0;i<(sizeof(restore)/sizeof(restore[0]));i++)
+	{
+		cam->cmd	= RESTORE_DATA;
+		cam->ctrl.id	= restore[i].restore_id;
+		if(restore[i].restore_fnptr)
+		{
+			ret_val	= restore[i].restore_fnptr(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_03
+ *  Name	:	ov3640_change_dim_config
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Configure the image width and height to the sensor
+ *
+ *  Comments	:  	Based on the driver request, changing the pixelformat also be performed here.
+ *  			Note:
+ *  				bfw_count be added for intel pxa based processor to overcome the loss of 
+ *  				first line
+ ************************************************************************************************************/
+FNRESLT ov3640_change_dim_config(cam_data *cam)
+{
+	static INT32 old_width,old_height;
+	UINT16 width,height,bfw_count	= 2;
+	FNRESLT ret_val;
+
+	UINT8 y_start	= 2;
+	UINT8 x_start	= 4;
+#if 0 
+	static INT32 focus_box	= ENABLE;
+	if(focus_box == ENABLE)
+	{
+		ov3640_write_reg(0x3F00 ,0x04);
+		ov3640_write_reg(0x3F00 ,0x01);
+		focus_box = DISABLE;
+	}else
+	{
+		ov3640_write_reg(0x3F00 ,0x02);
+		focus_box = ENABLE;
+	}
+#endif
+	if(cam->cam_sensor.fix_fmt_support)
+	{
+		ret_val	= cam->cam_sensor.fix_fmt_support(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+
+	if(	(cam->cam_sensor.fmt.fmt.pix.width == MODE_XGA_WIDTH) && 		\
+		(cam->cam_sensor.fmt.fmt.pix.height == MODE_XGA_HEIGHT))
+	{
+	        width	= cam->cam_sensor.fmt.fmt.pix.width + x_start +4;
+        	height	= cam->cam_sensor.fmt.fmt.pix.height+ y_start +2;
+	}else
+	{
+		width	= cam->cam_sensor.fmt.fmt.pix.width + x_start +4;
+        	height	= cam->cam_sensor.fmt.fmt.pix.height+ y_start +2 +bfw_count;
+	}
+
+	if((width == old_width) && (height == old_height))
+	{
+		goto config_pix_format_dump;
+	}else
+	{
+		old_width	= width;
+		old_height	= height;
+	}
+
+	ret_val	= configure_dimention_change(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+	ov3640_write_reg(0x3362 ,((height & 0xFF00)>>4) | ((width & 0xFF00)>>8));
+	ov3640_write_reg(0x3363 ,(width & 0xFF));
+	ov3640_write_reg(0x3364 ,(height & 0xFF));
+	ov3640_write_reg(0x3403 ,((x_start<<4)|y_start));
+	ov3640_write_reg(0x3088 ,(cam->cam_sensor.fmt.fmt.pix.width & 0xFF00)>>8);
+	ov3640_write_reg(0x3089 ,(cam->cam_sensor.fmt.fmt.pix.width & 0xFF));
+	ov3640_write_reg(0x308a ,((cam->cam_sensor.fmt.fmt.pix.height+bfw_count)& 0xFF00)>>8);
+	ov3640_write_reg(0x308b ,((cam->cam_sensor.fmt.fmt.pix.height+bfw_count)& 0xFF));
+
+/*
+ * Update the autofocus driver that the width and height of the sensor be changed
+ */
+	ov3640_write_reg(0x3f00 ,0x09);
+
+	config_pix_format_dump:
+	{
+		switch(cam->cam_sensor.fmt.fmt.pix.pixelformat)
+		{
+			case V4L2_PIX_FMT_UYVY:
+			default:
+			{
+				ov3640_write_reg(0x3400 ,0x00);
+				ov3640_write_reg(0x3404 ,0x02);
+			}break;
+
+			case V4L2_PIX_FMT_YUYV:
+			{
+				ov3640_write_reg(0x3400 ,0x00);
+				ov3640_write_reg(0x3404 ,0x00);
+			}break;
+#if 0			
+			case V4L2_PIX_FMT_YUV420:
+			{
+				ov3640_write_reg(0x3400 ,0x00);
+				ov3640_write_reg(0x3404 ,0x08);
+			}break;
+#endif
+			case V4L2_PIX_FMT_YUV444:
+			{
+				ov3640_write_reg(0x3400 ,0x00);
+				ov3640_write_reg(0x3404 ,0x0E);
+			}break;
+
+			case V4L2_PIX_FMT_BGR32:
+			{
+				ov3640_write_reg(0x3400 ,0x01);
+				ov3640_write_reg(0x3404 ,0x1C);
+
+			}break;
+
+			case V4L2_PIX_FMT_RGB555:
+			{
+				ov3640_write_reg(0x3400 ,0x01); 
+				ov3640_write_reg(0x3404 ,0x13);
+			}break;
+
+			case V4L2_PIX_FMT_RGB565:
+			{
+				ov3640_write_reg(0x3400 ,0x01); 
+				ov3640_write_reg(0x3404 ,0x30);
+			}break;	
+
+			case V4L2_PIX_FMT_SBGGR8:
+			{
+				ov3640_write_reg(0x3400 ,0x01);
+				ov3640_write_reg(0x3404 ,0x18);
+			}break;
+		}
+	}
+
+	ret_val	= restore_camera_config(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(ret_val);
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_20	
+ *  Name	:	ov3640_crop
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 	
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_crop(cam_data *cam)
+{
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->cam_sensor.cropcap.bounds.top = DISABLE;
+			cam->cam_sensor.cropcap.bounds.left = DISABLE;
+			cam->cam_sensor.cropcap.bounds.width = MAX_OV3640_WIDTH;
+			cam->cam_sensor.cropcap.bounds.height = MAX_OV3640_HEIGHT;
+			cam->cam_sensor.cropcap.defrect = cam->cam_sensor.cropcap.bounds;
+			cam->cam_sensor.cropcap.pixelaspect.numerator = 1;
+			cam->cam_sensor.cropcap.pixelaspect.denominator = 1;
+
+		}break;
+		case SET_DATA:
+		{
+
+		}break;
+		case QUERY_DATA:
+		{
+
+		}break;		
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_04	
+ *  Name	:	ov3640_brightness
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 	
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Image brightness from the sensor can be increased (or) decrease
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_brightness(cam_data *cam)
+{
+	static INT32 restore_brightness;
+/*
+ * Value must be in the range of 
+ * -0x30  0x0  0x30
+ *  -48   0   +48
+ */
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT8 reg_value;
+			ov3640_read_reg(0x3354,&reg_value);
+			if(reg_value == 0x08)
+			{
+				ov3640_read_reg(0x335e,&reg_value);
+				cam->ctrl.value	= -reg_value;
+			}else
+			{
+				ov3640_read_reg(0x335e,&reg_value);
+				cam->ctrl.value	= reg_value;
+			}
+			cam->ctrl.value	= (cam->ctrl.value)>48?48:		\
+						(cam->ctrl.value)<-48?-48:	\
+						(cam->ctrl.value);
+			restore_brightness	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_brightness;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= -48) && (cam->ctrl.value <= 48))
+			{
+				if(cam->ctrl.value >= 0)
+				{
+					ov3640_write_reg(0x335e,0xFF & (cam->ctrl.value));
+					WRITE_REG_WITH_OVT_MAST(0x3355, 0x04, 0x04);
+					ov3640_write_reg(0x3354,0x01);
+				}else
+				{
+					ov3640_write_reg(0x335e,0xFF & (-cam->ctrl.value));
+					WRITE_REG_WITH_OVT_MAST(0x3355, 0x04, 0x04);
+					ov3640_write_reg(0x3354,0x08);
+				}
+				restore_brightness	= cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_BRIGHTNESS;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"Brightness",strlen("Brightness"));
+			cam->qctrl.minimum = -48;
+			cam->qctrl.maximum = 48;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_05
+ *  Name	:	ov3640_exposure
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Histogram based exposure algorithm to increase the exposure of the image
+ *  Comments	:  	In ov3640 sensor Average based and Histogram based algorithm be available
+ *  			
+ ************************************************************************************************************/
+FNRESLT ov3640_exposure(cam_data *cam)
+{
+/*
+ * Histogram-based Algorithm
+ * Value must be in the range of 
+ * 0x38 - 0x88
+ *  -40 - +40
+ */
+	static INT32 restore_exposure;
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT8 reg_value;
+			ov3640_read_reg(0x3018,&reg_value);
+			cam->ctrl.value	= reg_value -0x80;
+			cam->ctrl.value	= (cam->ctrl.value)>40?40:		\
+						(cam->ctrl.value)<-40?-40:	\
+						(cam->ctrl.value);
+
+			restore_exposure	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_exposure;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= -40) && (cam->ctrl.value <= 40))
+			{
+				ov3640_write_reg(0x3018, 0x80 + cam->ctrl.value );
+				ov3640_write_reg(0x3019, 0x60 + cam->ctrl.value );
+				restore_exposure	= cam->ctrl.value;
+			}
+
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_EXPOSURE;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"Exposure",strlen("Exposure"));
+			cam->qctrl.minimum = -40;
+			cam->qctrl.maximum = 40;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_06	
+ *  Name	:	ov3640_sharpness
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Image output sharpness from the sensor be increased or decreased. 
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_sharpness(cam_data *cam)
+{
+/*
+ * Value must be in the range of 
+ * 0x42 0x45 0x48
+ *  -3   0   +3
+ */
+	static INT32 restore_sharpness;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT8 reg_value;
+			ov3640_read_reg(0x332d,&reg_value);
+			cam->ctrl.value	= reg_value -0x45;
+			cam->ctrl.value	= (cam->ctrl.value)>3?3:		\
+						(cam->ctrl.value)<-3?-3:	\
+						(cam->ctrl.value);
+
+			restore_sharpness	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_sharpness;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= -3) && (cam->ctrl.value <= 3))
+			{
+				ov3640_write_reg(0x332d, 0x45 + (cam->ctrl.value));
+				ov3640_write_reg(0x332f, 0x03);
+			}else
+			{
+				ov3640_write_reg(0x332d, 0x60);
+				ov3640_write_reg(0x332f, 0x03);
+			}
+			restore_sharpness	= cam->ctrl.value;
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_SHARPNESS;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"sharpness",strlen("sharpness"));
+			cam->qctrl.minimum = -3;
+			cam->qctrl.maximum = 3;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_07
+ *  Name	:	ov3640_effects
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Camera effects supported by the sensor  	
+ *  Comments	:  	Supported effects by the sensor are Sepia,Monochrome,Negative,Bluish,Greenish
+ *  			and Yellowish
+ ************************************************************************************************************/
+
+FNRESLT ov3640_effects(cam_data *cam)
+{
+	static INT32 old_effects_value;
+	static INT32 restore_effects;
+/*
+ * Value must be in the range of 
+ * 0 to 7
+ *
+ * 	Normal			0
+ * 	Sepia(antique)		1
+ * 	Mono chrome		2
+ * 	Negative		3
+ * 	Bluish			4
+ * 	Greenish		5
+ * 	Reddish			6
+ * 	Yellowish		7
+ */
+
+	switch(cam->cmd)
+ 	{
+		case GET_DATA:
+ 		{
+			cam->ctrl.value	= old_effects_value;
+			restore_effects	= cam->ctrl.value;
+ 		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_effects;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+ 		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 7))
+			{
+				old_effects_value	= cam->ctrl.value;
+				switch(cam->ctrl.value)
+				{
+					case EFFECT_NORMAL:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x00, 0x58);
+					}break;
+
+					case EFFECT_SEPIA:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0x40);
+						ov3640_write_reg(0x335b, 0xa6);
+					}break;
+
+					case EFFECT_MONOCHROME:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0x80);
+						ov3640_write_reg(0x335b, 0x80);
+					}break;
+
+					case EFFECT_NEGATIVE:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x40, 0x40); // bit[6] negative
+					}break;
+
+					case EFFECT_BLUISH:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0xa0);
+						ov3640_write_reg(0x335b, 0x40);
+					}break;
+
+					case EFFECT_GREENISH:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0x60);
+						ov3640_write_reg(0x335b, 0x60);
+					}break;
+
+					case EFFECT_REDDISH:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0x80);
+						ov3640_write_reg(0x335b, 0xc0);
+					}break;
+
+					case EFFECT_YELLOWISH:
+					{
+						ov3640_write_reg(0x3302, 0xef);
+						WRITE_REG_WITH_OVT_MAST(0x3355, 0x18, 0x58);
+						ov3640_write_reg(0x335a, 0x30);
+						ov3640_write_reg(0x335b, 0x90);
+					}break;
+				}
+				restore_effects	= cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+ 		{
+			cam->qctrl.id	= V4L2_SENS_EFFECTS;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"effects",strlen("effects"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 7;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_08
+ *  Name	:	ov3640_saturation
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Image output saturation from the sensor be increased or decreased.
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_saturation(cam_data *cam)
+{
+	static INT32 restore_saturation;
+
+/*
+ * Value must be in the range of 
+ * 0x10 0x20 0x70
+ *  -48   0   +48
+ */
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT8 reg_value;
+			ov3640_read_reg(0x3358,&reg_value);
+			cam->ctrl.value	= reg_value - 0x30;
+			cam->ctrl.value	= (cam->ctrl.value)>48?48:		\
+						(cam->ctrl.value)<-48?-48:	\
+						(cam->ctrl.value);
+			restore_saturation = cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_saturation;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= -48) && (cam->ctrl.value <= 48))
+			{
+				ov3640_write_reg(0x3302, 0xef);
+				WRITE_REG_WITH_OVT_MAST(0x3355, 0x02, 0x02);
+				ov3640_write_reg(0x3358, 0x30 + (cam->ctrl.value));
+				ov3640_write_reg(0x3359, 0x30 + (cam->ctrl.value));
+				restore_saturation = cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_SATURATION;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"saturation",strlen("saturation"));
+			cam->qctrl.minimum = -48;
+			cam->qctrl.maximum = 48;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_09
+ *  Name	:	ov3640_contrast
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Image output contrast from the sensor be increased or decreased.
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_contrast(cam_data *cam)
+{
+	static INT32 restore_contrast;
+
+/*
+ * Value must be in the range of 
+ * 0x14 0x20 0x2c
+ * -12   0   12
+ */
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT8 reg_value;
+			ov3640_read_reg(0x335c,&reg_value);
+			cam->ctrl.value	= reg_value - 0x20;
+			cam->ctrl.value	= (cam->ctrl.value)>12?12:		\
+						(cam->ctrl.value)<-12?-12:	\
+						(cam->ctrl.value);
+			restore_contrast = cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_contrast;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= -12) && (cam->ctrl.value <= 12))
+			{
+				ov3640_write_reg(0x3302, 0xef);
+				WRITE_REG_WITH_OVT_MAST(0x3355, 0x04, 0x04);
+//				ov3640_write_reg(0x3354, 0x01);
+				ov3640_write_reg(0x335c, 0x20 + (cam->ctrl.value));
+				ov3640_write_reg(0x335d, 0x20 + (cam->ctrl.value));
+				restore_contrast = cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_CONTRAST;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"contrast",strlen("contrast"));
+			cam->qctrl.minimum = -12;
+			cam->qctrl.maximum = 12;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_10
+ *  Name	:	planckian_locus_lookuptable
+ *  Parameter1	:	INT32 value	- Temperature of the source.
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	:	Adjust the whilebalance of the sensor based on envionment source temperature		
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT planckian_locus_lookuptable(INT32 value)
+{
+	typedef struct _aw_temp_gain_adj
+	{
+		UINT32 temp;
+		UINT8 r;
+		UINT8 g;
+		UINT8 b;
+	}aw_gain_adj;
+
+	aw_gain_adj temp_aw_gain[]	=	{				\
+							{3000,0x44,0x40,0x70},	\
+							{4000,0x52,0x40,0x48},	\
+							{5000,0x68,0x40,0x4e},	\
+							{6000,0x5e,0x40,0x46}	\
+						}; 
+
+	UINT32 i	= DISABLE;
+
+	if(value == ENABLE)
+	{
+		WRITE_REG_WITH_OVT_MAST(0x3308, 0x00, 0x80);
+		WRITE_REG_WITH_OVT_MAST(0x332b, 0x00, 0x08);
+	}else if(value == DISABLE)
+	{
+		WRITE_REG_WITH_OVT_MAST(0x3308, 0x80, 0x80);
+		WRITE_REG_WITH_OVT_MAST(0x332b, 0x00, 0x08);
+	}else
+	{
+		WRITE_REG_WITH_OVT_MAST(0x3308, 0x80, 0x80);
+		WRITE_REG_WITH_OVT_MAST(0x332b, 0x08, 0x08);
+		for(i	= DISABLE; i < (sizeof(temp_aw_gain)/sizeof(temp_aw_gain[0]));i++)
+		{
+			if(temp_aw_gain[i].temp == value)
+			{
+				ov3640_write_reg(0x33a7,temp_aw_gain[i].r);
+				ov3640_write_reg(0x33a8,temp_aw_gain[i].g);
+				ov3640_write_reg(0x33a9,temp_aw_gain[i].b);
+				break;
+			}
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_11	
+ *  Name	:	ov3640_white_balance
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Image Whitebalance settings from the sensor
+ *  Comments	:  	Auto White balance, Daylight,Tungsten,Fluorescent and cloudy settings are 
+ *  			available 
+ ************************************************************************************************************/
+FNRESLT ov3640_white_balance(cam_data *cam)
+{
+	FNRESLT ret_val;
+	static INT32 restore_white_balance = ENABLE;
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_AUTO_WHITE_BALANCE:
+				case V4L2_CID_DO_WHITE_BALANCE:
+				case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+				{
+					cam->ctrl.value	= restore_white_balance;
+				}break;
+			}
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_white_balance;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_AUTO_WHITE_BALANCE:
+				{
+					if(cam->ctrl.value)
+					{
+						restore_white_balance = ENABLE;
+					}else
+					{
+						restore_white_balance = DISABLE;
+						cam->ctrl.value = DISABLE;
+					}
+				}break;
+
+				case V4L2_CID_DO_WHITE_BALANCE:
+				{
+					restore_white_balance = DISABLE;
+					cam->ctrl.value = DISABLE;
+				}break;
+
+				case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+				{
+					if((cam->ctrl.value >=3000) && (cam->ctrl.value <=6000))
+					{
+						cam->ctrl.value-=cam->ctrl.value%1000;
+						restore_white_balance = cam->ctrl.value;
+					}
+				}break;
+			}
+			ret_val	= planckian_locus_lookuptable(cam->ctrl.value);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+
+		}break;
+
+		case QUERY_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+				{
+					cam->qctrl.id	= V4L2_CID_WHITE_BALANCE_TEMPERATURE;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+					strncpy(cam->qctrl.name,"White balance temperature",strlen("White balance temperature"));
+					cam->qctrl.minimum = 3000;
+					cam->qctrl.maximum = 6000;
+					cam->qctrl.step = 1000;
+					cam->qctrl.default_value = 1;
+					cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+				}break;
+			}
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_12	
+ *  Name	:	ov3640_vertical_flip
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Change the Image display order - Vertical flip 
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_vertical_flip(cam_data *cam)
+{
+	UINT8 reg_value;
+	static INT32 restore_vflip	= CONFIG_OV3640_DEFAULT_FLIP;
+	ov3640_read_reg(0x307c,&reg_value);
+	
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			if(reg_value & (0x1 <<0))
+			{
+				cam->ctrl.value = ENABLE;
+			}else
+			{
+				cam->ctrl.value	= DISABLE;
+			}
+			restore_vflip	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_vflip;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if(cam->ctrl.value)
+			{
+				reg_value = (reg_value |(0x1<<0));
+			}else
+			{
+				reg_value &=  ~((0x1<<0));
+			}
+			ov3640_write_reg(0x307c,reg_value);
+			restore_vflip	= cam->ctrl.value;
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_VFLIP;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"Vertical flip",strlen("Vertical flip"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = CONFIG_OV3640_DEFAULT_FLIP;
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_13	
+ *  Name	:	ov3640_horizontal_mirror
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Change the Image display order - Horizontal mirror
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_horizontal_mirror(cam_data *cam)
+{
+	UINT8 reg_value;
+	static INT32 restore_horizontal_mirror = CONFIG_OV3640_DEFAULT_MIRROR;
+	ov3640_read_reg(0x3090,&reg_value);
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			if(reg_value & (0x1 <<3))
+			{
+				cam->ctrl.value = ENABLE;
+			}else
+			{
+				cam->ctrl.value	= DISABLE;
+			}
+			restore_horizontal_mirror	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_horizontal_mirror;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if(cam->ctrl.value)
+			{
+				reg_value = (reg_value |(0x1<<3));
+			}else
+			{
+				reg_value &=  ~((0x1<<3));
+			}
+			ov3640_write_reg(0x3090,reg_value);
+			restore_horizontal_mirror	= cam->ctrl.value;
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_CID_HFLIP;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"Horizontal mirror",strlen("Horizontal mirror"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = CONFIG_OV3640_DEFAULT_MIRROR;
+
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_21
+ *
+ *  Name	:	ov3640_antishake_firmware_ctrl
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Auto focus firmware register dump
+ *  Comments	:  	Before performing autofocus related operations -Auto focus firmware dump should be 
+ *  			applied
+ ************************************************************************************************************/
+
+FNRESLT ov3640_antishake_firmware_ctrl(cam_data *cam)
+{
+	switch(cam->cmd)
+	{	
+		case GET_DATA:
+		{
+			UINT8 reg_value	= DISABLE;
+			switch(cam->ctrl.id)
+			{
+				case V4L2_SENS_ANTISHAKE_STATUS:
+				{
+					ov3640_read_reg(0x3f07,&reg_value);
+					cam->ctrl.value	= reg_value;
+				}break;
+			}
+
+		}break;
+
+		case SET_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_SENS_ANTISHAKE:
+				{
+					ov3640_write_reg(0x308c,0x00);
+					ov3640_write_reg(0x3104,0x02);
+					ov3640_write_reg(0x3105,0xff);
+					ov3640_write_reg(0x3106,0x00);
+					ov3640_write_reg(0x3107,0xff);
+					ov3640_write_reg(0x8000,0x02);
+					ov3640_write_reg(0x8001,0x07);
+					ov3640_write_reg(0x8002,0xE0);
+					ov3640_write_reg(0x8003,0x02);
+					ov3640_write_reg(0x8004,0x00);
+					ov3640_write_reg(0x8005,0x06);
+					ov3640_write_reg(0x8006,0xC0);
+					ov3640_write_reg(0x8007,0xE0);
+					ov3640_write_reg(0x8008,0xC0);
+					ov3640_write_reg(0x8009,0xF0);
+					ov3640_write_reg(0x800A,0xC0);
+					ov3640_write_reg(0x800B,0x83);
+					ov3640_write_reg(0x800C,0xC0);
+					ov3640_write_reg(0x800D,0x82);
+					ov3640_write_reg(0x800E,0xC0);
+					ov3640_write_reg(0x800F,0xD0);
+					ov3640_write_reg(0x8010,0x75);
+					ov3640_write_reg(0x8011,0xD0);
+					ov3640_write_reg(0x8012,0x00);
+					ov3640_write_reg(0x8013,0xC0);
+					ov3640_write_reg(0x8014,0x00);
+					ov3640_write_reg(0x8015,0xC0);
+					ov3640_write_reg(0x8016,0x04);
+					ov3640_write_reg(0x8017,0xC0);
+					ov3640_write_reg(0x8018,0x05);
+					ov3640_write_reg(0x8019,0xC0);
+					ov3640_write_reg(0x801A,0x06);
+					ov3640_write_reg(0x801B,0xC0);
+					ov3640_write_reg(0x801C,0x07);
+					ov3640_write_reg(0x801D,0x90);
+					ov3640_write_reg(0x801E,0x37);
+					ov3640_write_reg(0x801F,0x08);
+					ov3640_write_reg(0x8020,0xE0);
+					ov3640_write_reg(0x8021,0x20);
+					ov3640_write_reg(0x8022,0xE3);
+					ov3640_write_reg(0x8023,0x03);
+					ov3640_write_reg(0x8024,0x02);
+					ov3640_write_reg(0x8025,0x02);
+					ov3640_write_reg(0x8026,0x05);
+					ov3640_write_reg(0x8027,0x90);
+					ov3640_write_reg(0x8028,0x3F);
+					ov3640_write_reg(0x8029,0x01);
+					ov3640_write_reg(0x802A,0xE0);
+					ov3640_write_reg(0x802B,0x04);
+					ov3640_write_reg(0x802C,0xF0);
+					ov3640_write_reg(0x802D,0x30);
+					ov3640_write_reg(0x802E,0x0D);
+					ov3640_write_reg(0x802F,0x03);
+					ov3640_write_reg(0x8030,0x02);
+					ov3640_write_reg(0x8031,0x01);
+					ov3640_write_reg(0x8032,0xFB);
+					ov3640_write_reg(0x8033,0x30);
+					ov3640_write_reg(0x8034,0x0A);
+					ov3640_write_reg(0x8035,0x07);
+					ov3640_write_reg(0x8036,0x90);
+					ov3640_write_reg(0x8037,0x30);
+					ov3640_write_reg(0x8038,0xB4);
+					ov3640_write_reg(0x8039,0xE0);
+					ov3640_write_reg(0x803A,0x44);
+					ov3640_write_reg(0x803B,0x08);
+					ov3640_write_reg(0x803C,0xF0);
+					ov3640_write_reg(0x803D,0x05);
+					ov3640_write_reg(0x803E,0x45);
+					ov3640_write_reg(0x803F,0xE5);
+					ov3640_write_reg(0x8040,0x45);
+					ov3640_write_reg(0x8041,0x70);
+					ov3640_write_reg(0x8042,0x03);
+					ov3640_write_reg(0x8043,0x75);
+					ov3640_write_reg(0x8044,0x45);
+					ov3640_write_reg(0x8045,0x01);
+					ov3640_write_reg(0x8046,0x90);
+					ov3640_write_reg(0x8047,0x3A);
+					ov3640_write_reg(0x8048,0x00);
+					ov3640_write_reg(0x8049,0x74);
+					ov3640_write_reg(0x804A,0x80);
+					ov3640_write_reg(0x804B,0xF0);
+					ov3640_write_reg(0x804C,0x90);
+					ov3640_write_reg(0x804D,0x3A);
+					ov3640_write_reg(0x804E,0x03);
+					ov3640_write_reg(0x804F,0xE0);
+					ov3640_write_reg(0x8050,0xF5);
+					ov3640_write_reg(0x8051,0x51);
+					ov3640_write_reg(0x8052,0xE0);
+					ov3640_write_reg(0x8053,0xF5);
+					ov3640_write_reg(0x8054,0x53);
+					ov3640_write_reg(0x8055,0xE0);
+					ov3640_write_reg(0x8056,0xF5);
+					ov3640_write_reg(0x8057,0x55);
+					ov3640_write_reg(0x8058,0xE0);
+					ov3640_write_reg(0x8059,0xF5);
+					ov3640_write_reg(0x805A,0x57);
+					ov3640_write_reg(0x805B,0xE0);
+					ov3640_write_reg(0x805C,0xF5);
+					ov3640_write_reg(0x805D,0x52);
+					ov3640_write_reg(0x805E,0xE0);
+					ov3640_write_reg(0x805F,0xF5);
+					ov3640_write_reg(0x8060,0x54);
+					ov3640_write_reg(0x8061,0xE0);
+					ov3640_write_reg(0x8062,0xF5);
+					ov3640_write_reg(0x8063,0x56);
+					ov3640_write_reg(0x8064,0xE0);
+					ov3640_write_reg(0x8065,0xF5);
+					ov3640_write_reg(0x8066,0x58);
+					ov3640_write_reg(0x8067,0xE5);
+					ov3640_write_reg(0x8068,0x55);
+					ov3640_write_reg(0x8069,0xF5);
+					ov3640_write_reg(0x806A,0x27);
+					ov3640_write_reg(0x806B,0xE5);
+					ov3640_write_reg(0x806C,0x53);
+					ov3640_write_reg(0x806D,0xF5);
+					ov3640_write_reg(0x806E,0x28);
+					ov3640_write_reg(0x806F,0xE5);
+					ov3640_write_reg(0x8070,0x72);
+					ov3640_write_reg(0x8071,0x64);
+					ov3640_write_reg(0x8072,0x01);
+					ov3640_write_reg(0x8073,0x60);
+					ov3640_write_reg(0x8074,0x03);
+					ov3640_write_reg(0x8075,0x02);
+					ov3640_write_reg(0x8076,0x01);
+					ov3640_write_reg(0x8077,0x18);
+					ov3640_write_reg(0x8078,0x20);
+					ov3640_write_reg(0x8079,0x0A);
+					ov3640_write_reg(0x807A,0x03);
+					ov3640_write_reg(0x807B,0x02);
+					ov3640_write_reg(0x807C,0x01);
+					ov3640_write_reg(0x807D,0x24);
+					ov3640_write_reg(0x807E,0x20);
+					ov3640_write_reg(0x807F,0x0A);
+					ov3640_write_reg(0x8080,0x03);
+					ov3640_write_reg(0x8081,0x02);
+					ov3640_write_reg(0x8082,0x01);
+					ov3640_write_reg(0x8083,0xFB);
+					ov3640_write_reg(0x8084,0x20);
+					ov3640_write_reg(0x8085,0x09);
+					ov3640_write_reg(0x8086,0x3F);
+					ov3640_write_reg(0x8087,0x75);
+					ov3640_write_reg(0x8088,0x26);
+					ov3640_write_reg(0x8089,0x00);
+					ov3640_write_reg(0x808A,0x12);
+					ov3640_write_reg(0x808B,0x06);
+					ov3640_write_reg(0x808C,0x5F);
+					ov3640_write_reg(0x808D,0x25);
+					ov3640_write_reg(0x808E,0x5A);
+					ov3640_write_reg(0x808F,0xF5);
+					ov3640_write_reg(0x8090,0x5A);
+					ov3640_write_reg(0x8091,0xEE);
+					ov3640_write_reg(0x8092,0x35);
+					ov3640_write_reg(0x8093,0x59);
+					ov3640_write_reg(0x8094,0xF5);
+					ov3640_write_reg(0x8095,0x59);
+					ov3640_write_reg(0x8096,0x05);
+					ov3640_write_reg(0x8097,0x26);
+					ov3640_write_reg(0x8098,0xE5);
+					ov3640_write_reg(0x8099,0x26);
+					ov3640_write_reg(0x809A,0xB4);
+					ov3640_write_reg(0x809B,0x08);
+					ov3640_write_reg(0x809C,0xED);
+					ov3640_write_reg(0x809D,0xE5);
+					ov3640_write_reg(0x809E,0x5A);
+					ov3640_write_reg(0x809F,0xAE);
+					ov3640_write_reg(0x80A0,0x59);
+					ov3640_write_reg(0x80A1,0x78);
+					ov3640_write_reg(0x80A2,0x03);
+					ov3640_write_reg(0x80A3,0xCE);
+					ov3640_write_reg(0x80A4,0xC3);
+					ov3640_write_reg(0x80A5,0x13);
+					ov3640_write_reg(0x80A6,0xCE);
+					ov3640_write_reg(0x80A7,0x13);
+					ov3640_write_reg(0x80A8,0xD8);
+					ov3640_write_reg(0x80A9,0xF9);
+					ov3640_write_reg(0x80AA,0xF5);
+					ov3640_write_reg(0x80AB,0x5A);
+					ov3640_write_reg(0x80AC,0x8E);
+					ov3640_write_reg(0x80AD,0x59);
+					ov3640_write_reg(0x80AE,0xFF);
+					ov3640_write_reg(0x80AF,0x7C);
+					ov3640_write_reg(0x80B0,0x00);
+					ov3640_write_reg(0x80B1,0x7D);
+					ov3640_write_reg(0x80B2,0x03);
+					ov3640_write_reg(0x80B3,0x12);
+					ov3640_write_reg(0x80B4,0x0C);
+					ov3640_write_reg(0x80B5,0xC8);
+					ov3640_write_reg(0x80B6,0xEF);
+					ov3640_write_reg(0x80B7,0x78);
+					ov3640_write_reg(0x80B8,0x02);
+					ov3640_write_reg(0x80B9,0xCE);
+					ov3640_write_reg(0x80BA,0xC3);
+					ov3640_write_reg(0x80BB,0x13);
+					ov3640_write_reg(0x80BC,0xCE);
+					ov3640_write_reg(0x80BD,0x13);
+					ov3640_write_reg(0x80BE,0xD8);
+					ov3640_write_reg(0x80BF,0xF9);
+					ov3640_write_reg(0x80C0,0xF5);
+					ov3640_write_reg(0x80C1,0x4E);
+					ov3640_write_reg(0x80C2,0x8E);
+					ov3640_write_reg(0x80C3,0x4D);
+					ov3640_write_reg(0x80C4,0xD2);
+					ov3640_write_reg(0x80C5,0x09);
+					ov3640_write_reg(0x80C6,0xE5);
+					ov3640_write_reg(0x80C7,0x43);
+					ov3640_write_reg(0x80C8,0xC3);
+					ov3640_write_reg(0x80C9,0x95);
+					ov3640_write_reg(0x80CA,0x44);
+					ov3640_write_reg(0x80CB,0x50);
+					ov3640_write_reg(0x80CC,0x1D);
+					ov3640_write_reg(0x80CD,0xE5);
+					ov3640_write_reg(0x80CE,0x28);
+					ov3640_write_reg(0x80CF,0x95);
+					ov3640_write_reg(0x80D0,0x4E);
+					ov3640_write_reg(0x80D1,0xE5);
+					ov3640_write_reg(0x80D2,0x27);
+					ov3640_write_reg(0x80D3,0x95);
+					ov3640_write_reg(0x80D4,0x4D);
+					ov3640_write_reg(0x80D5,0x40);
+					ov3640_write_reg(0x80D6,0x0E);
+					ov3640_write_reg(0x80D7,0x12);
+					ov3640_write_reg(0x80D8,0x05);
+					ov3640_write_reg(0x80D9,0xD8);
+					ov3640_write_reg(0x80DA,0x40);
+					ov3640_write_reg(0x80DB,0x09);
+					ov3640_write_reg(0x80DC,0x12);
+					ov3640_write_reg(0x80DD,0x05);
+					ov3640_write_reg(0x80DE,0xE2);
+					ov3640_write_reg(0x80DF,0x85);
+					ov3640_write_reg(0x80E0,0x27);
+					ov3640_write_reg(0x80E1,0x4F);
+					ov3640_write_reg(0x80E2,0x85);
+					ov3640_write_reg(0x80E3,0x28);
+					ov3640_write_reg(0x80E4,0x50);
+					ov3640_write_reg(0x80E5,0x05);
+					ov3640_write_reg(0x80E6,0x43);
+					ov3640_write_reg(0x80E7,0x02);
+					ov3640_write_reg(0x80E8,0x01);
+					ov3640_write_reg(0x80E9,0xFB);
+					ov3640_write_reg(0x80EA,0xE5);
+					ov3640_write_reg(0x80EB,0x43);
+					ov3640_write_reg(0x80EC,0xC3);
+					ov3640_write_reg(0x80ED,0x95);
+					ov3640_write_reg(0x80EE,0x44);
+					ov3640_write_reg(0x80EF,0x50);
+					ov3640_write_reg(0x80F0,0x03);
+					ov3640_write_reg(0x80F1,0x02);
+					ov3640_write_reg(0x80F2,0x01);
+					ov3640_write_reg(0x80F3,0xFB);
+					ov3640_write_reg(0x80F4,0x12);
+					ov3640_write_reg(0x80F5,0x05);
+					ov3640_write_reg(0x80F6,0xD8);
+					ov3640_write_reg(0x80F7,0x40);
+					ov3640_write_reg(0x80F8,0x02);
+					ov3640_write_reg(0x80F9,0x80);
+					ov3640_write_reg(0x80FA,0x12);
+					ov3640_write_reg(0x80FB,0xE5);
+					ov3640_write_reg(0x80FC,0x50);
+					ov3640_write_reg(0x80FD,0x45);
+					ov3640_write_reg(0x80FE,0x4F);
+					ov3640_write_reg(0x80FF,0x70);
+					ov3640_write_reg(0x8100,0x0F);
+					ov3640_write_reg(0x8101,0xE5);
+					ov3640_write_reg(0x8102,0x59);
+					ov3640_write_reg(0x8103,0xC3);
+					ov3640_write_reg(0x8104,0x13);
+					ov3640_write_reg(0x8105,0xFE);
+					ov3640_write_reg(0x8106,0xE5);
+					ov3640_write_reg(0x8107,0x5A);
+					ov3640_write_reg(0x8108,0x12);
+					ov3640_write_reg(0x8109,0x06);
+					ov3640_write_reg(0x810A,0x1C);
+					ov3640_write_reg(0x810B,0x40);
+					ov3640_write_reg(0x810C,0x03);
+					ov3640_write_reg(0x810D,0x12);
+					ov3640_write_reg(0x810E,0x05);
+					ov3640_write_reg(0x810F,0xE2);
+					ov3640_write_reg(0x8110,0x90);
+					ov3640_write_reg(0x8111,0x3F);
+					ov3640_write_reg(0x8112,0x04);
+					ov3640_write_reg(0x8113,0xE5);
+					ov3640_write_reg(0x8114,0x43);
+					ov3640_write_reg(0x8115,0x02);
+					ov3640_write_reg(0x8116,0x01);
+					ov3640_write_reg(0x8117,0xED);
+					ov3640_write_reg(0x8118,0xE5);
+					ov3640_write_reg(0x8119,0x72);
+					ov3640_write_reg(0x811A,0x64);
+					ov3640_write_reg(0x811B,0x02);
+					ov3640_write_reg(0x811C,0x60);
+					ov3640_write_reg(0x811D,0x03);
+					ov3640_write_reg(0x811E,0x02);
+					ov3640_write_reg(0x811F,0x01);
+					ov3640_write_reg(0x8120,0xFB);
+					ov3640_write_reg(0x8121,0x20);
+					ov3640_write_reg(0x8122,0x0A);
+					ov3640_write_reg(0x8123,0x33);
+					ov3640_write_reg(0x8124,0x85);
+					ov3640_write_reg(0x8125,0x6E);
+					ov3640_write_reg(0x8126,0x70);
+					ov3640_write_reg(0x8127,0x85);
+					ov3640_write_reg(0x8128,0x6F);
+					ov3640_write_reg(0x8129,0x71);
+					ov3640_write_reg(0x812A,0x85);
+					ov3640_write_reg(0x812B,0x6C);
+					ov3640_write_reg(0x812C,0x6E);
+					ov3640_write_reg(0x812D,0x85);
+					ov3640_write_reg(0x812E,0x6D);
+					ov3640_write_reg(0x812F,0x6F);
+					ov3640_write_reg(0x8130,0x85);
+					ov3640_write_reg(0x8131,0x6A);
+					ov3640_write_reg(0x8132,0x6C);
+					ov3640_write_reg(0x8133,0x85);
+					ov3640_write_reg(0x8134,0x6B);
+					ov3640_write_reg(0x8135,0x6D);
+					ov3640_write_reg(0x8136,0x85);
+					ov3640_write_reg(0x8137,0x68);
+					ov3640_write_reg(0x8138,0x6A);
+					ov3640_write_reg(0x8139,0x85);
+					ov3640_write_reg(0x813A,0x69);
+					ov3640_write_reg(0x813B,0x6B);
+					ov3640_write_reg(0x813C,0x85);
+					ov3640_write_reg(0x813D,0x66);
+					ov3640_write_reg(0x813E,0x68);
+					ov3640_write_reg(0x813F,0x85);
+					ov3640_write_reg(0x8140,0x67);
+					ov3640_write_reg(0x8141,0x69);
+					ov3640_write_reg(0x8142,0x85);
+					ov3640_write_reg(0x8143,0x64);
+					ov3640_write_reg(0x8144,0x66);
+					ov3640_write_reg(0x8145,0x85);
+					ov3640_write_reg(0x8146,0x65);
+					ov3640_write_reg(0x8147,0x67);
+					ov3640_write_reg(0x8148,0x85);
+					ov3640_write_reg(0x8149,0x62);
+					ov3640_write_reg(0x814A,0x64);
+					ov3640_write_reg(0x814B,0x85);
+					ov3640_write_reg(0x814C,0x63);
+					ov3640_write_reg(0x814D,0x65);
+					ov3640_write_reg(0x814E,0x85);
+					ov3640_write_reg(0x814F,0x27);
+					ov3640_write_reg(0x8150,0x62);
+					ov3640_write_reg(0x8151,0x85);
+					ov3640_write_reg(0x8152,0x28);
+					ov3640_write_reg(0x8153,0x63);
+					ov3640_write_reg(0x8154,0x02);
+					ov3640_write_reg(0x8155,0x01);
+					ov3640_write_reg(0x8156,0xFB);
+					ov3640_write_reg(0x8157,0x20);
+					ov3640_write_reg(0x8158,0x0A);
+					ov3640_write_reg(0x8159,0x03);
+					ov3640_write_reg(0x815A,0x02);
+					ov3640_write_reg(0x815B,0x01);
+					ov3640_write_reg(0x815C,0xFB);
+					ov3640_write_reg(0x815D,0x20);
+					ov3640_write_reg(0x815E,0x09);
+					ov3640_write_reg(0x815F,0x36);
+					ov3640_write_reg(0x8160,0x75);
+					ov3640_write_reg(0x8161,0x5F);
+					ov3640_write_reg(0x8162,0x00);
+					ov3640_write_reg(0x8163,0x75);
+					ov3640_write_reg(0x8164,0x60);
+					ov3640_write_reg(0x8165,0x00);
+					ov3640_write_reg(0x8166,0x75);
+					ov3640_write_reg(0x8167,0x5D);
+					ov3640_write_reg(0x8168,0xFF);
+					ov3640_write_reg(0x8169,0x75);
+					ov3640_write_reg(0x816A,0x5E);
+					ov3640_write_reg(0x816B,0xFF);
+					ov3640_write_reg(0x816C,0x75);
+					ov3640_write_reg(0x816D,0x26);
+					ov3640_write_reg(0x816E,0x00);
+					ov3640_write_reg(0x816F,0x12);
+					ov3640_write_reg(0x8170,0x06);
+					ov3640_write_reg(0x8171,0x5F);
+					ov3640_write_reg(0x8172,0xFF);
+					ov3640_write_reg(0x8173,0xC3);
+					ov3640_write_reg(0x8174,0xE5);
+					ov3640_write_reg(0x8175,0x60);
+					ov3640_write_reg(0x8176,0x9F);
+					ov3640_write_reg(0x8177,0xE5);
+					ov3640_write_reg(0x8178,0x5F);
+					ov3640_write_reg(0x8179,0x9E);
+					ov3640_write_reg(0x817A,0x50);
+					ov3640_write_reg(0x817B,0x04);
+					ov3640_write_reg(0x817C,0x8E);
+					ov3640_write_reg(0x817D,0x5F);
+					ov3640_write_reg(0x817E,0x8F);
+					ov3640_write_reg(0x817F,0x60);
+					ov3640_write_reg(0x8180,0xD3);
+					ov3640_write_reg(0x8181,0xE5);
+					ov3640_write_reg(0x8182,0x5E);
+					ov3640_write_reg(0x8183,0x9F);
+					ov3640_write_reg(0x8184,0xE5);
+					ov3640_write_reg(0x8185,0x5D);
+					ov3640_write_reg(0x8186,0x9E);
+					ov3640_write_reg(0x8187,0x40);
+					ov3640_write_reg(0x8188,0x04);
+					ov3640_write_reg(0x8189,0x8E);
+					ov3640_write_reg(0x818A,0x5D);
+					ov3640_write_reg(0x818B,0x8F);
+					ov3640_write_reg(0x818C,0x5E);
+					ov3640_write_reg(0x818D,0x05);
+					ov3640_write_reg(0x818E,0x26);
+					ov3640_write_reg(0x818F,0xE5);
+					ov3640_write_reg(0x8190,0x26);
+					ov3640_write_reg(0x8191,0xB4);
+					ov3640_write_reg(0x8192,0x08);
+					ov3640_write_reg(0x8193,0xDB);
+					ov3640_write_reg(0x8194,0xD2);
+					ov3640_write_reg(0x8195,0x09);
+					ov3640_write_reg(0x8196,0xE5);
+					ov3640_write_reg(0x8197,0x43);
+					ov3640_write_reg(0x8198,0xC3);
+					ov3640_write_reg(0x8199,0x95);
+					ov3640_write_reg(0x819A,0x44);
+					ov3640_write_reg(0x819B,0x50);
+					ov3640_write_reg(0x819C,0x1E);
+					ov3640_write_reg(0x819D,0xE5);
+					ov3640_write_reg(0x819E,0x5F);
+					ov3640_write_reg(0x819F,0xC3);
+					ov3640_write_reg(0x81A0,0x13);
+					ov3640_write_reg(0x81A1,0xFE);
+					ov3640_write_reg(0x81A2,0xE5);
+					ov3640_write_reg(0x81A3,0x60);
+					ov3640_write_reg(0x81A4,0x12);
+					ov3640_write_reg(0x81A5,0x06);
+					ov3640_write_reg(0x81A6,0x1C);
+					ov3640_write_reg(0x81A7,0x40);
+					ov3640_write_reg(0x81A8,0x0E);
+					ov3640_write_reg(0x81A9,0x12);
+					ov3640_write_reg(0x81AA,0x05);
+					ov3640_write_reg(0x81AB,0xD8);
+					ov3640_write_reg(0x81AC,0x40);
+					ov3640_write_reg(0x81AD,0x09);
+					ov3640_write_reg(0x81AE,0x12);
+					ov3640_write_reg(0x81AF,0x05);
+					ov3640_write_reg(0x81B0,0xE2);
+					ov3640_write_reg(0x81B1,0x85);
+					ov3640_write_reg(0x81B2,0x27);
+					ov3640_write_reg(0x81B3,0x4F);
+					ov3640_write_reg(0x81B4,0x85);
+					ov3640_write_reg(0x81B5,0x28);
+					ov3640_write_reg(0x81B6,0x50);
+					ov3640_write_reg(0x81B7,0x05);
+					ov3640_write_reg(0x81B8,0x43);
+					ov3640_write_reg(0x81B9,0x80);
+					ov3640_write_reg(0x81BA,0x40);
+					ov3640_write_reg(0x81BB,0xE5);
+					ov3640_write_reg(0x81BC,0x43);
+					ov3640_write_reg(0x81BD,0xC3);
+					ov3640_write_reg(0x81BE,0x95);
+					ov3640_write_reg(0x81BF,0x44);
+					ov3640_write_reg(0x81C0,0x40);
+					ov3640_write_reg(0x81C1,0x39);
+					ov3640_write_reg(0x81C2,0x12);
+					ov3640_write_reg(0x81C3,0x05);
+					ov3640_write_reg(0x81C4,0xD8);
+					ov3640_write_reg(0x81C5,0x40);
+					ov3640_write_reg(0x81C6,0x02);
+					ov3640_write_reg(0x81C7,0x80);
+					ov3640_write_reg(0x81C8,0x1A);
+					ov3640_write_reg(0x81C9,0xE5);
+					ov3640_write_reg(0x81CA,0x50);
+					ov3640_write_reg(0x81CB,0x45);
+					ov3640_write_reg(0x81CC,0x4F);
+					ov3640_write_reg(0x81CD,0x70);
+					ov3640_write_reg(0x81CE,0x17);
+					ov3640_write_reg(0x81CF,0xAE);
+					ov3640_write_reg(0x81D0,0x5D);
+					ov3640_write_reg(0x81D1,0xAF);
+					ov3640_write_reg(0x81D2,0x5E);
+					ov3640_write_reg(0x81D3,0xFC);
+					ov3640_write_reg(0x81D4,0x7D);
+					ov3640_write_reg(0x81D5,0x03);
+					ov3640_write_reg(0x81D6,0x12);
+					ov3640_write_reg(0x81D7,0x0C);
+					ov3640_write_reg(0x81D8,0xC8);
+					ov3640_write_reg(0x81D9,0xEE);
+					ov3640_write_reg(0x81DA,0xC3);
+					ov3640_write_reg(0x81DB,0x13);
+					ov3640_write_reg(0x81DC,0xFE);
+					ov3640_write_reg(0x81DD,0xEF);
+					ov3640_write_reg(0x81DE,0x12);
+					ov3640_write_reg(0x81DF,0x06);
+					ov3640_write_reg(0x81E0,0x1C);
+					ov3640_write_reg(0x81E1,0x40);
+					ov3640_write_reg(0x81E2,0x03);
+					ov3640_write_reg(0x81E3,0x12);
+					ov3640_write_reg(0x81E4,0x05);
+					ov3640_write_reg(0x81E5,0xE2);
+					ov3640_write_reg(0x81E6,0xE5);
+					ov3640_write_reg(0x81E7,0x43);
+					ov3640_write_reg(0x81E8,0x44);
+					ov3640_write_reg(0x81E9,0x10);
+					ov3640_write_reg(0x81EA,0x90);
+					ov3640_write_reg(0x81EB,0x3F);
+					ov3640_write_reg(0x81EC,0x04);
+					ov3640_write_reg(0x81ED,0xF0);
+					ov3640_write_reg(0x81EE,0x75);
+					ov3640_write_reg(0x81EF,0x4F);
+					ov3640_write_reg(0x81F0,0x00);
+					ov3640_write_reg(0x81F1,0x75);
+					ov3640_write_reg(0x81F2,0x50);
+					ov3640_write_reg(0x81F3,0x00);
+					ov3640_write_reg(0x81F4,0x75);
+					ov3640_write_reg(0x81F5,0x43);
+					ov3640_write_reg(0x81F6,0x00);
+					ov3640_write_reg(0x81F7,0xC2);
+					ov3640_write_reg(0x81F8,0x0A);
+					ov3640_write_reg(0x81F9,0xC2);
+					ov3640_write_reg(0x81FA,0x09);
+					ov3640_write_reg(0x81FB,0x90);
+					ov3640_write_reg(0x81FC,0x37);
+					ov3640_write_reg(0x81FD,0x08);
+					ov3640_write_reg(0x81FE,0x74);
+					ov3640_write_reg(0x81FF,0x08);
+					ov3640_write_reg(0x8200,0xF0);
+					ov3640_write_reg(0x8201,0xD2);
+					ov3640_write_reg(0x8202,0x08);
+					ov3640_write_reg(0x8203,0x80);
+					ov3640_write_reg(0x8204,0x5A);
+					ov3640_write_reg(0x8205,0x90);
+					ov3640_write_reg(0x8206,0x37);
+					ov3640_write_reg(0x8207,0x08);
+					ov3640_write_reg(0x8208,0xE0);
+					ov3640_write_reg(0x8209,0x30);
+					ov3640_write_reg(0x820A,0xE6);
+					ov3640_write_reg(0x820B,0x5A);
+					ov3640_write_reg(0x820C,0x30);
+					ov3640_write_reg(0x820D,0x0A);
+					ov3640_write_reg(0x820E,0x07);
+					ov3640_write_reg(0x820F,0x90);
+					ov3640_write_reg(0x8210,0x30);
+					ov3640_write_reg(0x8211,0xB4);
+					ov3640_write_reg(0x8212,0xE0);
+					ov3640_write_reg(0x8213,0x44);
+					ov3640_write_reg(0x8214,0x08);
+					ov3640_write_reg(0x8215,0xF0);
+					ov3640_write_reg(0x8216,0x90);
+					ov3640_write_reg(0x8217,0x38);
+					ov3640_write_reg(0x8218,0x02);
+					ov3640_write_reg(0x8219,0xE0);
+					ov3640_write_reg(0x821A,0xF5);
+					ov3640_write_reg(0x821B,0x25);
+					ov3640_write_reg(0x821C,0x30);
+					ov3640_write_reg(0x821D,0xE3);
+					ov3640_write_reg(0x821E,0x06);
+					ov3640_write_reg(0x821F,0xA3);
+					ov3640_write_reg(0x8220,0x74);
+					ov3640_write_reg(0x8221,0xD9);
+					ov3640_write_reg(0x8222,0xF0);
+					ov3640_write_reg(0x8223,0x80);
+					ov3640_write_reg(0x8224,0x03);
+					ov3640_write_reg(0x8225,0x90);
+					ov3640_write_reg(0x8226,0x38);
+					ov3640_write_reg(0x8227,0x03);
+					ov3640_write_reg(0x8228,0xE5);
+					ov3640_write_reg(0x8229,0x45);
+					ov3640_write_reg(0x822A,0xF0);
+					ov3640_write_reg(0x822B,0xE5);
+					ov3640_write_reg(0x822C,0x51);
+					ov3640_write_reg(0x822D,0xF0);
+					ov3640_write_reg(0x822E,0xE5);
+					ov3640_write_reg(0x822F,0x53);
+					ov3640_write_reg(0x8230,0xF0);
+					ov3640_write_reg(0x8231,0xE5);
+					ov3640_write_reg(0x8232,0x55);
+					ov3640_write_reg(0x8233,0xF0);
+					ov3640_write_reg(0x8234,0xE5);
+					ov3640_write_reg(0x8235,0x57);
+					ov3640_write_reg(0x8236,0xF0);
+					ov3640_write_reg(0x8237,0xE5);
+					ov3640_write_reg(0x8238,0x52);
+					ov3640_write_reg(0x8239,0xF0);
+					ov3640_write_reg(0x823A,0xE5);
+					ov3640_write_reg(0x823B,0x54);
+					ov3640_write_reg(0x823C,0xF0);
+					ov3640_write_reg(0x823D,0xE5);
+					ov3640_write_reg(0x823E,0x56);
+					ov3640_write_reg(0x823F,0xF0);
+					ov3640_write_reg(0x8240,0xE5);
+					ov3640_write_reg(0x8241,0x58);
+					ov3640_write_reg(0x8242,0xF0);
+					ov3640_write_reg(0x8243,0xE5);
+					ov3640_write_reg(0x8244,0x61);
+					ov3640_write_reg(0x8245,0xF0);
+					ov3640_write_reg(0x8246,0xE5);
+					ov3640_write_reg(0x8247,0x5B);
+					ov3640_write_reg(0x8248,0xF0);
+					ov3640_write_reg(0x8249,0xE5);
+					ov3640_write_reg(0x824A,0x5C);
+					ov3640_write_reg(0x824B,0xF0);
+					ov3640_write_reg(0x824C,0x74);
+					ov3640_write_reg(0x824D,0x88);
+					ov3640_write_reg(0x824E,0xF0);
+					ov3640_write_reg(0x824F,0xF0);
+					ov3640_write_reg(0x8250,0x75);
+					ov3640_write_reg(0x8251,0x61);
+					ov3640_write_reg(0x8252,0x00);
+					ov3640_write_reg(0x8253,0x90);
+					ov3640_write_reg(0x8254,0x38);
+					ov3640_write_reg(0x8255,0x02);
+					ov3640_write_reg(0x8256,0x74);
+					ov3640_write_reg(0x8257,0x02);
+					ov3640_write_reg(0x8258,0xF0);
+					ov3640_write_reg(0x8259,0x90);
+					ov3640_write_reg(0x825A,0x37);
+					ov3640_write_reg(0x825B,0x08);
+					ov3640_write_reg(0x825C,0x74);
+					ov3640_write_reg(0x825D,0x40);
+					ov3640_write_reg(0x825E,0xF0);
+					ov3640_write_reg(0x825F,0x90);
+					ov3640_write_reg(0x8260,0x30);
+					ov3640_write_reg(0x8261,0xB4);
+					ov3640_write_reg(0x8262,0xE0);
+					ov3640_write_reg(0x8263,0x54);
+					ov3640_write_reg(0x8264,0xF7);
+					ov3640_write_reg(0x8265,0xF0);
+					ov3640_write_reg(0x8266,0xD0);
+					ov3640_write_reg(0x8267,0x07);
+					ov3640_write_reg(0x8268,0xD0);
+					ov3640_write_reg(0x8269,0x06);
+					ov3640_write_reg(0x826A,0xD0);
+					ov3640_write_reg(0x826B,0x05);
+					ov3640_write_reg(0x826C,0xD0);
+					ov3640_write_reg(0x826D,0x04);
+					ov3640_write_reg(0x826E,0xD0);
+					ov3640_write_reg(0x826F,0x00);
+					ov3640_write_reg(0x8270,0xD0);
+					ov3640_write_reg(0x8271,0xD0);
+					ov3640_write_reg(0x8272,0xD0);
+					ov3640_write_reg(0x8273,0x82);
+					ov3640_write_reg(0x8274,0xD0);
+					ov3640_write_reg(0x8275,0x83);
+					ov3640_write_reg(0x8276,0xD0);
+					ov3640_write_reg(0x8277,0xF0);
+					ov3640_write_reg(0x8278,0xD0);
+					ov3640_write_reg(0x8279,0xE0);
+					ov3640_write_reg(0x827A,0x32);
+					ov3640_write_reg(0x827B,0xE5);
+					ov3640_write_reg(0x827C,0x2F);
+					ov3640_write_reg(0x827D,0x14);
+					ov3640_write_reg(0x827E,0x60);
+					ov3640_write_reg(0x827F,0x57);
+					ov3640_write_reg(0x8280,0x14);
+					ov3640_write_reg(0x8281,0x70);
+					ov3640_write_reg(0x8282,0x03);
+					ov3640_write_reg(0x8283,0x02);
+					ov3640_write_reg(0x8284,0x03);
+					ov3640_write_reg(0x8285,0x27);
+					ov3640_write_reg(0x8286,0x14);
+					ov3640_write_reg(0x8287,0x70);
+					ov3640_write_reg(0x8288,0x03);
+					ov3640_write_reg(0x8289,0x02);
+					ov3640_write_reg(0x828A,0x03);
+					ov3640_write_reg(0x828B,0x69);
+					ov3640_write_reg(0x828C,0x14);
+					ov3640_write_reg(0x828D,0x70);
+					ov3640_write_reg(0x828E,0x03);
+					ov3640_write_reg(0x828F,0x02);
+					ov3640_write_reg(0x8290,0x03);
+					ov3640_write_reg(0x8291,0xD8);
+					ov3640_write_reg(0x8292,0x24);
+					ov3640_write_reg(0x8293,0x04);
+					ov3640_write_reg(0x8294,0x60);
+					ov3640_write_reg(0x8295,0x03);
+					ov3640_write_reg(0x8296,0x02);
+					ov3640_write_reg(0x8297,0x03);
+					ov3640_write_reg(0x8298,0xEF);
+					ov3640_write_reg(0x8299,0xE4);
+					ov3640_write_reg(0x829A,0xFD);
+					ov3640_write_reg(0x829B,0xFF);
+					ov3640_write_reg(0x829C,0x12);
+					ov3640_write_reg(0x829D,0x0B);
+					ov3640_write_reg(0x829E,0x2C);
+					ov3640_write_reg(0x829F,0x8E);
+					ov3640_write_reg(0x82A0,0x30);
+					ov3640_write_reg(0x82A1,0x8F);
+					ov3640_write_reg(0x82A2,0x31);
+					ov3640_write_reg(0x82A3,0x0D);
+					ov3640_write_reg(0x82A4,0xE4);
+					ov3640_write_reg(0x82A5,0xFF);
+					ov3640_write_reg(0x82A6,0x12);
+					ov3640_write_reg(0x82A7,0x0B);
+					ov3640_write_reg(0x82A8,0x2C);
+					ov3640_write_reg(0x82A9,0x8E);
+					ov3640_write_reg(0x82AA,0x34);
+					ov3640_write_reg(0x82AB,0x8F);
+					ov3640_write_reg(0x82AC,0x35);
+					ov3640_write_reg(0x82AD,0x12);
+					ov3640_write_reg(0x82AE,0x05);
+					ov3640_write_reg(0x82AF,0xAE);
+					ov3640_write_reg(0x82B0,0x50);
+					ov3640_write_reg(0x82B1,0x08);
+					ov3640_write_reg(0x82B2,0x75);
+					ov3640_write_reg(0x82B3,0x2E);
+					ov3640_write_reg(0x82B4,0x01);
+					ov3640_write_reg(0x82B5,0x75);
+					ov3640_write_reg(0x82B6,0x2F);
+					ov3640_write_reg(0x82B7,0x01);
+					ov3640_write_reg(0x82B8,0x80);
+					ov3640_write_reg(0x82B9,0x06);
+					ov3640_write_reg(0x82BA,0x75);
+					ov3640_write_reg(0x82BB,0x2E);
+					ov3640_write_reg(0x82BC,0xFF);
+					ov3640_write_reg(0x82BD,0x75);
+					ov3640_write_reg(0x82BE,0x2F);
+					ov3640_write_reg(0x82BF,0x03);
+					ov3640_write_reg(0x82C0,0x12);
+					ov3640_write_reg(0x82C1,0x03);
+					ov3640_write_reg(0x82C2,0xF8);
+					ov3640_write_reg(0x82C3,0x90);
+					ov3640_write_reg(0x82C4,0x33);
+					ov3640_write_reg(0x82C5,0xB3);
+					ov3640_write_reg(0x82C6,0x74);
+					ov3640_write_reg(0x82C7,0x80);
+					ov3640_write_reg(0x82C8,0xF0);
+					ov3640_write_reg(0x82C9,0xA3);
+					ov3640_write_reg(0x82CA,0x74);
+					ov3640_write_reg(0x82CB,0x2A);
+					ov3640_write_reg(0x82CC,0xF0);
+					ov3640_write_reg(0x82CD,0xA3);
+					ov3640_write_reg(0x82CE,0x74);
+					ov3640_write_reg(0x82CF,0x14);
+					ov3640_write_reg(0x82D0,0xF0);
+					ov3640_write_reg(0x82D1,0xA3);
+					ov3640_write_reg(0x82D2,0xE4);
+					ov3640_write_reg(0x82D3,0xF0);
+					ov3640_write_reg(0x82D4,0x02);
+					ov3640_write_reg(0x82D5,0x03);
+					ov3640_write_reg(0x82D6,0xEF);
+					ov3640_write_reg(0x82D7,0x12);
+					ov3640_write_reg(0x82D8,0x04);
+					ov3640_write_reg(0x82D9,0x44);
+					ov3640_write_reg(0x82DA,0xC0);
+					ov3640_write_reg(0x82DB,0x06);
+					ov3640_write_reg(0x82DC,0xC0);
+					ov3640_write_reg(0x82DD,0x07);
+					ov3640_write_reg(0x82DE,0x12);
+					ov3640_write_reg(0x82DF,0x04);
+					ov3640_write_reg(0x82E0,0x88);
+					ov3640_write_reg(0x82E1,0xD0);
+					ov3640_write_reg(0x82E2,0x05);
+					ov3640_write_reg(0x82E3,0xD0);
+					ov3640_write_reg(0x82E4,0x04);
+					ov3640_write_reg(0x82E5,0x12);
+					ov3640_write_reg(0x82E6,0x06);
+					ov3640_write_reg(0x82E7,0x10);
+					ov3640_write_reg(0x82E8,0x40);
+					ov3640_write_reg(0x82E9,0x05);
+					ov3640_write_reg(0x82EA,0x12);
+					ov3640_write_reg(0x82EB,0x05);
+					ov3640_write_reg(0x82EC,0xF6);
+					ov3640_write_reg(0x82ED,0x80);
+					ov3640_write_reg(0x82EE,0x03);
+					ov3640_write_reg(0x82EF,0x12);
+					ov3640_write_reg(0x82F0,0x06);
+					ov3640_write_reg(0x82F1,0x03);
+					ov3640_write_reg(0x82F2,0x12);
+					ov3640_write_reg(0x82F3,0x06);
+					ov3640_write_reg(0x82F4,0x26);
+					ov3640_write_reg(0x82F5,0x40);
+					ov3640_write_reg(0x82F6,0x11);
+					ov3640_write_reg(0x82F7,0x12);
+					ov3640_write_reg(0x82F8,0x05);
+					ov3640_write_reg(0x82F9,0xAE);
+					ov3640_write_reg(0x82FA,0x50);
+					ov3640_write_reg(0x82FB,0x09);
+					ov3640_write_reg(0x82FC,0x12);
+					ov3640_write_reg(0x82FD,0x03);
+					ov3640_write_reg(0x82FE,0xF8);
+					ov3640_write_reg(0x82FF,0x75);
+					ov3640_write_reg(0x8300,0x2F);
+					ov3640_write_reg(0x8301,0x02);
+					ov3640_write_reg(0x8302,0x02);
+					ov3640_write_reg(0x8303,0x03);
+					ov3640_write_reg(0x8304,0xB8);
+					ov3640_write_reg(0x8305,0x02);
+					ov3640_write_reg(0x8306,0x03);
+					ov3640_write_reg(0x8307,0xD3);
+					ov3640_write_reg(0x8308,0x75);
+					ov3640_write_reg(0x8309,0x2E);
+					ov3640_write_reg(0x830A,0xFF);
+					ov3640_write_reg(0x830B,0xD3);
+					ov3640_write_reg(0x830C,0xE5);
+					ov3640_write_reg(0x830D,0x4C);
+					ov3640_write_reg(0x830E,0x94);
+					ov3640_write_reg(0x830F,0x28);
+					ov3640_write_reg(0x8310,0xE5);
+					ov3640_write_reg(0x8311,0x4B);
+					ov3640_write_reg(0x8312,0x94);
+					ov3640_write_reg(0x8313,0x00);
+					ov3640_write_reg(0x8314,0xAF);
+					ov3640_write_reg(0x8315,0x2E);
+					ov3640_write_reg(0x8316,0xEF);
+					ov3640_write_reg(0x8317,0x40);
+					ov3640_write_reg(0x8318,0x0B);
+					ov3640_write_reg(0x8319,0x7D);
+					ov3640_write_reg(0x831A,0x50);
+					ov3640_write_reg(0x831B,0x12);
+					ov3640_write_reg(0x831C,0x04);
+					ov3640_write_reg(0x831D,0x67);
+					ov3640_write_reg(0x831E,0x75);
+					ov3640_write_reg(0x831F,0x2F);
+					ov3640_write_reg(0x8320,0x03);
+					ov3640_write_reg(0x8321,0x02);
+					ov3640_write_reg(0x8322,0x03);
+					ov3640_write_reg(0x8323,0xB8);
+					ov3640_write_reg(0x8324,0x02);
+					ov3640_write_reg(0x8325,0x03);
+					ov3640_write_reg(0x8326,0xCE);
+					ov3640_write_reg(0x8327,0x12);
+					ov3640_write_reg(0x8328,0x04);
+					ov3640_write_reg(0x8329,0x44);
+					ov3640_write_reg(0x832A,0xC0);
+					ov3640_write_reg(0x832B,0x06);
+					ov3640_write_reg(0x832C,0xC0);
+					ov3640_write_reg(0x832D,0x07);
+					ov3640_write_reg(0x832E,0xC3);
+					ov3640_write_reg(0x832F,0xE5);
+					ov3640_write_reg(0x8330,0x39);
+					ov3640_write_reg(0x8331,0x95);
+					ov3640_write_reg(0x8332,0x31);
+					ov3640_write_reg(0x8333,0xFF);
+					ov3640_write_reg(0x8334,0xE5);
+					ov3640_write_reg(0x8335,0x38);
+					ov3640_write_reg(0x8336,0x95);
+					ov3640_write_reg(0x8337,0x30);
+					ov3640_write_reg(0x8338,0xFE);
+					ov3640_write_reg(0x8339,0x12);
+					ov3640_write_reg(0x833A,0x0C);
+					ov3640_write_reg(0x833B,0xF7);
+					ov3640_write_reg(0x833C,0xD0);
+					ov3640_write_reg(0x833D,0x05);
+					ov3640_write_reg(0x833E,0xD0);
+					ov3640_write_reg(0x833F,0x04);
+					ov3640_write_reg(0x8340,0x12);
+					ov3640_write_reg(0x8341,0x06);
+					ov3640_write_reg(0x8342,0x10);
+					ov3640_write_reg(0x8343,0x40);
+					ov3640_write_reg(0x8344,0x05);
+					ov3640_write_reg(0x8345,0x12);
+					ov3640_write_reg(0x8346,0x05);
+					ov3640_write_reg(0x8347,0xF6);
+					ov3640_write_reg(0x8348,0x80);
+					ov3640_write_reg(0x8349,0x03);
+					ov3640_write_reg(0x834A,0x12);
+					ov3640_write_reg(0x834B,0x06);
+					ov3640_write_reg(0x834C,0x03);
+					ov3640_write_reg(0x834D,0x12);
+					ov3640_write_reg(0x834E,0x06);
+					ov3640_write_reg(0x834F,0x26);
+					ov3640_write_reg(0x8350,0x40);
+					ov3640_write_reg(0x8351,0x0E);
+					ov3640_write_reg(0x8352,0x12);
+					ov3640_write_reg(0x8353,0x05);
+					ov3640_write_reg(0x8354,0xAE);
+					ov3640_write_reg(0x8355,0x50);
+					ov3640_write_reg(0x8356,0x06);
+					ov3640_write_reg(0x8357,0x12);
+					ov3640_write_reg(0x8358,0x04);
+					ov3640_write_reg(0x8359,0x1E);
+					ov3640_write_reg(0x835A,0x02);
+					ov3640_write_reg(0x835B,0x03);
+					ov3640_write_reg(0x835C,0xB8);
+					ov3640_write_reg(0x835D,0x02);
+					ov3640_write_reg(0x835E,0x03);
+					ov3640_write_reg(0x835F,0xD3);
+					ov3640_write_reg(0x8360,0x75);
+					ov3640_write_reg(0x8361,0x2E);
+					ov3640_write_reg(0x8362,0xFF);
+					ov3640_write_reg(0x8363,0xAF);
+					ov3640_write_reg(0x8364,0x2E);
+					ov3640_write_reg(0x8365,0xEF);
+					ov3640_write_reg(0x8366,0x02);
+					ov3640_write_reg(0x8367,0x03);
+					ov3640_write_reg(0x8368,0xCE);
+					ov3640_write_reg(0x8369,0xE4);
+					ov3640_write_reg(0x836A,0xFD);
+					ov3640_write_reg(0x836B,0xFF);
+					ov3640_write_reg(0x836C,0x12);
+					ov3640_write_reg(0x836D,0x0B);
+					ov3640_write_reg(0x836E,0x2C);
+					ov3640_write_reg(0x836F,0x8E);
+					ov3640_write_reg(0x8370,0x32);
+					ov3640_write_reg(0x8371,0x8F);
+					ov3640_write_reg(0x8372,0x33);
+					ov3640_write_reg(0x8373,0x0D);
+					ov3640_write_reg(0x8374,0xE4);
+					ov3640_write_reg(0x8375,0xFF);
+					ov3640_write_reg(0x8376,0x12);
+					ov3640_write_reg(0x8377,0x0B);
+					ov3640_write_reg(0x8378,0x2C);
+					ov3640_write_reg(0x8379,0x8E);
+					ov3640_write_reg(0x837A,0x36);
+					ov3640_write_reg(0x837B,0x8F);
+					ov3640_write_reg(0x837C,0x37);
+					ov3640_write_reg(0x837D,0xC3);
+					ov3640_write_reg(0x837E,0xE5);
+					ov3640_write_reg(0x837F,0x37);
+					ov3640_write_reg(0x8380,0x95);
+					ov3640_write_reg(0x8381,0x35);
+					ov3640_write_reg(0x8382,0xFF);
+					ov3640_write_reg(0x8383,0xE5);
+					ov3640_write_reg(0x8384,0x36);
+					ov3640_write_reg(0x8385,0x95);
+					ov3640_write_reg(0x8386,0x34);
+					ov3640_write_reg(0x8387,0xFE);
+					ov3640_write_reg(0x8388,0x12);
+					ov3640_write_reg(0x8389,0x0C);
+					ov3640_write_reg(0x838A,0xF7);
+					ov3640_write_reg(0x838B,0xC0);
+					ov3640_write_reg(0x838C,0x06);
+					ov3640_write_reg(0x838D,0xC0);
+					ov3640_write_reg(0x838E,0x07);
+					ov3640_write_reg(0x838F,0x12);
+					ov3640_write_reg(0x8390,0x04);
+					ov3640_write_reg(0x8391,0x88);
+					ov3640_write_reg(0x8392,0xD0);
+					ov3640_write_reg(0x8393,0x05);
+					ov3640_write_reg(0x8394,0xD0);
+					ov3640_write_reg(0x8395,0x04);
+					ov3640_write_reg(0x8396,0xC3);
+					ov3640_write_reg(0x8397,0x12);
+					ov3640_write_reg(0x8398,0x06);
+					ov3640_write_reg(0x8399,0x11);
+					ov3640_write_reg(0x839A,0x40);
+					ov3640_write_reg(0x839B,0x05);
+					ov3640_write_reg(0x839C,0x12);
+					ov3640_write_reg(0x839D,0x05);
+					ov3640_write_reg(0x839E,0xF6);
+					ov3640_write_reg(0x839F,0x80);
+					ov3640_write_reg(0x83A0,0x03);
+					ov3640_write_reg(0x83A1,0x12);
+					ov3640_write_reg(0x83A2,0x06);
+					ov3640_write_reg(0x83A3,0x03);
+					ov3640_write_reg(0x83A4,0xC3);
+					ov3640_write_reg(0x83A5,0x12);
+					ov3640_write_reg(0x83A6,0x06);
+					ov3640_write_reg(0x83A7,0x27);
+					ov3640_write_reg(0x83A8,0x40);
+					ov3640_write_reg(0x83A9,0x1E);
+					ov3640_write_reg(0x83AA,0xD3);
+					ov3640_write_reg(0x83AB,0xE5);
+					ov3640_write_reg(0x83AC,0x4C);
+					ov3640_write_reg(0x83AD,0x94);
+					ov3640_write_reg(0x83AE,0x00);
+					ov3640_write_reg(0x83AF,0xE5);
+					ov3640_write_reg(0x83B0,0x4B);
+					ov3640_write_reg(0x83B1,0x94);
+					ov3640_write_reg(0x83B2,0x00);
+					ov3640_write_reg(0x83B3,0x40);
+					ov3640_write_reg(0x83B4,0x11);
+					ov3640_write_reg(0x83B5,0x12);
+					ov3640_write_reg(0x83B6,0x04);
+					ov3640_write_reg(0x83B7,0x1E);
+					ov3640_write_reg(0x83B8,0x85);
+					ov3640_write_reg(0x83B9,0x32);
+					ov3640_write_reg(0x83BA,0x30);
+					ov3640_write_reg(0x83BB,0x85);
+					ov3640_write_reg(0x83BC,0x33);
+					ov3640_write_reg(0x83BD,0x31);
+					ov3640_write_reg(0x83BE,0x85);
+					ov3640_write_reg(0x83BF,0x36);
+					ov3640_write_reg(0x83C0,0x34);
+					ov3640_write_reg(0x83C1,0x85);
+					ov3640_write_reg(0x83C2,0x37);
+					ov3640_write_reg(0x83C3,0x35);
+					ov3640_write_reg(0x83C4,0x80);
+					ov3640_write_reg(0x83C5,0x29);
+					ov3640_write_reg(0x83C6,0x80);
+					ov3640_write_reg(0x83C7,0x0B);
+					ov3640_write_reg(0x83C8,0x75);
+					ov3640_write_reg(0x83C9,0x2E);
+					ov3640_write_reg(0x83CA,0x01);
+					ov3640_write_reg(0x83CB,0xAF);
+					ov3640_write_reg(0x83CC,0x2E);
+					ov3640_write_reg(0x83CD,0xEF);
+					ov3640_write_reg(0x83CE,0x7D);
+					ov3640_write_reg(0x83CF,0x28);
+					ov3640_write_reg(0x83D0,0x12);
+					ov3640_write_reg(0x83D1,0x04);
+					ov3640_write_reg(0x83D2,0x67);
+					ov3640_write_reg(0x83D3,0x75);
+					ov3640_write_reg(0x83D4,0x2F);
+					ov3640_write_reg(0x83D5,0x04);
+					ov3640_write_reg(0x83D6,0x80);
+					ov3640_write_reg(0x83D7,0x17);
+					ov3640_write_reg(0x83D8,0x90);
+					ov3640_write_reg(0x83D9,0x33);
+					ov3640_write_reg(0x83DA,0xB3);
+					ov3640_write_reg(0x83DB,0x12);
+					ov3640_write_reg(0x83DC,0x06);
+					ov3640_write_reg(0x83DD,0x30);
+					ov3640_write_reg(0x83DE,0xE5);
+					ov3640_write_reg(0x83DF,0x4C);
+					ov3640_write_reg(0x83E0,0x45);
+					ov3640_write_reg(0x83E1,0x4B);
+					ov3640_write_reg(0x83E2,0x70);
+					ov3640_write_reg(0x83E3,0x05);
+					ov3640_write_reg(0x83E4,0xFF);
+					ov3640_write_reg(0x83E5,0xFE);
+					ov3640_write_reg(0x83E6,0x12);
+					ov3640_write_reg(0x83E7,0x0B);
+					ov3640_write_reg(0x83E8,0x7A);
+					ov3640_write_reg(0x83E9,0xE4);
+					ov3640_write_reg(0x83EA,0xF5);
+					ov3640_write_reg(0x83EB,0x2F);
+					ov3640_write_reg(0x83EC,0x75);
+					ov3640_write_reg(0x83ED,0x3C);
+					ov3640_write_reg(0x83EE,0x04);
+					ov3640_write_reg(0x83EF,0x90);
+					ov3640_write_reg(0x83F0,0x3F);
+					ov3640_write_reg(0x83F1,0x03);
+					ov3640_write_reg(0x83F2,0xE0);
+					ov3640_write_reg(0x83F3,0x04);
+					ov3640_write_reg(0x83F4,0xF0);
+					ov3640_write_reg(0x83F5,0xC2);
+					ov3640_write_reg(0x83F6,0x08);
+					ov3640_write_reg(0x83F7,0x22);
+					ov3640_write_reg(0x83F8,0xAF);
+					ov3640_write_reg(0x83F9,0x2E);
+					ov3640_write_reg(0x83FA,0xEF);
+					ov3640_write_reg(0x83FB,0x33);
+					ov3640_write_reg(0x83FC,0x95);
+					ov3640_write_reg(0x83FD,0xE0);
+					ov3640_write_reg(0x83FE,0xFE);
+					ov3640_write_reg(0x83FF,0x7C);
+					ov3640_write_reg(0x8400,0x00);
+					ov3640_write_reg(0x8401,0x7D);
+					ov3640_write_reg(0x8402,0x28);
+					ov3640_write_reg(0x8403,0x12);
+					ov3640_write_reg(0x8404,0x0C);
+					ov3640_write_reg(0x8405,0xC8);
+					ov3640_write_reg(0x8406,0xEF);
+					ov3640_write_reg(0x8407,0x25);
+					ov3640_write_reg(0x8408,0x4C);
+					ov3640_write_reg(0x8409,0xF5);
+					ov3640_write_reg(0x840A,0x4C);
+					ov3640_write_reg(0x840B,0xEE);
+					ov3640_write_reg(0x840C,0x35);
+					ov3640_write_reg(0x840D,0x4B);
+					ov3640_write_reg(0x840E,0xF5);
+					ov3640_write_reg(0x840F,0x4B);
+					ov3640_write_reg(0x8410,0xE5);
+					ov3640_write_reg(0x8411,0x4C);
+					ov3640_write_reg(0x8412,0x25);
+					ov3640_write_reg(0x8413,0x3E);
+					ov3640_write_reg(0x8414,0xFF);
+					ov3640_write_reg(0x8415,0xE5);
+					ov3640_write_reg(0x8416,0x4B);
+					ov3640_write_reg(0x8417,0x35);
+					ov3640_write_reg(0x8418,0x3D);
+					ov3640_write_reg(0x8419,0xFE);
+					ov3640_write_reg(0x841A,0x12);
+					ov3640_write_reg(0x841B,0x0B);
+					ov3640_write_reg(0x841C,0x7A);
+					ov3640_write_reg(0x841D,0x22);
+					ov3640_write_reg(0x841E,0xAF);
+					ov3640_write_reg(0x841F,0x2E);
+					ov3640_write_reg(0x8420,0xEF);
+					ov3640_write_reg(0x8421,0x33);
+					ov3640_write_reg(0x8422,0x95);
+					ov3640_write_reg(0x8423,0xE0);
+					ov3640_write_reg(0x8424,0xFE);
+					ov3640_write_reg(0x8425,0x7C);
+					ov3640_write_reg(0x8426,0x00);
+					ov3640_write_reg(0x8427,0x7D);
+					ov3640_write_reg(0x8428,0x28);
+					ov3640_write_reg(0x8429,0x12);
+					ov3640_write_reg(0x842A,0x0C);
+					ov3640_write_reg(0x842B,0xC8);
+					ov3640_write_reg(0x842C,0xEF);
+					ov3640_write_reg(0x842D,0x25);
+					ov3640_write_reg(0x842E,0x4C);
+					ov3640_write_reg(0x842F,0xF5);
+					ov3640_write_reg(0x8430,0x4C);
+					ov3640_write_reg(0x8431,0xEE);
+					ov3640_write_reg(0x8432,0x35);
+					ov3640_write_reg(0x8433,0x4B);
+					ov3640_write_reg(0x8434,0xF5);
+					ov3640_write_reg(0x8435,0x4B);
+					ov3640_write_reg(0x8436,0xE5);
+					ov3640_write_reg(0x8437,0x4C);
+					ov3640_write_reg(0x8438,0x25);
+					ov3640_write_reg(0x8439,0x3E);
+					ov3640_write_reg(0x843A,0xFF);
+					ov3640_write_reg(0x843B,0xE5);
+					ov3640_write_reg(0x843C,0x4B);
+					ov3640_write_reg(0x843D,0x35);
+					ov3640_write_reg(0x843E,0x3D);
+					ov3640_write_reg(0x843F,0xFE);
+					ov3640_write_reg(0x8440,0x12);
+					ov3640_write_reg(0x8441,0x0B);
+					ov3640_write_reg(0x8442,0x7A);
+					ov3640_write_reg(0x8443,0x22);
+					ov3640_write_reg(0x8444,0xE4);
+					ov3640_write_reg(0x8445,0xFD);
+					ov3640_write_reg(0x8446,0xFF);
+					ov3640_write_reg(0x8447,0x12);
+					ov3640_write_reg(0x8448,0x0B);
+					ov3640_write_reg(0x8449,0x2C);
+					ov3640_write_reg(0x844A,0x8E);
+					ov3640_write_reg(0x844B,0x32);
+					ov3640_write_reg(0x844C,0x8F);
+					ov3640_write_reg(0x844D,0x33);
+					ov3640_write_reg(0x844E,0x0D);
+					ov3640_write_reg(0x844F,0xE4);
+					ov3640_write_reg(0x8450,0xFF);
+					ov3640_write_reg(0x8451,0x12);
+					ov3640_write_reg(0x8452,0x0B);
+					ov3640_write_reg(0x8453,0x2C);
+					ov3640_write_reg(0x8454,0x8E);
+					ov3640_write_reg(0x8455,0x36);
+					ov3640_write_reg(0x8456,0x8F);
+					ov3640_write_reg(0x8457,0x37);
+					ov3640_write_reg(0x8458,0xC3);
+					ov3640_write_reg(0x8459,0xE5);
+					ov3640_write_reg(0x845A,0x37);
+					ov3640_write_reg(0x845B,0x95);
+					ov3640_write_reg(0x845C,0x35);
+					ov3640_write_reg(0x845D,0xFF);
+					ov3640_write_reg(0x845E,0xE5);
+					ov3640_write_reg(0x845F,0x36);
+					ov3640_write_reg(0x8460,0x95);
+					ov3640_write_reg(0x8461,0x34);
+					ov3640_write_reg(0x8462,0xFE);
+					ov3640_write_reg(0x8463,0x12);
+					ov3640_write_reg(0x8464,0x0C);
+					ov3640_write_reg(0x8465,0xF7);
+					ov3640_write_reg(0x8466,0x22);
+					ov3640_write_reg(0x8467,0x33);
+					ov3640_write_reg(0x8468,0x95);
+					ov3640_write_reg(0x8469,0xE0);
+					ov3640_write_reg(0x846A,0xFE);
+					ov3640_write_reg(0x846B,0x7C);
+					ov3640_write_reg(0x846C,0x00);
+					ov3640_write_reg(0x846D,0x12);
+					ov3640_write_reg(0x846E,0x0C);
+					ov3640_write_reg(0x846F,0xC8);
+					ov3640_write_reg(0x8470,0xEF);
+					ov3640_write_reg(0x8471,0x25);
+					ov3640_write_reg(0x8472,0x4C);
+					ov3640_write_reg(0x8473,0xF5);
+					ov3640_write_reg(0x8474,0x4C);
+					ov3640_write_reg(0x8475,0xEE);
+					ov3640_write_reg(0x8476,0x35);
+					ov3640_write_reg(0x8477,0x4B);
+					ov3640_write_reg(0x8478,0xF5);
+					ov3640_write_reg(0x8479,0x4B);
+					ov3640_write_reg(0x847A,0xE5);
+					ov3640_write_reg(0x847B,0x4C);
+					ov3640_write_reg(0x847C,0x25);
+					ov3640_write_reg(0x847D,0x3E);
+					ov3640_write_reg(0x847E,0xFF);
+					ov3640_write_reg(0x847F,0xE5);
+					ov3640_write_reg(0x8480,0x4B);
+					ov3640_write_reg(0x8481,0x35);
+					ov3640_write_reg(0x8482,0x3D);
+					ov3640_write_reg(0x8483,0xFE);
+					ov3640_write_reg(0x8484,0x12);
+					ov3640_write_reg(0x8485,0x0B);
+					ov3640_write_reg(0x8486,0x7A);
+					ov3640_write_reg(0x8487,0x22);
+					ov3640_write_reg(0x8488,0xC3);
+					ov3640_write_reg(0x8489,0xE5);
+					ov3640_write_reg(0x848A,0x33);
+					ov3640_write_reg(0x848B,0x95);
+					ov3640_write_reg(0x848C,0x31);
+					ov3640_write_reg(0x848D,0xFF);
+					ov3640_write_reg(0x848E,0xE5);
+					ov3640_write_reg(0x848F,0x32);
+					ov3640_write_reg(0x8490,0x95);
+					ov3640_write_reg(0x8491,0x30);
+					ov3640_write_reg(0x8492,0xFE);
+					ov3640_write_reg(0x8493,0x12);
+					ov3640_write_reg(0x8494,0x0C);
+					ov3640_write_reg(0x8495,0xF7);
+					ov3640_write_reg(0x8496,0x22);
+					ov3640_write_reg(0x8497,0x90);
+					ov3640_write_reg(0x8498,0x3F);
+					ov3640_write_reg(0x8499,0x00);
+					ov3640_write_reg(0x849A,0xE0);
+					ov3640_write_reg(0x849B,0x54);
+					ov3640_write_reg(0x849C,0x1F);
+					ov3640_write_reg(0x849D,0xFF);
+					ov3640_write_reg(0x849E,0x60);
+					ov3640_write_reg(0x849F,0x02);
+					ov3640_write_reg(0x84A0,0xE4);
+					ov3640_write_reg(0x84A1,0xF0);
+					ov3640_write_reg(0x84A2,0xEF);
+					ov3640_write_reg(0x84A3,0x14);
+					ov3640_write_reg(0x84A4,0xB4);
+					ov3640_write_reg(0x84A5,0x19);
+					ov3640_write_reg(0x84A6,0x00);
+					ov3640_write_reg(0x84A7,0x40);
+					ov3640_write_reg(0x84A8,0x03);
+					ov3640_write_reg(0x84A9,0x02);
+					ov3640_write_reg(0x84AA,0x05);
+					ov3640_write_reg(0x84AB,0x9B);
+					ov3640_write_reg(0x84AC,0x90);
+					ov3640_write_reg(0x84AD,0x04);
+					ov3640_write_reg(0x84AE,0xBA);
+					ov3640_write_reg(0x84AF,0x75);
+					ov3640_write_reg(0x84B0,0xF0);
+					ov3640_write_reg(0x84B1,0x03);
+					ov3640_write_reg(0x84B2,0xA4);
+					ov3640_write_reg(0x84B3,0xC5);
+					ov3640_write_reg(0x84B4,0x83);
+					ov3640_write_reg(0x84B5,0x25);
+					ov3640_write_reg(0x84B6,0xF0);
+					ov3640_write_reg(0x84B7,0xC5);
+					ov3640_write_reg(0x84B8,0x83);
+					ov3640_write_reg(0x84B9,0x73);
+					ov3640_write_reg(0x84BA,0x02);
+					ov3640_write_reg(0x84BB,0x05);
+					ov3640_write_reg(0x84BC,0x05);
+					ov3640_write_reg(0x84BD,0x02);
+					ov3640_write_reg(0x84BE,0x05);
+					ov3640_write_reg(0x84BF,0x09);
+					ov3640_write_reg(0x84C0,0x02);
+					ov3640_write_reg(0x84C1,0x05);
+					ov3640_write_reg(0x84C2,0x0E);
+					ov3640_write_reg(0x84C3,0x02);
+					ov3640_write_reg(0x84C4,0x05);
+					ov3640_write_reg(0x84C5,0x12);
+					ov3640_write_reg(0x84C6,0x02);
+					ov3640_write_reg(0x84C7,0x05);
+					ov3640_write_reg(0x84C8,0x17);
+					ov3640_write_reg(0x84C9,0x02);
+					ov3640_write_reg(0x84CA,0x05);
+					ov3640_write_reg(0x84CB,0x26);
+					ov3640_write_reg(0x84CC,0x02);
+					ov3640_write_reg(0x84CD,0x05);
+					ov3640_write_reg(0x84CE,0x2E);
+					ov3640_write_reg(0x84CF,0x02);
+					ov3640_write_reg(0x84D0,0x05);
+					ov3640_write_reg(0x84D1,0x38);
+					ov3640_write_reg(0x84D2,0x02);
+					ov3640_write_reg(0x84D3,0x05);
+					ov3640_write_reg(0x84D4,0x47);
+					ov3640_write_reg(0x84D5,0x02);
+					ov3640_write_reg(0x84D6,0x05);
+					ov3640_write_reg(0x84D7,0x4C);
+					ov3640_write_reg(0x84D8,0x02);
+					ov3640_write_reg(0x84D9,0x05);
+					ov3640_write_reg(0x84DA,0x54);
+					ov3640_write_reg(0x84DB,0x02);
+					ov3640_write_reg(0x84DC,0x05);
+					ov3640_write_reg(0x84DD,0x5C);
+					ov3640_write_reg(0x84DE,0x02);
+					ov3640_write_reg(0x84DF,0x05);
+					ov3640_write_reg(0x84E0,0x9B);
+					ov3640_write_reg(0x84E1,0x02);
+					ov3640_write_reg(0x84E2,0x05);
+					ov3640_write_reg(0x84E3,0x9B);
+					ov3640_write_reg(0x84E4,0x02);
+					ov3640_write_reg(0x84E5,0x05);
+					ov3640_write_reg(0x84E6,0x66);
+					ov3640_write_reg(0x84E7,0x02);
+					ov3640_write_reg(0x84E8,0x05);
+					ov3640_write_reg(0x84E9,0x9B);
+					ov3640_write_reg(0x84EA,0x02);
+					ov3640_write_reg(0x84EB,0x05);
+					ov3640_write_reg(0x84EC,0x9B);
+					ov3640_write_reg(0x84ED,0x02);
+					ov3640_write_reg(0x84EE,0x05);
+					ov3640_write_reg(0x84EF,0x9B);
+					ov3640_write_reg(0x84F0,0x02);
+					ov3640_write_reg(0x84F1,0x05);
+					ov3640_write_reg(0x84F2,0x9B);
+					ov3640_write_reg(0x84F3,0x02);
+					ov3640_write_reg(0x84F4,0x05);
+					ov3640_write_reg(0x84F5,0x71);
+					ov3640_write_reg(0x84F6,0x02);
+					ov3640_write_reg(0x84F7,0x05);
+					ov3640_write_reg(0x84F8,0x9B);
+					ov3640_write_reg(0x84F9,0x02);
+					ov3640_write_reg(0x84FA,0x05);
+					ov3640_write_reg(0x84FB,0x9B);
+					ov3640_write_reg(0x84FC,0x02);
+					ov3640_write_reg(0x84FD,0x05);
+					ov3640_write_reg(0x84FE,0x9B);
+					ov3640_write_reg(0x84FF,0x02);
+					ov3640_write_reg(0x8500,0x05);
+					ov3640_write_reg(0x8501,0x86);
+					ov3640_write_reg(0x8502,0x02);
+					ov3640_write_reg(0x8503,0x05);
+					ov3640_write_reg(0x8504,0x8E);
+					ov3640_write_reg(0x8505,0x7F);
+					ov3640_write_reg(0x8506,0x01);
+					ov3640_write_reg(0x8507,0x80);
+					ov3640_write_reg(0x8508,0x02);
+					ov3640_write_reg(0x8509,0xE4);
+					ov3640_write_reg(0x850A,0xFF);
+					ov3640_write_reg(0x850B,0x02);
+					ov3640_write_reg(0x850C,0x0C);
+					ov3640_write_reg(0x850D,0xDA);
+					ov3640_write_reg(0x850E,0xD2);
+					ov3640_write_reg(0x850F,0x0F);
+					ov3640_write_reg(0x8510,0x80);
+					ov3640_write_reg(0x8511,0x02);
+					ov3640_write_reg(0x8512,0xC2);
+					ov3640_write_reg(0x8513,0x0F);
+					ov3640_write_reg(0x8514,0x02);
+					ov3640_write_reg(0x8515,0x0C);
+					ov3640_write_reg(0x8516,0x76);
+					ov3640_write_reg(0x8517,0xC2);
+					ov3640_write_reg(0x8518,0x0D);
+					ov3640_write_reg(0x8519,0x75);
+					ov3640_write_reg(0x851A,0x3C);
+					ov3640_write_reg(0x851B,0x01);
+					ov3640_write_reg(0x851C,0xC2);
+					ov3640_write_reg(0x851D,0x0C);
+					ov3640_write_reg(0x851E,0x90);
+					ov3640_write_reg(0x851F,0x3F);
+					ov3640_write_reg(0x8520,0x02);
+					ov3640_write_reg(0x8521,0xE4);
+					ov3640_write_reg(0x8522,0xF0);
+					ov3640_write_reg(0x8523,0xA3);
+					ov3640_write_reg(0x8524,0xF0);
+					ov3640_write_reg(0x8525,0x22);
+					ov3640_write_reg(0x8526,0xC2);
+					ov3640_write_reg(0x8527,0x0D);
+					ov3640_write_reg(0x8528,0xE4);
+					ov3640_write_reg(0x8529,0xF5);
+					ov3640_write_reg(0x852A,0x3C);
+					ov3640_write_reg(0x852B,0xD2);
+					ov3640_write_reg(0x852C,0x0C);
+					ov3640_write_reg(0x852D,0x22);
+					ov3640_write_reg(0x852E,0xE4);
+					ov3640_write_reg(0x852F,0xF5);
+					ov3640_write_reg(0x8530,0x3C);
+					ov3640_write_reg(0x8531,0xC2);
+					ov3640_write_reg(0x8532,0x0C);
+					ov3640_write_reg(0x8533,0xC2);
+					ov3640_write_reg(0x8534,0x0B);
+					ov3640_write_reg(0x8535,0xD2);
+					ov3640_write_reg(0x8536,0x0D);
+					ov3640_write_reg(0x8537,0x22);
+					ov3640_write_reg(0x8538,0xC2);
+					ov3640_write_reg(0x8539,0x0D);
+					ov3640_write_reg(0x853A,0xE4);
+					ov3640_write_reg(0x853B,0xF5);
+					ov3640_write_reg(0x853C,0x3C);
+					ov3640_write_reg(0x853D,0xC2);
+					ov3640_write_reg(0x853E,0x0C);
+					ov3640_write_reg(0x853F,0xF5);
+					ov3640_write_reg(0x8540,0x72);
+					ov3640_write_reg(0x8541,0xF5);
+					ov3640_write_reg(0x8542,0x4B);
+					ov3640_write_reg(0x8543,0xF5);
+					ov3640_write_reg(0x8544,0x4C);
+					ov3640_write_reg(0x8545,0x80);
+					ov3640_write_reg(0x8546,0x4D);
+					ov3640_write_reg(0x8547,0xC2);
+					ov3640_write_reg(0x8548,0x0D);
+					ov3640_write_reg(0x8549,0xD2);
+					ov3640_write_reg(0x854A,0x0B);
+					ov3640_write_reg(0x854B,0x22);
+					ov3640_write_reg(0x854C,0x12);
+					ov3640_write_reg(0x854D,0x06);
+					ov3640_write_reg(0x854E,0x53);
+					ov3640_write_reg(0x854F,0x75);
+					ov3640_write_reg(0x8550,0x72);
+					ov3640_write_reg(0x8551,0x01);
+					ov3640_write_reg(0x8552,0x80);
+					ov3640_write_reg(0x8553,0x0B);
+					ov3640_write_reg(0x8554,0x12);
+					ov3640_write_reg(0x8555,0x06);
+					ov3640_write_reg(0x8556,0x53);
+					ov3640_write_reg(0x8557,0x75);
+					ov3640_write_reg(0x8558,0x72);
+					ov3640_write_reg(0x8559,0x02);
+					ov3640_write_reg(0x855A,0x80);
+					ov3640_write_reg(0x855B,0x03);
+					ov3640_write_reg(0x855C,0xE4);
+					ov3640_write_reg(0x855D,0xF5);
+					ov3640_write_reg(0x855E,0x72);
+					ov3640_write_reg(0x855F,0x90);
+					ov3640_write_reg(0x8560,0x3F);
+					ov3640_write_reg(0x8561,0x04);
+					ov3640_write_reg(0x8562,0xE5);
+					ov3640_write_reg(0x8563,0x72);
+					ov3640_write_reg(0x8564,0xF0);
+					ov3640_write_reg(0x8565,0x22);
+					ov3640_write_reg(0x8566,0xD2);
+					ov3640_write_reg(0x8567,0x0A);
+					ov3640_write_reg(0x8568,0x90);
+					ov3640_write_reg(0x8569,0x3F);
+					ov3640_write_reg(0x856A,0x01);
+					ov3640_write_reg(0x856B,0xE0);
+					ov3640_write_reg(0x856C,0x90);
+					ov3640_write_reg(0x856D,0x3F);
+					ov3640_write_reg(0x856E,0x05);
+					ov3640_write_reg(0x856F,0xF0);
+					ov3640_write_reg(0x8570,0x22);
+					ov3640_write_reg(0x8571,0x90);
+					ov3640_write_reg(0x8572,0x3F);
+					ov3640_write_reg(0x8573,0x06);
+					ov3640_write_reg(0x8574,0xE0);
+					ov3640_write_reg(0x8575,0xF5);
+					ov3640_write_reg(0x8576,0x46);
+					ov3640_write_reg(0x8577,0xE4);
+					ov3640_write_reg(0x8578,0xF0);
+					ov3640_write_reg(0x8579,0xE5);
+					ov3640_write_reg(0x857A,0x46);
+					ov3640_write_reg(0x857B,0xD3);
+					ov3640_write_reg(0x857C,0x94);
+					ov3640_write_reg(0x857D,0x06);
+					ov3640_write_reg(0x857E,0x40);
+					ov3640_write_reg(0x857F,0x03);
+					ov3640_write_reg(0x8580,0x75);
+					ov3640_write_reg(0x8581,0x46);
+					ov3640_write_reg(0x8582,0x06);
+					ov3640_write_reg(0x8583,0xD2);
+					ov3640_write_reg(0x8584,0x0E);
+					ov3640_write_reg(0x8585,0x22);
+					ov3640_write_reg(0x8586,0x75);
+					ov3640_write_reg(0x8587,0x4B);
+					ov3640_write_reg(0x8588,0x02);
+					ov3640_write_reg(0x8589,0x75);
+					ov3640_write_reg(0x858A,0x4C);
+					ov3640_write_reg(0x858B,0x58);
+					ov3640_write_reg(0x858C,0x80);
+					ov3640_write_reg(0x858D,0x06);
+					ov3640_write_reg(0x858E,0x85);
+					ov3640_write_reg(0x858F,0x3D);
+					ov3640_write_reg(0x8590,0x4B);
+					ov3640_write_reg(0x8591,0x85);
+					ov3640_write_reg(0x8592,0x3E);
+					ov3640_write_reg(0x8593,0x4C);
+					ov3640_write_reg(0x8594,0xAF);
+					ov3640_write_reg(0x8595,0x4C);
+					ov3640_write_reg(0x8596,0xAE);
+					ov3640_write_reg(0x8597,0x4B);
+					ov3640_write_reg(0x8598,0x12);
+					ov3640_write_reg(0x8599,0x0B);
+					ov3640_write_reg(0x859A,0x7A);
+					ov3640_write_reg(0x859B,0x22);
+					ov3640_write_reg(0x859C,0xE5);
+					ov3640_write_reg(0x859D,0x46);
+					ov3640_write_reg(0x859E,0x24);
+					ov3640_write_reg(0x859F,0x09);
+					ov3640_write_reg(0x85A0,0xFF);
+					ov3640_write_reg(0x85A1,0xE4);
+					ov3640_write_reg(0x85A2,0x33);
+					ov3640_write_reg(0x85A3,0xFE);
+					ov3640_write_reg(0x85A4,0x12);
+					ov3640_write_reg(0x85A5,0x0C);
+					ov3640_write_reg(0x85A6,0xC8);
+					ov3640_write_reg(0x85A7,0xEE);
+					ov3640_write_reg(0x85A8,0xC4);
+					ov3640_write_reg(0x85A9,0xF8);
+					ov3640_write_reg(0x85AA,0x54);
+					ov3640_write_reg(0x85AB,0xF0);
+					ov3640_write_reg(0x85AC,0xC8);
+					ov3640_write_reg(0x85AD,0x22);
+					ov3640_write_reg(0x85AE,0xE5);
+					ov3640_write_reg(0x85AF,0x4C);
+					ov3640_write_reg(0x85B0,0x25);
+					ov3640_write_reg(0x85B1,0x3E);
+					ov3640_write_reg(0x85B2,0xCF);
+					ov3640_write_reg(0x85B3,0xE5);
+					ov3640_write_reg(0x85B4,0x4B);
+					ov3640_write_reg(0x85B5,0x35);
+					ov3640_write_reg(0x85B6,0x3D);
+					ov3640_write_reg(0x85B7,0xCF);
+					ov3640_write_reg(0x85B8,0x24);
+					ov3640_write_reg(0x85B9,0x28);
+					ov3640_write_reg(0x85BA,0xCF);
+					ov3640_write_reg(0x85BB,0x34);
+					ov3640_write_reg(0x85BC,0x00);
+					ov3640_write_reg(0x85BD,0xFE);
+					ov3640_write_reg(0x85BE,0xC3);
+					ov3640_write_reg(0x85BF,0xEF);
+					ov3640_write_reg(0x85C0,0x94);
+					ov3640_write_reg(0x85C1,0x58);
+					ov3640_write_reg(0x85C2,0xEE);
+					ov3640_write_reg(0x85C3,0x94);
+					ov3640_write_reg(0x85C4,0x02);
+					ov3640_write_reg(0x85C5,0x22);
+					ov3640_write_reg(0x85C6,0xC2);
+					ov3640_write_reg(0x85C7,0x00);
+					ov3640_write_reg(0x85C8,0x90);
+					ov3640_write_reg(0x85C9,0x30);
+					ov3640_write_reg(0x85CA,0xB4);
+					ov3640_write_reg(0x85CB,0xE5);
+					ov3640_write_reg(0x85CC,0x20);
+					ov3640_write_reg(0x85CD,0xF0);
+					ov3640_write_reg(0x85CE,0x22);
+					ov3640_write_reg(0x85CF,0x90);
+					ov3640_write_reg(0x85D0,0x3A);
+					ov3640_write_reg(0x85D1,0x00);
+					ov3640_write_reg(0x85D2,0xF0);
+					ov3640_write_reg(0x85D3,0x90);
+					ov3640_write_reg(0x85D4,0x3A);
+					ov3640_write_reg(0x85D5,0x03);
+					ov3640_write_reg(0x85D6,0xE0);
+					ov3640_write_reg(0x85D7,0x22);
+					ov3640_write_reg(0x85D8,0xD3);
+					ov3640_write_reg(0x85D9,0xE5);
+					ov3640_write_reg(0x85DA,0x28);
+					ov3640_write_reg(0x85DB,0x95);
+					ov3640_write_reg(0x85DC,0x50);
+					ov3640_write_reg(0x85DD,0xE5);
+					ov3640_write_reg(0x85DE,0x27);
+					ov3640_write_reg(0x85DF,0x95);
+					ov3640_write_reg(0x85E0,0x4F);
+					ov3640_write_reg(0x85E1,0x22);
+					ov3640_write_reg(0x85E2,0x85);
+					ov3640_write_reg(0x85E3,0x45);
+					ov3640_write_reg(0x85E4,0x61);
+					ov3640_write_reg(0x85E5,0x90);
+					ov3640_write_reg(0x85E6,0x3F);
+					ov3640_write_reg(0x85E7,0x07);
+					ov3640_write_reg(0x85E8,0xE5);
+					ov3640_write_reg(0x85E9,0x61);
+					ov3640_write_reg(0x85EA,0xF0);
+					ov3640_write_reg(0x85EB,0x22);
+					ov3640_write_reg(0x85EC,0xC3);
+					ov3640_write_reg(0x85ED,0x74);
+					ov3640_write_reg(0x85EE,0x07);
+					ov3640_write_reg(0x85EF,0x95);
+					ov3640_write_reg(0x85F0,0x46);
+					ov3640_write_reg(0x85F1,0xFF);
+					ov3640_write_reg(0x85F2,0xE4);
+					ov3640_write_reg(0x85F3,0x94);
+					ov3640_write_reg(0x85F4,0x00);
+					ov3640_write_reg(0x85F5,0x22);
+					ov3640_write_reg(0x85F6,0x85);
+					ov3640_write_reg(0x85F7,0x32);
+					ov3640_write_reg(0x85F8,0x38);
+					ov3640_write_reg(0x85F9,0x85);
+					ov3640_write_reg(0x85FA,0x33);
+					ov3640_write_reg(0x85FB,0x39);
+					ov3640_write_reg(0x85FC,0x85);
+					ov3640_write_reg(0x85FD,0x30);
+					ov3640_write_reg(0x85FE,0x3A);
+					ov3640_write_reg(0x85FF,0x85);
+					ov3640_write_reg(0x8600,0x31);
+					ov3640_write_reg(0x8601,0x3B);
+					ov3640_write_reg(0x8602,0x22);
+					ov3640_write_reg(0x8603,0x85);
+					ov3640_write_reg(0x8604,0x36);
+					ov3640_write_reg(0x8605,0x38);
+					ov3640_write_reg(0x8606,0x85);
+					ov3640_write_reg(0x8607,0x37);
+					ov3640_write_reg(0x8608,0x39);
+					ov3640_write_reg(0x8609,0x85);
+					ov3640_write_reg(0x860A,0x34);
+					ov3640_write_reg(0x860B,0x3A);
+					ov3640_write_reg(0x860C,0x85);
+					ov3640_write_reg(0x860D,0x35);
+					ov3640_write_reg(0x860E,0x3B);
+					ov3640_write_reg(0x860F,0x22);
+					ov3640_write_reg(0x8610,0xD3);
+					ov3640_write_reg(0x8611,0xEF);
+					ov3640_write_reg(0x8612,0x9D);
+					ov3640_write_reg(0x8613,0xEC);
+					ov3640_write_reg(0x8614,0x64);
+					ov3640_write_reg(0x8615,0x80);
+					ov3640_write_reg(0x8616,0xF8);
+					ov3640_write_reg(0x8617,0xEE);
+					ov3640_write_reg(0x8618,0x64);
+					ov3640_write_reg(0x8619,0x80);
+					ov3640_write_reg(0x861A,0x98);
+					ov3640_write_reg(0x861B,0x22);
+					ov3640_write_reg(0x861C,0x13);
+					ov3640_write_reg(0x861D,0xFF);
+					ov3640_write_reg(0x861E,0xD3);
+					ov3640_write_reg(0x861F,0xE5);
+					ov3640_write_reg(0x8620,0x28);
+					ov3640_write_reg(0x8621,0x9F);
+					ov3640_write_reg(0x8622,0xE5);
+					ov3640_write_reg(0x8623,0x27);
+					ov3640_write_reg(0x8624,0x9E);
+					ov3640_write_reg(0x8625,0x22);
+					ov3640_write_reg(0x8626,0xD3);
+					ov3640_write_reg(0x8627,0xE5);
+					ov3640_write_reg(0x8628,0x39);
+					ov3640_write_reg(0x8629,0x95);
+					ov3640_write_reg(0x862A,0x3B);
+					ov3640_write_reg(0x862B,0xE5);
+					ov3640_write_reg(0x862C,0x38);
+					ov3640_write_reg(0x862D,0x95);
+					ov3640_write_reg(0x862E,0x3A);
+					ov3640_write_reg(0x862F,0x22);
+					ov3640_write_reg(0x8630,0x74);
+					ov3640_write_reg(0x8631,0xFF);
+					ov3640_write_reg(0x8632,0xF0);
+					ov3640_write_reg(0x8633,0xA3);
+					ov3640_write_reg(0x8634,0x74);
+					ov3640_write_reg(0x8635,0x80);
+					ov3640_write_reg(0x8636,0xF0);
+					ov3640_write_reg(0x8637,0xA3);
+					ov3640_write_reg(0x8638,0xF0);
+					ov3640_write_reg(0x8639,0xA3);
+					ov3640_write_reg(0x863A,0x74);
+					ov3640_write_reg(0x863B,0x01);
+					ov3640_write_reg(0x863C,0xF0);
+					ov3640_write_reg(0x863D,0x22);
+					ov3640_write_reg(0x863E,0xFB);
+					ov3640_write_reg(0x863F,0xEF);
+					ov3640_write_reg(0x8640,0x75);
+					ov3640_write_reg(0x8641,0xF0);
+					ov3640_write_reg(0x8642,0x08);
+					ov3640_write_reg(0x8643,0xA4);
+					ov3640_write_reg(0x8644,0xFE);
+					ov3640_write_reg(0x8645,0x22);
+					ov3640_write_reg(0x8646,0x54);
+					ov3640_write_reg(0x8647,0x07);
+					ov3640_write_reg(0x8648,0xC4);
+					ov3640_write_reg(0x8649,0xF8);
+					ov3640_write_reg(0x864A,0x54);
+					ov3640_write_reg(0x864B,0xF0);
+					ov3640_write_reg(0x864C,0xC8);
+					ov3640_write_reg(0x864D,0xE4);
+					ov3640_write_reg(0x864E,0xC4);
+					ov3640_write_reg(0x864F,0x54);
+					ov3640_write_reg(0x8650,0x0F);
+					ov3640_write_reg(0x8651,0x48);
+					ov3640_write_reg(0x8652,0x22);
+					ov3640_write_reg(0x8653,0xE4);
+					ov3640_write_reg(0x8654,0xF5);
+					ov3640_write_reg(0x8655,0x4F);
+					ov3640_write_reg(0x8656,0xF5);
+					ov3640_write_reg(0x8657,0x50);
+					ov3640_write_reg(0x8658,0xF5);
+					ov3640_write_reg(0x8659,0x43);
+					ov3640_write_reg(0x865A,0xC2);
+					ov3640_write_reg(0x865B,0x09);
+					ov3640_write_reg(0x865C,0xC2);
+					ov3640_write_reg(0x865D,0x0A);
+					ov3640_write_reg(0x865E,0x22);
+					ov3640_write_reg(0x865F,0xE5);
+					ov3640_write_reg(0x8660,0x26);
+					ov3640_write_reg(0x8661,0x25);
+					ov3640_write_reg(0x8662,0xE0);
+					ov3640_write_reg(0x8663,0x24);
+					ov3640_write_reg(0x8664,0x62);
+					ov3640_write_reg(0x8665,0xF8);
+					ov3640_write_reg(0x8666,0xE6);
+					ov3640_write_reg(0x8667,0xFE);
+					ov3640_write_reg(0x8668,0x08);
+					ov3640_write_reg(0x8669,0xE6);
+					ov3640_write_reg(0x866A,0x22);
+					ov3640_write_reg(0x866B,0xFE);
+					ov3640_write_reg(0x866C,0xA3);
+					ov3640_write_reg(0x866D,0xE0);
+					ov3640_write_reg(0x866E,0xFD);
+					ov3640_write_reg(0x866F,0xEE);
+					ov3640_write_reg(0x8670,0xF5);
+					ov3640_write_reg(0x8671,0x08);
+					ov3640_write_reg(0x8672,0xED);
+					ov3640_write_reg(0x8673,0xF5);
+					ov3640_write_reg(0x8674,0x09);
+					ov3640_write_reg(0x8675,0x22);
+					ov3640_write_reg(0x8676,0xD3);
+					ov3640_write_reg(0x8677,0xE5);
+					ov3640_write_reg(0x8678,0x0B);
+					ov3640_write_reg(0x8679,0x94);
+					ov3640_write_reg(0x867A,0x40);
+					ov3640_write_reg(0x867B,0xE5);
+					ov3640_write_reg(0x867C,0x0A);
+					ov3640_write_reg(0x867D,0x94);
+					ov3640_write_reg(0x867E,0x00);
+					ov3640_write_reg(0x867F,0x22);
+					ov3640_write_reg(0x8680,0x90);
+					ov3640_write_reg(0x8681,0x33);
+					ov3640_write_reg(0x8682,0x5F);
+					ov3640_write_reg(0x8683,0xE0);
+					ov3640_write_reg(0x8684,0x54);
+					ov3640_write_reg(0x8685,0x0F);
+					ov3640_write_reg(0x8686,0x12);
+					ov3640_write_reg(0x8687,0x06);
+					ov3640_write_reg(0x8688,0x6B);
+					ov3640_write_reg(0x8689,0x90);
+					ov3640_write_reg(0x868A,0x33);
+					ov3640_write_reg(0x868B,0x5F);
+					ov3640_write_reg(0x868C,0xE0);
+					ov3640_write_reg(0x868D,0x54);
+					ov3640_write_reg(0x868E,0x70);
+					ov3640_write_reg(0x868F,0x75);
+					ov3640_write_reg(0x8690,0xF0);
+					ov3640_write_reg(0x8691,0x10);
+					ov3640_write_reg(0x8692,0xA4);
+					ov3640_write_reg(0x8693,0xFF);
+					ov3640_write_reg(0x8694,0x90);
+					ov3640_write_reg(0x8695,0x33);
+					ov3640_write_reg(0x8696,0x61);
+					ov3640_write_reg(0x8697,0xE0);
+					ov3640_write_reg(0x8698,0xFD);
+					ov3640_write_reg(0x8699,0xE5);
+					ov3640_write_reg(0x869A,0xF0);
+					ov3640_write_reg(0x869B,0xF5);
+					ov3640_write_reg(0x869C,0x0A);
+					ov3640_write_reg(0x869D,0xEF);
+					ov3640_write_reg(0x869E,0x4D);
+					ov3640_write_reg(0x869F,0xF5);
+					ov3640_write_reg(0x86A0,0x0B);
+					ov3640_write_reg(0x86A1,0xE5);
+					ov3640_write_reg(0x86A2,0x4A);
+					ov3640_write_reg(0x86A3,0xB5);
+					ov3640_write_reg(0x86A4,0x09);
+					ov3640_write_reg(0x86A5,0x11);
+					ov3640_write_reg(0x86A6,0xE5);
+					ov3640_write_reg(0x86A7,0x49);
+					ov3640_write_reg(0x86A8,0xB5);
+					ov3640_write_reg(0x86A9,0x08);
+					ov3640_write_reg(0x86AA,0x0C);
+					ov3640_write_reg(0x86AB,0xE5);
+					ov3640_write_reg(0x86AC,0x42);
+					ov3640_write_reg(0x86AD,0x65);
+					ov3640_write_reg(0x86AE,0x0B);
+					ov3640_write_reg(0x86AF,0x70);
+					ov3640_write_reg(0x86B0,0x04);
+					ov3640_write_reg(0x86B1,0xE5);
+					ov3640_write_reg(0x86B2,0x41);
+					ov3640_write_reg(0x86B3,0x65);
+					ov3640_write_reg(0x86B4,0x0A);
+					ov3640_write_reg(0x86B5,0x60);
+					ov3640_write_reg(0x86B6,0x19);
+					ov3640_write_reg(0x86B7,0x85);
+					ov3640_write_reg(0x86B8,0x08);
+					ov3640_write_reg(0x86B9,0x49);
+					ov3640_write_reg(0x86BA,0x85);
+					ov3640_write_reg(0x86BB,0x09);
+					ov3640_write_reg(0x86BC,0x4A);
+					ov3640_write_reg(0x86BD,0x85);
+					ov3640_write_reg(0x86BE,0x0A);
+					ov3640_write_reg(0x86BF,0x41);
+					ov3640_write_reg(0x86C0,0x85);
+					ov3640_write_reg(0x86C1,0x0B);
+					ov3640_write_reg(0x86C2,0x42);
+					ov3640_write_reg(0x86C3,0xE4);
+					ov3640_write_reg(0x86C4,0xFB);
+					ov3640_write_reg(0x86C5,0xAD);
+					ov3640_write_reg(0x86C6,0x0B);
+					ov3640_write_reg(0x86C7,0xAC);
+					ov3640_write_reg(0x86C8,0x0A);
+					ov3640_write_reg(0x86C9,0xAF);
+					ov3640_write_reg(0x86CA,0x09);
+					ov3640_write_reg(0x86CB,0xAE);
+					ov3640_write_reg(0x86CC,0x08);
+					ov3640_write_reg(0x86CD,0x12);
+					ov3640_write_reg(0x86CE,0x08);
+					ov3640_write_reg(0x86CF,0xEF);
+					ov3640_write_reg(0x86D0,0x90);
+					ov3640_write_reg(0x86D1,0x33);
+					ov3640_write_reg(0x86D2,0x02);
+					ov3640_write_reg(0x86D3,0xE0);
+					ov3640_write_reg(0x86D4,0x20);
+					ov3640_write_reg(0x86D5,0xE5);
+					ov3640_write_reg(0x86D6,0x03);
+					ov3640_write_reg(0x86D7,0x12);
+					ov3640_write_reg(0x86D8,0x07);
+					ov3640_write_reg(0x86D9,0x2B);
+					ov3640_write_reg(0x86DA,0x90);
+					ov3640_write_reg(0x86DB,0x33);
+					ov3640_write_reg(0x86DC,0x02);
+					ov3640_write_reg(0x86DD,0xE0);
+					ov3640_write_reg(0x86DE,0x30);
+					ov3640_write_reg(0x86DF,0xE5);
+					ov3640_write_reg(0x86E0,0x2C);
+					ov3640_write_reg(0x86E1,0x90);
+					ov3640_write_reg(0x86E2,0x30);
+					ov3640_write_reg(0x86E3,0x88);
+					ov3640_write_reg(0x86E4,0xE0);
+					ov3640_write_reg(0x86E5,0x12);
+					ov3640_write_reg(0x86E6,0x06);
+					ov3640_write_reg(0x86E7,0x6B);
+					ov3640_write_reg(0x86E8,0xA3);
+					ov3640_write_reg(0x86E9,0xE0);
+					ov3640_write_reg(0x86EA,0xFE);
+					ov3640_write_reg(0x86EB,0xA3);
+					ov3640_write_reg(0x86EC,0xE0);
+					ov3640_write_reg(0x86ED,0xFD);
+					ov3640_write_reg(0x86EE,0xEE);
+					ov3640_write_reg(0x86EF,0xF5);
+					ov3640_write_reg(0x86F0,0x0A);
+					ov3640_write_reg(0x86F1,0xED);
+					ov3640_write_reg(0x86F2,0xF5);
+					ov3640_write_reg(0x86F3,0x0B);
+					ov3640_write_reg(0x86F4,0xE5);
+					ov3640_write_reg(0x86F5,0x48);
+					ov3640_write_reg(0x86F6,0xB5);
+					ov3640_write_reg(0x86F7,0x09);
+					ov3640_write_reg(0x86F8,0x11);
+					ov3640_write_reg(0x86F9,0xE5);
+					ov3640_write_reg(0x86FA,0x47);
+					ov3640_write_reg(0x86FB,0xB5);
+					ov3640_write_reg(0x86FC,0x08);
+					ov3640_write_reg(0x86FD,0x0C);
+					ov3640_write_reg(0x86FE,0xE5);
+					ov3640_write_reg(0x86FF,0x40);
+					ov3640_write_reg(0x8700,0x65);
+					ov3640_write_reg(0x8701,0x0B);
+					ov3640_write_reg(0x8702,0x70);
+					ov3640_write_reg(0x8703,0x04);
+					ov3640_write_reg(0x8704,0xE5);
+					ov3640_write_reg(0x8705,0x3F);
+					ov3640_write_reg(0x8706,0x65);
+					ov3640_write_reg(0x8707,0x0A);
+					ov3640_write_reg(0x8708,0x60);
+					ov3640_write_reg(0x8709,0x03);
+					ov3640_write_reg(0x870A,0x12);
+					ov3640_write_reg(0x870B,0x07);
+					ov3640_write_reg(0x870C,0x2B);
+					ov3640_write_reg(0x870D,0x30);
+					ov3640_write_reg(0x870E,0x0E);
+					ov3640_write_reg(0x870F,0x1A);
+					ov3640_write_reg(0x8710,0xE4);
+					ov3640_write_reg(0x8711,0xFB);
+					ov3640_write_reg(0x8712,0xAD);
+					ov3640_write_reg(0x8713,0x42);
+					ov3640_write_reg(0x8714,0xAC);
+					ov3640_write_reg(0x8715,0x41);
+					ov3640_write_reg(0x8716,0xAF);
+					ov3640_write_reg(0x8717,0x4A);
+					ov3640_write_reg(0x8718,0xAE);
+					ov3640_write_reg(0x8719,0x49);
+					ov3640_write_reg(0x871A,0x12);
+					ov3640_write_reg(0x871B,0x08);
+					ov3640_write_reg(0x871C,0xEF);
+					ov3640_write_reg(0x871D,0xAD);
+					ov3640_write_reg(0x871E,0x40);
+					ov3640_write_reg(0x871F,0xAC);
+					ov3640_write_reg(0x8720,0x3F);
+					ov3640_write_reg(0x8721,0xAF);
+					ov3640_write_reg(0x8722,0x48);
+					ov3640_write_reg(0x8723,0xAE);
+					ov3640_write_reg(0x8724,0x47);
+					ov3640_write_reg(0x8725,0x12);
+					ov3640_write_reg(0x8726,0x09);
+					ov3640_write_reg(0x8727,0x6D);
+					ov3640_write_reg(0x8728,0xC2);
+					ov3640_write_reg(0x8729,0x0E);
+					ov3640_write_reg(0x872A,0x22);
+					ov3640_write_reg(0x872B,0x85);
+					ov3640_write_reg(0x872C,0x08);
+					ov3640_write_reg(0x872D,0x47);
+					ov3640_write_reg(0x872E,0x85);
+					ov3640_write_reg(0x872F,0x09);
+					ov3640_write_reg(0x8730,0x48);
+					ov3640_write_reg(0x8731,0x85);
+					ov3640_write_reg(0x8732,0x0A);
+					ov3640_write_reg(0x8733,0x3F);
+					ov3640_write_reg(0x8734,0x85);
+					ov3640_write_reg(0x8735,0x0B);
+					ov3640_write_reg(0x8736,0x40);
+					ov3640_write_reg(0x8737,0xAD);
+					ov3640_write_reg(0x8738,0x40);
+					ov3640_write_reg(0x8739,0xAC);
+					ov3640_write_reg(0x873A,0x3F);
+					ov3640_write_reg(0x873B,0xAF);
+					ov3640_write_reg(0x873C,0x48);
+					ov3640_write_reg(0x873D,0xAE);
+					ov3640_write_reg(0x873E,0x47);
+					ov3640_write_reg(0x873F,0x12);
+					ov3640_write_reg(0x8740,0x09);
+					ov3640_write_reg(0x8741,0x6D);
+					ov3640_write_reg(0x8742,0x22);
+					ov3640_write_reg(0x8743,0xE5);
+					ov3640_write_reg(0x8744,0x24);
+					ov3640_write_reg(0x8745,0x70);
+					ov3640_write_reg(0x8746,0x0A);
+					ov3640_write_reg(0x8747,0xF5);
+					ov3640_write_reg(0x8748,0x3D);
+					ov3640_write_reg(0x8749,0xF5);
+					ov3640_write_reg(0x874A,0x3E);
+					ov3640_write_reg(0x874B,0x12);
+					ov3640_write_reg(0x874C,0x0C);
+					ov3640_write_reg(0x874D,0xEA);
+					ov3640_write_reg(0x874E,0x05);
+					ov3640_write_reg(0x874F,0x24);
+					ov3640_write_reg(0x8750,0x22);
+					ov3640_write_reg(0x8751,0xE5);
+					ov3640_write_reg(0x8752,0x24);
+					ov3640_write_reg(0x8753,0xC3);
+					ov3640_write_reg(0x8754,0x94);
+					ov3640_write_reg(0x8755,0x01);
+					ov3640_write_reg(0x8756,0x50);
+					ov3640_write_reg(0x8757,0x03);
+					ov3640_write_reg(0x8758,0x05);
+					ov3640_write_reg(0x8759,0x24);
+					ov3640_write_reg(0x875A,0x22);
+					ov3640_write_reg(0x875B,0xE5);
+					ov3640_write_reg(0x875C,0x24);
+					ov3640_write_reg(0x875D,0xB4);
+					ov3640_write_reg(0x875E,0x01);
+					ov3640_write_reg(0x875F,0x1A);
+					ov3640_write_reg(0x8760,0xE4);
+					ov3640_write_reg(0x8761,0xFD);
+					ov3640_write_reg(0x8762,0xFF);
+					ov3640_write_reg(0x8763,0x12);
+					ov3640_write_reg(0x8764,0x0B);
+					ov3640_write_reg(0x8765,0x2C);
+					ov3640_write_reg(0x8766,0x8E);
+					ov3640_write_reg(0x8767,0x22);
+					ov3640_write_reg(0x8768,0x8F);
+					ov3640_write_reg(0x8769,0x23);
+					ov3640_write_reg(0x876A,0x75);
+					ov3640_write_reg(0x876B,0x3D);
+					ov3640_write_reg(0x876C,0x00);
+					ov3640_write_reg(0x876D,0x75);
+					ov3640_write_reg(0x876E,0x3E);
+					ov3640_write_reg(0x876F,0x0A);
+					ov3640_write_reg(0x8770,0xAF);
+					ov3640_write_reg(0x8771,0x3E);
+					ov3640_write_reg(0x8772,0xAE);
+					ov3640_write_reg(0x8773,0x3D);
+					ov3640_write_reg(0x8774,0x12);
+					ov3640_write_reg(0x8775,0x0B);
+					ov3640_write_reg(0x8776,0x7A);
+					ov3640_write_reg(0x8777,0x05);
+					ov3640_write_reg(0x8778,0x24);
+					ov3640_write_reg(0x8779,0x22);
+					ov3640_write_reg(0x877A,0xE4);
+					ov3640_write_reg(0x877B,0xFD);
+					ov3640_write_reg(0x877C,0xFF);
+					ov3640_write_reg(0x877D,0x12);
+					ov3640_write_reg(0x877E,0x0B);
+					ov3640_write_reg(0x877F,0x2C);
+					ov3640_write_reg(0x8780,0xC3);
+					ov3640_write_reg(0x8781,0xEF);
+					ov3640_write_reg(0x8782,0x95);
+					ov3640_write_reg(0x8783,0x23);
+					ov3640_write_reg(0x8784,0xFF);
+					ov3640_write_reg(0x8785,0xEE);
+					ov3640_write_reg(0x8786,0x95);
+					ov3640_write_reg(0x8787,0x22);
+					ov3640_write_reg(0x8788,0xFE);
+					ov3640_write_reg(0x8789,0x12);
+					ov3640_write_reg(0x878A,0x0C);
+					ov3640_write_reg(0x878B,0xF7);
+					ov3640_write_reg(0x878C,0xD3);
+					ov3640_write_reg(0x878D,0xEF);
+					ov3640_write_reg(0x878E,0x94);
+					ov3640_write_reg(0x878F,0x20);
+					ov3640_write_reg(0x8790,0xEE);
+					ov3640_write_reg(0x8791,0x64);
+					ov3640_write_reg(0x8792,0x80);
+					ov3640_write_reg(0x8793,0x94);
+					ov3640_write_reg(0x8794,0x80);
+					ov3640_write_reg(0x8795,0x40);
+					ov3640_write_reg(0x8796,0x15);
+					ov3640_write_reg(0x8797,0xC2);
+					ov3640_write_reg(0x8798,0x0B);
+					ov3640_write_reg(0x8799,0xE4);
+					ov3640_write_reg(0x879A,0xF5);
+					ov3640_write_reg(0x879B,0x24);
+					ov3640_write_reg(0x879C,0x74);
+					ov3640_write_reg(0x879D,0xF6);
+					ov3640_write_reg(0x879E,0x25);
+					ov3640_write_reg(0x879F,0x3E);
+					ov3640_write_reg(0x87A0,0xF5);
+					ov3640_write_reg(0x87A1,0x3E);
+					ov3640_write_reg(0x87A2,0x74);
+					ov3640_write_reg(0x87A3,0xFF);
+					ov3640_write_reg(0x87A4,0x35);
+					ov3640_write_reg(0x87A5,0x3D);
+					ov3640_write_reg(0x87A6,0xF5);
+					ov3640_write_reg(0x87A7,0x3D);
+					ov3640_write_reg(0x87A8,0xE4);
+					ov3640_write_reg(0x87A9,0xFF);
+					ov3640_write_reg(0x87AA,0x80);
+					ov3640_write_reg(0x87AB,0x1F);
+					ov3640_write_reg(0x87AC,0xC3);
+					ov3640_write_reg(0x87AD,0xE5);
+					ov3640_write_reg(0x87AE,0x3E);
+					ov3640_write_reg(0x87AF,0x94);
+					ov3640_write_reg(0x87B0,0x96);
+					ov3640_write_reg(0x87B1,0xE5);
+					ov3640_write_reg(0x87B2,0x3D);
+					ov3640_write_reg(0x87B3,0x94);
+					ov3640_write_reg(0x87B4,0x00);
+					ov3640_write_reg(0x87B5,0x50);
+					ov3640_write_reg(0x87B6,0x18);
+					ov3640_write_reg(0x87B7,0x74);
+					ov3640_write_reg(0x87B8,0x0A);
+					ov3640_write_reg(0x87B9,0x25);
+					ov3640_write_reg(0x87BA,0x3E);
+					ov3640_write_reg(0x87BB,0xF5);
+					ov3640_write_reg(0x87BC,0x3E);
+					ov3640_write_reg(0x87BD,0xE4);
+					ov3640_write_reg(0x87BE,0x35);
+					ov3640_write_reg(0x87BF,0x3D);
+					ov3640_write_reg(0x87C0,0xF5);
+					ov3640_write_reg(0x87C1,0x3D);
+					ov3640_write_reg(0x87C2,0xE5);
+					ov3640_write_reg(0x87C3,0x3E);
+					ov3640_write_reg(0x87C4,0x24);
+					ov3640_write_reg(0x87C5,0xFF);
+					ov3640_write_reg(0x87C6,0xFF);
+					ov3640_write_reg(0x87C7,0xE5);
+					ov3640_write_reg(0x87C8,0x3D);
+					ov3640_write_reg(0x87C9,0x34);
+					ov3640_write_reg(0x87CA,0xFF);
+					ov3640_write_reg(0x87CB,0xFE);
+					ov3640_write_reg(0x87CC,0x02);
+					ov3640_write_reg(0x87CD,0x0B);
+					ov3640_write_reg(0x87CE,0x7A);
+					ov3640_write_reg(0x87CF,0xC2);
+					ov3640_write_reg(0x87D0,0x0B);
+					ov3640_write_reg(0x87D1,0xE4);
+					ov3640_write_reg(0x87D2,0xF5);
+					ov3640_write_reg(0x87D3,0x24);
+					ov3640_write_reg(0x87D4,0xFF);
+					ov3640_write_reg(0x87D5,0xFE);
+					ov3640_write_reg(0x87D6,0x12);
+					ov3640_write_reg(0x87D7,0x0B);
+					ov3640_write_reg(0x87D8,0x7A);
+					ov3640_write_reg(0x87D9,0x75);
+					ov3640_write_reg(0x87DA,0x3D);
+					ov3640_write_reg(0x87DB,0x00);
+					ov3640_write_reg(0x87DC,0x75);
+					ov3640_write_reg(0x87DD,0x3E);
+					ov3640_write_reg(0x87DE,0xC8);
+					ov3640_write_reg(0x87DF,0x22);
+					ov3640_write_reg(0x87E0,0x78);
+					ov3640_write_reg(0x87E1,0x7F);
+					ov3640_write_reg(0x87E2,0xE4);
+					ov3640_write_reg(0x87E3,0xF6);
+					ov3640_write_reg(0x87E4,0xD8);
+					ov3640_write_reg(0x87E5,0xFD);
+					ov3640_write_reg(0x87E6,0x75);
+					ov3640_write_reg(0x87E7,0x81);
+					ov3640_write_reg(0x87E8,0x72);
+					ov3640_write_reg(0x87E9,0x02);
+					ov3640_write_reg(0x87EA,0x08);
+					ov3640_write_reg(0x87EB,0x27);
+					ov3640_write_reg(0x87EC,0x02);
+					ov3640_write_reg(0x87ED,0x0B);
+					ov3640_write_reg(0x87EE,0xEF);
+					ov3640_write_reg(0x87EF,0xE4);
+					ov3640_write_reg(0x87F0,0x93);
+					ov3640_write_reg(0x87F1,0xA3);
+					ov3640_write_reg(0x87F2,0xF8);
+					ov3640_write_reg(0x87F3,0xE4);
+					ov3640_write_reg(0x87F4,0x93);
+					ov3640_write_reg(0x87F5,0xA3);
+					ov3640_write_reg(0x87F6,0x40);
+					ov3640_write_reg(0x87F7,0x03);
+					ov3640_write_reg(0x87F8,0xF6);
+					ov3640_write_reg(0x87F9,0x80);
+					ov3640_write_reg(0x87FA,0x01);
+					ov3640_write_reg(0x87FB,0xF2);
+					ov3640_write_reg(0x87FC,0x08);
+					ov3640_write_reg(0x87FD,0xDF);
+					ov3640_write_reg(0x87FE,0xF4);
+					ov3640_write_reg(0x87FF,0x80);
+					ov3640_write_reg(0x8800,0x29);
+					ov3640_write_reg(0x8801,0xE4);
+					ov3640_write_reg(0x8802,0x93);
+					ov3640_write_reg(0x8803,0xA3);
+					ov3640_write_reg(0x8804,0xF8);
+					ov3640_write_reg(0x8805,0x54);
+					ov3640_write_reg(0x8806,0x07);
+					ov3640_write_reg(0x8807,0x24);
+					ov3640_write_reg(0x8808,0x0C);
+					ov3640_write_reg(0x8809,0xC8);
+					ov3640_write_reg(0x880A,0xC3);
+					ov3640_write_reg(0x880B,0x33);
+					ov3640_write_reg(0x880C,0xC4);
+					ov3640_write_reg(0x880D,0x54);
+					ov3640_write_reg(0x880E,0x0F);
+					ov3640_write_reg(0x880F,0x44);
+					ov3640_write_reg(0x8810,0x20);
+					ov3640_write_reg(0x8811,0xC8);
+					ov3640_write_reg(0x8812,0x83);
+					ov3640_write_reg(0x8813,0x40);
+					ov3640_write_reg(0x8814,0x04);
+					ov3640_write_reg(0x8815,0xF4);
+					ov3640_write_reg(0x8816,0x56);
+					ov3640_write_reg(0x8817,0x80);
+					ov3640_write_reg(0x8818,0x01);
+					ov3640_write_reg(0x8819,0x46);
+					ov3640_write_reg(0x881A,0xF6);
+					ov3640_write_reg(0x881B,0xDF);
+					ov3640_write_reg(0x881C,0xE4);
+					ov3640_write_reg(0x881D,0x80);
+					ov3640_write_reg(0x881E,0x0B);
+					ov3640_write_reg(0x881F,0x01);
+					ov3640_write_reg(0x8820,0x02);
+					ov3640_write_reg(0x8821,0x04);
+					ov3640_write_reg(0x8822,0x08);
+					ov3640_write_reg(0x8823,0x10);
+					ov3640_write_reg(0x8824,0x20);
+					ov3640_write_reg(0x8825,0x40);
+					ov3640_write_reg(0x8826,0x80);
+					ov3640_write_reg(0x8827,0x90);
+					ov3640_write_reg(0x8828,0x0B);
+					ov3640_write_reg(0x8829,0xB9);
+					ov3640_write_reg(0x882A,0xE4);
+					ov3640_write_reg(0x882B,0x7E);
+					ov3640_write_reg(0x882C,0x01);
+					ov3640_write_reg(0x882D,0x93);
+					ov3640_write_reg(0x882E,0x60);
+					ov3640_write_reg(0x882F,0xBC);
+					ov3640_write_reg(0x8830,0xA3);
+					ov3640_write_reg(0x8831,0xFF);
+					ov3640_write_reg(0x8832,0x54);
+					ov3640_write_reg(0x8833,0x3F);
+					ov3640_write_reg(0x8834,0x30);
+					ov3640_write_reg(0x8835,0xE5);
+					ov3640_write_reg(0x8836,0x09);
+					ov3640_write_reg(0x8837,0x54);
+					ov3640_write_reg(0x8838,0x1F);
+					ov3640_write_reg(0x8839,0xFE);
+					ov3640_write_reg(0x883A,0xE4);
+					ov3640_write_reg(0x883B,0x93);
+					ov3640_write_reg(0x883C,0xA3);
+					ov3640_write_reg(0x883D,0x60);
+					ov3640_write_reg(0x883E,0x01);
+					ov3640_write_reg(0x883F,0x0E);
+					ov3640_write_reg(0x8840,0xCF);
+					ov3640_write_reg(0x8841,0x54);
+					ov3640_write_reg(0x8842,0xC0);
+					ov3640_write_reg(0x8843,0x25);
+					ov3640_write_reg(0x8844,0xE0);
+					ov3640_write_reg(0x8845,0x60);
+					ov3640_write_reg(0x8846,0xA8);
+					ov3640_write_reg(0x8847,0x40);
+					ov3640_write_reg(0x8848,0xB8);
+					ov3640_write_reg(0x8849,0xE4);
+					ov3640_write_reg(0x884A,0x93);
+					ov3640_write_reg(0x884B,0xA3);
+					ov3640_write_reg(0x884C,0xFA);
+					ov3640_write_reg(0x884D,0xE4);
+					ov3640_write_reg(0x884E,0x93);
+					ov3640_write_reg(0x884F,0xA3);
+					ov3640_write_reg(0x8850,0xF8);
+					ov3640_write_reg(0x8851,0xE4);
+					ov3640_write_reg(0x8852,0x93);
+					ov3640_write_reg(0x8853,0xA3);
+					ov3640_write_reg(0x8854,0xC8);
+					ov3640_write_reg(0x8855,0xC5);
+					ov3640_write_reg(0x8856,0x82);
+					ov3640_write_reg(0x8857,0xC8);
+					ov3640_write_reg(0x8858,0xCA);
+					ov3640_write_reg(0x8859,0xC5);
+					ov3640_write_reg(0x885A,0x83);
+					ov3640_write_reg(0x885B,0xCA);
+					ov3640_write_reg(0x885C,0xF0);
+					ov3640_write_reg(0x885D,0xA3);
+					ov3640_write_reg(0x885E,0xC8);
+					ov3640_write_reg(0x885F,0xC5);
+					ov3640_write_reg(0x8860,0x82);
+					ov3640_write_reg(0x8861,0xC8);
+					ov3640_write_reg(0x8862,0xCA);
+					ov3640_write_reg(0x8863,0xC5);
+					ov3640_write_reg(0x8864,0x83);
+					ov3640_write_reg(0x8865,0xCA);
+					ov3640_write_reg(0x8866,0xDF);
+					ov3640_write_reg(0x8867,0xE9);
+					ov3640_write_reg(0x8868,0xDE);
+					ov3640_write_reg(0x8869,0xE7);
+					ov3640_write_reg(0x886A,0x80);
+					ov3640_write_reg(0x886B,0xBE);
+					ov3640_write_reg(0x886C,0xC2);
+					ov3640_write_reg(0x886D,0x8C);
+					ov3640_write_reg(0x886E,0x75);
+					ov3640_write_reg(0x886F,0x89);
+					ov3640_write_reg(0x8870,0x03);
+					ov3640_write_reg(0x8871,0x90);
+					ov3640_write_reg(0x8872,0x31);
+					ov3640_write_reg(0x8873,0x00);
+					ov3640_write_reg(0x8874,0xE0);
+					ov3640_write_reg(0x8875,0x54);
+					ov3640_write_reg(0x8876,0xFE);
+					ov3640_write_reg(0x8877,0xF0);
+					ov3640_write_reg(0x8878,0xE0);
+					ov3640_write_reg(0x8879,0x54);
+					ov3640_write_reg(0x887A,0xFD);
+					ov3640_write_reg(0x887B,0xF0);
+					ov3640_write_reg(0x887C,0xA3);
+					ov3640_write_reg(0x887D,0xE4);
+					ov3640_write_reg(0x887E,0xF0);
+					ov3640_write_reg(0x887F,0x90);
+					ov3640_write_reg(0x8880,0x33);
+					ov3640_write_reg(0x8881,0xB0);
+					ov3640_write_reg(0x8882,0xF0);
+					ov3640_write_reg(0x8883,0xA3);
+					ov3640_write_reg(0x8884,0x04);
+					ov3640_write_reg(0x8885,0xF0);
+					ov3640_write_reg(0x8886,0xA3);
+					ov3640_write_reg(0x8887,0xF0);
+					ov3640_write_reg(0x8888,0xA3);
+					ov3640_write_reg(0x8889,0x12);
+					ov3640_write_reg(0x888A,0x06);
+					ov3640_write_reg(0x888B,0x30);
+					ov3640_write_reg(0x888C,0x90);
+					ov3640_write_reg(0x888D,0x33);
+					ov3640_write_reg(0x888E,0x00);
+					ov3640_write_reg(0x888F,0x74);
+					ov3640_write_reg(0x8890,0x13);
+					ov3640_write_reg(0x8891,0xF0);
+					ov3640_write_reg(0x8892,0x90);
+					ov3640_write_reg(0x8893,0x30);
+					ov3640_write_reg(0x8894,0xB2);
+					ov3640_write_reg(0x8895,0xE0);
+					ov3640_write_reg(0x8896,0x44);
+					ov3640_write_reg(0x8897,0x18);
+					ov3640_write_reg(0x8898,0xF0);
+					ov3640_write_reg(0x8899,0x90);
+					ov3640_write_reg(0x889A,0x30);
+					ov3640_write_reg(0x889B,0xB0);
+					ov3640_write_reg(0x889C,0xE0);
+					ov3640_write_reg(0x889D,0x44);
+					ov3640_write_reg(0x889E,0x03);
+					ov3640_write_reg(0x889F,0xF0);
+					ov3640_write_reg(0x88A0,0xA3);
+					ov3640_write_reg(0x88A1,0xE0);
+					ov3640_write_reg(0x88A2,0x44);
+					ov3640_write_reg(0x88A3,0xC0);
+					ov3640_write_reg(0x88A4,0xF0);
+					ov3640_write_reg(0x88A5,0x90);
+					ov3640_write_reg(0x88A6,0x30);
+					ov3640_write_reg(0x88A7,0xB4);
+					ov3640_write_reg(0x88A8,0xE0);
+					ov3640_write_reg(0x88A9,0x44);
+					ov3640_write_reg(0x88AA,0x0F);
+					ov3640_write_reg(0x88AB,0xF0);
+					ov3640_write_reg(0x88AC,0xE0);
+					ov3640_write_reg(0x88AD,0x54);
+					ov3640_write_reg(0x88AE,0xF7);
+					ov3640_write_reg(0x88AF,0xF0);
+					ov3640_write_reg(0x88B0,0xE0);
+					ov3640_write_reg(0x88B1,0xF5);
+					ov3640_write_reg(0x88B2,0x20);
+					ov3640_write_reg(0x88B3,0x90);
+					ov3640_write_reg(0x88B4,0x39);
+					ov3640_write_reg(0x88B5,0x01);
+					ov3640_write_reg(0x88B6,0x74);
+					ov3640_write_reg(0x88B7,0x35);
+					ov3640_write_reg(0x88B8,0xF0);
+					ov3640_write_reg(0x88B9,0x90);
+					ov3640_write_reg(0x88BA,0x39);
+					ov3640_write_reg(0x88BB,0x00);
+					ov3640_write_reg(0x88BC,0x74);
+					ov3640_write_reg(0x88BD,0x20);
+					ov3640_write_reg(0x88BE,0xF0);
+					ov3640_write_reg(0x88BF,0x90);
+					ov3640_write_reg(0x88C0,0x30);
+					ov3640_write_reg(0x88C1,0x0E);
+					ov3640_write_reg(0x88C2,0x74);
+					ov3640_write_reg(0x88C3,0x36);
+					ov3640_write_reg(0x88C4,0xF0);
+					ov3640_write_reg(0x88C5,0x90);
+					ov3640_write_reg(0x88C6,0x30);
+					ov3640_write_reg(0x88C7,0x11);
+					ov3640_write_reg(0x88C8,0xE4);
+					ov3640_write_reg(0x88C9,0xF0);
+					ov3640_write_reg(0x88CA,0x90);
+					ov3640_write_reg(0x88CB,0x30);
+					ov3640_write_reg(0x88CC,0x14);
+					ov3640_write_reg(0x88CD,0x74);
+					ov3640_write_reg(0x88CE,0x04);
+					ov3640_write_reg(0x88CF,0xF0);
+					ov3640_write_reg(0x88D0,0x90);
+					ov3640_write_reg(0x88D1,0x30);
+					ov3640_write_reg(0x88D2,0x2D);
+					ov3640_write_reg(0x88D3,0xE4);
+					ov3640_write_reg(0x88D4,0xF0);
+					ov3640_write_reg(0x88D5,0xA3);
+					ov3640_write_reg(0x88D6,0xF0);
+					ov3640_write_reg(0x88D7,0x90);
+					ov3640_write_reg(0x88D8,0x37);
+					ov3640_write_reg(0x88D9,0x00);
+					ov3640_write_reg(0x88DA,0xE0);
+					ov3640_write_reg(0x88DB,0x54);
+					ov3640_write_reg(0x88DC,0xF7);
+					ov3640_write_reg(0x88DD,0xF0);
+					ov3640_write_reg(0x88DE,0xE0);
+					ov3640_write_reg(0x88DF,0x54);
+					ov3640_write_reg(0x88E0,0xBF);
+					ov3640_write_reg(0x88E1,0xF0);
+					ov3640_write_reg(0x88E2,0x90);
+					ov3640_write_reg(0x88E3,0x35);
+					ov3640_write_reg(0x88E4,0x08);
+					ov3640_write_reg(0x88E5,0x74);
+					ov3640_write_reg(0x88E6,0x07);
+					ov3640_write_reg(0x88E7,0xF0);
+					ov3640_write_reg(0x88E8,0x75);
+					ov3640_write_reg(0x88E9,0xB8);
+					ov3640_write_reg(0x88EA,0x01);
+					ov3640_write_reg(0x88EB,0x75);
+					ov3640_write_reg(0x88EC,0xA8);
+					ov3640_write_reg(0x88ED,0x81);
+					ov3640_write_reg(0x88EE,0x22);
+					ov3640_write_reg(0x88EF,0x8E);
+					ov3640_write_reg(0x88F0,0x0C);
+					ov3640_write_reg(0x88F1,0x8F);
+					ov3640_write_reg(0x88F2,0x0D);
+					ov3640_write_reg(0x88F3,0x8C);
+					ov3640_write_reg(0x88F4,0x0E);
+					ov3640_write_reg(0x88F5,0x8D);
+					ov3640_write_reg(0x88F6,0x0F);
+					ov3640_write_reg(0x88F7,0xEB);
+					ov3640_write_reg(0x88F8,0xD3);
+					ov3640_write_reg(0x88F9,0x94);
+					ov3640_write_reg(0x88FA,0x03);
+					ov3640_write_reg(0x88FB,0x40);
+					ov3640_write_reg(0x88FC,0x02);
+					ov3640_write_reg(0x88FD,0xE4);
+					ov3640_write_reg(0x88FE,0xFB);
+					ov3640_write_reg(0x88FF,0xE5);
+					ov3640_write_reg(0x8900,0x0F);
+					ov3640_write_reg(0x8901,0xAE);
+					ov3640_write_reg(0x8902,0x0E);
+					ov3640_write_reg(0x8903,0x78);
+					ov3640_write_reg(0x8904,0x03);
+					ov3640_write_reg(0x8905,0xCE);
+					ov3640_write_reg(0x8906,0xC3);
+					ov3640_write_reg(0x8907,0x13);
+					ov3640_write_reg(0x8908,0xCE);
+					ov3640_write_reg(0x8909,0x13);
+					ov3640_write_reg(0x890A,0xD8);
+					ov3640_write_reg(0x890B,0xF9);
+					ov3640_write_reg(0x890C,0xFB);
+					ov3640_write_reg(0x890D,0xAA);
+					ov3640_write_reg(0x890E,0x06);
+					ov3640_write_reg(0x890F,0x12);
+					ov3640_write_reg(0x8910,0x05);
+					ov3640_write_reg(0x8911,0xEC);
+					ov3640_write_reg(0x8912,0xFE);
+					ov3640_write_reg(0x8913,0xAD);
+					ov3640_write_reg(0x8914,0x03);
+					ov3640_write_reg(0x8915,0xAC);
+					ov3640_write_reg(0x8916,0x02);
+					ov3640_write_reg(0x8917,0x12);
+					ov3640_write_reg(0x8918,0x05);
+					ov3640_write_reg(0x8919,0xA4);
+					ov3640_write_reg(0x891A,0xEF);
+					ov3640_write_reg(0x891B,0xC4);
+					ov3640_write_reg(0x891C,0x54);
+					ov3640_write_reg(0x891D,0x0F);
+					ov3640_write_reg(0x891E,0x48);
+					ov3640_write_reg(0x891F,0xF9);
+					ov3640_write_reg(0x8920,0x12);
+					ov3640_write_reg(0x8921,0x05);
+					ov3640_write_reg(0x8922,0x9C);
+					ov3640_write_reg(0x8923,0xEF);
+					ov3640_write_reg(0x8924,0xC4);
+					ov3640_write_reg(0x8925,0x54);
+					ov3640_write_reg(0x8926,0x0F);
+					ov3640_write_reg(0x8927,0x48);
+					ov3640_write_reg(0x8928,0xFB);
+					ov3640_write_reg(0x8929,0xE5);
+					ov3640_write_reg(0x892A,0x0D);
+					ov3640_write_reg(0x892B,0xAE);
+					ov3640_write_reg(0x892C,0x0C);
+					ov3640_write_reg(0x892D,0x78);
+					ov3640_write_reg(0x892E,0x05);
+					ov3640_write_reg(0x892F,0xCE);
+					ov3640_write_reg(0x8930,0xC3);
+					ov3640_write_reg(0x8931,0x13);
+					ov3640_write_reg(0x8932,0xCE);
+					ov3640_write_reg(0x8933,0x13);
+					ov3640_write_reg(0x8934,0xD8);
+					ov3640_write_reg(0x8935,0xF9);
+					ov3640_write_reg(0x8936,0xFD);
+					ov3640_write_reg(0x8937,0xAC);
+					ov3640_write_reg(0x8938,0x06);
+					ov3640_write_reg(0x8939,0x12);
+					ov3640_write_reg(0x893A,0x05);
+					ov3640_write_reg(0x893B,0xEC);
+					ov3640_write_reg(0x893C,0x12);
+					ov3640_write_reg(0x893D,0x05);
+					ov3640_write_reg(0x893E,0xA3);
+					ov3640_write_reg(0x893F,0xEF);
+					ov3640_write_reg(0x8940,0xC4);
+					ov3640_write_reg(0x8941,0x54);
+					ov3640_write_reg(0x8942,0x0F);
+					ov3640_write_reg(0x8943,0x48);
+					ov3640_write_reg(0x8944,0xFA);
+					ov3640_write_reg(0x8945,0xE5);
+					ov3640_write_reg(0x8946,0x0D);
+					ov3640_write_reg(0x8947,0xAE);
+					ov3640_write_reg(0x8948,0x0C);
+					ov3640_write_reg(0x8949,0x78);
+					ov3640_write_reg(0x894A,0x05);
+					ov3640_write_reg(0x894B,0xCE);
+					ov3640_write_reg(0x894C,0xC3);
+					ov3640_write_reg(0x894D,0x13);
+					ov3640_write_reg(0x894E,0xCE);
+					ov3640_write_reg(0x894F,0x13);
+					ov3640_write_reg(0x8950,0xD8);
+					ov3640_write_reg(0x8951,0xF9);
+					ov3640_write_reg(0x8952,0xFD);
+					ov3640_write_reg(0x8953,0xAC);
+					ov3640_write_reg(0x8954,0x06);
+					ov3640_write_reg(0x8955,0x12);
+					ov3640_write_reg(0x8956,0x05);
+					ov3640_write_reg(0x8957,0x9C);
+					ov3640_write_reg(0x8958,0xEF);
+					ov3640_write_reg(0x8959,0xC4);
+					ov3640_write_reg(0x895A,0x54);
+					ov3640_write_reg(0x895B,0x0F);
+					ov3640_write_reg(0x895C,0x48);
+					ov3640_write_reg(0x895D,0xFF);
+					ov3640_write_reg(0x895E,0x90);
+					ov3640_write_reg(0x895F,0x39);
+					ov3640_write_reg(0x8960,0x0A);
+					ov3640_write_reg(0x8961,0xEA);
+					ov3640_write_reg(0x8962,0xF0);
+					ov3640_write_reg(0x8963,0xA3);
+					ov3640_write_reg(0x8964,0xE9);
+					ov3640_write_reg(0x8965,0xF0);
+					ov3640_write_reg(0x8966,0xA3);
+					ov3640_write_reg(0x8967,0xEF);
+					ov3640_write_reg(0x8968,0xF0);
+					ov3640_write_reg(0x8969,0xA3);
+					ov3640_write_reg(0x896A,0xEB);
+					ov3640_write_reg(0x896B,0xF0);
+					ov3640_write_reg(0x896C,0x22);
+					ov3640_write_reg(0x896D,0xAB);
+					ov3640_write_reg(0x896E,0x05);
+					ov3640_write_reg(0x896F,0xAA);
+					ov3640_write_reg(0x8970,0x04);
+					ov3640_write_reg(0x8971,0x8F);
+					ov3640_write_reg(0x8972,0x82);
+					ov3640_write_reg(0x8973,0x8E);
+					ov3640_write_reg(0x8974,0x83);
+					ov3640_write_reg(0x8975,0x12);
+					ov3640_write_reg(0x8976,0x05);
+					ov3640_write_reg(0x8977,0xEC);
+					ov3640_write_reg(0x8978,0xFE);
+					ov3640_write_reg(0x8979,0xAD);
+					ov3640_write_reg(0x897A,0x82);
+					ov3640_write_reg(0x897B,0xAC);
+					ov3640_write_reg(0x897C,0x83);
+					ov3640_write_reg(0x897D,0x12);
+					ov3640_write_reg(0x897E,0x05);
+					ov3640_write_reg(0x897F,0xA4);
+					ov3640_write_reg(0x8980,0x68);
+					ov3640_write_reg(0x8981,0xF5);
+					ov3640_write_reg(0x8982,0x0C);
+					ov3640_write_reg(0x8983,0xEF);
+					ov3640_write_reg(0x8984,0xC4);
+					ov3640_write_reg(0x8985,0x54);
+					ov3640_write_reg(0x8986,0x0F);
+					ov3640_write_reg(0x8987,0x48);
+					ov3640_write_reg(0x8988,0xF5);
+					ov3640_write_reg(0x8989,0x0D);
+					ov3640_write_reg(0x898A,0x12);
+					ov3640_write_reg(0x898B,0x05);
+					ov3640_write_reg(0x898C,0x9C);
+					ov3640_write_reg(0x898D,0x68);
+					ov3640_write_reg(0x898E,0xF5);
+					ov3640_write_reg(0x898F,0x10);
+					ov3640_write_reg(0x8990,0xEF);
+					ov3640_write_reg(0x8991,0xC4);
+					ov3640_write_reg(0x8992,0x54);
+					ov3640_write_reg(0x8993,0x0F);
+					ov3640_write_reg(0x8994,0x48);
+					ov3640_write_reg(0x8995,0xF5);
+					ov3640_write_reg(0x8996,0x11);
+					ov3640_write_reg(0x8997,0x12);
+					ov3640_write_reg(0x8998,0x05);
+					ov3640_write_reg(0x8999,0xEC);
+					ov3640_write_reg(0x899A,0xFE);
+					ov3640_write_reg(0x899B,0xAD);
+					ov3640_write_reg(0x899C,0x03);
+					ov3640_write_reg(0x899D,0xAC);
+					ov3640_write_reg(0x899E,0x02);
+					ov3640_write_reg(0x899F,0x12);
+					ov3640_write_reg(0x89A0,0x05);
+					ov3640_write_reg(0x89A1,0xA4);
+					ov3640_write_reg(0x89A2,0x68);
+					ov3640_write_reg(0x89A3,0xF5);
+					ov3640_write_reg(0x89A4,0x0E);
+					ov3640_write_reg(0x89A5,0xEF);
+					ov3640_write_reg(0x89A6,0xC4);
+					ov3640_write_reg(0x89A7,0x54);
+					ov3640_write_reg(0x89A8,0x0F);
+					ov3640_write_reg(0x89A9,0x48);
+					ov3640_write_reg(0x89AA,0xF5);
+					ov3640_write_reg(0x89AB,0x0F);
+					ov3640_write_reg(0x89AC,0x12);
+					ov3640_write_reg(0x89AD,0x05);
+					ov3640_write_reg(0x89AE,0x9C);
+					ov3640_write_reg(0x89AF,0x68);
+					ov3640_write_reg(0x89B0,0xFE);
+					ov3640_write_reg(0x89B1,0xEF);
+					ov3640_write_reg(0x89B2,0xC4);
+					ov3640_write_reg(0x89B3,0x54);
+					ov3640_write_reg(0x89B4,0x0F);
+					ov3640_write_reg(0x89B5,0x48);
+					ov3640_write_reg(0x89B6,0xFD);
+					ov3640_write_reg(0x89B7,0xAC);
+					ov3640_write_reg(0x89B8,0x06);
+					ov3640_write_reg(0x89B9,0xE5);
+					ov3640_write_reg(0x89BA,0x0C);
+					ov3640_write_reg(0x89BB,0x54);
+					ov3640_write_reg(0x89BC,0x0F);
+					ov3640_write_reg(0x89BD,0xFB);
+					ov3640_write_reg(0x89BE,0xE5);
+					ov3640_write_reg(0x89BF,0x0E);
+					ov3640_write_reg(0x89C0,0x12);
+					ov3640_write_reg(0x89C1,0x06);
+					ov3640_write_reg(0x89C2,0x46);
+					ov3640_write_reg(0x89C3,0x4B);
+					ov3640_write_reg(0x89C4,0xFB);
+					ov3640_write_reg(0x89C5,0xE5);
+					ov3640_write_reg(0x89C6,0x10);
+					ov3640_write_reg(0x89C7,0x54);
+					ov3640_write_reg(0x89C8,0x0F);
+					ov3640_write_reg(0x89C9,0xFA);
+					ov3640_write_reg(0x89CA,0xEC);
+					ov3640_write_reg(0x89CB,0x12);
+					ov3640_write_reg(0x89CC,0x06);
+					ov3640_write_reg(0x89CD,0x46);
+					ov3640_write_reg(0x89CE,0x4A);
+					ov3640_write_reg(0x89CF,0xFF);
+					ov3640_write_reg(0x89D0,0x90);
+					ov3640_write_reg(0x89D1,0x33);
+					ov3640_write_reg(0x89D2,0xAA);
+					ov3640_write_reg(0x89D3,0xEB);
+					ov3640_write_reg(0x89D4,0xF0);
+					ov3640_write_reg(0x89D5,0xE5);
+					ov3640_write_reg(0x89D6,0x0D);
+					ov3640_write_reg(0x89D7,0xA3);
+					ov3640_write_reg(0x89D8,0xF0);
+					ov3640_write_reg(0x89D9,0xE5);
+					ov3640_write_reg(0x89DA,0x0F);
+					ov3640_write_reg(0x89DB,0xA3);
+					ov3640_write_reg(0x89DC,0xF0);
+					ov3640_write_reg(0x89DD,0xA3);
+					ov3640_write_reg(0x89DE,0xEF);
+					ov3640_write_reg(0x89DF,0xF0);
+					ov3640_write_reg(0x89E0,0xE5);
+					ov3640_write_reg(0x89E1,0x11);
+					ov3640_write_reg(0x89E2,0xA3);
+					ov3640_write_reg(0x89E3,0xF0);
+					ov3640_write_reg(0x89E4,0xAF);
+					ov3640_write_reg(0x89E5,0x05);
+					ov3640_write_reg(0x89E6,0xEF);
+					ov3640_write_reg(0x89E7,0xA3);
+					ov3640_write_reg(0x89E8,0xF0);
+					ov3640_write_reg(0x89E9,0x22);
+					ov3640_write_reg(0x89EA,0x90);
+					ov3640_write_reg(0x89EB,0x3F);
+					ov3640_write_reg(0x89EC,0x05);
+					ov3640_write_reg(0x89ED,0xE0);
+					ov3640_write_reg(0x89EE,0x54);
+					ov3640_write_reg(0x89EF,0xE0);
+					ov3640_write_reg(0x89F0,0xF5);
+					ov3640_write_reg(0x89F1,0x08);
+					ov3640_write_reg(0x89F2,0xE0);
+					ov3640_write_reg(0x89F3,0x54);
+					ov3640_write_reg(0x89F4,0x1F);
+					ov3640_write_reg(0x89F5,0xF0);
+					ov3640_write_reg(0x89F6,0xE5);
+					ov3640_write_reg(0x89F7,0x08);
+					ov3640_write_reg(0x89F8,0xB4);
+					ov3640_write_reg(0x89F9,0x80);
+					ov3640_write_reg(0x89FA,0x1D);
+					ov3640_write_reg(0x89FB,0xC3);
+					ov3640_write_reg(0x89FC,0xE5);
+					ov3640_write_reg(0x89FD,0x4C);
+					ov3640_write_reg(0x89FE,0x94);
+					ov3640_write_reg(0x89FF,0xFF);
+					ov3640_write_reg(0x8A00,0xE5);
+					ov3640_write_reg(0x8A01,0x4B);
+					ov3640_write_reg(0x8A02,0x94);
+					ov3640_write_reg(0x8A03,0x03);
+					ov3640_write_reg(0x8A04,0x40);
+					ov3640_write_reg(0x8A05,0x08);
+					ov3640_write_reg(0x8A06,0x75);
+					ov3640_write_reg(0x8A07,0x4B);
+					ov3640_write_reg(0x8A08,0x03);
+					ov3640_write_reg(0x8A09,0x75);
+					ov3640_write_reg(0x8A0A,0x4C);
+					ov3640_write_reg(0x8A0B,0xFF);
+					ov3640_write_reg(0x8A0C,0x80);
+					ov3640_write_reg(0x8A0D,0x4F);
+					ov3640_write_reg(0x8A0E,0x05);
+					ov3640_write_reg(0x8A0F,0x4C);
+					ov3640_write_reg(0x8A10,0xE5);
+					ov3640_write_reg(0x8A11,0x4C);
+					ov3640_write_reg(0x8A12,0x70);
+					ov3640_write_reg(0x8A13,0x02);
+					ov3640_write_reg(0x8A14,0x05);
+					ov3640_write_reg(0x8A15,0x4B);
+					ov3640_write_reg(0x8A16,0x80);
+					ov3640_write_reg(0x8A17,0x45);
+					ov3640_write_reg(0x8A18,0xE5);
+					ov3640_write_reg(0x8A19,0x08);
+					ov3640_write_reg(0x8A1A,0xB4);
+					ov3640_write_reg(0x8A1B,0x40);
+					ov3640_write_reg(0x8A1C,0x16);
+					ov3640_write_reg(0x8A1D,0xE5);
+					ov3640_write_reg(0x8A1E,0x4C);
+					ov3640_write_reg(0x8A1F,0x45);
+					ov3640_write_reg(0x8A20,0x4B);
+					ov3640_write_reg(0x8A21,0x70);
+					ov3640_write_reg(0x8A22,0x06);
+					ov3640_write_reg(0x8A23,0xF5);
+					ov3640_write_reg(0x8A24,0x4B);
+					ov3640_write_reg(0x8A25,0xF5);
+					ov3640_write_reg(0x8A26,0x4C);
+					ov3640_write_reg(0x8A27,0x80);
+					ov3640_write_reg(0x8A28,0x08);
+					ov3640_write_reg(0x8A29,0xE5);
+					ov3640_write_reg(0x8A2A,0x4C);
+					ov3640_write_reg(0x8A2B,0x15);
+					ov3640_write_reg(0x8A2C,0x4C);
+					ov3640_write_reg(0x8A2D,0x70);
+					ov3640_write_reg(0x8A2E,0x02);
+					ov3640_write_reg(0x8A2F,0x15);
+					ov3640_write_reg(0x8A30,0x4B);
+					ov3640_write_reg(0x8A31,0x80);
+					ov3640_write_reg(0x8A32,0x2A);
+					ov3640_write_reg(0x8A33,0xE5);
+					ov3640_write_reg(0x8A34,0x08);
+					ov3640_write_reg(0x8A35,0x64);
+					ov3640_write_reg(0x8A36,0x20);
+					ov3640_write_reg(0x8A37,0x70);
+					ov3640_write_reg(0x8A38,0x2B);
+					ov3640_write_reg(0x8A39,0x90);
+					ov3640_write_reg(0x8A3A,0x3F);
+					ov3640_write_reg(0x8A3B,0x05);
+					ov3640_write_reg(0x8A3C,0xE0);
+					ov3640_write_reg(0x8A3D,0x54);
+					ov3640_write_reg(0x8A3E,0x03);
+					ov3640_write_reg(0x8A3F,0xFE);
+					ov3640_write_reg(0x8A40,0xA3);
+					ov3640_write_reg(0x8A41,0xE0);
+					ov3640_write_reg(0x8A42,0x7C);
+					ov3640_write_reg(0x8A43,0x00);
+					ov3640_write_reg(0x8A44,0x24);
+					ov3640_write_reg(0x8A45,0x00);
+					ov3640_write_reg(0x8A46,0xF5);
+					ov3640_write_reg(0x8A47,0x4C);
+					ov3640_write_reg(0x8A48,0xEC);
+					ov3640_write_reg(0x8A49,0x3E);
+					ov3640_write_reg(0x8A4A,0xF5);
+					ov3640_write_reg(0x8A4B,0x4B);
+					ov3640_write_reg(0x8A4C,0xD3);
+					ov3640_write_reg(0x8A4D,0xE5);
+					ov3640_write_reg(0x8A4E,0x4C);
+					ov3640_write_reg(0x8A4F,0x94);
+					ov3640_write_reg(0x8A50,0xFF);
+					ov3640_write_reg(0x8A51,0xE5);
+					ov3640_write_reg(0x8A52,0x4B);
+					ov3640_write_reg(0x8A53,0x94);
+					ov3640_write_reg(0x8A54,0x03);
+					ov3640_write_reg(0x8A55,0x40);
+					ov3640_write_reg(0x8A56,0x06);
+					ov3640_write_reg(0x8A57,0x75);
+					ov3640_write_reg(0x8A58,0x4B);
+					ov3640_write_reg(0x8A59,0x03);
+					ov3640_write_reg(0x8A5A,0x75);
+					ov3640_write_reg(0x8A5B,0x4C);
+					ov3640_write_reg(0x8A5C,0xFF);
+					ov3640_write_reg(0x8A5D,0xAF);
+					ov3640_write_reg(0x8A5E,0x4C);
+					ov3640_write_reg(0x8A5F,0xAE);
+					ov3640_write_reg(0x8A60,0x4B);
+					ov3640_write_reg(0x8A61,0x12);
+					ov3640_write_reg(0x8A62,0x0B);
+					ov3640_write_reg(0x8A63,0x7A);
+					ov3640_write_reg(0x8A64,0x22);
+					ov3640_write_reg(0x8A65,0xE5);
+					ov3640_write_reg(0x8A66,0x3C);
+					ov3640_write_reg(0x8A67,0xD3);
+					ov3640_write_reg(0x8A68,0x94);
+					ov3640_write_reg(0x8A69,0x02);
+					ov3640_write_reg(0x8A6A,0x40);
+					ov3640_write_reg(0x8A6B,0x03);
+					ov3640_write_reg(0x8A6C,0x15);
+					ov3640_write_reg(0x8A6D,0x3C);
+					ov3640_write_reg(0x8A6E,0x22);
+					ov3640_write_reg(0x8A6F,0xE5);
+					ov3640_write_reg(0x8A70,0x3C);
+					ov3640_write_reg(0x8A71,0xB4);
+					ov3640_write_reg(0x8A72,0x02);
+					ov3640_write_reg(0x8A73,0x0D);
+					ov3640_write_reg(0x8A74,0xE4);
+					ov3640_write_reg(0x8A75,0xF5);
+					ov3640_write_reg(0x8A76,0x3C);
+					ov3640_write_reg(0x8A77,0xFD);
+					ov3640_write_reg(0x8A78,0xFF);
+					ov3640_write_reg(0x8A79,0x12);
+					ov3640_write_reg(0x8A7A,0x0B);
+					ov3640_write_reg(0x8A7B,0x2C);
+					ov3640_write_reg(0x8A7C,0x8E);
+					ov3640_write_reg(0x8A7D,0x2B);
+					ov3640_write_reg(0x8A7E,0x8F);
+					ov3640_write_reg(0x8A7F,0x2C);
+					ov3640_write_reg(0x8A80,0x22);
+					ov3640_write_reg(0x8A81,0xE4);
+					ov3640_write_reg(0x8A82,0xFD);
+					ov3640_write_reg(0x8A83,0xFF);
+					ov3640_write_reg(0x8A84,0x12);
+					ov3640_write_reg(0x8A85,0x0B);
+					ov3640_write_reg(0x8A86,0x2C);
+					ov3640_write_reg(0x8A87,0x8E);
+					ov3640_write_reg(0x8A88,0x08);
+					ov3640_write_reg(0x8A89,0x8F);
+					ov3640_write_reg(0x8A8A,0x09);
+					ov3640_write_reg(0x8A8B,0xC3);
+					ov3640_write_reg(0x8A8C,0xE5);
+					ov3640_write_reg(0x8A8D,0x09);
+					ov3640_write_reg(0x8A8E,0x95);
+					ov3640_write_reg(0x8A8F,0x2C);
+					ov3640_write_reg(0x8A90,0xFF);
+					ov3640_write_reg(0x8A91,0xE5);
+					ov3640_write_reg(0x8A92,0x08);
+					ov3640_write_reg(0x8A93,0x95);
+					ov3640_write_reg(0x8A94,0x2B);
+					ov3640_write_reg(0x8A95,0xFE);
+					ov3640_write_reg(0x8A96,0x12);
+					ov3640_write_reg(0x8A97,0x0C);
+					ov3640_write_reg(0x8A98,0xF7);
+					ov3640_write_reg(0x8A99,0x8E);
+					ov3640_write_reg(0x8A9A,0x0A);
+					ov3640_write_reg(0x8A9B,0x8F);
+					ov3640_write_reg(0x8A9C,0x0B);
+					ov3640_write_reg(0x8A9D,0xE5);
+					ov3640_write_reg(0x8A9E,0x29);
+					ov3640_write_reg(0x8A9F,0xD3);
+					ov3640_write_reg(0x8AA0,0x94);
+					ov3640_write_reg(0x8AA1,0x02);
+					ov3640_write_reg(0x8AA2,0x40);
+					ov3640_write_reg(0x8AA3,0x28);
+					ov3640_write_reg(0x8AA4,0x12);
+					ov3640_write_reg(0x8AA5,0x06);
+					ov3640_write_reg(0x8AA6,0x76);
+					ov3640_write_reg(0x8AA7,0x50);
+					ov3640_write_reg(0x8AA8,0x05);
+					ov3640_write_reg(0x8AA9,0x12);
+					ov3640_write_reg(0x8AAA,0x0C);
+					ov3640_write_reg(0x8AAB,0xB6);
+					ov3640_write_reg(0x8AAC,0x50);
+					ov3640_write_reg(0x8AAD,0x0A);
+					ov3640_write_reg(0x8AAE,0x85);
+					ov3640_write_reg(0x8AAF,0x08);
+					ov3640_write_reg(0x8AB0,0x2B);
+					ov3640_write_reg(0x8AB1,0x85);
+					ov3640_write_reg(0x8AB2,0x09);
+					ov3640_write_reg(0x8AB3,0x2C);
+					ov3640_write_reg(0x8AB4,0xE4);
+					ov3640_write_reg(0x8AB5,0xF5);
+					ov3640_write_reg(0x8AB6,0x2A);
+					ov3640_write_reg(0x8AB7,0x22);
+					ov3640_write_reg(0x8AB8,0x05);
+					ov3640_write_reg(0x8AB9,0x2A);
+					ov3640_write_reg(0x8ABA,0xE5);
+					ov3640_write_reg(0x8ABB,0x2A);
+					ov3640_write_reg(0x8ABC,0xD3);
+					ov3640_write_reg(0x8ABD,0x94);
+					ov3640_write_reg(0x8ABE,0x02);
+					ov3640_write_reg(0x8ABF,0x40);
+					ov3640_write_reg(0x8AC0,0x1B);
+					ov3640_write_reg(0x8AC1,0xE4);
+					ov3640_write_reg(0x8AC2,0xF5);
+					ov3640_write_reg(0x8AC3,0x29);
+					ov3640_write_reg(0x8AC4,0xF5);
+					ov3640_write_reg(0x8AC5,0x2A);
+					ov3640_write_reg(0x8AC6,0x75);
+					ov3640_write_reg(0x8AC7,0x3C);
+					ov3640_write_reg(0x8AC8,0x01);
+					ov3640_write_reg(0x8AC9,0x02);
+					ov3640_write_reg(0x8ACA,0x02);
+					ov3640_write_reg(0x8ACB,0x7B);
+					ov3640_write_reg(0x8ACC,0x12);
+					ov3640_write_reg(0x8ACD,0x06);
+					ov3640_write_reg(0x8ACE,0x76);
+					ov3640_write_reg(0x8ACF,0x50);
+					ov3640_write_reg(0x8AD0,0x05);
+					ov3640_write_reg(0x8AD1,0x12);
+					ov3640_write_reg(0x8AD2,0x0C);
+					ov3640_write_reg(0x8AD3,0xB6);
+					ov3640_write_reg(0x8AD4,0x50);
+					ov3640_write_reg(0x8AD5,0x03);
+					ov3640_write_reg(0x8AD6,0x05);
+					ov3640_write_reg(0x8AD7,0x29);
+					ov3640_write_reg(0x8AD8,0x22);
+					ov3640_write_reg(0x8AD9,0xE4);
+					ov3640_write_reg(0x8ADA,0xF5);
+					ov3640_write_reg(0x8ADB,0x29);
+					ov3640_write_reg(0x8ADC,0x22);
+					ov3640_write_reg(0x8ADD,0x7D);
+					ov3640_write_reg(0x8ADE,0x08);
+					ov3640_write_reg(0x8ADF,0xEF);
+					ov3640_write_reg(0x8AE0,0x33);
+					ov3640_write_reg(0x8AE1,0x92);
+					ov3640_write_reg(0x8AE2,0x01);
+					ov3640_write_reg(0x8AE3,0x12);
+					ov3640_write_reg(0x8AE4,0x05);
+					ov3640_write_reg(0x8AE5,0xC8);
+					ov3640_write_reg(0x8AE6,0xEF);
+					ov3640_write_reg(0x8AE7,0x25);
+					ov3640_write_reg(0x8AE8,0xE0);
+					ov3640_write_reg(0x8AE9,0xFF);
+					ov3640_write_reg(0x8AEA,0xD2);
+					ov3640_write_reg(0x8AEB,0x00);
+					ov3640_write_reg(0x8AEC,0xE5);
+					ov3640_write_reg(0x8AED,0x20);
+					ov3640_write_reg(0x8AEE,0xF0);
+					ov3640_write_reg(0x8AEF,0x7E);
+					ov3640_write_reg(0x8AF0,0x01);
+					ov3640_write_reg(0x8AF1,0xAC);
+					ov3640_write_reg(0x8AF2,0x06);
+					ov3640_write_reg(0x8AF3,0x1E);
+					ov3640_write_reg(0x8AF4,0xEC);
+					ov3640_write_reg(0x8AF5,0x70);
+					ov3640_write_reg(0x8AF6,0xFA);
+					ov3640_write_reg(0x8AF7,0x12);
+					ov3640_write_reg(0x8AF8,0x05);
+					ov3640_write_reg(0x8AF9,0xC6);
+					ov3640_write_reg(0x8AFA,0xDD);
+					ov3640_write_reg(0x8AFB,0xE3);
+					ov3640_write_reg(0x8AFC,0x90);
+					ov3640_write_reg(0x8AFD,0x30);
+					ov3640_write_reg(0x8AFE,0xB1);
+					ov3640_write_reg(0x8AFF,0xE0);
+					ov3640_write_reg(0x8B00,0x54);
+					ov3640_write_reg(0x8B01,0x7F);
+					ov3640_write_reg(0x8B02,0xF0);
+					ov3640_write_reg(0x8B03,0xD2);
+					ov3640_write_reg(0x8B04,0x00);
+					ov3640_write_reg(0x8B05,0x12);
+					ov3640_write_reg(0x8B06,0x05);
+					ov3640_write_reg(0x8B07,0xC8);
+					ov3640_write_reg(0x8B08,0x7E);
+					ov3640_write_reg(0x8B09,0x01);
+					ov3640_write_reg(0x8B0A,0xAF);
+					ov3640_write_reg(0x8B0B,0x06);
+					ov3640_write_reg(0x8B0C,0x1E);
+					ov3640_write_reg(0x8B0D,0xEF);
+					ov3640_write_reg(0x8B0E,0x70);
+					ov3640_write_reg(0x8B0F,0xFA);
+					ov3640_write_reg(0x8B10,0x90);
+					ov3640_write_reg(0x8B11,0x30);
+					ov3640_write_reg(0x8B12,0xB5);
+					ov3640_write_reg(0x8B13,0xE0);
+					ov3640_write_reg(0x8B14,0x54);
+					ov3640_write_reg(0x8B15,0x02);
+					ov3640_write_reg(0x8B16,0xF5);
+					ov3640_write_reg(0x8B17,0x10);
+					ov3640_write_reg(0x8B18,0x12);
+					ov3640_write_reg(0x8B19,0x05);
+					ov3640_write_reg(0x8B1A,0xC6);
+					ov3640_write_reg(0x8B1B,0x90);
+					ov3640_write_reg(0x8B1C,0x30);
+					ov3640_write_reg(0x8B1D,0xB1);
+					ov3640_write_reg(0x8B1E,0xE0);
+					ov3640_write_reg(0x8B1F,0x44);
+					ov3640_write_reg(0x8B20,0x80);
+					ov3640_write_reg(0x8B21,0xF0);
+					ov3640_write_reg(0x8B22,0x7E);
+					ov3640_write_reg(0x8B23,0x01);
+					ov3640_write_reg(0x8B24,0xAF);
+					ov3640_write_reg(0x8B25,0x06);
+					ov3640_write_reg(0x8B26,0x1E);
+					ov3640_write_reg(0x8B27,0xEF);
+					ov3640_write_reg(0x8B28,0x70);
+					ov3640_write_reg(0x8B29,0xFA);
+					ov3640_write_reg(0x8B2A,0xD3);
+					ov3640_write_reg(0x8B2B,0x22);
+					ov3640_write_reg(0x8B2C,0xED);
+					ov3640_write_reg(0x8B2D,0x70);
+					ov3640_write_reg(0x8B2E,0x1E);
+					ov3640_write_reg(0x8B2F,0x12);
+					ov3640_write_reg(0x8B30,0x06);
+					ov3640_write_reg(0x8B31,0x3F);
+					ov3640_write_reg(0x8B32,0x24);
+					ov3640_write_reg(0x8B33,0x80);
+					ov3640_write_reg(0x8B34,0x12);
+					ov3640_write_reg(0x8B35,0x05);
+					ov3640_write_reg(0x8B36,0xCF);
+					ov3640_write_reg(0x8B37,0xF5);
+					ov3640_write_reg(0x8B38,0x0C);
+					ov3640_write_reg(0x8B39,0xEE);
+					ov3640_write_reg(0x8B3A,0x24);
+					ov3640_write_reg(0x8B3B,0x81);
+					ov3640_write_reg(0x8B3C,0x12);
+					ov3640_write_reg(0x8B3D,0x05);
+					ov3640_write_reg(0x8B3E,0xCF);
+					ov3640_write_reg(0x8B3F,0x12);
+					ov3640_write_reg(0x8B40,0x06);
+					ov3640_write_reg(0x8B41,0x3E);
+					ov3640_write_reg(0x8B42,0x24);
+					ov3640_write_reg(0x8B43,0x82);
+					ov3640_write_reg(0x8B44,0x12);
+					ov3640_write_reg(0x8B45,0x05);
+					ov3640_write_reg(0x8B46,0xCF);
+					ov3640_write_reg(0x8B47,0xFC);
+					ov3640_write_reg(0x8B48,0xEE);
+					ov3640_write_reg(0x8B49,0x24);
+					ov3640_write_reg(0x8B4A,0x83);
+					ov3640_write_reg(0x8B4B,0x80);
+					ov3640_write_reg(0x8B4C,0x21);
+					ov3640_write_reg(0x8B4D,0xED);
+					ov3640_write_reg(0x8B4E,0x64);
+					ov3640_write_reg(0x8B4F,0x01);
+					ov3640_write_reg(0x8B50,0x70);
+					ov3640_write_reg(0x8B51,0x1F);
+					ov3640_write_reg(0x8B52,0x12);
+					ov3640_write_reg(0x8B53,0x06);
+					ov3640_write_reg(0x8B54,0x3F);
+					ov3640_write_reg(0x8B55,0x24);
+					ov3640_write_reg(0x8B56,0x84);
+					ov3640_write_reg(0x8B57,0x12);
+					ov3640_write_reg(0x8B58,0x05);
+					ov3640_write_reg(0x8B59,0xCF);
+					ov3640_write_reg(0x8B5A,0xF5);
+					ov3640_write_reg(0x8B5B,0x0C);
+					ov3640_write_reg(0x8B5C,0xEE);
+					ov3640_write_reg(0x8B5D,0x24);
+					ov3640_write_reg(0x8B5E,0x85);
+					ov3640_write_reg(0x8B5F,0x12);
+					ov3640_write_reg(0x8B60,0x05);
+					ov3640_write_reg(0x8B61,0xCF);
+					ov3640_write_reg(0x8B62,0x12);
+					ov3640_write_reg(0x8B63,0x06);
+					ov3640_write_reg(0x8B64,0x3E);
+					ov3640_write_reg(0x8B65,0x24);
+					ov3640_write_reg(0x8B66,0x86);
+					ov3640_write_reg(0x8B67,0x12);
+					ov3640_write_reg(0x8B68,0x05);
+					ov3640_write_reg(0x8B69,0xCF);
+					ov3640_write_reg(0x8B6A,0xFC);
+					ov3640_write_reg(0x8B6B,0xEE);
+					ov3640_write_reg(0x8B6C,0x24);
+					ov3640_write_reg(0x8B6D,0x87);
+					ov3640_write_reg(0x8B6E,0x12);
+					ov3640_write_reg(0x8B6F,0x05);
+					ov3640_write_reg(0x8B70,0xCF);
+					ov3640_write_reg(0x8B71,0xEC);
+					ov3640_write_reg(0x8B72,0xFE);
+					ov3640_write_reg(0x8B73,0xEB);
+					ov3640_write_reg(0x8B74,0xF5);
+					ov3640_write_reg(0x8B75,0x82);
+					ov3640_write_reg(0x8B76,0xE5);
+					ov3640_write_reg(0x8B77,0x82);
+					ov3640_write_reg(0x8B78,0xFF);
+					ov3640_write_reg(0x8B79,0x22);
+					ov3640_write_reg(0x8B7A,0x8E);
+					ov3640_write_reg(0x8B7B,0x0C);
+					ov3640_write_reg(0x8B7C,0x8F);
+					ov3640_write_reg(0x8B7D,0x0D);
+					ov3640_write_reg(0x8B7E,0xE5);
+					ov3640_write_reg(0x8B7F,0x0C);
+					ov3640_write_reg(0x8B80,0x54);
+					ov3640_write_reg(0x8B81,0x03);
+					ov3640_write_reg(0x8B82,0xFC);
+					ov3640_write_reg(0x8B83,0xAD);
+					ov3640_write_reg(0x8B84,0x0D);
+					ov3640_write_reg(0x8B85,0xED);
+					ov3640_write_reg(0x8B86,0xC4);
+					ov3640_write_reg(0x8B87,0xF8);
+					ov3640_write_reg(0x8B88,0x54);
+					ov3640_write_reg(0x8B89,0x0F);
+					ov3640_write_reg(0x8B8A,0xC8);
+					ov3640_write_reg(0x8B8B,0x68);
+					ov3640_write_reg(0x8B8C,0xFF);
+					ov3640_write_reg(0x8B8D,0xEC);
+					ov3640_write_reg(0x8B8E,0xC4);
+					ov3640_write_reg(0x8B8F,0x54);
+					ov3640_write_reg(0x8B90,0xF0);
+					ov3640_write_reg(0x8B91,0x48);
+					ov3640_write_reg(0x8B92,0xAB);
+					ov3640_write_reg(0x8B93,0x07);
+					ov3640_write_reg(0x8B94,0xFA);
+					ov3640_write_reg(0x8B95,0xEC);
+					ov3640_write_reg(0x8B96,0x90);
+					ov3640_write_reg(0x8B97,0x3F);
+					ov3640_write_reg(0x8B98,0x05);
+					ov3640_write_reg(0x8B99,0xF0);
+					ov3640_write_reg(0x8B9A,0xA3);
+					ov3640_write_reg(0x8B9B,0xE5);
+					ov3640_write_reg(0x8B9C,0x0D);
+					ov3640_write_reg(0x8B9D,0xF0);
+					ov3640_write_reg(0x8B9E,0x45);
+					ov3640_write_reg(0x8B9F,0x0C);
+					ov3640_write_reg(0x8BA0,0x70);
+					ov3640_write_reg(0x8BA1,0x03);
+					ov3640_write_reg(0x8BA2,0x7A);
+					ov3640_write_reg(0x8BA3,0x80);
+					ov3640_write_reg(0x8BA4,0xFB);
+					ov3640_write_reg(0x8BA5,0x43);
+					ov3640_write_reg(0x8BA6,0x03);
+					ov3640_write_reg(0x8BA7,0x0F);
+					ov3640_write_reg(0x8BA8,0xAF);
+					ov3640_write_reg(0x8BA9,0x03);
+					ov3640_write_reg(0x8BAA,0xAE);
+					ov3640_write_reg(0x8BAB,0x02);
+					ov3640_write_reg(0x8BAC,0x12);
+					ov3640_write_reg(0x8BAD,0x0C);
+					ov3640_write_reg(0x8BAE,0x22);
+					ov3640_write_reg(0x8BAF,0xE5);
+					ov3640_write_reg(0x8BB0,0x0C);
+					ov3640_write_reg(0x8BB1,0x54);
+					ov3640_write_reg(0x8BB2,0x03);
+					ov3640_write_reg(0x8BB3,0xF5);
+					ov3640_write_reg(0x8BB4,0x5B);
+					ov3640_write_reg(0x8BB5,0x85);
+					ov3640_write_reg(0x8BB6,0x0D);
+					ov3640_write_reg(0x8BB7,0x5C);
+					ov3640_write_reg(0x8BB8,0x22);
+					ov3640_write_reg(0x8BB9,0x02);
+					ov3640_write_reg(0x8BBA,0x3D);
+					ov3640_write_reg(0x8BBB,0x00);
+					ov3640_write_reg(0x8BBC,0x96);
+					ov3640_write_reg(0x8BBD,0x01);
+					ov3640_write_reg(0x8BBE,0x3C);
+					ov3640_write_reg(0x8BBF,0x00);
+					ov3640_write_reg(0x8BC0,0x01);
+					ov3640_write_reg(0x8BC1,0x72);
+					ov3640_write_reg(0x8BC2,0x00);
+					ov3640_write_reg(0x8BC3,0x01);
+					ov3640_write_reg(0x8BC4,0x46);
+					ov3640_write_reg(0x8BC5,0x01);
+					ov3640_write_reg(0x8BC6,0x02);
+					ov3640_write_reg(0x8BC7,0x49);
+					ov3640_write_reg(0x8BC8,0x00);
+					ov3640_write_reg(0x8BC9,0x00);
+					ov3640_write_reg(0x8BCA,0x02);
+					ov3640_write_reg(0x8BCB,0x41);
+					ov3640_write_reg(0x8BCC,0x00);
+					ov3640_write_reg(0x8BCD,0x00);
+					ov3640_write_reg(0x8BCE,0x02);
+					ov3640_write_reg(0x8BCF,0x47);
+					ov3640_write_reg(0x8BD0,0x00);
+					ov3640_write_reg(0x8BD1,0x00);
+					ov3640_write_reg(0x8BD2,0x02);
+					ov3640_write_reg(0x8BD3,0x3F);
+					ov3640_write_reg(0x8BD4,0x00);
+					ov3640_write_reg(0x8BD5,0x00);
+					ov3640_write_reg(0x8BD6,0x01);
+					ov3640_write_reg(0x8BD7,0x43);
+					ov3640_write_reg(0x8BD8,0x00);
+					ov3640_write_reg(0x8BD9,0x01);
+					ov3640_write_reg(0x8BDA,0x61);
+					ov3640_write_reg(0x8BDB,0x00);
+					ov3640_write_reg(0x8BDC,0x01);
+					ov3640_write_reg(0x8BDD,0x45);
+					ov3640_write_reg(0x8BDE,0x00);
+					ov3640_write_reg(0x8BDF,0x02);
+					ov3640_write_reg(0x8BE0,0x4F);
+					ov3640_write_reg(0x8BE1,0x00);
+					ov3640_write_reg(0x8BE2,0x00);
+					ov3640_write_reg(0x8BE3,0xC1);
+					ov3640_write_reg(0x8BE4,0x0D);
+					ov3640_write_reg(0x8BE5,0xC1);
+					ov3640_write_reg(0x8BE6,0x0A);
+					ov3640_write_reg(0x8BE7,0xC1);
+					ov3640_write_reg(0x8BE8,0x09);
+					ov3640_write_reg(0x8BE9,0xC1);
+					ov3640_write_reg(0x8BEA,0x0E);
+					ov3640_write_reg(0x8BEB,0x01);
+					ov3640_write_reg(0x8BEC,0x44);
+					ov3640_write_reg(0x8BED,0x07);
+					ov3640_write_reg(0x8BEE,0x00);
+					ov3640_write_reg(0x8BEF,0x12);
+					ov3640_write_reg(0x8BF0,0x08);
+					ov3640_write_reg(0x8BF1,0x6C);
+					ov3640_write_reg(0x8BF2,0x12);
+					ov3640_write_reg(0x8BF3,0x0C);
+					ov3640_write_reg(0x8BF4,0xEA);
+					ov3640_write_reg(0x8BF5,0x12);
+					ov3640_write_reg(0x8BF6,0x06);
+					ov3640_write_reg(0x8BF7,0x80);
+					ov3640_write_reg(0x8BF8,0x12);
+					ov3640_write_reg(0x8BF9,0x04);
+					ov3640_write_reg(0x8BFA,0x97);
+					ov3640_write_reg(0x8BFB,0x30);
+					ov3640_write_reg(0x8BFC,0x08);
+					ov3640_write_reg(0x8BFD,0xF7);
+					ov3640_write_reg(0x8BFE,0xC2);
+					ov3640_write_reg(0x8BFF,0x08);
+					ov3640_write_reg(0x8C00,0x30);
+					ov3640_write_reg(0x8C01,0x0B);
+					ov3640_write_reg(0x8C02,0x05);
+					ov3640_write_reg(0x8C03,0x12);
+					ov3640_write_reg(0x8C04,0x07);
+					ov3640_write_reg(0x8C05,0x43);
+					ov3640_write_reg(0x8C06,0x80);
+					ov3640_write_reg(0x8C07,0xED);
+					ov3640_write_reg(0x8C08,0xE5);
+					ov3640_write_reg(0x8C09,0x3C);
+					ov3640_write_reg(0x8C0A,0xB4);
+					ov3640_write_reg(0x8C0B,0x01);
+					ov3640_write_reg(0x8C0C,0x05);
+					ov3640_write_reg(0x8C0D,0x12);
+					ov3640_write_reg(0x8C0E,0x02);
+					ov3640_write_reg(0x8C0F,0x7B);
+					ov3640_write_reg(0x8C10,0x80);
+					ov3640_write_reg(0x8C11,0xE3);
+					ov3640_write_reg(0x8C12,0x30);
+					ov3640_write_reg(0x8C13,0x0C);
+					ov3640_write_reg(0x8C14,0x05);
+					ov3640_write_reg(0x8C15,0x12);
+					ov3640_write_reg(0x8C16,0x0A);
+					ov3640_write_reg(0x8C17,0x65);
+					ov3640_write_reg(0x8C18,0x80);
+					ov3640_write_reg(0x8C19,0xDB);
+					ov3640_write_reg(0x8C1A,0x30);
+					ov3640_write_reg(0x8C1B,0x0D);
+					ov3640_write_reg(0x8C1C,0xD8);
+					ov3640_write_reg(0x8C1D,0x12);
+					ov3640_write_reg(0x8C1E,0x09);
+					ov3640_write_reg(0x8C1F,0xEA);
+					ov3640_write_reg(0x8C20,0x80);
+					ov3640_write_reg(0x8C21,0xD3);
+					ov3640_write_reg(0x8C22,0x8E);
+					ov3640_write_reg(0x8C23,0x0E);
+					ov3640_write_reg(0x8C24,0x8F);
+					ov3640_write_reg(0x8C25,0x0F);
+					ov3640_write_reg(0x8C26,0x12);
+					ov3640_write_reg(0x8C27,0x0C);
+					ov3640_write_reg(0x8C28,0x96);
+					ov3640_write_reg(0x8C29,0x7F);
+					ov3640_write_reg(0x8C2A,0x18);
+					ov3640_write_reg(0x8C2B,0x12);
+					ov3640_write_reg(0x8C2C,0x0A);
+					ov3640_write_reg(0x8C2D,0xDD);
+					ov3640_write_reg(0x8C2E,0x40);
+					ov3640_write_reg(0x8C2F,0x02);
+					ov3640_write_reg(0x8C30,0x80);
+					ov3640_write_reg(0x8C31,0x13);
+					ov3640_write_reg(0x8C32,0xE5);
+					ov3640_write_reg(0x8C33,0x0E);
+					ov3640_write_reg(0x8C34,0xFF);
+					ov3640_write_reg(0x8C35,0x12);
+					ov3640_write_reg(0x8C36,0x0A);
+					ov3640_write_reg(0x8C37,0xDD);
+					ov3640_write_reg(0x8C38,0x40);
+					ov3640_write_reg(0x8C39,0x02);
+					ov3640_write_reg(0x8C3A,0x80);
+					ov3640_write_reg(0x8C3B,0x09);
+					ov3640_write_reg(0x8C3C,0xAF);
+					ov3640_write_reg(0x8C3D,0x0F);
+					ov3640_write_reg(0x8C3E,0xE5);
+					ov3640_write_reg(0x8C3F,0x0F);
+					ov3640_write_reg(0x8C40,0x12);
+					ov3640_write_reg(0x8C41,0x0A);
+					ov3640_write_reg(0x8C42,0xDD);
+					ov3640_write_reg(0x8C43,0x40);
+					ov3640_write_reg(0x8C44,0x05);
+					ov3640_write_reg(0x8C45,0x12);
+					ov3640_write_reg(0x8C46,0x0C);
+					ov3640_write_reg(0x8C47,0x4E);
+					ov3640_write_reg(0x8C48,0x80);
+					ov3640_write_reg(0x8C49,0xDC);
+					ov3640_write_reg(0x8C4A,0x12);
+					ov3640_write_reg(0x8C4B,0x0C);
+					ov3640_write_reg(0x8C4C,0x4E);
+					ov3640_write_reg(0x8C4D,0x22);
+					ov3640_write_reg(0x8C4E,0xC2);
+					ov3640_write_reg(0x8C4F,0x01);
+					ov3640_write_reg(0x8C50,0x12);
+					ov3640_write_reg(0x8C51,0x05);
+					ov3640_write_reg(0x8C52,0xC8);
+					ov3640_write_reg(0x8C53,0x7F);
+					ov3640_write_reg(0x8C54,0x01);
+					ov3640_write_reg(0x8C55,0xAE);
+					ov3640_write_reg(0x8C56,0x07);
+					ov3640_write_reg(0x8C57,0x1F);
+					ov3640_write_reg(0x8C58,0xEE);
+					ov3640_write_reg(0x8C59,0x70);
+					ov3640_write_reg(0x8C5A,0xFA);
+					ov3640_write_reg(0x8C5B,0xD2);
+					ov3640_write_reg(0x8C5C,0x00);
+					ov3640_write_reg(0x8C5D,0x12);
+					ov3640_write_reg(0x8C5E,0x05);
+					ov3640_write_reg(0x8C5F,0xC8);
+					ov3640_write_reg(0x8C60,0x7F);
+					ov3640_write_reg(0x8C61,0x01);
+					ov3640_write_reg(0x8C62,0xAE);
+					ov3640_write_reg(0x8C63,0x07);
+					ov3640_write_reg(0x8C64,0x1F);
+					ov3640_write_reg(0x8C65,0xEE);
+					ov3640_write_reg(0x8C66,0x70);
+					ov3640_write_reg(0x8C67,0xFA);
+					ov3640_write_reg(0x8C68,0xD2);
+					ov3640_write_reg(0x8C69,0x01);
+					ov3640_write_reg(0x8C6A,0x12);
+					ov3640_write_reg(0x8C6B,0x05);
+					ov3640_write_reg(0x8C6C,0xC8);
+					ov3640_write_reg(0x8C6D,0x7F);
+					ov3640_write_reg(0x8C6E,0x01);
+					ov3640_write_reg(0x8C6F,0xAE);
+					ov3640_write_reg(0x8C70,0x07);
+					ov3640_write_reg(0x8C71,0x1F);
+					ov3640_write_reg(0x8C72,0xEE);
+					ov3640_write_reg(0x8C73,0x70);
+					ov3640_write_reg(0x8C74,0xFA);
+					ov3640_write_reg(0x8C75,0x22);
+					ov3640_write_reg(0x8C76,0x90);
+					ov3640_write_reg(0x8C77,0x30);
+					ov3640_write_reg(0x8C78,0x14);
+					ov3640_write_reg(0x8C79,0xE0);
+					ov3640_write_reg(0x8C7A,0x30);
+					ov3640_write_reg(0x8C7B,0x0F);
+					ov3640_write_reg(0x8C7C,0x10);
+					ov3640_write_reg(0x8C7D,0x54);
+					ov3640_write_reg(0x8C7E,0xF7);
+					ov3640_write_reg(0x8C7F,0xF0);
+					ov3640_write_reg(0x8C80,0xA3);
+					ov3640_write_reg(0x8C81,0xE0);
+					ov3640_write_reg(0x8C82,0x54);
+					ov3640_write_reg(0x8C83,0xBF);
+					ov3640_write_reg(0x8C84,0xF0);
+					ov3640_write_reg(0x8C85,0x90);
+					ov3640_write_reg(0x8C86,0x30);
+					ov3640_write_reg(0x8C87,0x2D);
+					ov3640_write_reg(0x8C88,0xE4);
+					ov3640_write_reg(0x8C89,0xF0);
+					ov3640_write_reg(0x8C8A,0xA3);
+					ov3640_write_reg(0x8C8B,0xF0);
+					ov3640_write_reg(0x8C8C,0x22);
+					ov3640_write_reg(0x8C8D,0x44);
+					ov3640_write_reg(0x8C8E,0x08);
+					ov3640_write_reg(0x8C8F,0xF0);
+					ov3640_write_reg(0x8C90,0xA3);
+					ov3640_write_reg(0x8C91,0xE0);
+					ov3640_write_reg(0x8C92,0x44);
+					ov3640_write_reg(0x8C93,0x40);
+					ov3640_write_reg(0x8C94,0xF0);
+					ov3640_write_reg(0x8C95,0x22);
+					ov3640_write_reg(0x8C96,0xD2);
+					ov3640_write_reg(0x8C97,0x01);
+					ov3640_write_reg(0x8C98,0xD2);
+					ov3640_write_reg(0x8C99,0x00);
+					ov3640_write_reg(0x8C9A,0x12);
+					ov3640_write_reg(0x8C9B,0x05);
+					ov3640_write_reg(0x8C9C,0xC8);
+					ov3640_write_reg(0x8C9D,0x7F);
+					ov3640_write_reg(0x8C9E,0x02);
+					ov3640_write_reg(0x8C9F,0xAE);
+					ov3640_write_reg(0x8CA0,0x07);
+					ov3640_write_reg(0x8CA1,0x1F);
+					ov3640_write_reg(0x8CA2,0xEE);
+					ov3640_write_reg(0x8CA3,0x70);
+					ov3640_write_reg(0x8CA4,0xFA);
+					ov3640_write_reg(0x8CA5,0xC2);
+					ov3640_write_reg(0x8CA6,0x01);
+					ov3640_write_reg(0x8CA7,0x12);
+					ov3640_write_reg(0x8CA8,0x05);
+					ov3640_write_reg(0x8CA9,0xC8);
+					ov3640_write_reg(0x8CAA,0x7F);
+					ov3640_write_reg(0x8CAB,0x01);
+					ov3640_write_reg(0x8CAC,0xAE);
+					ov3640_write_reg(0x8CAD,0x07);
+					ov3640_write_reg(0x8CAE,0x1F);
+					ov3640_write_reg(0x8CAF,0xEE);
+					ov3640_write_reg(0x8CB0,0x70);
+					ov3640_write_reg(0x8CB1,0xFA);
+					ov3640_write_reg(0x8CB2,0x12);
+					ov3640_write_reg(0x8CB3,0x05);
+					ov3640_write_reg(0x8CB4,0xC6);
+					ov3640_write_reg(0x8CB5,0x22);
+					ov3640_write_reg(0x8CB6,0x90);
+					ov3640_write_reg(0x8CB7,0x30);
+					ov3640_write_reg(0x8CB8,0x1B);
+					ov3640_write_reg(0x8CB9,0xE0);
+					ov3640_write_reg(0x8CBA,0xFF);
+					ov3640_write_reg(0x8CBB,0x65);
+					ov3640_write_reg(0x8CBC,0x2D);
+					ov3640_write_reg(0x8CBD,0x70);
+					ov3640_write_reg(0x8CBE,0x01);
+					ov3640_write_reg(0x8CBF,0xE4);
+					ov3640_write_reg(0x8CC0,0x60);
+					ov3640_write_reg(0x8CC1,0x04);
+					ov3640_write_reg(0x8CC2,0x8F);
+					ov3640_write_reg(0x8CC3,0x2D);
+					ov3640_write_reg(0x8CC4,0xD3);
+					ov3640_write_reg(0x8CC5,0x22);
+					ov3640_write_reg(0x8CC6,0xC3);
+					ov3640_write_reg(0x8CC7,0x22);
+					ov3640_write_reg(0x8CC8,0xEF);
+					ov3640_write_reg(0x8CC9,0x8D);
+					ov3640_write_reg(0x8CCA,0xF0);
+					ov3640_write_reg(0x8CCB,0xA4);
+					ov3640_write_reg(0x8CCC,0xA8);
+					ov3640_write_reg(0x8CCD,0xF0);
+					ov3640_write_reg(0x8CCE,0xCF);
+					ov3640_write_reg(0x8CCF,0x8C);
+					ov3640_write_reg(0x8CD0,0xF0);
+					ov3640_write_reg(0x8CD1,0xA4);
+					ov3640_write_reg(0x8CD2,0x28);
+					ov3640_write_reg(0x8CD3,0xCE);
+					ov3640_write_reg(0x8CD4,0x8D);
+					ov3640_write_reg(0x8CD5,0xF0);
+					ov3640_write_reg(0x8CD6,0xA4);
+					ov3640_write_reg(0x8CD7,0x2E);
+					ov3640_write_reg(0x8CD8,0xFE);
+					ov3640_write_reg(0x8CD9,0x22);
+					ov3640_write_reg(0x8CDA,0xEF);
+					ov3640_write_reg(0x8CDB,0x90);
+					ov3640_write_reg(0x8CDC,0x33);
+					ov3640_write_reg(0x8CDD,0x00);
+					ov3640_write_reg(0x8CDE,0x60);
+					ov3640_write_reg(0x8CDF,0x05);
+					ov3640_write_reg(0x8CE0,0xE0);
+					ov3640_write_reg(0x8CE1,0x44);
+					ov3640_write_reg(0x8CE2,0x40);
+					ov3640_write_reg(0x8CE3,0xF0);
+					ov3640_write_reg(0x8CE4,0x22);
+					ov3640_write_reg(0x8CE5,0xE0);
+					ov3640_write_reg(0x8CE6,0x54);
+					ov3640_write_reg(0x8CE7,0xBF);
+					ov3640_write_reg(0x8CE8,0xF0);
+					ov3640_write_reg(0x8CE9,0x22);
+					ov3640_write_reg(0x8CEA,0x85);
+					ov3640_write_reg(0x8CEB,0x3D);
+					ov3640_write_reg(0x8CEC,0x4B);
+					ov3640_write_reg(0x8CED,0x85);
+					ov3640_write_reg(0x8CEE,0x3E);
+					ov3640_write_reg(0x8CEF,0x4C);
+					ov3640_write_reg(0x8CF0,0xAF);
+					ov3640_write_reg(0x8CF1,0x4C);
+					ov3640_write_reg(0x8CF2,0xAE);
+					ov3640_write_reg(0x8CF3,0x4B);
+					ov3640_write_reg(0x8CF4,0x02);
+					ov3640_write_reg(0x8CF5,0x0B);
+					ov3640_write_reg(0x8CF6,0x7A);
+					ov3640_write_reg(0x8CF7,0xEE);
+					ov3640_write_reg(0x8CF8,0x30);
+					ov3640_write_reg(0x8CF9,0xE7);
+					ov3640_write_reg(0x8CFA,0x07);
+					ov3640_write_reg(0x8CFB,0xC3);
+					ov3640_write_reg(0x8CFC,0xE4);
+					ov3640_write_reg(0x8CFD,0x9F);
+					ov3640_write_reg(0x8CFE,0xFF);
+					ov3640_write_reg(0x8CFF,0xE4);
+					ov3640_write_reg(0x8D00,0x9E);
+					ov3640_write_reg(0x8D01,0xFE);
+					ov3640_write_reg(0x8D02,0x22);
+					ov3640_write_reg(0x3104,0x00);
+					mdelay(100);
+/*
+ * V4L2_SENS_ANTISHAKE_ENABLE
+ */					ov3640_write_reg(0x3f00,0x0A);
+					ov3640_write_reg(0x3f00,0x0F);
+				}break;
+			}
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_14
+ *  Name	:	ov3640_af_firmware_dump
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Auto focus firmware register dump
+ *  Comments	:  	Before performing autofocus related operations -Auto focus firmware dump should be 
+ *  			applied
+ ************************************************************************************************************/
+
+FNRESLT ov3640_af_firmware_dump(cam_data *cam)
+{
+	check_sequence	= DISABLE;
+	ov3640_write_reg(0x308c,0x00);
+	ov3640_write_reg(0x3104,0x02);
+	ov3640_write_reg(0x3105,0xff);
+	ov3640_write_reg(0x3106,0x00);
+	ov3640_write_reg(0x3107,0xff);
+	ov3640_write_reg(0x8000,0x02);
+	ov3640_write_reg(0x8001,0x07);
+	ov3640_write_reg(0x8002,0x74);
+	ov3640_write_reg(0x8003,0x02);
+	ov3640_write_reg(0x8004,0x08);
+	ov3640_write_reg(0x8005,0x00);
+	ov3640_write_reg(0x8006,0x85);
+	ov3640_write_reg(0x8007,0x3C);
+	ov3640_write_reg(0x8008,0x27);
+	ov3640_write_reg(0x8009,0x85);
+	ov3640_write_reg(0x800A,0x3D);
+	ov3640_write_reg(0x800B,0x28);
+	ov3640_write_reg(0x800C,0x85);
+	ov3640_write_reg(0x800D,0x3E);
+	ov3640_write_reg(0x800E,0x2B);
+	ov3640_write_reg(0x800F,0x85);
+	ov3640_write_reg(0x8010,0x3F);
+	ov3640_write_reg(0x8011,0x2C);
+	ov3640_write_reg(0x8012,0xE5);
+	ov3640_write_reg(0x8013,0x24);
+	ov3640_write_reg(0x8014,0x14);
+	ov3640_write_reg(0x8015,0x70);
+	ov3640_write_reg(0x8016,0x03);
+	ov3640_write_reg(0x8017,0x02);
+	ov3640_write_reg(0x8018,0x00);
+	ov3640_write_reg(0x8019,0xA7);
+	ov3640_write_reg(0x801A,0x14);
+	ov3640_write_reg(0x801B,0x70);
+	ov3640_write_reg(0x801C,0x03);
+	ov3640_write_reg(0x801D,0x02);
+	ov3640_write_reg(0x801E,0x01);
+	ov3640_write_reg(0x801F,0x45);
+	ov3640_write_reg(0x8020,0x14);
+	ov3640_write_reg(0x8021,0x70);
+	ov3640_write_reg(0x8022,0x03);
+	ov3640_write_reg(0x8023,0x02);
+	ov3640_write_reg(0x8024,0x01);
+	ov3640_write_reg(0x8025,0xEC);
+	ov3640_write_reg(0x8026,0x24);
+	ov3640_write_reg(0x8027,0x03);
+	ov3640_write_reg(0x8028,0x60);
+	ov3640_write_reg(0x8029,0x03);
+	ov3640_write_reg(0x802A,0x02);
+	ov3640_write_reg(0x802B,0x02);
+	ov3640_write_reg(0x802C,0x42);
+	ov3640_write_reg(0x802D,0xE5);
+	ov3640_write_reg(0x802E,0x48);
+	ov3640_write_reg(0x802F,0x45);
+	ov3640_write_reg(0x8030,0x47);
+	ov3640_write_reg(0x8031,0x70);
+	ov3640_write_reg(0x8032,0x12);
+	ov3640_write_reg(0x8033,0x85);
+	ov3640_write_reg(0x8034,0x27);
+	ov3640_write_reg(0x8035,0x25);
+	ov3640_write_reg(0x8036,0x85);
+	ov3640_write_reg(0x8037,0x28);
+	ov3640_write_reg(0x8038,0x26);
+	ov3640_write_reg(0x8039,0x85);
+	ov3640_write_reg(0x803A,0x2B);
+	ov3640_write_reg(0x803B,0x29);
+	ov3640_write_reg(0x803C,0x85);
+	ov3640_write_reg(0x803D,0x2C);
+	ov3640_write_reg(0x803E,0x2A);
+	ov3640_write_reg(0x803F,0xF5);
+	ov3640_write_reg(0x8040,0x22);
+	ov3640_write_reg(0x8041,0xF5);
+	ov3640_write_reg(0x8042,0x23);
+	ov3640_write_reg(0x8043,0x80);
+	ov3640_write_reg(0x8044,0x1D);
+	ov3640_write_reg(0x8045,0xC3);
+	ov3640_write_reg(0x8046,0xE5);
+	ov3640_write_reg(0x8047,0x2C);
+	ov3640_write_reg(0x8048,0x95);
+	ov3640_write_reg(0x8049,0x2A);
+	ov3640_write_reg(0x804A,0xE5);
+	ov3640_write_reg(0x804B,0x2B);
+	ov3640_write_reg(0x804C,0x95);
+	ov3640_write_reg(0x804D,0x29);
+	ov3640_write_reg(0x804E,0x40);
+	ov3640_write_reg(0x804F,0x12);
+	ov3640_write_reg(0x8050,0x85);
+	ov3640_write_reg(0x8051,0x27);
+	ov3640_write_reg(0x8052,0x25);
+	ov3640_write_reg(0x8053,0x85);
+	ov3640_write_reg(0x8054,0x28);
+	ov3640_write_reg(0x8055,0x26);
+	ov3640_write_reg(0x8056,0x85);
+	ov3640_write_reg(0x8057,0x2B);
+	ov3640_write_reg(0x8058,0x29);
+	ov3640_write_reg(0x8059,0x85);
+	ov3640_write_reg(0x805A,0x2C);
+	ov3640_write_reg(0x805B,0x2A);
+	ov3640_write_reg(0x805C,0x85);
+	ov3640_write_reg(0x805D,0x47);
+	ov3640_write_reg(0x805E,0x22);
+	ov3640_write_reg(0x805F,0x85);
+	ov3640_write_reg(0x8060,0x48);
+	ov3640_write_reg(0x8061,0x23);
+	ov3640_write_reg(0x8062,0xE5);
+	ov3640_write_reg(0x8063,0x48);
+	ov3640_write_reg(0x8064,0x45);
+	ov3640_write_reg(0x8065,0x47);
+	ov3640_write_reg(0x8066,0x70);
+	ov3640_write_reg(0x8067,0x08);
+	ov3640_write_reg(0x8068,0x85);
+	ov3640_write_reg(0x8069,0x35);
+	ov3640_write_reg(0x806A,0x47);
+	ov3640_write_reg(0x806B,0x85);
+	ov3640_write_reg(0x806C,0x36);
+	ov3640_write_reg(0x806D,0x48);
+	ov3640_write_reg(0x806E,0x80);
+	ov3640_write_reg(0x806F,0x1A);
+	ov3640_write_reg(0x8070,0xC3);
+	ov3640_write_reg(0x8071,0xE5);
+	ov3640_write_reg(0x8072,0x48);
+	ov3640_write_reg(0x8073,0x95);
+	ov3640_write_reg(0x8074,0x4A);
+	ov3640_write_reg(0x8075,0xE5);
+	ov3640_write_reg(0x8076,0x47);
+	ov3640_write_reg(0x8077,0x95);
+	ov3640_write_reg(0x8078,0x49);
+	ov3640_write_reg(0x8079,0x50);
+	ov3640_write_reg(0x807A,0x04);
+	ov3640_write_reg(0x807B,0xE5);
+	ov3640_write_reg(0x807C,0x3B);
+	ov3640_write_reg(0x807D,0x80);
+	ov3640_write_reg(0x807E,0x02);
+	ov3640_write_reg(0x807F,0xE5);
+	ov3640_write_reg(0x8080,0x4C);
+	ov3640_write_reg(0x8081,0x25);
+	ov3640_write_reg(0x8082,0x48);
+	ov3640_write_reg(0x8083,0xF5);
+	ov3640_write_reg(0x8084,0x48);
+	ov3640_write_reg(0x8085,0xE4);
+	ov3640_write_reg(0x8086,0x35);
+	ov3640_write_reg(0x8087,0x47);
+	ov3640_write_reg(0x8088,0xF5);
+	ov3640_write_reg(0x8089,0x47);
+	ov3640_write_reg(0x808A,0x85);
+	ov3640_write_reg(0x808B,0x47);
+	ov3640_write_reg(0x808C,0x13);
+	ov3640_write_reg(0x808D,0x85);
+	ov3640_write_reg(0x808E,0x48);
+	ov3640_write_reg(0x808F,0x14);
+	ov3640_write_reg(0x8090,0x12);
+	ov3640_write_reg(0x8091,0x0B);
+	ov3640_write_reg(0x8092,0x86);
+	ov3640_write_reg(0x8093,0xD3);
+	ov3640_write_reg(0x8094,0xE5);
+	ov3640_write_reg(0x8095,0x48);
+	ov3640_write_reg(0x8096,0x95);
+	ov3640_write_reg(0x8097,0x4A);
+	ov3640_write_reg(0x8098,0xE5);
+	ov3640_write_reg(0x8099,0x47);
+	ov3640_write_reg(0x809A,0x95);
+	ov3640_write_reg(0x809B,0x49);
+	ov3640_write_reg(0x809C,0x50);
+	ov3640_write_reg(0x809D,0x03);
+	ov3640_write_reg(0x809E,0x02);
+	ov3640_write_reg(0x809F,0x02);
+	ov3640_write_reg(0x80A0,0x42);
+	ov3640_write_reg(0x80A1,0x75);
+	ov3640_write_reg(0x80A2,0x24);
+	ov3640_write_reg(0x80A3,0x01);
+	ov3640_write_reg(0x80A4,0x02);
+	ov3640_write_reg(0x80A5,0x02);
+	ov3640_write_reg(0x80A6,0x42);
+	ov3640_write_reg(0x80A7,0xC3);
+	ov3640_write_reg(0x80A8,0xE5);
+	ov3640_write_reg(0x80A9,0x2C);
+	ov3640_write_reg(0x80AA,0x95);
+	ov3640_write_reg(0x80AB,0x2A);
+	ov3640_write_reg(0x80AC,0xFF);
+	ov3640_write_reg(0x80AD,0xE5);
+	ov3640_write_reg(0x80AE,0x2B);
+	ov3640_write_reg(0x80AF,0x95);
+	ov3640_write_reg(0x80B0,0x29);
+	ov3640_write_reg(0x80B1,0xFE);
+	ov3640_write_reg(0x80B2,0x12);
+	ov3640_write_reg(0x80B3,0x0D);
+	ov3640_write_reg(0x80B4,0x27);
+	ov3640_write_reg(0x80B5,0xC0);
+	ov3640_write_reg(0x80B6,0x06);
+	ov3640_write_reg(0x80B7,0xC0);
+	ov3640_write_reg(0x80B8,0x07);
+	ov3640_write_reg(0x80B9,0xC3);
+	ov3640_write_reg(0x80BA,0xE5);
+	ov3640_write_reg(0x80BB,0x28);
+	ov3640_write_reg(0x80BC,0x95);
+	ov3640_write_reg(0x80BD,0x26);
+	ov3640_write_reg(0x80BE,0xFF);
+	ov3640_write_reg(0x80BF,0xE5);
+	ov3640_write_reg(0x80C0,0x27);
+	ov3640_write_reg(0x80C1,0x95);
+	ov3640_write_reg(0x80C2,0x25);
+	ov3640_write_reg(0x80C3,0xFE);
+	ov3640_write_reg(0x80C4,0x12);
+	ov3640_write_reg(0x80C5,0x0D);
+	ov3640_write_reg(0x80C6,0x27);
+	ov3640_write_reg(0x80C7,0xD0);
+	ov3640_write_reg(0x80C8,0x05);
+	ov3640_write_reg(0x80C9,0xD0);
+	ov3640_write_reg(0x80CA,0x04);
+	ov3640_write_reg(0x80CB,0xD3);
+	ov3640_write_reg(0x80CC,0xEF);
+	ov3640_write_reg(0x80CD,0x9D);
+	ov3640_write_reg(0x80CE,0xEC);
+	ov3640_write_reg(0x80CF,0x64);
+	ov3640_write_reg(0x80D0,0x80);
+	ov3640_write_reg(0x80D1,0xF8);
+	ov3640_write_reg(0x80D2,0xEE);
+	ov3640_write_reg(0x80D3,0x64);
+	ov3640_write_reg(0x80D4,0x80);
+	ov3640_write_reg(0x80D5,0x98);
+	ov3640_write_reg(0x80D6,0x40);
+	ov3640_write_reg(0x80D7,0x0E);
+	ov3640_write_reg(0x80D8,0x85);
+	ov3640_write_reg(0x80D9,0x27);
+	ov3640_write_reg(0x80DA,0x2D);
+	ov3640_write_reg(0x80DB,0x85);
+	ov3640_write_reg(0x80DC,0x28);
+	ov3640_write_reg(0x80DD,0x2E);
+	ov3640_write_reg(0x80DE,0x85);
+	ov3640_write_reg(0x80DF,0x25);
+	ov3640_write_reg(0x80E0,0x2F);
+	ov3640_write_reg(0x80E1,0x85);
+	ov3640_write_reg(0x80E2,0x26);
+	ov3640_write_reg(0x80E3,0x30);
+	ov3640_write_reg(0x80E4,0x80);
+	ov3640_write_reg(0x80E5,0x0C);
+	ov3640_write_reg(0x80E6,0x85);
+	ov3640_write_reg(0x80E7,0x2B);
+	ov3640_write_reg(0x80E8,0x2D);
+	ov3640_write_reg(0x80E9,0x85);
+	ov3640_write_reg(0x80EA,0x2C);
+	ov3640_write_reg(0x80EB,0x2E);
+	ov3640_write_reg(0x80EC,0x85);
+	ov3640_write_reg(0x80ED,0x29);
+	ov3640_write_reg(0x80EE,0x2F);
+	ov3640_write_reg(0x80EF,0x85);
+	ov3640_write_reg(0x80F0,0x2A);
+	ov3640_write_reg(0x80F1,0x30);
+	ov3640_write_reg(0x80F2,0xC3);
+	ov3640_write_reg(0x80F3,0xE5);
+	ov3640_write_reg(0x80F4,0x2E);
+	ov3640_write_reg(0x80F5,0x95);
+	ov3640_write_reg(0x80F6,0x30);
+	ov3640_write_reg(0x80F7,0xE5);
+	ov3640_write_reg(0x80F8,0x2D);
+	ov3640_write_reg(0x80F9,0x95);
+	ov3640_write_reg(0x80FA,0x2F);
+	ov3640_write_reg(0x80FB,0x40);
+	ov3640_write_reg(0x80FC,0x30);
+	ov3640_write_reg(0x80FD,0xAF);
+	ov3640_write_reg(0x80FE,0x4C);
+	ov3640_write_reg(0x80FF,0x7E);
+	ov3640_write_reg(0x8100,0x00);
+	ov3640_write_reg(0x8101,0xE5);
+	ov3640_write_reg(0x8102,0x48);
+	ov3640_write_reg(0x8103,0x2F);
+	ov3640_write_reg(0x8104,0xFD);
+	ov3640_write_reg(0x8105,0xEE);
+	ov3640_write_reg(0x8106,0x35);
+	ov3640_write_reg(0x8107,0x47);
+	ov3640_write_reg(0x8108,0xFC);
+	ov3640_write_reg(0x8109,0xC3);
+	ov3640_write_reg(0x810A,0xED);
+	ov3640_write_reg(0x810B,0x95);
+	ov3640_write_reg(0x810C,0x4E);
+	ov3640_write_reg(0x810D,0xEC);
+	ov3640_write_reg(0x810E,0x95);
+	ov3640_write_reg(0x810F,0x4D);
+	ov3640_write_reg(0x8110,0x50);
+	ov3640_write_reg(0x8111,0x18);
+	ov3640_write_reg(0x8112,0xEF);
+	ov3640_write_reg(0x8113,0x25);
+	ov3640_write_reg(0x8114,0x48);
+	ov3640_write_reg(0x8115,0xF5);
+	ov3640_write_reg(0x8116,0x48);
+	ov3640_write_reg(0x8117,0xEE);
+	ov3640_write_reg(0x8118,0x35);
+	ov3640_write_reg(0x8119,0x47);
+	ov3640_write_reg(0x811A,0xF5);
+	ov3640_write_reg(0x811B,0x47);
+	ov3640_write_reg(0x811C,0xF5);
+	ov3640_write_reg(0x811D,0x13);
+	ov3640_write_reg(0x811E,0x85);
+	ov3640_write_reg(0x811F,0x48);
+	ov3640_write_reg(0x8120,0x14);
+	ov3640_write_reg(0x8121,0x12);
+	ov3640_write_reg(0x8122,0x0B);
+	ov3640_write_reg(0x8123,0x86);
+	ov3640_write_reg(0x8124,0x75);
+	ov3640_write_reg(0x8125,0x24);
+	ov3640_write_reg(0x8126,0x02);
+	ov3640_write_reg(0x8127,0x02);
+	ov3640_write_reg(0x8128,0x01);
+	ov3640_write_reg(0x8129,0xC2);
+	ov3640_write_reg(0x812A,0x02);
+	ov3640_write_reg(0x812B,0x01);
+	ov3640_write_reg(0x812C,0xD0);
+	ov3640_write_reg(0x812D,0x85);
+	ov3640_write_reg(0x812E,0x47);
+	ov3640_write_reg(0x812F,0x0D);
+	ov3640_write_reg(0x8130,0x85);
+	ov3640_write_reg(0x8131,0x48);
+	ov3640_write_reg(0x8132,0x0E);
+	ov3640_write_reg(0x8133,0x85);
+	ov3640_write_reg(0x8134,0x22);
+	ov3640_write_reg(0x8135,0x0F);
+	ov3640_write_reg(0x8136,0x85);
+	ov3640_write_reg(0x8137,0x23);
+	ov3640_write_reg(0x8138,0x10);
+	ov3640_write_reg(0x8139,0x12);
+	ov3640_write_reg(0x813A,0x0B);
+	ov3640_write_reg(0x813B,0x41);
+	ov3640_write_reg(0x813C,0x85);
+	ov3640_write_reg(0x813D,0x22);
+	ov3640_write_reg(0x813E,0x47);
+	ov3640_write_reg(0x813F,0x85);
+	ov3640_write_reg(0x8140,0x23);
+	ov3640_write_reg(0x8141,0x48);
+	ov3640_write_reg(0x8142,0x02);
+	ov3640_write_reg(0x8143,0x01);
+	ov3640_write_reg(0x8144,0xE7);
+	ov3640_write_reg(0x8145,0xC3);
+	ov3640_write_reg(0x8146,0xE5);
+	ov3640_write_reg(0x8147,0x2C);
+	ov3640_write_reg(0x8148,0x95);
+	ov3640_write_reg(0x8149,0x2A);
+	ov3640_write_reg(0x814A,0xFF);
+	ov3640_write_reg(0x814B,0xE5);
+	ov3640_write_reg(0x814C,0x2B);
+	ov3640_write_reg(0x814D,0x95);
+	ov3640_write_reg(0x814E,0x29);
+	ov3640_write_reg(0x814F,0xFE);
+	ov3640_write_reg(0x8150,0x12);
+	ov3640_write_reg(0x8151,0x0D);
+	ov3640_write_reg(0x8152,0x27);
+	ov3640_write_reg(0x8153,0xC0);
+	ov3640_write_reg(0x8154,0x06);
+	ov3640_write_reg(0x8155,0xC0);
+	ov3640_write_reg(0x8156,0x07);
+	ov3640_write_reg(0x8157,0xC3);
+	ov3640_write_reg(0x8158,0xE5);
+	ov3640_write_reg(0x8159,0x28);
+	ov3640_write_reg(0x815A,0x95);
+	ov3640_write_reg(0x815B,0x26);
+	ov3640_write_reg(0x815C,0xFF);
+	ov3640_write_reg(0x815D,0xE5);
+	ov3640_write_reg(0x815E,0x27);
+	ov3640_write_reg(0x815F,0x95);
+	ov3640_write_reg(0x8160,0x25);
+	ov3640_write_reg(0x8161,0xFE);
+	ov3640_write_reg(0x8162,0x12);
+	ov3640_write_reg(0x8163,0x0D);
+	ov3640_write_reg(0x8164,0x27);
+	ov3640_write_reg(0x8165,0xD0);
+	ov3640_write_reg(0x8166,0x05);
+	ov3640_write_reg(0x8167,0xD0);
+	ov3640_write_reg(0x8168,0x04);
+	ov3640_write_reg(0x8169,0xD3);
+	ov3640_write_reg(0x816A,0xEF);
+	ov3640_write_reg(0x816B,0x9D);
+	ov3640_write_reg(0x816C,0xEC);
+	ov3640_write_reg(0x816D,0x64);
+	ov3640_write_reg(0x816E,0x80);
+	ov3640_write_reg(0x816F,0xF8);
+	ov3640_write_reg(0x8170,0xEE);
+	ov3640_write_reg(0x8171,0x64);
+	ov3640_write_reg(0x8172,0x80);
+	ov3640_write_reg(0x8173,0x98);
+	ov3640_write_reg(0x8174,0x40);
+	ov3640_write_reg(0x8175,0x0E);
+	ov3640_write_reg(0x8176,0x85);
+	ov3640_write_reg(0x8177,0x27);
+	ov3640_write_reg(0x8178,0x2D);
+	ov3640_write_reg(0x8179,0x85);
+	ov3640_write_reg(0x817A,0x28);
+	ov3640_write_reg(0x817B,0x2E);
+	ov3640_write_reg(0x817C,0x85);
+	ov3640_write_reg(0x817D,0x25);
+	ov3640_write_reg(0x817E,0x2F);
+	ov3640_write_reg(0x817F,0x85);
+	ov3640_write_reg(0x8180,0x26);
+	ov3640_write_reg(0x8181,0x30);
+	ov3640_write_reg(0x8182,0x80);
+	ov3640_write_reg(0x8183,0x0C);
+	ov3640_write_reg(0x8184,0x85);
+	ov3640_write_reg(0x8185,0x2B);
+	ov3640_write_reg(0x8186,0x2D);
+	ov3640_write_reg(0x8187,0x85);
+	ov3640_write_reg(0x8188,0x2C);
+	ov3640_write_reg(0x8189,0x2E);
+	ov3640_write_reg(0x818A,0x85);
+	ov3640_write_reg(0x818B,0x29);
+	ov3640_write_reg(0x818C,0x2F);
+	ov3640_write_reg(0x818D,0x85);
+	ov3640_write_reg(0x818E,0x2A);
+	ov3640_write_reg(0x818F,0x30);
+	ov3640_write_reg(0x8190,0xC3);
+	ov3640_write_reg(0x8191,0xE5);
+	ov3640_write_reg(0x8192,0x2E);
+	ov3640_write_reg(0x8193,0x95);
+	ov3640_write_reg(0x8194,0x30);
+	ov3640_write_reg(0x8195,0xE5);
+	ov3640_write_reg(0x8196,0x2D);
+	ov3640_write_reg(0x8197,0x95);
+	ov3640_write_reg(0x8198,0x2F);
+	ov3640_write_reg(0x8199,0x40);
+	ov3640_write_reg(0x819A,0x37);
+	ov3640_write_reg(0x819B,0xAF);
+	ov3640_write_reg(0x819C,0x4C);
+	ov3640_write_reg(0x819D,0x7E);
+	ov3640_write_reg(0x819E,0x00);
+	ov3640_write_reg(0x819F,0xE5);
+	ov3640_write_reg(0x81A0,0x48);
+	ov3640_write_reg(0x81A1,0x2F);
+	ov3640_write_reg(0x81A2,0xFD);
+	ov3640_write_reg(0x81A3,0xEE);
+	ov3640_write_reg(0x81A4,0x35);
+	ov3640_write_reg(0x81A5,0x47);
+	ov3640_write_reg(0x81A6,0xFC);
+	ov3640_write_reg(0x81A7,0xC3);
+	ov3640_write_reg(0x81A8,0xED);
+	ov3640_write_reg(0x81A9,0x95);
+	ov3640_write_reg(0x81AA,0x4E);
+	ov3640_write_reg(0x81AB,0xEC);
+	ov3640_write_reg(0x81AC,0x95);
+	ov3640_write_reg(0x81AD,0x4D);
+	ov3640_write_reg(0x81AE,0x50);
+	ov3640_write_reg(0x81AF,0x20);
+	ov3640_write_reg(0x81B0,0xEF);
+	ov3640_write_reg(0x81B1,0x25);
+	ov3640_write_reg(0x81B2,0x48);
+	ov3640_write_reg(0x81B3,0xF5);
+	ov3640_write_reg(0x81B4,0x48);
+	ov3640_write_reg(0x81B5,0xEE);
+	ov3640_write_reg(0x81B6,0x35);
+	ov3640_write_reg(0x81B7,0x47);
+	ov3640_write_reg(0x81B8,0xF5);
+	ov3640_write_reg(0x81B9,0x47);
+	ov3640_write_reg(0x81BA,0xF5);
+	ov3640_write_reg(0x81BB,0x13);
+	ov3640_write_reg(0x81BC,0x85);
+	ov3640_write_reg(0x81BD,0x48);
+	ov3640_write_reg(0x81BE,0x14);
+	ov3640_write_reg(0x81BF,0x12);
+	ov3640_write_reg(0x81C0,0x0B);
+	ov3640_write_reg(0x81C1,0x86);
+	ov3640_write_reg(0x81C2,0x85);
+	ov3640_write_reg(0x81C3,0x27);
+	ov3640_write_reg(0x81C4,0x25);
+	ov3640_write_reg(0x81C5,0x85);
+	ov3640_write_reg(0x81C6,0x28);
+	ov3640_write_reg(0x81C7,0x26);
+	ov3640_write_reg(0x81C8,0x85);
+	ov3640_write_reg(0x81C9,0x2B);
+	ov3640_write_reg(0x81CA,0x29);
+	ov3640_write_reg(0x81CB,0x85);
+	ov3640_write_reg(0x81CC,0x2C);
+	ov3640_write_reg(0x81CD,0x2A);
+	ov3640_write_reg(0x81CE,0x80);
+	ov3640_write_reg(0x81CF,0x72);
+	ov3640_write_reg(0x81D0,0x80);
+	ov3640_write_reg(0x81D1,0x15);
+	ov3640_write_reg(0x81D2,0xC3);
+	ov3640_write_reg(0x81D3,0xE5);
+	ov3640_write_reg(0x81D4,0x48);
+	ov3640_write_reg(0x81D5,0x95);
+	ov3640_write_reg(0x81D6,0x4C);
+	ov3640_write_reg(0x81D7,0xF5);
+	ov3640_write_reg(0x81D8,0x48);
+	ov3640_write_reg(0x81D9,0xE5);
+	ov3640_write_reg(0x81DA,0x47);
+	ov3640_write_reg(0x81DB,0x94);
+	ov3640_write_reg(0x81DC,0x00);
+	ov3640_write_reg(0x81DD,0xF5);
+	ov3640_write_reg(0x81DE,0x47);
+	ov3640_write_reg(0x81DF,0xF5);
+	ov3640_write_reg(0x81E0,0x13);
+	ov3640_write_reg(0x81E1,0x85);
+	ov3640_write_reg(0x81E2,0x48);
+	ov3640_write_reg(0x81E3,0x14);
+	ov3640_write_reg(0x81E4,0x12);
+	ov3640_write_reg(0x81E5,0x0B);
+	ov3640_write_reg(0x81E6,0x86);
+	ov3640_write_reg(0x81E7,0x75);
+	ov3640_write_reg(0x81E8,0x24);
+	ov3640_write_reg(0x81E9,0x03);
+	ov3640_write_reg(0x81EA,0x80);
+	ov3640_write_reg(0x81EB,0x56);
+	ov3640_write_reg(0x81EC,0xE4);
+	ov3640_write_reg(0x81ED,0xF5);
+	ov3640_write_reg(0x81EE,0x24);
+	ov3640_write_reg(0x81EF,0xC3);
+	ov3640_write_reg(0x81F0,0xE5);
+	ov3640_write_reg(0x81F1,0x42);
+	ov3640_write_reg(0x81F2,0x95);
+	ov3640_write_reg(0x81F3,0x30);
+	ov3640_write_reg(0x81F4,0xE5);
+	ov3640_write_reg(0x81F5,0x41);
+	ov3640_write_reg(0x81F6,0x95);
+	ov3640_write_reg(0x81F7,0x2F);
+	ov3640_write_reg(0x81F8,0x50);
+	ov3640_write_reg(0x81F9,0x23);
+	ov3640_write_reg(0x81FA,0xE5);
+	ov3640_write_reg(0x81FB,0x40);
+	ov3640_write_reg(0x81FC,0x54);
+	ov3640_write_reg(0x81FD,0x0C);
+	ov3640_write_reg(0x81FE,0xFF);
+	ov3640_write_reg(0x81FF,0xBF);
+	ov3640_write_reg(0x8200,0x04);
+	ov3640_write_reg(0x8201,0x05);
+	ov3640_write_reg(0x8202,0x75);
+	ov3640_write_reg(0x8203,0x40);
+	ov3640_write_reg(0x8204,0x46);
+	ov3640_write_reg(0x8205,0x80);
+	ov3640_write_reg(0x8206,0x32);
+	ov3640_write_reg(0x8207,0xEF);
+	ov3640_write_reg(0x8208,0x64);
+	ov3640_write_reg(0x8209,0x08);
+	ov3640_write_reg(0x820A,0x70);
+	ov3640_write_reg(0x820B,0x2D);
+	ov3640_write_reg(0x820C,0x75);
+	ov3640_write_reg(0x820D,0x40);
+	ov3640_write_reg(0x820E,0x4A);
+	ov3640_write_reg(0x820F,0x85);
+	ov3640_write_reg(0x8210,0x3C);
+	ov3640_write_reg(0x8211,0x43);
+	ov3640_write_reg(0x8212,0x85);
+	ov3640_write_reg(0x8213,0x3D);
+	ov3640_write_reg(0x8214,0x44);
+	ov3640_write_reg(0x8215,0x85);
+	ov3640_write_reg(0x8216,0x3E);
+	ov3640_write_reg(0x8217,0x45);
+	ov3640_write_reg(0x8218,0x85);
+	ov3640_write_reg(0x8219,0x3F);
+	ov3640_write_reg(0x821A,0x46);
+	ov3640_write_reg(0x821B,0x80);
+	ov3640_write_reg(0x821C,0x1C);
+	ov3640_write_reg(0x821D,0xE5);
+	ov3640_write_reg(0x821E,0x40);
+	ov3640_write_reg(0x821F,0x54);
+	ov3640_write_reg(0x8220,0x0C);
+	ov3640_write_reg(0x8221,0xFF);
+	ov3640_write_reg(0x8222,0xBF);
+	ov3640_write_reg(0x8223,0x04);
+	ov3640_write_reg(0x8224,0x05);
+	ov3640_write_reg(0x8225,0x75);
+	ov3640_write_reg(0x8226,0x40);
+	ov3640_write_reg(0x8227,0xC6);
+	ov3640_write_reg(0x8228,0x80);
+	ov3640_write_reg(0x8229,0x0F);
+	ov3640_write_reg(0x822A,0xBF);
+	ov3640_write_reg(0x822B,0x08);
+	ov3640_write_reg(0x822C,0x0C);
+	ov3640_write_reg(0x822D,0x75);
+	ov3640_write_reg(0x822E,0x40);
+	ov3640_write_reg(0x822F,0xCA);
+	ov3640_write_reg(0x8230,0xE4);
+	ov3640_write_reg(0x8231,0xF5);
+	ov3640_write_reg(0x8232,0x43);
+	ov3640_write_reg(0x8233,0xF5);
+	ov3640_write_reg(0x8234,0x44);
+	ov3640_write_reg(0x8235,0xF5);
+	ov3640_write_reg(0x8236,0x45);
+	ov3640_write_reg(0x8237,0xF5);
+	ov3640_write_reg(0x8238,0x46);
+	ov3640_write_reg(0x8239,0x12);
+	ov3640_write_reg(0x823A,0x0A);
+	ov3640_write_reg(0x823B,0x7D);
+	ov3640_write_reg(0x823C,0x90);
+	ov3640_write_reg(0x823D,0x3F);
+	ov3640_write_reg(0x823E,0x01);
+	ov3640_write_reg(0x823F,0xE5);
+	ov3640_write_reg(0x8240,0x40);
+	ov3640_write_reg(0x8241,0xF0);
+	ov3640_write_reg(0x8242,0xC2);
+	ov3640_write_reg(0x8243,0x09);
+	ov3640_write_reg(0x8244,0x22);
+	ov3640_write_reg(0x8245,0xE5);
+	ov3640_write_reg(0x8246,0x4B);
+	ov3640_write_reg(0x8247,0x70);
+	ov3640_write_reg(0x8248,0x03);
+	ov3640_write_reg(0x8249,0x02);
+	ov3640_write_reg(0x824A,0x03);
+	ov3640_write_reg(0x824B,0x7A);
+	ov3640_write_reg(0x824C,0xC2);
+	ov3640_write_reg(0x824D,0xAF);
+	ov3640_write_reg(0x824E,0x85);
+	ov3640_write_reg(0x824F,0x4B);
+	ov3640_write_reg(0x8250,0x0C);
+	ov3640_write_reg(0x8251,0xE4);
+	ov3640_write_reg(0x8252,0xF5);
+	ov3640_write_reg(0x8253,0x4B);
+	ov3640_write_reg(0x8254,0xD2);
+	ov3640_write_reg(0x8255,0xAF);
+	ov3640_write_reg(0x8256,0xE5);
+	ov3640_write_reg(0x8257,0x0C);
+	ov3640_write_reg(0x8258,0x12);
+	ov3640_write_reg(0x8259,0x0C);
+	ov3640_write_reg(0x825A,0x48);
+	ov3640_write_reg(0x825B,0x02);
+	ov3640_write_reg(0x825C,0x92);
+	ov3640_write_reg(0x825D,0x00);
+	ov3640_write_reg(0x825E,0x02);
+	ov3640_write_reg(0x825F,0xA3);
+	ov3640_write_reg(0x8260,0x01);
+	ov3640_write_reg(0x8261,0x02);
+	ov3640_write_reg(0x8262,0xAE);
+	ov3640_write_reg(0x8263,0x02);
+	ov3640_write_reg(0x8264,0x02);
+	ov3640_write_reg(0x8265,0xB9);
+	ov3640_write_reg(0x8266,0x03);
+	ov3640_write_reg(0x8267,0x02);
+	ov3640_write_reg(0x8268,0xCC);
+	ov3640_write_reg(0x8269,0x04);
+	ov3640_write_reg(0x826A,0x02);
+	ov3640_write_reg(0x826B,0xE3);
+	ov3640_write_reg(0x826C,0x05);
+	ov3640_write_reg(0x826D,0x02);
+	ov3640_write_reg(0x826E,0xF6);
+	ov3640_write_reg(0x826F,0x06);
+	ov3640_write_reg(0x8270,0x03);
+	ov3640_write_reg(0x8271,0x0F);
+	ov3640_write_reg(0x8272,0x07);
+	ov3640_write_reg(0x8273,0x03);
+	ov3640_write_reg(0x8274,0x2C);
+	ov3640_write_reg(0x8275,0x08);
+	ov3640_write_reg(0x8276,0x03);
+	ov3640_write_reg(0x8277,0x4B);
+	ov3640_write_reg(0x8278,0x09);
+	ov3640_write_reg(0x8279,0x03);
+	ov3640_write_reg(0x827A,0x50);
+	ov3640_write_reg(0x827B,0x10);
+	ov3640_write_reg(0x827C,0x03);
+	ov3640_write_reg(0x827D,0x50);
+	ov3640_write_reg(0x827E,0x11);
+	ov3640_write_reg(0x827F,0x03);
+	ov3640_write_reg(0x8280,0x50);
+	ov3640_write_reg(0x8281,0x12);
+	ov3640_write_reg(0x8282,0x03);
+	ov3640_write_reg(0x8283,0x50);
+	ov3640_write_reg(0x8284,0x13);
+	ov3640_write_reg(0x8285,0x03);
+	ov3640_write_reg(0x8286,0x50);
+	ov3640_write_reg(0x8287,0x14);
+	ov3640_write_reg(0x8288,0x03);
+	ov3640_write_reg(0x8289,0x50);
+	ov3640_write_reg(0x828A,0x15);
+	ov3640_write_reg(0x828B,0x03);
+	ov3640_write_reg(0x828C,0x60);
+	ov3640_write_reg(0x828D,0x20);
+	ov3640_write_reg(0x828E,0x00);
+	ov3640_write_reg(0x828F,0x00);
+	ov3640_write_reg(0x8290,0x03);
+	ov3640_write_reg(0x8291,0x74);
+	ov3640_write_reg(0x8292,0xE5);
+	ov3640_write_reg(0x8293,0x4F);
+	ov3640_write_reg(0x8294,0x70);
+	ov3640_write_reg(0x8295,0x03);
+	ov3640_write_reg(0x8296,0x02);
+	ov3640_write_reg(0x8297,0x03);
+	ov3640_write_reg(0x8298,0x74);
+	ov3640_write_reg(0x8299,0xE5);
+	ov3640_write_reg(0x829A,0x40);
+	ov3640_write_reg(0x829B,0x60);
+	ov3640_write_reg(0x829C,0x03);
+	ov3640_write_reg(0x829D,0x02);
+	ov3640_write_reg(0x829E,0x03);
+	ov3640_write_reg(0x829F,0x74);
+	ov3640_write_reg(0x82A0,0x02);
+	ov3640_write_reg(0x82A1,0x03);
+	ov3640_write_reg(0x82A2,0x27);
+	ov3640_write_reg(0x82A3,0xD2);
+	ov3640_write_reg(0x82A4,0x08);
+	ov3640_write_reg(0x82A5,0x75);
+	ov3640_write_reg(0x82A6,0x0E);
+	ov3640_write_reg(0x82A7,0x01);
+	ov3640_write_reg(0x82A8,0x12);
+	ov3640_write_reg(0x82A9,0x0D);
+	ov3640_write_reg(0x82AA,0x13);
+	ov3640_write_reg(0x82AB,0x02);
+	ov3640_write_reg(0x82AC,0x03);
+	ov3640_write_reg(0x82AD,0x74);
+	ov3640_write_reg(0x82AE,0xE4);
+	ov3640_write_reg(0x82AF,0xF5);
+	ov3640_write_reg(0x82B0,0x0E);
+	ov3640_write_reg(0x82B1,0x12);
+	ov3640_write_reg(0x82B2,0x0D);
+	ov3640_write_reg(0x82B3,0x13);
+	ov3640_write_reg(0x82B4,0xC2);
+	ov3640_write_reg(0x82B5,0x08);
+	ov3640_write_reg(0x82B6,0x02);
+	ov3640_write_reg(0x82B7,0x03);
+	ov3640_write_reg(0x82B8,0x74);
+	ov3640_write_reg(0x82B9,0xE5);
+	ov3640_write_reg(0x82BA,0x40);
+	ov3640_write_reg(0x82BB,0x60);
+	ov3640_write_reg(0x82BC,0x03);
+	ov3640_write_reg(0x82BD,0x02);
+	ov3640_write_reg(0x82BE,0x03);
+	ov3640_write_reg(0x82BF,0x74);
+	ov3640_write_reg(0x82C0,0xE5);
+	ov3640_write_reg(0x82C1,0x4F);
+	ov3640_write_reg(0x82C2,0x60);
+	ov3640_write_reg(0x82C3,0x03);
+	ov3640_write_reg(0x82C4,0x02);
+	ov3640_write_reg(0x82C5,0x03);
+	ov3640_write_reg(0x82C6,0x74);
+	ov3640_write_reg(0x82C7,0x75);
+	ov3640_write_reg(0x82C8,0x40);
+	ov3640_write_reg(0x82C9,0x65);
+	ov3640_write_reg(0x82CA,0x80);
+	ov3640_write_reg(0x82CB,0x77);
+	ov3640_write_reg(0x82CC,0xE5);
+	ov3640_write_reg(0x82CD,0x40);
+	ov3640_write_reg(0x82CE,0x60);
+	ov3640_write_reg(0x82CF,0x03);
+	ov3640_write_reg(0x82D0,0x02);
+	ov3640_write_reg(0x82D1,0x03);
+	ov3640_write_reg(0x82D2,0x74);
+	ov3640_write_reg(0x82D3,0xE5);
+	ov3640_write_reg(0x82D4,0x4F);
+	ov3640_write_reg(0x82D5,0x60);
+	ov3640_write_reg(0x82D6,0x03);
+	ov3640_write_reg(0x82D7,0x02);
+	ov3640_write_reg(0x82D8,0x03);
+	ov3640_write_reg(0x82D9,0x74);
+	ov3640_write_reg(0x82DA,0x75);
+	ov3640_write_reg(0x82DB,0x40);
+	ov3640_write_reg(0x82DC,0x4A);
+	ov3640_write_reg(0x82DD,0x75);
+	ov3640_write_reg(0x82DE,0x4F);
+	ov3640_write_reg(0x82DF,0x01);
+	ov3640_write_reg(0x82E0,0x02);
+	ov3640_write_reg(0x82E1,0x03);
+	ov3640_write_reg(0x82E2,0x74);
+	ov3640_write_reg(0x82E3,0xE5);
+	ov3640_write_reg(0x82E4,0x40);
+	ov3640_write_reg(0x82E5,0x60);
+	ov3640_write_reg(0x82E6,0x03);
+	ov3640_write_reg(0x82E7,0x02);
+	ov3640_write_reg(0x82E8,0x03);
+	ov3640_write_reg(0x82E9,0x74);
+	ov3640_write_reg(0x82EA,0xE5);
+	ov3640_write_reg(0x82EB,0x4F);
+	ov3640_write_reg(0x82EC,0x60);
+	ov3640_write_reg(0x82ED,0x03);
+	ov3640_write_reg(0x82EE,0x02);
+	ov3640_write_reg(0x82EF,0x03);
+	ov3640_write_reg(0x82F0,0x74);
+	ov3640_write_reg(0x82F1,0x75);
+	ov3640_write_reg(0x82F2,0x40);
+	ov3640_write_reg(0x82F3,0x4E);
+	ov3640_write_reg(0x82F4,0x80);
+	ov3640_write_reg(0x82F5,0x4D);
+	ov3640_write_reg(0x82F6,0xE5);
+	ov3640_write_reg(0x82F7,0x40);
+	ov3640_write_reg(0x82F8,0xB4);
+	ov3640_write_reg(0x82F9,0x46);
+	ov3640_write_reg(0x82FA,0x09);
+	ov3640_write_reg(0x82FB,0x75);
+	ov3640_write_reg(0x82FC,0x40);
+	ov3640_write_reg(0x82FD,0x47);
+	ov3640_write_reg(0x82FE,0x85);
+	ov3640_write_reg(0x82FF,0x40);
+	ov3640_write_reg(0x8300,0x0D);
+	ov3640_write_reg(0x8301,0x12);
+	ov3640_write_reg(0x8302,0x0A);
+	ov3640_write_reg(0x8303,0x80);
+	ov3640_write_reg(0x8304,0xE5);
+	ov3640_write_reg(0x8305,0x40);
+	ov3640_write_reg(0x8306,0x64);
+	ov3640_write_reg(0x8307,0x4A);
+	ov3640_write_reg(0x8308,0x70);
+	ov3640_write_reg(0x8309,0x6A);
+	ov3640_write_reg(0x830A,0x75);
+	ov3640_write_reg(0x830B,0x40);
+	ov3640_write_reg(0x830C,0x4B);
+	ov3640_write_reg(0x830D,0x80);
+	ov3640_write_reg(0x830E,0x34);
+	ov3640_write_reg(0x830F,0xE5);
+	ov3640_write_reg(0x8310,0x40);
+	ov3640_write_reg(0x8311,0x64);
+	ov3640_write_reg(0x8312,0x4B);
+	ov3640_write_reg(0x8313,0x70);
+	ov3640_write_reg(0x8314,0x5F);
+	ov3640_write_reg(0x8315,0x85);
+	ov3640_write_reg(0x8316,0x47);
+	ov3640_write_reg(0x8317,0x0D);
+	ov3640_write_reg(0x8318,0x85);
+	ov3640_write_reg(0x8319,0x48);
+	ov3640_write_reg(0x831A,0x0E);
+	ov3640_write_reg(0x831B,0xF5);
+	ov3640_write_reg(0x831C,0x0F);
+	ov3640_write_reg(0x831D,0xF5);
+	ov3640_write_reg(0x831E,0x10);
+	ov3640_write_reg(0x831F,0x12);
+	ov3640_write_reg(0x8320,0x0B);
+	ov3640_write_reg(0x8321,0x41);
+	ov3640_write_reg(0x8322,0xE4);
+	ov3640_write_reg(0x8323,0xF5);
+	ov3640_write_reg(0x8324,0x47);
+	ov3640_write_reg(0x8325,0xF5);
+	ov3640_write_reg(0x8326,0x48);
+	ov3640_write_reg(0x8327,0x75);
+	ov3640_write_reg(0x8328,0x40);
+	ov3640_write_reg(0x8329,0x69);
+	ov3640_write_reg(0x832A,0x80);
+	ov3640_write_reg(0x832B,0x17);
+	ov3640_write_reg(0x832C,0xE4);
+	ov3640_write_reg(0x832D,0xF5);
+	ov3640_write_reg(0x832E,0x40);
+	ov3640_write_reg(0x832F,0xF5);
+	ov3640_write_reg(0x8330,0x4F);
+	ov3640_write_reg(0x8331,0x85);
+	ov3640_write_reg(0x8332,0x47);
+	ov3640_write_reg(0x8333,0x0D);
+	ov3640_write_reg(0x8334,0x85);
+	ov3640_write_reg(0x8335,0x48);
+	ov3640_write_reg(0x8336,0x0E);
+	ov3640_write_reg(0x8337,0xF5);
+	ov3640_write_reg(0x8338,0x0F);
+	ov3640_write_reg(0x8339,0xF5);
+	ov3640_write_reg(0x833A,0x10);
+	ov3640_write_reg(0x833B,0x12);
+	ov3640_write_reg(0x833C,0x0B);
+	ov3640_write_reg(0x833D,0x41);
+	ov3640_write_reg(0x833E,0xE4);
+	ov3640_write_reg(0x833F,0xF5);
+	ov3640_write_reg(0x8340,0x47);
+	ov3640_write_reg(0x8341,0xF5);
+	ov3640_write_reg(0x8342,0x48);
+	ov3640_write_reg(0x8343,0x85);
+	ov3640_write_reg(0x8344,0x40);
+	ov3640_write_reg(0x8345,0x0D);
+	ov3640_write_reg(0x8346,0x12);
+	ov3640_write_reg(0x8347,0x0A);
+	ov3640_write_reg(0x8348,0x80);
+	ov3640_write_reg(0x8349,0x80);
+	ov3640_write_reg(0x834A,0x29);
+	ov3640_write_reg(0x834B,0x12);
+	ov3640_write_reg(0x834C,0x06);
+	ov3640_write_reg(0x834D,0xD6);
+	ov3640_write_reg(0x834E,0x80);
+	ov3640_write_reg(0x834F,0x24);
+	ov3640_write_reg(0x8350,0xE5);
+	ov3640_write_reg(0x8351,0x4F);
+	ov3640_write_reg(0x8352,0x70);
+	ov3640_write_reg(0x8353,0x20);
+	ov3640_write_reg(0x8354,0xE5);
+	ov3640_write_reg(0x8355,0x40);
+	ov3640_write_reg(0x8356,0x70);
+	ov3640_write_reg(0x8357,0x1C);
+	ov3640_write_reg(0x8358,0x85);
+	ov3640_write_reg(0x8359,0x0C);
+	ov3640_write_reg(0x835A,0x0D);
+	ov3640_write_reg(0x835B,0x12);
+	ov3640_write_reg(0x835C,0x05);
+	ov3640_write_reg(0x835D,0x7E);
+	ov3640_write_reg(0x835E,0x80);
+	ov3640_write_reg(0x835F,0x14);
+	ov3640_write_reg(0x8360,0xE5);
+	ov3640_write_reg(0x8361,0x3C);
+	ov3640_write_reg(0x8362,0x90);
+	ov3640_write_reg(0x8363,0x3F);
+	ov3640_write_reg(0x8364,0x02);
+	ov3640_write_reg(0x8365,0xF0);
+	ov3640_write_reg(0x8366,0xA3);
+	ov3640_write_reg(0x8367,0xE5);
+	ov3640_write_reg(0x8368,0x3D);
+	ov3640_write_reg(0x8369,0xF0);
+	ov3640_write_reg(0x836A,0xE5);
+	ov3640_write_reg(0x836B,0x3E);
+	ov3640_write_reg(0x836C,0xA3);
+	ov3640_write_reg(0x836D,0xF0);
+	ov3640_write_reg(0x836E,0x90);
+	ov3640_write_reg(0x836F,0x3F);
+	ov3640_write_reg(0x8370,0x07);
+	ov3640_write_reg(0x8371,0xE5);
+	ov3640_write_reg(0x8372,0x3F);
+	ov3640_write_reg(0x8373,0xF0);
+	ov3640_write_reg(0x8374,0x90);
+	ov3640_write_reg(0x8375,0x3F);
+	ov3640_write_reg(0x8376,0x01);
+	ov3640_write_reg(0x8377,0xE5);
+	ov3640_write_reg(0x8378,0x40);
+	ov3640_write_reg(0x8379,0xF0);
+	ov3640_write_reg(0x837A,0x22);
+	ov3640_write_reg(0x837B,0xE5);
+	ov3640_write_reg(0x837C,0x15);
+	ov3640_write_reg(0x837D,0xD3);
+	ov3640_write_reg(0x837E,0x94);
+	ov3640_write_reg(0x837F,0x04);
+	ov3640_write_reg(0x8380,0x40);
+	ov3640_write_reg(0x8381,0x03);
+	ov3640_write_reg(0x8382,0xE4);
+	ov3640_write_reg(0x8383,0xF5);
+	ov3640_write_reg(0x8384,0x15);
+	ov3640_write_reg(0x8385,0xE5);
+	ov3640_write_reg(0x8386,0x15);
+	ov3640_write_reg(0x8387,0x25);
+	ov3640_write_reg(0x8388,0xE0);
+	ov3640_write_reg(0x8389,0x25);
+	ov3640_write_reg(0x838A,0xE0);
+	ov3640_write_reg(0x838B,0xF5);
+	ov3640_write_reg(0x838C,0x15);
+	ov3640_write_reg(0x838D,0xE5);
+	ov3640_write_reg(0x838E,0x12);
+	ov3640_write_reg(0x838F,0xAE);
+	ov3640_write_reg(0x8390,0x11);
+	ov3640_write_reg(0x8391,0x78);
+	ov3640_write_reg(0x8392,0x05);
+	ov3640_write_reg(0x8393,0xCE);
+	ov3640_write_reg(0x8394,0xC3);
+	ov3640_write_reg(0x8395,0x13);
+	ov3640_write_reg(0x8396,0xCE);
+	ov3640_write_reg(0x8397,0x13);
+	ov3640_write_reg(0x8398,0xD8);
+	ov3640_write_reg(0x8399,0xF9);
+	ov3640_write_reg(0x839A,0xFB);
+	ov3640_write_reg(0x839B,0xAA);
+	ov3640_write_reg(0x839C,0x06);
+	ov3640_write_reg(0x839D,0x25);
+	ov3640_write_reg(0x839E,0xE0);
+	ov3640_write_reg(0x839F,0xFF);
+	ov3640_write_reg(0x83A0,0xEA);
+	ov3640_write_reg(0x83A1,0x33);
+	ov3640_write_reg(0x83A2,0xFE);
+	ov3640_write_reg(0x83A3,0xEF);
+	ov3640_write_reg(0x83A4,0x78);
+	ov3640_write_reg(0x83A5,0x03);
+	ov3640_write_reg(0x83A6,0xCE);
+	ov3640_write_reg(0x83A7,0xC3);
+	ov3640_write_reg(0x83A8,0x13);
+	ov3640_write_reg(0x83A9,0xCE);
+	ov3640_write_reg(0x83AA,0x13);
+	ov3640_write_reg(0x83AB,0xD8);
+	ov3640_write_reg(0x83AC,0xF9);
+	ov3640_write_reg(0x83AD,0xF5);
+	ov3640_write_reg(0x83AE,0x1C);
+	ov3640_write_reg(0x83AF,0xE5);
+	ov3640_write_reg(0x83B0,0x14);
+	ov3640_write_reg(0x83B1,0xAE);
+	ov3640_write_reg(0x83B2,0x13);
+	ov3640_write_reg(0x83B3,0x78);
+	ov3640_write_reg(0x83B4,0x03);
+	ov3640_write_reg(0x83B5,0xCE);
+	ov3640_write_reg(0x83B6,0xC3);
+	ov3640_write_reg(0x83B7,0x13);
+	ov3640_write_reg(0x83B8,0xCE);
+	ov3640_write_reg(0x83B9,0x13);
+	ov3640_write_reg(0x83BA,0xD8);
+	ov3640_write_reg(0x83BB,0xF9);
+	ov3640_write_reg(0x83BC,0x25);
+	ov3640_write_reg(0x83BD,0xE0);
+	ov3640_write_reg(0x83BE,0xFF);
+	ov3640_write_reg(0x83BF,0xEE);
+	ov3640_write_reg(0x83C0,0x33);
+	ov3640_write_reg(0x83C1,0xFE);
+	ov3640_write_reg(0x83C2,0xEF);
+	ov3640_write_reg(0x83C3,0x78);
+	ov3640_write_reg(0x83C4,0x03);
+	ov3640_write_reg(0x83C5,0xCE);
+	ov3640_write_reg(0x83C6,0xC3);
+	ov3640_write_reg(0x83C7,0x13);
+	ov3640_write_reg(0x83C8,0xCE);
+	ov3640_write_reg(0x83C9,0x13);
+	ov3640_write_reg(0x83CA,0xD8);
+	ov3640_write_reg(0x83CB,0xF9);
+	ov3640_write_reg(0x83CC,0xF9);
+	ov3640_write_reg(0x83CD,0x7C);
+	ov3640_write_reg(0x83CE,0x00);
+	ov3640_write_reg(0x83CF,0x7D);
+	ov3640_write_reg(0x83D0,0x06);
+	ov3640_write_reg(0x83D1,0xAF);
+	ov3640_write_reg(0x83D2,0x03);
+	ov3640_write_reg(0x83D3,0xAE);
+	ov3640_write_reg(0x83D4,0x02);
+	ov3640_write_reg(0x83D5,0x12);
+	ov3640_write_reg(0x83D6,0x0C);
+	ov3640_write_reg(0x83D7,0x36);
+	ov3640_write_reg(0x83D8,0xEF);
+	ov3640_write_reg(0x83D9,0x78);
+	ov3640_write_reg(0x83DA,0x03);
+	ov3640_write_reg(0x83DB,0xCE);
+	ov3640_write_reg(0x83DC,0xC3);
+	ov3640_write_reg(0x83DD,0x13);
+	ov3640_write_reg(0x83DE,0xCE);
+	ov3640_write_reg(0x83DF,0x13);
+	ov3640_write_reg(0x83E0,0xD8);
+	ov3640_write_reg(0x83E1,0xF9);
+	ov3640_write_reg(0x83E2,0xFB);
+	ov3640_write_reg(0x83E3,0xE5);
+	ov3640_write_reg(0x83E4,0x14);
+	ov3640_write_reg(0x83E5,0xAE);
+	ov3640_write_reg(0x83E6,0x13);
+	ov3640_write_reg(0x83E7,0x78);
+	ov3640_write_reg(0x83E8,0x03);
+	ov3640_write_reg(0x83E9,0xCE);
+	ov3640_write_reg(0x83EA,0xC3);
+	ov3640_write_reg(0x83EB,0x13);
+	ov3640_write_reg(0x83EC,0xCE);
+	ov3640_write_reg(0x83ED,0x13);
+	ov3640_write_reg(0x83EE,0xD8);
+	ov3640_write_reg(0x83EF,0xF9);
+	ov3640_write_reg(0x83F0,0xFF);
+	ov3640_write_reg(0x83F1,0x7C);
+	ov3640_write_reg(0x83F2,0x00);
+	ov3640_write_reg(0x83F3,0x7D);
+	ov3640_write_reg(0x83F4,0x06);
+	ov3640_write_reg(0x83F5,0x12);
+	ov3640_write_reg(0x83F6,0x0C);
+	ov3640_write_reg(0x83F7,0x36);
+	ov3640_write_reg(0x83F8,0xEF);
+	ov3640_write_reg(0x83F9,0x78);
+	ov3640_write_reg(0x83FA,0x03);
+	ov3640_write_reg(0x83FB,0xCE);
+	ov3640_write_reg(0x83FC,0xC3);
+	ov3640_write_reg(0x83FD,0x13);
+	ov3640_write_reg(0x83FE,0xCE);
+	ov3640_write_reg(0x83FF,0x13);
+	ov3640_write_reg(0x8400,0xD8);
+	ov3640_write_reg(0x8401,0xF9);
+	ov3640_write_reg(0x8402,0xFD);
+	ov3640_write_reg(0x8403,0xE5);
+	ov3640_write_reg(0x8404,0x1C);
+	ov3640_write_reg(0x8405,0x75);
+	ov3640_write_reg(0x8406,0xF0);
+	ov3640_write_reg(0x8407,0x20);
+	ov3640_write_reg(0x8408,0xA4);
+	ov3640_write_reg(0x8409,0x85);
+	ov3640_write_reg(0x840A,0xF0);
+	ov3640_write_reg(0x840B,0x16);
+	ov3640_write_reg(0x840C,0xF5);
+	ov3640_write_reg(0x840D,0x17);
+	ov3640_write_reg(0x840E,0xE9);
+	ov3640_write_reg(0x840F,0x75);
+	ov3640_write_reg(0x8410,0xF0);
+	ov3640_write_reg(0x8411,0x08);
+	ov3640_write_reg(0x8412,0xA4);
+	ov3640_write_reg(0x8413,0x85);
+	ov3640_write_reg(0x8414,0xF0);
+	ov3640_write_reg(0x8415,0x18);
+	ov3640_write_reg(0x8416,0xF5);
+	ov3640_write_reg(0x8417,0x19);
+	ov3640_write_reg(0x8418,0xEB);
+	ov3640_write_reg(0x8419,0x75);
+	ov3640_write_reg(0x841A,0xF0);
+	ov3640_write_reg(0x841B,0x20);
+	ov3640_write_reg(0x841C,0xA4);
+	ov3640_write_reg(0x841D,0x85);
+	ov3640_write_reg(0x841E,0xF0);
+	ov3640_write_reg(0x841F,0x1A);
+	ov3640_write_reg(0x8420,0xF5);
+	ov3640_write_reg(0x8421,0x1B);
+	ov3640_write_reg(0x8422,0xAF);
+	ov3640_write_reg(0x8423,0x05);
+	ov3640_write_reg(0x8424,0xEF);
+	ov3640_write_reg(0x8425,0x75);
+	ov3640_write_reg(0x8426,0xF0);
+	ov3640_write_reg(0x8427,0x08);
+	ov3640_write_reg(0x8428,0xA4);
+	ov3640_write_reg(0x8429,0xFD);
+	ov3640_write_reg(0x842A,0xAC);
+	ov3640_write_reg(0x842B,0xF0);
+	ov3640_write_reg(0x842C,0xE5);
+	ov3640_write_reg(0x842D,0x16);
+	ov3640_write_reg(0x842E,0x54);
+	ov3640_write_reg(0x842F,0x0F);
+	ov3640_write_reg(0x8430,0xFB);
+	ov3640_write_reg(0x8431,0xE5);
+	ov3640_write_reg(0x8432,0x18);
+	ov3640_write_reg(0x8433,0x54);
+	ov3640_write_reg(0x8434,0x07);
+	ov3640_write_reg(0x8435,0xC4);
+	ov3640_write_reg(0x8436,0xF8);
+	ov3640_write_reg(0x8437,0x54);
+	ov3640_write_reg(0x8438,0xF0);
+	ov3640_write_reg(0x8439,0xC8);
+	ov3640_write_reg(0x843A,0xE4);
+	ov3640_write_reg(0x843B,0xC4);
+	ov3640_write_reg(0x843C,0x54);
+	ov3640_write_reg(0x843D,0x0F);
+	ov3640_write_reg(0x843E,0x48);
+	ov3640_write_reg(0x843F,0x2B);
+	ov3640_write_reg(0x8440,0xFB);
+	ov3640_write_reg(0x8441,0xE5);
+	ov3640_write_reg(0x8442,0x1A);
+	ov3640_write_reg(0x8443,0x54);
+	ov3640_write_reg(0x8444,0x0F);
+	ov3640_write_reg(0x8445,0xFA);
+	ov3640_write_reg(0x8446,0xEC);
+	ov3640_write_reg(0x8447,0x54);
+	ov3640_write_reg(0x8448,0x07);
+	ov3640_write_reg(0x8449,0xC4);
+	ov3640_write_reg(0x844A,0xF8);
+	ov3640_write_reg(0x844B,0x54);
+	ov3640_write_reg(0x844C,0xF0);
+	ov3640_write_reg(0x844D,0xC8);
+	ov3640_write_reg(0x844E,0xE4);
+	ov3640_write_reg(0x844F,0xC4);
+	ov3640_write_reg(0x8450,0x54);
+	ov3640_write_reg(0x8451,0x0F);
+	ov3640_write_reg(0x8452,0x48);
+	ov3640_write_reg(0x8453,0x2A);
+	ov3640_write_reg(0x8454,0xFF);
+	ov3640_write_reg(0x8455,0x90);
+	ov3640_write_reg(0x8456,0x33);
+	ov3640_write_reg(0x8457,0x5F);
+	ov3640_write_reg(0x8458,0xE0);
+	ov3640_write_reg(0x8459,0x90);
+	ov3640_write_reg(0x845A,0x39);
+	ov3640_write_reg(0x845B,0x0A);
+	ov3640_write_reg(0x845C,0xB4);
+	ov3640_write_reg(0x845D,0x68);
+	ov3640_write_reg(0x845E,0x11);
+	ov3640_write_reg(0x845F,0x74);
+	ov3640_write_reg(0x8460,0x18);
+	ov3640_write_reg(0x8461,0xF0);
+	ov3640_write_reg(0x8462,0xA3);
+	ov3640_write_reg(0x8463,0x74);
+	ov3640_write_reg(0x8464,0x48);
+	ov3640_write_reg(0x8465,0xF0);
+	ov3640_write_reg(0x8466,0xA3);
+	ov3640_write_reg(0x8467,0x74);
+	ov3640_write_reg(0x8468,0x28);
+	ov3640_write_reg(0x8469,0xF0);
+	ov3640_write_reg(0x846A,0xA3);
+	ov3640_write_reg(0x846B,0x74);
+	ov3640_write_reg(0x846C,0x78);
+	ov3640_write_reg(0x846D,0xF0);
+	ov3640_write_reg(0x846E,0x80);
+	ov3640_write_reg(0x846F,0x0F);
+	ov3640_write_reg(0x8470,0x74);
+	ov3640_write_reg(0x8471,0x0C);
+	ov3640_write_reg(0x8472,0xF0);
+	ov3640_write_reg(0x8473,0xA3);
+	ov3640_write_reg(0x8474,0x74);
+	ov3640_write_reg(0x8475,0x24);
+	ov3640_write_reg(0x8476,0xF0);
+	ov3640_write_reg(0x8477,0xA3);
+	ov3640_write_reg(0x8478,0x74);
+	ov3640_write_reg(0x8479,0x14);
+	ov3640_write_reg(0x847A,0xF0);
+	ov3640_write_reg(0x847B,0xA3);
+	ov3640_write_reg(0x847C,0x74);
+	ov3640_write_reg(0x847D,0x3C);
+	ov3640_write_reg(0x847E,0xF0);
+	ov3640_write_reg(0x847F,0x90);
+	ov3640_write_reg(0x8480,0x33);
+	ov3640_write_reg(0x8481,0xAA);
+	ov3640_write_reg(0x8482,0xEB);
+	ov3640_write_reg(0x8483,0xF0);
+	ov3640_write_reg(0x8484,0xE5);
+	ov3640_write_reg(0x8485,0x17);
+	ov3640_write_reg(0x8486,0xA3);
+	ov3640_write_reg(0x8487,0xF0);
+	ov3640_write_reg(0x8488,0xE5);
+	ov3640_write_reg(0x8489,0x19);
+	ov3640_write_reg(0x848A,0xA3);
+	ov3640_write_reg(0x848B,0xF0);
+	ov3640_write_reg(0x848C,0xA3);
+	ov3640_write_reg(0x848D,0xEF);
+	ov3640_write_reg(0x848E,0xF0);
+	ov3640_write_reg(0x848F,0xE5);
+	ov3640_write_reg(0x8490,0x1B);
+	ov3640_write_reg(0x8491,0xA3);
+	ov3640_write_reg(0x8492,0xF0);
+	ov3640_write_reg(0x8493,0xED);
+	ov3640_write_reg(0x8494,0xA3);
+	ov3640_write_reg(0x8495,0xF0);
+	ov3640_write_reg(0x8496,0x22);
+	ov3640_write_reg(0x8497,0x90);
+	ov3640_write_reg(0x8498,0x3F);
+	ov3640_write_reg(0x8499,0x05);
+	ov3640_write_reg(0x849A,0xE0);
+	ov3640_write_reg(0x849B,0xF5);
+	ov3640_write_reg(0x849C,0x0C);
+	ov3640_write_reg(0x849D,0x54);
+	ov3640_write_reg(0x849E,0x03);
+	ov3640_write_reg(0x849F,0x75);
+	ov3640_write_reg(0x84A0,0x0D);
+	ov3640_write_reg(0x84A1,0x00);
+	ov3640_write_reg(0x84A2,0xF5);
+	ov3640_write_reg(0x84A3,0x0E);
+	ov3640_write_reg(0x84A4,0x75);
+	ov3640_write_reg(0x84A5,0x0E);
+	ov3640_write_reg(0x84A6,0x00);
+	ov3640_write_reg(0x84A7,0xF5);
+	ov3640_write_reg(0x84A8,0x0D);
+	ov3640_write_reg(0x84A9,0xA3);
+	ov3640_write_reg(0x84AA,0xE0);
+	ov3640_write_reg(0x84AB,0x25);
+	ov3640_write_reg(0x84AC,0x0E);
+	ov3640_write_reg(0x84AD,0xF5);
+	ov3640_write_reg(0x84AE,0x0E);
+	ov3640_write_reg(0x84AF,0xE4);
+	ov3640_write_reg(0x84B0,0x35);
+	ov3640_write_reg(0x84B1,0x0D);
+	ov3640_write_reg(0x84B2,0xF5);
+	ov3640_write_reg(0x84B3,0x0D);
+	ov3640_write_reg(0x84B4,0x53);
+	ov3640_write_reg(0x84B5,0x0C);
+	ov3640_write_reg(0x84B6,0xE0);
+	ov3640_write_reg(0x84B7,0xE5);
+	ov3640_write_reg(0x84B8,0x0C);
+	ov3640_write_reg(0x84B9,0x64);
+	ov3640_write_reg(0x84BA,0x20);
+	ov3640_write_reg(0x84BB,0x70);
+	ov3640_write_reg(0x84BC,0x03);
+	ov3640_write_reg(0x84BD,0x02);
+	ov3640_write_reg(0x84BE,0x05);
+	ov3640_write_reg(0x84BF,0x51);
+	ov3640_write_reg(0x84C0,0xE5);
+	ov3640_write_reg(0x84C1,0x0C);
+	ov3640_write_reg(0x84C2,0xB4);
+	ov3640_write_reg(0x84C3,0x80);
+	ov3640_write_reg(0x84C4,0x49);
+	ov3640_write_reg(0x84C5,0xE5);
+	ov3640_write_reg(0x84C6,0x48);
+	ov3640_write_reg(0x84C7,0x25);
+	ov3640_write_reg(0x84C8,0x0E);
+	ov3640_write_reg(0x84C9,0xF5);
+	ov3640_write_reg(0x84CA,0x0E);
+	ov3640_write_reg(0x84CB,0xE5);
+	ov3640_write_reg(0x84CC,0x47);
+	ov3640_write_reg(0x84CD,0x35);
+	ov3640_write_reg(0x84CE,0x0D);
+	ov3640_write_reg(0x84CF,0xF5);
+	ov3640_write_reg(0x84D0,0x0D);
+	ov3640_write_reg(0x84D1,0xD3);
+	ov3640_write_reg(0x84D2,0xE5);
+	ov3640_write_reg(0x84D3,0x0E);
+	ov3640_write_reg(0x84D4,0x95);
+	ov3640_write_reg(0x84D5,0x4E);
+	ov3640_write_reg(0x84D6,0xE5);
+	ov3640_write_reg(0x84D7,0x0D);
+	ov3640_write_reg(0x84D8,0x95);
+	ov3640_write_reg(0x84D9,0x4D);
+	ov3640_write_reg(0x84DA,0x40);
+	ov3640_write_reg(0x84DB,0x06);
+	ov3640_write_reg(0x84DC,0x85);
+	ov3640_write_reg(0x84DD,0x4D);
+	ov3640_write_reg(0x84DE,0x0D);
+	ov3640_write_reg(0x84DF,0x85);
+	ov3640_write_reg(0x84E0,0x4E);
+	ov3640_write_reg(0x84E1,0x0E);
+	ov3640_write_reg(0x84E2,0xE5);
+	ov3640_write_reg(0x84E3,0x48);
+	ov3640_write_reg(0x84E4,0x65);
+	ov3640_write_reg(0x84E5,0x0E);
+	ov3640_write_reg(0x84E6,0x70);
+	ov3640_write_reg(0x84E7,0x04);
+	ov3640_write_reg(0x84E8,0xE5);
+	ov3640_write_reg(0x84E9,0x47);
+	ov3640_write_reg(0x84EA,0x65);
+	ov3640_write_reg(0x84EB,0x0D);
+	ov3640_write_reg(0x84EC,0x60);
+	ov3640_write_reg(0x84ED,0x20);
+	ov3640_write_reg(0x84EE,0xD3);
+	ov3640_write_reg(0x84EF,0xE5);
+	ov3640_write_reg(0x84F0,0x0E);
+	ov3640_write_reg(0x84F1,0x95);
+	ov3640_write_reg(0x84F2,0x4E);
+	ov3640_write_reg(0x84F3,0xE5);
+	ov3640_write_reg(0x84F4,0x0D);
+	ov3640_write_reg(0x84F5,0x95);
+	ov3640_write_reg(0x84F6,0x4D);
+	ov3640_write_reg(0x84F7,0x40);
+	ov3640_write_reg(0x84F8,0x06);
+	ov3640_write_reg(0x84F9,0x85);
+	ov3640_write_reg(0x84FA,0x4D);
+	ov3640_write_reg(0x84FB,0x0D);
+	ov3640_write_reg(0x84FC,0x85);
+	ov3640_write_reg(0x84FD,0x4E);
+	ov3640_write_reg(0x84FE,0x0E);
+	ov3640_write_reg(0x84FF,0x85);
+	ov3640_write_reg(0x8500,0x0D);
+	ov3640_write_reg(0x8501,0x13);
+	ov3640_write_reg(0x8502,0x85);
+	ov3640_write_reg(0x8503,0x0E);
+	ov3640_write_reg(0x8504,0x14);
+	ov3640_write_reg(0x8505,0x12);
+	ov3640_write_reg(0x8506,0x0B);
+	ov3640_write_reg(0x8507,0x86);
+	ov3640_write_reg(0x8508,0x85);
+	ov3640_write_reg(0x8509,0x0D);
+	ov3640_write_reg(0x850A,0x47);
+	ov3640_write_reg(0x850B,0x85);
+	ov3640_write_reg(0x850C,0x0E);
+	ov3640_write_reg(0x850D,0x48);
+	ov3640_write_reg(0x850E,0xE5);
+	ov3640_write_reg(0x850F,0x0C);
+	ov3640_write_reg(0x8510,0x64);
+	ov3640_write_reg(0x8511,0x40);
+	ov3640_write_reg(0x8512,0x70);
+	ov3640_write_reg(0x8513,0x69);
+	ov3640_write_reg(0x8514,0xD3);
+	ov3640_write_reg(0x8515,0xE5);
+	ov3640_write_reg(0x8516,0x48);
+	ov3640_write_reg(0x8517,0x95);
+	ov3640_write_reg(0x8518,0x4A);
+	ov3640_write_reg(0x8519,0xE5);
+	ov3640_write_reg(0x851A,0x47);
+	ov3640_write_reg(0x851B,0x95);
+	ov3640_write_reg(0x851C,0x49);
+	ov3640_write_reg(0x851D,0x40);
+	ov3640_write_reg(0x851E,0x0E);
+	ov3640_write_reg(0x851F,0xE5);
+	ov3640_write_reg(0x8520,0x48);
+	ov3640_write_reg(0x8521,0x95);
+	ov3640_write_reg(0x8522,0x0E);
+	ov3640_write_reg(0x8523,0xF5);
+	ov3640_write_reg(0x8524,0x0E);
+	ov3640_write_reg(0x8525,0xE5);
+	ov3640_write_reg(0x8526,0x47);
+	ov3640_write_reg(0x8527,0x95);
+	ov3640_write_reg(0x8528,0x0D);
+	ov3640_write_reg(0x8529,0xF5);
+	ov3640_write_reg(0x852A,0x0D);
+	ov3640_write_reg(0x852B,0x80);
+	ov3640_write_reg(0x852C,0x05);
+	ov3640_write_reg(0x852D,0xE4);
+	ov3640_write_reg(0x852E,0xF5);
+	ov3640_write_reg(0x852F,0x0D);
+	ov3640_write_reg(0x8530,0xF5);
+	ov3640_write_reg(0x8531,0x0E);
+	ov3640_write_reg(0x8532,0xE5);
+	ov3640_write_reg(0x8533,0x48);
+	ov3640_write_reg(0x8534,0x65);
+	ov3640_write_reg(0x8535,0x0E);
+	ov3640_write_reg(0x8536,0x70);
+	ov3640_write_reg(0x8537,0x04);
+	ov3640_write_reg(0x8538,0xE5);
+	ov3640_write_reg(0x8539,0x47);
+	ov3640_write_reg(0x853A,0x65);
+	ov3640_write_reg(0x853B,0x0D);
+	ov3640_write_reg(0x853C,0x60);
+	ov3640_write_reg(0x853D,0x3F);
+	ov3640_write_reg(0x853E,0xD3);
+	ov3640_write_reg(0x853F,0xE5);
+	ov3640_write_reg(0x8540,0x0E);
+	ov3640_write_reg(0x8541,0x95);
+	ov3640_write_reg(0x8542,0x4E);
+	ov3640_write_reg(0x8543,0xE5);
+	ov3640_write_reg(0x8544,0x0D);
+	ov3640_write_reg(0x8545,0x95);
+	ov3640_write_reg(0x8546,0x4D);
+	ov3640_write_reg(0x8547,0x40);
+	ov3640_write_reg(0x8548,0x25);
+	ov3640_write_reg(0x8549,0x85);
+	ov3640_write_reg(0x854A,0x4D);
+	ov3640_write_reg(0x854B,0x0D);
+	ov3640_write_reg(0x854C,0x85);
+	ov3640_write_reg(0x854D,0x4E);
+	ov3640_write_reg(0x854E,0x0E);
+	ov3640_write_reg(0x854F,0x80);
+	ov3640_write_reg(0x8550,0x1D);
+	ov3640_write_reg(0x8551,0xE5);
+	ov3640_write_reg(0x8552,0x48);
+	ov3640_write_reg(0x8553,0x65);
+	ov3640_write_reg(0x8554,0x0E);
+	ov3640_write_reg(0x8555,0x70);
+	ov3640_write_reg(0x8556,0x04);
+	ov3640_write_reg(0x8557,0xE5);
+	ov3640_write_reg(0x8558,0x47);
+	ov3640_write_reg(0x8559,0x65);
+	ov3640_write_reg(0x855A,0x0D);
+	ov3640_write_reg(0x855B,0x60);
+	ov3640_write_reg(0x855C,0x20);
+	ov3640_write_reg(0x855D,0xD3);
+	ov3640_write_reg(0x855E,0xE5);
+	ov3640_write_reg(0x855F,0x0E);
+	ov3640_write_reg(0x8560,0x95);
+	ov3640_write_reg(0x8561,0x4E);
+	ov3640_write_reg(0x8562,0xE5);
+	ov3640_write_reg(0x8563,0x0D);
+	ov3640_write_reg(0x8564,0x95);
+	ov3640_write_reg(0x8565,0x4D);
+	ov3640_write_reg(0x8566,0x40);
+	ov3640_write_reg(0x8567,0x06);
+	ov3640_write_reg(0x8568,0x85);
+	ov3640_write_reg(0x8569,0x4D);
+	ov3640_write_reg(0x856A,0x0D);
+	ov3640_write_reg(0x856B,0x85);
+	ov3640_write_reg(0x856C,0x4E);
+	ov3640_write_reg(0x856D,0x0E);
+	ov3640_write_reg(0x856E,0x85);
+	ov3640_write_reg(0x856F,0x0D);
+	ov3640_write_reg(0x8570,0x13);
+	ov3640_write_reg(0x8571,0x85);
+	ov3640_write_reg(0x8572,0x0E);
+	ov3640_write_reg(0x8573,0x14);
+	ov3640_write_reg(0x8574,0x12);
+	ov3640_write_reg(0x8575,0x0B);
+	ov3640_write_reg(0x8576,0x86);
+	ov3640_write_reg(0x8577,0x85);
+	ov3640_write_reg(0x8578,0x0D);
+	ov3640_write_reg(0x8579,0x47);
+	ov3640_write_reg(0x857A,0x85);
+	ov3640_write_reg(0x857B,0x0E);
+	ov3640_write_reg(0x857C,0x48);
+	ov3640_write_reg(0x857D,0x22);
+	ov3640_write_reg(0x857E,0xE5);
+	ov3640_write_reg(0x857F,0x0D);
+	ov3640_write_reg(0x8580,0x30);
+	ov3640_write_reg(0x8581,0xE7);
+	ov3640_write_reg(0x8582,0x70);
+	ov3640_write_reg(0x8583,0x54);
+	ov3640_write_reg(0x8584,0x7F);
+	ov3640_write_reg(0x8585,0xF5);
+	ov3640_write_reg(0x8586,0x3B);
+	ov3640_write_reg(0x8587,0x90);
+	ov3640_write_reg(0x8588,0x3F);
+	ov3640_write_reg(0x8589,0x01);
+	ov3640_write_reg(0x858A,0xE0);
+	ov3640_write_reg(0x858B,0xF5);
+	ov3640_write_reg(0x858C,0x4C);
+	ov3640_write_reg(0x858D,0xA3);
+	ov3640_write_reg(0x858E,0xE0);
+	ov3640_write_reg(0x858F,0x75);
+	ov3640_write_reg(0x8590,0x35);
+	ov3640_write_reg(0x8591,0x00);
+	ov3640_write_reg(0x8592,0xF5);
+	ov3640_write_reg(0x8593,0x36);
+	ov3640_write_reg(0x8594,0xA3);
+	ov3640_write_reg(0x8595,0xE0);
+	ov3640_write_reg(0x8596,0x75);
+	ov3640_write_reg(0x8597,0x49);
+	ov3640_write_reg(0x8598,0x00);
+	ov3640_write_reg(0x8599,0xF5);
+	ov3640_write_reg(0x859A,0x4A);
+	ov3640_write_reg(0x859B,0xA3);
+	ov3640_write_reg(0x859C,0xE0);
+	ov3640_write_reg(0x859D,0x75);
+	ov3640_write_reg(0x859E,0x4D);
+	ov3640_write_reg(0x859F,0x00);
+	ov3640_write_reg(0x85A0,0xF5);
+	ov3640_write_reg(0x85A1,0x4E);
+	ov3640_write_reg(0x85A2,0x75);
+	ov3640_write_reg(0x85A3,0x4E);
+	ov3640_write_reg(0x85A4,0x00);
+	ov3640_write_reg(0x85A5,0xF5);
+	ov3640_write_reg(0x85A6,0x4D);
+	ov3640_write_reg(0x85A7,0xA3);
+	ov3640_write_reg(0x85A8,0xE0);
+	ov3640_write_reg(0x85A9,0x25);
+	ov3640_write_reg(0x85AA,0x4E);
+	ov3640_write_reg(0x85AB,0xF5);
+	ov3640_write_reg(0x85AC,0x4E);
+	ov3640_write_reg(0x85AD,0xE4);
+	ov3640_write_reg(0x85AE,0x35);
+	ov3640_write_reg(0x85AF,0x4D);
+	ov3640_write_reg(0x85B0,0xF5);
+	ov3640_write_reg(0x85B1,0x4D);
+	ov3640_write_reg(0x85B2,0xA3);
+	ov3640_write_reg(0x85B3,0xE0);
+	ov3640_write_reg(0x85B4,0x75);
+	ov3640_write_reg(0x85B5,0x41);
+	ov3640_write_reg(0x85B6,0x00);
+	ov3640_write_reg(0x85B7,0xF5);
+	ov3640_write_reg(0x85B8,0x42);
+	ov3640_write_reg(0x85B9,0x75);
+	ov3640_write_reg(0x85BA,0x42);
+	ov3640_write_reg(0x85BB,0x00);
+	ov3640_write_reg(0x85BC,0xF5);
+	ov3640_write_reg(0x85BD,0x41);
+	ov3640_write_reg(0x85BE,0xA3);
+	ov3640_write_reg(0x85BF,0xE0);
+	ov3640_write_reg(0x85C0,0x25);
+	ov3640_write_reg(0x85C1,0x42);
+	ov3640_write_reg(0x85C2,0xF5);
+	ov3640_write_reg(0x85C3,0x42);
+	ov3640_write_reg(0x85C4,0xE4);
+	ov3640_write_reg(0x85C5,0x35);
+	ov3640_write_reg(0x85C6,0x41);
+	ov3640_write_reg(0x85C7,0xF5);
+	ov3640_write_reg(0x85C8,0x41);
+	ov3640_write_reg(0x85C9,0xE5);
+	ov3640_write_reg(0x85CA,0x36);
+	ov3640_write_reg(0x85CB,0x25);
+	ov3640_write_reg(0x85CC,0xE0);
+	ov3640_write_reg(0x85CD,0xF5);
+	ov3640_write_reg(0x85CE,0x36);
+	ov3640_write_reg(0x85CF,0xE5);
+	ov3640_write_reg(0x85D0,0x35);
+	ov3640_write_reg(0x85D1,0x33);
+	ov3640_write_reg(0x85D2,0xF5);
+	ov3640_write_reg(0x85D3,0x35);
+	ov3640_write_reg(0x85D4,0xE5);
+	ov3640_write_reg(0x85D5,0x4A);
+	ov3640_write_reg(0x85D6,0x25);
+	ov3640_write_reg(0x85D7,0xE0);
+	ov3640_write_reg(0x85D8,0xF5);
+	ov3640_write_reg(0x85D9,0x4A);
+	ov3640_write_reg(0x85DA,0xE5);
+	ov3640_write_reg(0x85DB,0x49);
+	ov3640_write_reg(0x85DC,0x33);
+	ov3640_write_reg(0x85DD,0xF5);
+	ov3640_write_reg(0x85DE,0x49);
+	ov3640_write_reg(0x85DF,0x90);
+	ov3640_write_reg(0x85E0,0x3F);
+	ov3640_write_reg(0x85E1,0x00);
+	ov3640_write_reg(0x85E2,0xE4);
+	ov3640_write_reg(0x85E3,0xF0);
+	ov3640_write_reg(0x85E4,0xA3);
+	ov3640_write_reg(0x85E5,0xF0);
+	ov3640_write_reg(0x85E6,0xA3);
+	ov3640_write_reg(0x85E7,0xF0);
+	ov3640_write_reg(0x85E8,0xA3);
+	ov3640_write_reg(0x85E9,0xF0);
+	ov3640_write_reg(0x85EA,0xA3);
+	ov3640_write_reg(0x85EB,0xF0);
+	ov3640_write_reg(0x85EC,0xA3);
+	ov3640_write_reg(0x85ED,0xF0);
+	ov3640_write_reg(0x85EE,0xA3);
+	ov3640_write_reg(0x85EF,0xF0);
+	ov3640_write_reg(0x85F0,0xA3);
+	ov3640_write_reg(0x85F1,0xF0);
+	ov3640_write_reg(0x85F2,0x22);
+	ov3640_write_reg(0x85F3,0x90);
+	ov3640_write_reg(0x85F4,0x3F);
+	ov3640_write_reg(0x85F5,0x02);
+	ov3640_write_reg(0x85F6,0xE0);
+	ov3640_write_reg(0x85F7,0xFF);
+	ov3640_write_reg(0x85F8,0x7E);
+	ov3640_write_reg(0x85F9,0x00);
+	ov3640_write_reg(0x85FA,0x7F);
+	ov3640_write_reg(0x85FB,0x00);
+	ov3640_write_reg(0x85FC,0xFE);
+	ov3640_write_reg(0x85FD,0xA3);
+	ov3640_write_reg(0x85FE,0xE0);
+	ov3640_write_reg(0x85FF,0x2F);
+	ov3640_write_reg(0x8600,0xFF);
+	ov3640_write_reg(0x8601,0xE4);
+	ov3640_write_reg(0x8602,0x3E);
+	ov3640_write_reg(0x8603,0xFE);
+	ov3640_write_reg(0x8604,0xE5);
+	ov3640_write_reg(0x8605,0x0D);
+	ov3640_write_reg(0x8606,0x24);
+	ov3640_write_reg(0x8607,0xEF);
+	ov3640_write_reg(0x8608,0x60);
+	ov3640_write_reg(0x8609,0x13);
+	ov3640_write_reg(0x860A,0x14);
+	ov3640_write_reg(0x860B,0x60);
+	ov3640_write_reg(0x860C,0x13);
+	ov3640_write_reg(0x860D,0x14);
+	ov3640_write_reg(0x860E,0x60);
+	ov3640_write_reg(0x860F,0x15);
+	ov3640_write_reg(0x8610,0x14);
+	ov3640_write_reg(0x8611,0x60);
+	ov3640_write_reg(0x8612,0x17);
+	ov3640_write_reg(0x8613,0x14);
+	ov3640_write_reg(0x8614,0x60);
+	ov3640_write_reg(0x8615,0x19);
+	ov3640_write_reg(0x8616,0x24);
+	ov3640_write_reg(0x8617,0x05);
+	ov3640_write_reg(0x8618,0x70);
+	ov3640_write_reg(0x8619,0x19);
+	ov3640_write_reg(0x861A,0x8F);
+	ov3640_write_reg(0x861B,0x3B);
+	ov3640_write_reg(0x861C,0x22);
+	ov3640_write_reg(0x861D,0x8F);
+	ov3640_write_reg(0x861E,0x4C);
+	ov3640_write_reg(0x861F,0x22);
+	ov3640_write_reg(0x8620,0x8E);
+	ov3640_write_reg(0x8621,0x35);
+	ov3640_write_reg(0x8622,0x8F);
+	ov3640_write_reg(0x8623,0x36);
+	ov3640_write_reg(0x8624,0x22);
+	ov3640_write_reg(0x8625,0x8E);
+	ov3640_write_reg(0x8626,0x49);
+	ov3640_write_reg(0x8627,0x8F);
+	ov3640_write_reg(0x8628,0x4A);
+	ov3640_write_reg(0x8629,0x22);
+	ov3640_write_reg(0x862A,0x8E);
+	ov3640_write_reg(0x862B,0x4D);
+	ov3640_write_reg(0x862C,0x8F);
+	ov3640_write_reg(0x862D,0x4E);
+	ov3640_write_reg(0x862E,0x22);
+	ov3640_write_reg(0x862F,0x8E);
+	ov3640_write_reg(0x8630,0x41);
+	ov3640_write_reg(0x8631,0x8F);
+	ov3640_write_reg(0x8632,0x42);
+	ov3640_write_reg(0x8633,0x22);
+	ov3640_write_reg(0x8634,0xE5);
+	ov3640_write_reg(0x8635,0x12);
+	ov3640_write_reg(0x8636,0x25);
+	ov3640_write_reg(0x8637,0xE0);
+	ov3640_write_reg(0x8638,0xFF);
+	ov3640_write_reg(0x8639,0xE5);
+	ov3640_write_reg(0x863A,0x11);
+	ov3640_write_reg(0x863B,0x33);
+	ov3640_write_reg(0x863C,0xFE);
+	ov3640_write_reg(0x863D,0xEF);
+	ov3640_write_reg(0x863E,0x78);
+	ov3640_write_reg(0x863F,0x03);
+	ov3640_write_reg(0x8640,0xCE);
+	ov3640_write_reg(0x8641,0xC3);
+	ov3640_write_reg(0x8642,0x13);
+	ov3640_write_reg(0x8643,0xCE);
+	ov3640_write_reg(0x8644,0x13);
+	ov3640_write_reg(0x8645,0xD8);
+	ov3640_write_reg(0x8646,0xF9);
+	ov3640_write_reg(0x8647,0xF5);
+	ov3640_write_reg(0x8648,0x16);
+	ov3640_write_reg(0x8649,0x8E);
+	ov3640_write_reg(0x864A,0x15);
+	ov3640_write_reg(0x864B,0xE5);
+	ov3640_write_reg(0x864C,0x14);
+	ov3640_write_reg(0x864D,0x25);
+	ov3640_write_reg(0x864E,0xE0);
+	ov3640_write_reg(0x864F,0xFF);
+	ov3640_write_reg(0x8650,0xE5);
+	ov3640_write_reg(0x8651,0x13);
+	ov3640_write_reg(0x8652,0x33);
+	ov3640_write_reg(0x8653,0xFE);
+	ov3640_write_reg(0x8654,0xEF);
+	ov3640_write_reg(0x8655,0x78);
+	ov3640_write_reg(0x8656,0x03);
+	ov3640_write_reg(0x8657,0xCE);
+	ov3640_write_reg(0x8658,0xC3);
+	ov3640_write_reg(0x8659,0x13);
+	ov3640_write_reg(0x865A,0xCE);
+	ov3640_write_reg(0x865B,0x13);
+	ov3640_write_reg(0x865C,0xD8);
+	ov3640_write_reg(0x865D,0xF9);
+	ov3640_write_reg(0x865E,0xF5);
+	ov3640_write_reg(0x865F,0x18);
+	ov3640_write_reg(0x8660,0x8E);
+	ov3640_write_reg(0x8661,0x17);
+	ov3640_write_reg(0x8662,0xAE);
+	ov3640_write_reg(0x8663,0x11);
+	ov3640_write_reg(0x8664,0xAF);
+	ov3640_write_reg(0x8665,0x12);
+	ov3640_write_reg(0x8666,0x7C);
+	ov3640_write_reg(0x8667,0x00);
+	ov3640_write_reg(0x8668,0x7D);
+	ov3640_write_reg(0x8669,0x06);
+	ov3640_write_reg(0x866A,0x12);
+	ov3640_write_reg(0x866B,0x0C);
+	ov3640_write_reg(0x866C,0x36);
+	ov3640_write_reg(0x866D,0xEF);
+	ov3640_write_reg(0x866E,0x78);
+	ov3640_write_reg(0x866F,0x03);
+	ov3640_write_reg(0x8670,0xCE);
+	ov3640_write_reg(0x8671,0xC3);
+	ov3640_write_reg(0x8672,0x13);
+	ov3640_write_reg(0x8673,0xCE);
+	ov3640_write_reg(0x8674,0x13);
+	ov3640_write_reg(0x8675,0xD8);
+	ov3640_write_reg(0x8676,0xF9);
+	ov3640_write_reg(0x8677,0xF5);
+	ov3640_write_reg(0x8678,0x1A);
+	ov3640_write_reg(0x8679,0x8E);
+	ov3640_write_reg(0x867A,0x19);
+	ov3640_write_reg(0x867B,0xAE);
+	ov3640_write_reg(0x867C,0x13);
+	ov3640_write_reg(0x867D,0xAF);
+	ov3640_write_reg(0x867E,0x14);
+	ov3640_write_reg(0x867F,0x7C);
+	ov3640_write_reg(0x8680,0x00);
+	ov3640_write_reg(0x8681,0x7D);
+	ov3640_write_reg(0x8682,0x06);
+	ov3640_write_reg(0x8683,0x12);
+	ov3640_write_reg(0x8684,0x0C);
+	ov3640_write_reg(0x8685,0x36);
+	ov3640_write_reg(0x8686,0xEF);
+	ov3640_write_reg(0x8687,0x78);
+	ov3640_write_reg(0x8688,0x03);
+	ov3640_write_reg(0x8689,0xCE);
+	ov3640_write_reg(0x868A,0xC3);
+	ov3640_write_reg(0x868B,0x13);
+	ov3640_write_reg(0x868C,0xCE);
+	ov3640_write_reg(0x868D,0x13);
+	ov3640_write_reg(0x868E,0xD8);
+	ov3640_write_reg(0x868F,0xF9);
+	ov3640_write_reg(0x8690,0xFD);
+	ov3640_write_reg(0x8691,0xAC);
+	ov3640_write_reg(0x8692,0x06);
+	ov3640_write_reg(0x8693,0xE5);
+	ov3640_write_reg(0x8694,0x15);
+	ov3640_write_reg(0x8695,0x54);
+	ov3640_write_reg(0x8696,0x0F);
+	ov3640_write_reg(0x8697,0xFB);
+	ov3640_write_reg(0x8698,0xE5);
+	ov3640_write_reg(0x8699,0x17);
+	ov3640_write_reg(0x869A,0x54);
+	ov3640_write_reg(0x869B,0x07);
+	ov3640_write_reg(0x869C,0xC4);
+	ov3640_write_reg(0x869D,0xF8);
+	ov3640_write_reg(0x869E,0x54);
+	ov3640_write_reg(0x869F,0xF0);
+	ov3640_write_reg(0x86A0,0xC8);
+	ov3640_write_reg(0x86A1,0xE4);
+	ov3640_write_reg(0x86A2,0xC4);
+	ov3640_write_reg(0x86A3,0x54);
+	ov3640_write_reg(0x86A4,0x0F);
+	ov3640_write_reg(0x86A5,0x48);
+	ov3640_write_reg(0x86A6,0x2B);
+	ov3640_write_reg(0x86A7,0xFB);
+	ov3640_write_reg(0x86A8,0xE5);
+	ov3640_write_reg(0x86A9,0x19);
+	ov3640_write_reg(0x86AA,0x54);
+	ov3640_write_reg(0x86AB,0x0F);
+	ov3640_write_reg(0x86AC,0xFA);
+	ov3640_write_reg(0x86AD,0xEC);
+	ov3640_write_reg(0x86AE,0x54);
+	ov3640_write_reg(0x86AF,0x07);
+	ov3640_write_reg(0x86B0,0xC4);
+	ov3640_write_reg(0x86B1,0xF8);
+	ov3640_write_reg(0x86B2,0x54);
+	ov3640_write_reg(0x86B3,0xF0);
+	ov3640_write_reg(0x86B4,0xC8);
+	ov3640_write_reg(0x86B5,0xE4);
+	ov3640_write_reg(0x86B6,0xC4);
+	ov3640_write_reg(0x86B7,0x54);
+	ov3640_write_reg(0x86B8,0x0F);
+	ov3640_write_reg(0x86B9,0x48);
+	ov3640_write_reg(0x86BA,0x2A);
+	ov3640_write_reg(0x86BB,0xFF);
+	ov3640_write_reg(0x86BC,0x90);
+	ov3640_write_reg(0x86BD,0x33);
+	ov3640_write_reg(0x86BE,0xAA);
+	ov3640_write_reg(0x86BF,0xEB);
+	ov3640_write_reg(0x86C0,0xF0);
+	ov3640_write_reg(0x86C1,0xE5);
+	ov3640_write_reg(0x86C2,0x16);
+	ov3640_write_reg(0x86C3,0xA3);
+	ov3640_write_reg(0x86C4,0xF0);
+	ov3640_write_reg(0x86C5,0xE5);
+	ov3640_write_reg(0x86C6,0x18);
+	ov3640_write_reg(0x86C7,0xA3);
+	ov3640_write_reg(0x86C8,0xF0);
+	ov3640_write_reg(0x86C9,0xA3);
+	ov3640_write_reg(0x86CA,0xEF);
+	ov3640_write_reg(0x86CB,0xF0);
+	ov3640_write_reg(0x86CC,0xE5);
+	ov3640_write_reg(0x86CD,0x1A);
+	ov3640_write_reg(0x86CE,0xA3);
+	ov3640_write_reg(0x86CF,0xF0);
+	ov3640_write_reg(0x86D0,0xAF);
+	ov3640_write_reg(0x86D1,0x05);
+	ov3640_write_reg(0x86D2,0xEF);
+	ov3640_write_reg(0x86D3,0xA3);
+	ov3640_write_reg(0x86D4,0xF0);
+	ov3640_write_reg(0x86D5,0x22);
+	ov3640_write_reg(0x86D6,0x90);
+	ov3640_write_reg(0x86D7,0x33);
+	ov3640_write_reg(0x86D8,0x62);
+	ov3640_write_reg(0x86D9,0xE0);
+	ov3640_write_reg(0x86DA,0x54);
+	ov3640_write_reg(0x86DB,0x0F);
+	ov3640_write_reg(0x86DC,0xFE);
+	ov3640_write_reg(0x86DD,0xA3);
+	ov3640_write_reg(0x86DE,0xE0);
+	ov3640_write_reg(0x86DF,0x7C);
+	ov3640_write_reg(0x86E0,0x00);
+	ov3640_write_reg(0x86E1,0x24);
+	ov3640_write_reg(0x86E2,0x00);
+	ov3640_write_reg(0x86E3,0xF5);
+	ov3640_write_reg(0x86E4,0x0E);
+	ov3640_write_reg(0x86E5,0xEC);
+	ov3640_write_reg(0x86E6,0x3E);
+	ov3640_write_reg(0x86E7,0xF5);
+	ov3640_write_reg(0x86E8,0x0D);
+	ov3640_write_reg(0x86E9,0x90);
+	ov3640_write_reg(0x86EA,0x33);
+	ov3640_write_reg(0x86EB,0x62);
+	ov3640_write_reg(0x86EC,0xE0);
+	ov3640_write_reg(0x86ED,0x54);
+	ov3640_write_reg(0x86EE,0x70);
+	ov3640_write_reg(0x86EF,0x75);
+	ov3640_write_reg(0x86F0,0xF0);
+	ov3640_write_reg(0x86F1,0x10);
+	ov3640_write_reg(0x86F2,0xA4);
+	ov3640_write_reg(0x86F3,0xFF);
+	ov3640_write_reg(0x86F4,0xAE);
+	ov3640_write_reg(0x86F5,0xF0);
+	ov3640_write_reg(0x86F6,0x90);
+	ov3640_write_reg(0x86F7,0x33);
+	ov3640_write_reg(0x86F8,0x64);
+	ov3640_write_reg(0x86F9,0xE0);
+	ov3640_write_reg(0x86FA,0x2F);
+	ov3640_write_reg(0x86FB,0xF5);
+	ov3640_write_reg(0x86FC,0x10);
+	ov3640_write_reg(0x86FD,0xEC);
+	ov3640_write_reg(0x86FE,0x3E);
+	ov3640_write_reg(0x86FF,0xF5);
+	ov3640_write_reg(0x8700,0x0F);
+	ov3640_write_reg(0x8701,0x85);
+	ov3640_write_reg(0x8702,0x0D);
+	ov3640_write_reg(0x8703,0x51);
+	ov3640_write_reg(0x8704,0x85);
+	ov3640_write_reg(0x8705,0x0E);
+	ov3640_write_reg(0x8706,0x52);
+	ov3640_write_reg(0x8707,0xF5);
+	ov3640_write_reg(0x8708,0x53);
+	ov3640_write_reg(0x8709,0x85);
+	ov3640_write_reg(0x870A,0x10);
+	ov3640_write_reg(0x870B,0x54);
+	ov3640_write_reg(0x870C,0x85);
+	ov3640_write_reg(0x870D,0x0D);
+	ov3640_write_reg(0x870E,0x11);
+	ov3640_write_reg(0x870F,0x85);
+	ov3640_write_reg(0x8710,0x0E);
+	ov3640_write_reg(0x8711,0x12);
+	ov3640_write_reg(0x8712,0xF5);
+	ov3640_write_reg(0x8713,0x13);
+	ov3640_write_reg(0x8714,0x85);
+	ov3640_write_reg(0x8715,0x10);
+	ov3640_write_reg(0x8716,0x14);
+	ov3640_write_reg(0x8717,0xE4);
+	ov3640_write_reg(0x8718,0xF5);
+	ov3640_write_reg(0x8719,0x15);
+	ov3640_write_reg(0x871A,0x12);
+	ov3640_write_reg(0x871B,0x03);
+	ov3640_write_reg(0x871C,0x7B);
+	ov3640_write_reg(0x871D,0x90);
+	ov3640_write_reg(0x871E,0x33);
+	ov3640_write_reg(0x871F,0x65);
+	ov3640_write_reg(0x8720,0xE0);
+	ov3640_write_reg(0x8721,0x30);
+	ov3640_write_reg(0x8722,0xE3);
+	ov3640_write_reg(0x8723,0x35);
+	ov3640_write_reg(0x8724,0x90);
+	ov3640_write_reg(0x8725,0x33);
+	ov3640_write_reg(0x8726,0xA4);
+	ov3640_write_reg(0x8727,0xE0);
+	ov3640_write_reg(0x8728,0x54);
+	ov3640_write_reg(0x8729,0x0F);
+	ov3640_write_reg(0x872A,0xFC);
+	ov3640_write_reg(0x872B,0xA3);
+	ov3640_write_reg(0x872C,0xE0);
+	ov3640_write_reg(0x872D,0x75);
+	ov3640_write_reg(0x872E,0xF0);
+	ov3640_write_reg(0x872F,0x04);
+	ov3640_write_reg(0x8730,0xA4);
+	ov3640_write_reg(0x8731,0xAE);
+	ov3640_write_reg(0x8732,0xF0);
+	ov3640_write_reg(0x8733,0x24);
+	ov3640_write_reg(0x8734,0x00);
+	ov3640_write_reg(0x8735,0xF5);
+	ov3640_write_reg(0x8736,0x0E);
+	ov3640_write_reg(0x8737,0xEE);
+	ov3640_write_reg(0x8738,0x3C);
+	ov3640_write_reg(0x8739,0xF5);
+	ov3640_write_reg(0x873A,0x0D);
+	ov3640_write_reg(0x873B,0x90);
+	ov3640_write_reg(0x873C,0x33);
+	ov3640_write_reg(0x873D,0xA4);
+	ov3640_write_reg(0x873E,0xE0);
+	ov3640_write_reg(0x873F,0x54);
+	ov3640_write_reg(0x8740,0x70);
+	ov3640_write_reg(0x8741,0x75);
+	ov3640_write_reg(0x8742,0xF0);
+	ov3640_write_reg(0x8743,0x10);
+	ov3640_write_reg(0x8744,0xA4);
+	ov3640_write_reg(0x8745,0xFD);
+	ov3640_write_reg(0x8746,0xAC);
+	ov3640_write_reg(0x8747,0xF0);
+	ov3640_write_reg(0x8748,0x90);
+	ov3640_write_reg(0x8749,0x33);
+	ov3640_write_reg(0x874A,0xA6);
+	ov3640_write_reg(0x874B,0xE0);
+	ov3640_write_reg(0x874C,0x75);
+	ov3640_write_reg(0x874D,0xF0);
+	ov3640_write_reg(0x874E,0x04);
+	ov3640_write_reg(0x874F,0xA4);
+	ov3640_write_reg(0x8750,0xAE);
+	ov3640_write_reg(0x8751,0xF0);
+	ov3640_write_reg(0x8752,0x2D);
+	ov3640_write_reg(0x8753,0xF5);
+	ov3640_write_reg(0x8754,0x10);
+	ov3640_write_reg(0x8755,0xEE);
+	ov3640_write_reg(0x8756,0x3C);
+	ov3640_write_reg(0x8757,0xF5);
+	ov3640_write_reg(0x8758,0x0F);
+	ov3640_write_reg(0x8759,0x85);
+	ov3640_write_reg(0x875A,0x0D);
+	ov3640_write_reg(0x875B,0x55);
+	ov3640_write_reg(0x875C,0x85);
+	ov3640_write_reg(0x875D,0x0E);
+	ov3640_write_reg(0x875E,0x56);
+	ov3640_write_reg(0x875F,0x85);
+	ov3640_write_reg(0x8760,0x0F);
+	ov3640_write_reg(0x8761,0x57);
+	ov3640_write_reg(0x8762,0x85);
+	ov3640_write_reg(0x8763,0x10);
+	ov3640_write_reg(0x8764,0x58);
+	ov3640_write_reg(0x8765,0x85);
+	ov3640_write_reg(0x8766,0x0D);
+	ov3640_write_reg(0x8767,0x11);
+	ov3640_write_reg(0x8768,0x85);
+	ov3640_write_reg(0x8769,0x0E);
+	ov3640_write_reg(0x876A,0x12);
+	ov3640_write_reg(0x876B,0x85);
+	ov3640_write_reg(0x876C,0x0F);
+	ov3640_write_reg(0x876D,0x13);
+	ov3640_write_reg(0x876E,0x85);
+	ov3640_write_reg(0x876F,0x10);
+	ov3640_write_reg(0x8770,0x14);
+	ov3640_write_reg(0x8771,0x02);
+	ov3640_write_reg(0x8772,0x06);
+	ov3640_write_reg(0x8773,0x34);
+	ov3640_write_reg(0x8774,0x78);
+	ov3640_write_reg(0x8775,0x7F);
+	ov3640_write_reg(0x8776,0xE4);
+	ov3640_write_reg(0x8777,0xF6);
+	ov3640_write_reg(0x8778,0xD8);
+	ov3640_write_reg(0x8779,0xFD);
+	ov3640_write_reg(0x877A,0x75);
+	ov3640_write_reg(0x877B,0x81);
+	ov3640_write_reg(0x877C,0x58);
+	ov3640_write_reg(0x877D,0x02);
+	ov3640_write_reg(0x877E,0x07);
+	ov3640_write_reg(0x877F,0xBB);
+	ov3640_write_reg(0x8780,0x02);
+	ov3640_write_reg(0x8781,0x0B);
+	ov3640_write_reg(0x8782,0xFE);
+	ov3640_write_reg(0x8783,0xE4);
+	ov3640_write_reg(0x8784,0x93);
+	ov3640_write_reg(0x8785,0xA3);
+	ov3640_write_reg(0x8786,0xF8);
+	ov3640_write_reg(0x8787,0xE4);
+	ov3640_write_reg(0x8788,0x93);
+	ov3640_write_reg(0x8789,0xA3);
+	ov3640_write_reg(0x878A,0x40);
+	ov3640_write_reg(0x878B,0x03);
+	ov3640_write_reg(0x878C,0xF6);
+	ov3640_write_reg(0x878D,0x80);
+	ov3640_write_reg(0x878E,0x01);
+	ov3640_write_reg(0x878F,0xF2);
+	ov3640_write_reg(0x8790,0x08);
+	ov3640_write_reg(0x8791,0xDF);
+	ov3640_write_reg(0x8792,0xF4);
+	ov3640_write_reg(0x8793,0x80);
+	ov3640_write_reg(0x8794,0x29);
+	ov3640_write_reg(0x8795,0xE4);
+	ov3640_write_reg(0x8796,0x93);
+	ov3640_write_reg(0x8797,0xA3);
+	ov3640_write_reg(0x8798,0xF8);
+	ov3640_write_reg(0x8799,0x54);
+	ov3640_write_reg(0x879A,0x07);
+	ov3640_write_reg(0x879B,0x24);
+	ov3640_write_reg(0x879C,0x0C);
+	ov3640_write_reg(0x879D,0xC8);
+	ov3640_write_reg(0x879E,0xC3);
+	ov3640_write_reg(0x879F,0x33);
+	ov3640_write_reg(0x87A0,0xC4);
+	ov3640_write_reg(0x87A1,0x54);
+	ov3640_write_reg(0x87A2,0x0F);
+	ov3640_write_reg(0x87A3,0x44);
+	ov3640_write_reg(0x87A4,0x20);
+	ov3640_write_reg(0x87A5,0xC8);
+	ov3640_write_reg(0x87A6,0x83);
+	ov3640_write_reg(0x87A7,0x40);
+	ov3640_write_reg(0x87A8,0x04);
+	ov3640_write_reg(0x87A9,0xF4);
+	ov3640_write_reg(0x87AA,0x56);
+	ov3640_write_reg(0x87AB,0x80);
+	ov3640_write_reg(0x87AC,0x01);
+	ov3640_write_reg(0x87AD,0x46);
+	ov3640_write_reg(0x87AE,0xF6);
+	ov3640_write_reg(0x87AF,0xDF);
+	ov3640_write_reg(0x87B0,0xE4);
+	ov3640_write_reg(0x87B1,0x80);
+	ov3640_write_reg(0x87B2,0x0B);
+	ov3640_write_reg(0x87B3,0x01);
+	ov3640_write_reg(0x87B4,0x02);
+	ov3640_write_reg(0x87B5,0x04);
+	ov3640_write_reg(0x87B6,0x08);
+	ov3640_write_reg(0x87B7,0x10);
+	ov3640_write_reg(0x87B8,0x20);
+	ov3640_write_reg(0x87B9,0x40);
+	ov3640_write_reg(0x87BA,0x80);
+	ov3640_write_reg(0x87BB,0x90);
+	ov3640_write_reg(0x87BC,0x0D);
+	ov3640_write_reg(0x87BD,0x39);
+	ov3640_write_reg(0x87BE,0xE4);
+	ov3640_write_reg(0x87BF,0x7E);
+	ov3640_write_reg(0x87C0,0x01);
+	ov3640_write_reg(0x87C1,0x93);
+	ov3640_write_reg(0x87C2,0x60);
+	ov3640_write_reg(0x87C3,0xBC);
+	ov3640_write_reg(0x87C4,0xA3);
+	ov3640_write_reg(0x87C5,0xFF);
+	ov3640_write_reg(0x87C6,0x54);
+	ov3640_write_reg(0x87C7,0x3F);
+	ov3640_write_reg(0x87C8,0x30);
+	ov3640_write_reg(0x87C9,0xE5);
+	ov3640_write_reg(0x87CA,0x09);
+	ov3640_write_reg(0x87CB,0x54);
+	ov3640_write_reg(0x87CC,0x1F);
+	ov3640_write_reg(0x87CD,0xFE);
+	ov3640_write_reg(0x87CE,0xE4);
+	ov3640_write_reg(0x87CF,0x93);
+	ov3640_write_reg(0x87D0,0xA3);
+	ov3640_write_reg(0x87D1,0x60);
+	ov3640_write_reg(0x87D2,0x01);
+	ov3640_write_reg(0x87D3,0x0E);
+	ov3640_write_reg(0x87D4,0xCF);
+	ov3640_write_reg(0x87D5,0x54);
+	ov3640_write_reg(0x87D6,0xC0);
+	ov3640_write_reg(0x87D7,0x25);
+	ov3640_write_reg(0x87D8,0xE0);
+	ov3640_write_reg(0x87D9,0x60);
+	ov3640_write_reg(0x87DA,0xA8);
+	ov3640_write_reg(0x87DB,0x40);
+	ov3640_write_reg(0x87DC,0xB8);
+	ov3640_write_reg(0x87DD,0xE4);
+	ov3640_write_reg(0x87DE,0x93);
+	ov3640_write_reg(0x87DF,0xA3);
+	ov3640_write_reg(0x87E0,0xFA);
+	ov3640_write_reg(0x87E1,0xE4);
+	ov3640_write_reg(0x87E2,0x93);
+	ov3640_write_reg(0x87E3,0xA3);
+	ov3640_write_reg(0x87E4,0xF8);
+	ov3640_write_reg(0x87E5,0xE4);
+	ov3640_write_reg(0x87E6,0x93);
+	ov3640_write_reg(0x87E7,0xA3);
+	ov3640_write_reg(0x87E8,0xC8);
+	ov3640_write_reg(0x87E9,0xC5);
+	ov3640_write_reg(0x87EA,0x82);
+	ov3640_write_reg(0x87EB,0xC8);
+	ov3640_write_reg(0x87EC,0xCA);
+	ov3640_write_reg(0x87ED,0xC5);
+	ov3640_write_reg(0x87EE,0x83);
+	ov3640_write_reg(0x87EF,0xCA);
+	ov3640_write_reg(0x87F0,0xF0);
+	ov3640_write_reg(0x87F1,0xA3);
+	ov3640_write_reg(0x87F2,0xC8);
+	ov3640_write_reg(0x87F3,0xC5);
+	ov3640_write_reg(0x87F4,0x82);
+	ov3640_write_reg(0x87F5,0xC8);
+	ov3640_write_reg(0x87F6,0xCA);
+	ov3640_write_reg(0x87F7,0xC5);
+	ov3640_write_reg(0x87F8,0x83);
+	ov3640_write_reg(0x87F9,0xCA);
+	ov3640_write_reg(0x87FA,0xDF);
+	ov3640_write_reg(0x87FB,0xE9);
+	ov3640_write_reg(0x87FC,0xDE);
+	ov3640_write_reg(0x87FD,0xE7);
+	ov3640_write_reg(0x87FE,0x80);
+	ov3640_write_reg(0x87FF,0xBE);
+	ov3640_write_reg(0x8800,0xC0);
+	ov3640_write_reg(0x8801,0xE0);
+	ov3640_write_reg(0x8802,0xC0);
+	ov3640_write_reg(0x8803,0xF0);
+	ov3640_write_reg(0x8804,0xC0);
+	ov3640_write_reg(0x8805,0x83);
+	ov3640_write_reg(0x8806,0xC0);
+	ov3640_write_reg(0x8807,0x82);
+	ov3640_write_reg(0x8808,0xC0);
+	ov3640_write_reg(0x8809,0xD0);
+	ov3640_write_reg(0x880A,0x75);
+	ov3640_write_reg(0x880B,0xD0);
+	ov3640_write_reg(0x880C,0x00);
+	ov3640_write_reg(0x880D,0xC0);
+	ov3640_write_reg(0x880E,0x00);
+	ov3640_write_reg(0x880F,0xC0);
+	ov3640_write_reg(0x8810,0x01);
+	ov3640_write_reg(0x8811,0xC0);
+	ov3640_write_reg(0x8812,0x02);
+	ov3640_write_reg(0x8813,0xC0);
+	ov3640_write_reg(0x8814,0x03);
+	ov3640_write_reg(0x8815,0xC0);
+	ov3640_write_reg(0x8816,0x04);
+	ov3640_write_reg(0x8817,0xC0);
+	ov3640_write_reg(0x8818,0x05);
+	ov3640_write_reg(0x8819,0xC0);
+	ov3640_write_reg(0x881A,0x06);
+	ov3640_write_reg(0x881B,0xC0);
+	ov3640_write_reg(0x881C,0x07);
+	ov3640_write_reg(0x881D,0x90);
+	ov3640_write_reg(0x881E,0x37);
+	ov3640_write_reg(0x881F,0x08);
+	ov3640_write_reg(0x8820,0xE0);
+	ov3640_write_reg(0x8821,0xF5);
+	ov3640_write_reg(0x8822,0x08);
+	ov3640_write_reg(0x8823,0xE5);
+	ov3640_write_reg(0x8824,0x08);
+	ov3640_write_reg(0x8825,0x30);
+	ov3640_write_reg(0x8826,0xE3);
+	ov3640_write_reg(0x8827,0x28);
+	ov3640_write_reg(0x8828,0x85);
+	ov3640_write_reg(0x8829,0x3C);
+	ov3640_write_reg(0x882A,0x37);
+	ov3640_write_reg(0x882B,0x85);
+	ov3640_write_reg(0x882C,0x3D);
+	ov3640_write_reg(0x882D,0x38);
+	ov3640_write_reg(0x882E,0x85);
+	ov3640_write_reg(0x882F,0x3E);
+	ov3640_write_reg(0x8830,0x39);
+	ov3640_write_reg(0x8831,0x85);
+	ov3640_write_reg(0x8832,0x3F);
+	ov3640_write_reg(0x8833,0x3A);
+	ov3640_write_reg(0x8834,0x75);
+	ov3640_write_reg(0x8835,0x09);
+	ov3640_write_reg(0x8836,0x00);
+	ov3640_write_reg(0x8837,0x75);
+	ov3640_write_reg(0x8838,0x0A);
+	ov3640_write_reg(0x8839,0x00);
+	ov3640_write_reg(0x883A,0x12);
+	ov3640_write_reg(0x883B,0x08);
+	ov3640_write_reg(0x883C,0x89);
+	ov3640_write_reg(0x883D,0x8E);
+	ov3640_write_reg(0x883E,0x3C);
+	ov3640_write_reg(0x883F,0x8F);
+	ov3640_write_reg(0x8840,0x3D);
+	ov3640_write_reg(0x8841,0x75);
+	ov3640_write_reg(0x8842,0x09);
+	ov3640_write_reg(0x8843,0x00);
+	ov3640_write_reg(0x8844,0x75);
+	ov3640_write_reg(0x8845,0x0A);
+	ov3640_write_reg(0x8846,0x01);
+	ov3640_write_reg(0x8847,0x12);
+	ov3640_write_reg(0x8848,0x08);
+	ov3640_write_reg(0x8849,0x89);
+	ov3640_write_reg(0x884A,0x8E);
+	ov3640_write_reg(0x884B,0x3E);
+	ov3640_write_reg(0x884C,0x8F);
+	ov3640_write_reg(0x884D,0x3F);
+	ov3640_write_reg(0x884E,0xD2);
+	ov3640_write_reg(0x884F,0x09);
+	ov3640_write_reg(0x8850,0xE5);
+	ov3640_write_reg(0x8851,0x08);
+	ov3640_write_reg(0x8852,0x30);
+	ov3640_write_reg(0x8853,0xE1);
+	ov3640_write_reg(0x8854,0x08);
+	ov3640_write_reg(0x8855,0x90);
+	ov3640_write_reg(0x8856,0x3F);
+	ov3640_write_reg(0x8857,0x00);
+	ov3640_write_reg(0x8858,0xE0);
+	ov3640_write_reg(0x8859,0xF5);
+	ov3640_write_reg(0x885A,0x4B);
+	ov3640_write_reg(0x885B,0xE4);
+	ov3640_write_reg(0x885C,0xF0);
+	ov3640_write_reg(0x885D,0xE5);
+	ov3640_write_reg(0x885E,0x08);
+	ov3640_write_reg(0x885F,0x30);
+	ov3640_write_reg(0x8860,0xE0);
+	ov3640_write_reg(0x8861,0x06);
+	ov3640_write_reg(0x8862,0x90);
+	ov3640_write_reg(0x8863,0x3F);
+	ov3640_write_reg(0x8864,0x01);
+	ov3640_write_reg(0x8865,0xE5);
+	ov3640_write_reg(0x8866,0x40);
+	ov3640_write_reg(0x8867,0xF0);
+	ov3640_write_reg(0x8868,0x90);
+	ov3640_write_reg(0x8869,0x37);
+	ov3640_write_reg(0x886A,0x08);
+	ov3640_write_reg(0x886B,0xE5);
+	ov3640_write_reg(0x886C,0x08);
+	ov3640_write_reg(0x886D,0xF0);
+	ov3640_write_reg(0x886E,0xD0);
+	ov3640_write_reg(0x886F,0x07);
+	ov3640_write_reg(0x8870,0xD0);
+	ov3640_write_reg(0x8871,0x06);
+	ov3640_write_reg(0x8872,0xD0);
+	ov3640_write_reg(0x8873,0x05);
+	ov3640_write_reg(0x8874,0xD0);
+	ov3640_write_reg(0x8875,0x04);
+	ov3640_write_reg(0x8876,0xD0);
+	ov3640_write_reg(0x8877,0x03);
+	ov3640_write_reg(0x8878,0xD0);
+	ov3640_write_reg(0x8879,0x02);
+	ov3640_write_reg(0x887A,0xD0);
+	ov3640_write_reg(0x887B,0x01);
+	ov3640_write_reg(0x887C,0xD0);
+	ov3640_write_reg(0x887D,0x00);
+	ov3640_write_reg(0x887E,0xD0);
+	ov3640_write_reg(0x887F,0xD0);
+	ov3640_write_reg(0x8880,0xD0);
+	ov3640_write_reg(0x8881,0x82);
+	ov3640_write_reg(0x8882,0xD0);
+	ov3640_write_reg(0x8883,0x83);
+	ov3640_write_reg(0x8884,0xD0);
+	ov3640_write_reg(0x8885,0xF0);
+	ov3640_write_reg(0x8886,0xD0);
+	ov3640_write_reg(0x8887,0xE0);
+	ov3640_write_reg(0x8888,0x32);
+	ov3640_write_reg(0x8889,0xE5);
+	ov3640_write_reg(0x888A,0x0A);
+	ov3640_write_reg(0x888B,0x70);
+	ov3640_write_reg(0x888C,0x36);
+	ov3640_write_reg(0x888D,0xE5);
+	ov3640_write_reg(0x888E,0x09);
+	ov3640_write_reg(0x888F,0x75);
+	ov3640_write_reg(0x8890,0xF0);
+	ov3640_write_reg(0x8891,0x08);
+	ov3640_write_reg(0x8892,0xA4);
+	ov3640_write_reg(0x8893,0xFF);
+	ov3640_write_reg(0x8894,0x24);
+	ov3640_write_reg(0x8895,0x80);
+	ov3640_write_reg(0x8896,0x90);
+	ov3640_write_reg(0x8897,0x3A);
+	ov3640_write_reg(0x8898,0x00);
+	ov3640_write_reg(0x8899,0xF0);
+	ov3640_write_reg(0x889A,0x90);
+	ov3640_write_reg(0x889B,0x3A);
+	ov3640_write_reg(0x889C,0x03);
+	ov3640_write_reg(0x889D,0xE0);
+	ov3640_write_reg(0x889E,0xF5);
+	ov3640_write_reg(0x889F,0x0B);
+	ov3640_write_reg(0x88A0,0xEF);
+	ov3640_write_reg(0x88A1,0x24);
+	ov3640_write_reg(0x88A2,0x81);
+	ov3640_write_reg(0x88A3,0x90);
+	ov3640_write_reg(0x88A4,0x3A);
+	ov3640_write_reg(0x88A5,0x00);
+	ov3640_write_reg(0x88A6,0xF0);
+	ov3640_write_reg(0x88A7,0x90);
+	ov3640_write_reg(0x88A8,0x3A);
+	ov3640_write_reg(0x88A9,0x03);
+	ov3640_write_reg(0x88AA,0xE0);
+	ov3640_write_reg(0x88AB,0xFC);
+	ov3640_write_reg(0x88AC,0xE5);
+	ov3640_write_reg(0x88AD,0x09);
+	ov3640_write_reg(0x88AE,0x75);
+	ov3640_write_reg(0x88AF,0xF0);
+	ov3640_write_reg(0x88B0,0x08);
+	ov3640_write_reg(0x88B1,0xA4);
+	ov3640_write_reg(0x88B2,0xFF);
+	ov3640_write_reg(0x88B3,0x24);
+	ov3640_write_reg(0x88B4,0x82);
+	ov3640_write_reg(0x88B5,0x90);
+	ov3640_write_reg(0x88B6,0x3A);
+	ov3640_write_reg(0x88B7,0x00);
+	ov3640_write_reg(0x88B8,0xF0);
+	ov3640_write_reg(0x88B9,0x90);
+	ov3640_write_reg(0x88BA,0x3A);
+	ov3640_write_reg(0x88BB,0x03);
+	ov3640_write_reg(0x88BC,0xE0);
+	ov3640_write_reg(0x88BD,0xFD);
+	ov3640_write_reg(0x88BE,0xEF);
+	ov3640_write_reg(0x88BF,0x24);
+	ov3640_write_reg(0x88C0,0x83);
+	ov3640_write_reg(0x88C1,0x80);
+	ov3640_write_reg(0x88C2,0x3A);
+	ov3640_write_reg(0x88C3,0xE5);
+	ov3640_write_reg(0x88C4,0x0A);
+	ov3640_write_reg(0x88C5,0x64);
+	ov3640_write_reg(0x88C6,0x01);
+	ov3640_write_reg(0x88C7,0x70);
+	ov3640_write_reg(0x88C8,0x3C);
+	ov3640_write_reg(0x88C9,0xE5);
+	ov3640_write_reg(0x88CA,0x09);
+	ov3640_write_reg(0x88CB,0x75);
+	ov3640_write_reg(0x88CC,0xF0);
+	ov3640_write_reg(0x88CD,0x08);
+	ov3640_write_reg(0x88CE,0xA4);
+	ov3640_write_reg(0x88CF,0xFF);
+	ov3640_write_reg(0x88D0,0x24);
+	ov3640_write_reg(0x88D1,0x84);
+	ov3640_write_reg(0x88D2,0x90);
+	ov3640_write_reg(0x88D3,0x3A);
+	ov3640_write_reg(0x88D4,0x00);
+	ov3640_write_reg(0x88D5,0xF0);
+	ov3640_write_reg(0x88D6,0x90);
+	ov3640_write_reg(0x88D7,0x3A);
+	ov3640_write_reg(0x88D8,0x03);
+	ov3640_write_reg(0x88D9,0xE0);
+	ov3640_write_reg(0x88DA,0xF5);
+	ov3640_write_reg(0x88DB,0x0B);
+	ov3640_write_reg(0x88DC,0xEF);
+	ov3640_write_reg(0x88DD,0x24);
+	ov3640_write_reg(0x88DE,0x85);
+	ov3640_write_reg(0x88DF,0x90);
+	ov3640_write_reg(0x88E0,0x3A);
+	ov3640_write_reg(0x88E1,0x00);
+	ov3640_write_reg(0x88E2,0xF0);
+	ov3640_write_reg(0x88E3,0x90);
+	ov3640_write_reg(0x88E4,0x3A);
+	ov3640_write_reg(0x88E5,0x03);
+	ov3640_write_reg(0x88E6,0xE0);
+	ov3640_write_reg(0x88E7,0xFC);
+	ov3640_write_reg(0x88E8,0xE5);
+	ov3640_write_reg(0x88E9,0x09);
+	ov3640_write_reg(0x88EA,0x75);
+	ov3640_write_reg(0x88EB,0xF0);
+	ov3640_write_reg(0x88EC,0x08);
+	ov3640_write_reg(0x88ED,0xA4);
+	ov3640_write_reg(0x88EE,0xFF);
+	ov3640_write_reg(0x88EF,0x24);
+	ov3640_write_reg(0x88F0,0x86);
+	ov3640_write_reg(0x88F1,0x90);
+	ov3640_write_reg(0x88F2,0x3A);
+	ov3640_write_reg(0x88F3,0x00);
+	ov3640_write_reg(0x88F4,0xF0);
+	ov3640_write_reg(0x88F5,0x90);
+	ov3640_write_reg(0x88F6,0x3A);
+	ov3640_write_reg(0x88F7,0x03);
+	ov3640_write_reg(0x88F8,0xE0);
+	ov3640_write_reg(0x88F9,0xFD);
+	ov3640_write_reg(0x88FA,0xEF);
+	ov3640_write_reg(0x88FB,0x24);
+	ov3640_write_reg(0x88FC,0x87);
+	ov3640_write_reg(0x88FD,0x90);
+	ov3640_write_reg(0x88FE,0x3A);
+	ov3640_write_reg(0x88FF,0x00);
+	ov3640_write_reg(0x8900,0xF0);
+	ov3640_write_reg(0x8901,0x90);
+	ov3640_write_reg(0x8902,0x3A);
+	ov3640_write_reg(0x8903,0x03);
+	ov3640_write_reg(0x8904,0xE0);
+	ov3640_write_reg(0x8905,0xED);
+	ov3640_write_reg(0x8906,0xFE);
+	ov3640_write_reg(0x8907,0xEC);
+	ov3640_write_reg(0x8908,0xFB);
+	ov3640_write_reg(0x8909,0xEB);
+	ov3640_write_reg(0x890A,0xFF);
+	ov3640_write_reg(0x890B,0x22);
+	ov3640_write_reg(0x890C,0x85);
+	ov3640_write_reg(0x890D,0x3C);
+	ov3640_write_reg(0x890E,0x33);
+	ov3640_write_reg(0x890F,0x85);
+	ov3640_write_reg(0x8910,0x3D);
+	ov3640_write_reg(0x8911,0x34);
+	ov3640_write_reg(0x8912,0xE5);
+	ov3640_write_reg(0x8913,0x31);
+	ov3640_write_reg(0x8914,0xD3);
+	ov3640_write_reg(0x8915,0x94);
+	ov3640_write_reg(0x8916,0x02);
+	ov3640_write_reg(0x8917,0x40);
+	ov3640_write_reg(0x8918,0x4F);
+	ov3640_write_reg(0x8919,0xE5);
+	ov3640_write_reg(0x891A,0x3D);
+	ov3640_write_reg(0x891B,0x95);
+	ov3640_write_reg(0x891C,0x34);
+	ov3640_write_reg(0x891D,0xFF);
+	ov3640_write_reg(0x891E,0xE5);
+	ov3640_write_reg(0x891F,0x3C);
+	ov3640_write_reg(0x8920,0x95);
+	ov3640_write_reg(0x8921,0x33);
+	ov3640_write_reg(0x8922,0xFE);
+	ov3640_write_reg(0x8923,0x12);
+	ov3640_write_reg(0x8924,0x0D);
+	ov3640_write_reg(0x8925,0x27);
+	ov3640_write_reg(0x8926,0xD3);
+	ov3640_write_reg(0x8927,0xEF);
+	ov3640_write_reg(0x8928,0x94);
+	ov3640_write_reg(0x8929,0x40);
+	ov3640_write_reg(0x892A,0xEE);
+	ov3640_write_reg(0x892B,0x64);
+	ov3640_write_reg(0x892C,0x80);
+	ov3640_write_reg(0x892D,0x94);
+	ov3640_write_reg(0x892E,0x80);
+	ov3640_write_reg(0x892F,0x50);
+	ov3640_write_reg(0x8930,0x05);
+	ov3640_write_reg(0x8931,0x12);
+	ov3640_write_reg(0x8932,0x0D);
+	ov3640_write_reg(0x8933,0x4A);
+	ov3640_write_reg(0x8934,0x50);
+	ov3640_write_reg(0x8935,0x0A);
+	ov3640_write_reg(0x8936,0x85);
+	ov3640_write_reg(0x8937,0x3C);
+	ov3640_write_reg(0x8938,0x33);
+	ov3640_write_reg(0x8939,0x85);
+	ov3640_write_reg(0x893A,0x3D);
+	ov3640_write_reg(0x893B,0x34);
+	ov3640_write_reg(0x893C,0xE4);
+	ov3640_write_reg(0x893D,0xF5);
+	ov3640_write_reg(0x893E,0x32);
+	ov3640_write_reg(0x893F,0x22);
+	ov3640_write_reg(0x8940,0x05);
+	ov3640_write_reg(0x8941,0x32);
+	ov3640_write_reg(0x8942,0xE5);
+	ov3640_write_reg(0x8943,0x32);
+	ov3640_write_reg(0x8944,0xD3);
+	ov3640_write_reg(0x8945,0x94);
+	ov3640_write_reg(0x8946,0x02);
+	ov3640_write_reg(0x8947,0x40);
+	ov3640_write_reg(0x8948,0x43);
+	ov3640_write_reg(0x8949,0xE4);
+	ov3640_write_reg(0x894A,0xF5);
+	ov3640_write_reg(0x894B,0x31);
+	ov3640_write_reg(0x894C,0xF5);
+	ov3640_write_reg(0x894D,0x32);
+	ov3640_write_reg(0x894E,0x75);
+	ov3640_write_reg(0x894F,0x40);
+	ov3640_write_reg(0x8950,0x69);
+	ov3640_write_reg(0x8951,0xF5);
+	ov3640_write_reg(0x8952,0x47);
+	ov3640_write_reg(0x8953,0xF5);
+	ov3640_write_reg(0x8954,0x48);
+	ov3640_write_reg(0x8955,0x85);
+	ov3640_write_reg(0x8956,0x47);
+	ov3640_write_reg(0x8957,0x13);
+	ov3640_write_reg(0x8958,0x85);
+	ov3640_write_reg(0x8959,0x48);
+	ov3640_write_reg(0x895A,0x14);
+	ov3640_write_reg(0x895B,0x12);
+	ov3640_write_reg(0x895C,0x0B);
+	ov3640_write_reg(0x895D,0x86);
+	ov3640_write_reg(0x895E,0x12);
+	ov3640_write_reg(0x895F,0x0A);
+	ov3640_write_reg(0x8960,0x7D);
+	ov3640_write_reg(0x8961,0x90);
+	ov3640_write_reg(0x8962,0x3F);
+	ov3640_write_reg(0x8963,0x01);
+	ov3640_write_reg(0x8964,0xE5);
+	ov3640_write_reg(0x8965,0x40);
+	ov3640_write_reg(0x8966,0xF0);
+	ov3640_write_reg(0x8967,0x22);
+	ov3640_write_reg(0x8968,0xC3);
+	ov3640_write_reg(0x8969,0xE5);
+	ov3640_write_reg(0x896A,0x3D);
+	ov3640_write_reg(0x896B,0x95);
+	ov3640_write_reg(0x896C,0x44);
+	ov3640_write_reg(0x896D,0xFF);
+	ov3640_write_reg(0x896E,0xE5);
+	ov3640_write_reg(0x896F,0x3C);
+	ov3640_write_reg(0x8970,0x95);
+	ov3640_write_reg(0x8971,0x43);
+	ov3640_write_reg(0x8972,0xFE);
+	ov3640_write_reg(0x8973,0x12);
+	ov3640_write_reg(0x8974,0x0D);
+	ov3640_write_reg(0x8975,0x27);
+	ov3640_write_reg(0x8976,0xD3);
+	ov3640_write_reg(0x8977,0xEF);
+	ov3640_write_reg(0x8978,0x94);
+	ov3640_write_reg(0x8979,0x40);
+	ov3640_write_reg(0x897A,0xEE);
+	ov3640_write_reg(0x897B,0x64);
+	ov3640_write_reg(0x897C,0x80);
+	ov3640_write_reg(0x897D,0x94);
+	ov3640_write_reg(0x897E,0x80);
+	ov3640_write_reg(0x897F,0x50);
+	ov3640_write_reg(0x8980,0x05);
+	ov3640_write_reg(0x8981,0x12);
+	ov3640_write_reg(0x8982,0x0D);
+	ov3640_write_reg(0x8983,0x4A);
+	ov3640_write_reg(0x8984,0x50);
+	ov3640_write_reg(0x8985,0x03);
+	ov3640_write_reg(0x8986,0x05);
+	ov3640_write_reg(0x8987,0x31);
+	ov3640_write_reg(0x8988,0x22);
+	ov3640_write_reg(0x8989,0xE4);
+	ov3640_write_reg(0x898A,0xF5);
+	ov3640_write_reg(0x898B,0x31);
+	ov3640_write_reg(0x898C,0x22);
+	ov3640_write_reg(0x898D,0x7E);
+	ov3640_write_reg(0x898E,0x08);
+	ov3640_write_reg(0x898F,0xE5);
+	ov3640_write_reg(0x8990,0x18);
+	ov3640_write_reg(0x8991,0x33);
+	ov3640_write_reg(0x8992,0x92);
+	ov3640_write_reg(0x8993,0x01);
+	ov3640_write_reg(0x8994,0x90);
+	ov3640_write_reg(0x8995,0x30);
+	ov3640_write_reg(0x8996,0xB4);
+	ov3640_write_reg(0x8997,0xE5);
+	ov3640_write_reg(0x8998,0x20);
+	ov3640_write_reg(0x8999,0xF0);
+	ov3640_write_reg(0x899A,0x7F);
+	ov3640_write_reg(0x899B,0x0A);
+	ov3640_write_reg(0x899C,0xAD);
+	ov3640_write_reg(0x899D,0x07);
+	ov3640_write_reg(0x899E,0x1F);
+	ov3640_write_reg(0x899F,0xED);
+	ov3640_write_reg(0x89A0,0x70);
+	ov3640_write_reg(0x89A1,0xFA);
+	ov3640_write_reg(0x89A2,0xE5);
+	ov3640_write_reg(0x89A3,0x18);
+	ov3640_write_reg(0x89A4,0x25);
+	ov3640_write_reg(0x89A5,0xE0);
+	ov3640_write_reg(0x89A6,0xF5);
+	ov3640_write_reg(0x89A7,0x18);
+	ov3640_write_reg(0x89A8,0xD2);
+	ov3640_write_reg(0x89A9,0x00);
+	ov3640_write_reg(0x89AA,0x90);
+	ov3640_write_reg(0x89AB,0x30);
+	ov3640_write_reg(0x89AC,0xB4);
+	ov3640_write_reg(0x89AD,0xE5);
+	ov3640_write_reg(0x89AE,0x20);
+	ov3640_write_reg(0x89AF,0xF0);
+	ov3640_write_reg(0x89B0,0x7F);
+	ov3640_write_reg(0x89B1,0x0A);
+	ov3640_write_reg(0x89B2,0xAD);
+	ov3640_write_reg(0x89B3,0x07);
+	ov3640_write_reg(0x89B4,0x1F);
+	ov3640_write_reg(0x89B5,0xED);
+	ov3640_write_reg(0x89B6,0x70);
+	ov3640_write_reg(0x89B7,0xFA);
+	ov3640_write_reg(0x89B8,0xC2);
+	ov3640_write_reg(0x89B9,0x00);
+	ov3640_write_reg(0x89BA,0x90);
+	ov3640_write_reg(0x89BB,0x30);
+	ov3640_write_reg(0x89BC,0xB4);
+	ov3640_write_reg(0x89BD,0xE5);
+	ov3640_write_reg(0x89BE,0x20);
+	ov3640_write_reg(0x89BF,0xF0);
+	ov3640_write_reg(0x89C0,0xDE);
+	ov3640_write_reg(0x89C1,0xCD);
+	ov3640_write_reg(0x89C2,0x90);
+	ov3640_write_reg(0x89C3,0x30);
+	ov3640_write_reg(0x89C4,0xB1);
+	ov3640_write_reg(0x89C5,0xE0);
+	ov3640_write_reg(0x89C6,0x54);
+	ov3640_write_reg(0x89C7,0x7F);
+	ov3640_write_reg(0x89C8,0xF0);
+	ov3640_write_reg(0x89C9,0x7F);
+	ov3640_write_reg(0x89CA,0x05);
+	ov3640_write_reg(0x89CB,0xAE);
+	ov3640_write_reg(0x89CC,0x07);
+	ov3640_write_reg(0x89CD,0x1F);
+	ov3640_write_reg(0x89CE,0xEE);
+	ov3640_write_reg(0x89CF,0x70);
+	ov3640_write_reg(0x89D0,0xFA);
+	ov3640_write_reg(0x89D1,0xD2);
+	ov3640_write_reg(0x89D2,0x00);
+	ov3640_write_reg(0x89D3,0x90);
+	ov3640_write_reg(0x89D4,0x30);
+	ov3640_write_reg(0x89D5,0xB4);
+	ov3640_write_reg(0x89D6,0xE5);
+	ov3640_write_reg(0x89D7,0x20);
+	ov3640_write_reg(0x89D8,0xF0);
+	ov3640_write_reg(0x89D9,0x7F);
+	ov3640_write_reg(0x89DA,0x05);
+	ov3640_write_reg(0x89DB,0xAE);
+	ov3640_write_reg(0x89DC,0x07);
+	ov3640_write_reg(0x89DD,0x1F);
+	ov3640_write_reg(0x89DE,0xEE);
+	ov3640_write_reg(0x89DF,0x70);
+	ov3640_write_reg(0x89E0,0xFA);
+	ov3640_write_reg(0x89E1,0x90);
+	ov3640_write_reg(0x89E2,0x30);
+	ov3640_write_reg(0x89E3,0xB5);
+	ov3640_write_reg(0x89E4,0xE0);
+	ov3640_write_reg(0x89E5,0x54);
+	ov3640_write_reg(0x89E6,0x02);
+	ov3640_write_reg(0x89E7,0xFE);
+	ov3640_write_reg(0x89E8,0xC2);
+	ov3640_write_reg(0x89E9,0x00);
+	ov3640_write_reg(0x89EA,0x90);
+	ov3640_write_reg(0x89EB,0x30);
+	ov3640_write_reg(0x89EC,0xB4);
+	ov3640_write_reg(0x89ED,0xE5);
+	ov3640_write_reg(0x89EE,0x20);
+	ov3640_write_reg(0x89EF,0xF0);
+	ov3640_write_reg(0x89F0,0x90);
+	ov3640_write_reg(0x89F1,0x30);
+	ov3640_write_reg(0x89F2,0xB1);
+	ov3640_write_reg(0x89F3,0xE0);
+	ov3640_write_reg(0x89F4,0x44);
+	ov3640_write_reg(0x89F5,0x80);
+	ov3640_write_reg(0x89F6,0xF0);
+	ov3640_write_reg(0x89F7,0x7F);
+	ov3640_write_reg(0x89F8,0x05);
+	ov3640_write_reg(0x89F9,0xAD);
+	ov3640_write_reg(0x89FA,0x07);
+	ov3640_write_reg(0x89FB,0x1F);
+	ov3640_write_reg(0x89FC,0xED);
+	ov3640_write_reg(0x89FD,0x70);
+	ov3640_write_reg(0x89FE,0xFA);
+	ov3640_write_reg(0x89FF,0xBE);
+	ov3640_write_reg(0x8A00,0x02);
+	ov3640_write_reg(0x8A01,0x02);
+	ov3640_write_reg(0x8A02,0xC3);
+	ov3640_write_reg(0x8A03,0x22);
+	ov3640_write_reg(0x8A04,0xD3);
+	ov3640_write_reg(0x8A05,0x22);
+	ov3640_write_reg(0x8A06,0xC2);
+	ov3640_write_reg(0x8A07,0x8C);
+	ov3640_write_reg(0x8A08,0x75);
+	ov3640_write_reg(0x8A09,0x89);
+	ov3640_write_reg(0x8A0A,0x03);
+	ov3640_write_reg(0x8A0B,0xE4);
+	ov3640_write_reg(0x8A0C,0xF5);
+	ov3640_write_reg(0x8A0D,0xA8);
+	ov3640_write_reg(0x8A0E,0x90);
+	ov3640_write_reg(0x8A0F,0x31);
+	ov3640_write_reg(0x8A10,0x00);
+	ov3640_write_reg(0x8A11,0xE0);
+	ov3640_write_reg(0x8A12,0x54);
+	ov3640_write_reg(0x8A13,0xFE);
+	ov3640_write_reg(0x8A14,0xF0);
+	ov3640_write_reg(0x8A15,0xE0);
+	ov3640_write_reg(0x8A16,0x54);
+	ov3640_write_reg(0x8A17,0xFD);
+	ov3640_write_reg(0x8A18,0xF0);
+	ov3640_write_reg(0x8A19,0xA3);
+	ov3640_write_reg(0x8A1A,0xE4);
+	ov3640_write_reg(0x8A1B,0xF0);
+	ov3640_write_reg(0x8A1C,0x90);
+	ov3640_write_reg(0x8A1D,0x33);
+	ov3640_write_reg(0x8A1E,0xB0);
+	ov3640_write_reg(0x8A1F,0xF0);
+	ov3640_write_reg(0x8A20,0xA3);
+	ov3640_write_reg(0x8A21,0x04);
+	ov3640_write_reg(0x8A22,0xF0);
+	ov3640_write_reg(0x8A23,0xA3);
+	ov3640_write_reg(0x8A24,0xF0);
+	ov3640_write_reg(0x8A25,0x90);
+	ov3640_write_reg(0x8A26,0x33);
+	ov3640_write_reg(0x8A27,0x00);
+	ov3640_write_reg(0x8A28,0xE0);
+	ov3640_write_reg(0x8A29,0x44);
+	ov3640_write_reg(0x8A2A,0x02);
+	ov3640_write_reg(0x8A2B,0xF0);
+	ov3640_write_reg(0x8A2C,0xE0);
+	ov3640_write_reg(0x8A2D,0x54);
+	ov3640_write_reg(0x8A2E,0xBF);
+	ov3640_write_reg(0x8A2F,0xF0);
+	ov3640_write_reg(0x8A30,0xD2);
+	ov3640_write_reg(0x8A31,0x08);
+	ov3640_write_reg(0x8A32,0x12);
+	ov3640_write_reg(0x8A33,0x0C);
+	ov3640_write_reg(0x8A34,0xD6);
+	ov3640_write_reg(0x8A35,0x90);
+	ov3640_write_reg(0x8A36,0x30);
+	ov3640_write_reg(0x8A37,0xB2);
+	ov3640_write_reg(0x8A38,0xE0);
+	ov3640_write_reg(0x8A39,0x44);
+	ov3640_write_reg(0x8A3A,0x10);
+	ov3640_write_reg(0x8A3B,0xF0);
+	ov3640_write_reg(0x8A3C,0x90);
+	ov3640_write_reg(0x8A3D,0x30);
+	ov3640_write_reg(0x8A3E,0xB4);
+	ov3640_write_reg(0x8A3F,0xE0);
+	ov3640_write_reg(0x8A40,0xF5);
+	ov3640_write_reg(0x8A41,0x20);
+	ov3640_write_reg(0x8A42,0x90);
+	ov3640_write_reg(0x8A43,0x39);
+	ov3640_write_reg(0x8A44,0x01);
+	ov3640_write_reg(0x8A45,0x74);
+	ov3640_write_reg(0x8A46,0x35);
+	ov3640_write_reg(0x8A47,0xF0);
+	ov3640_write_reg(0x8A48,0x90);
+	ov3640_write_reg(0x8A49,0x39);
+	ov3640_write_reg(0x8A4A,0x00);
+	ov3640_write_reg(0x8A4B,0x74);
+	ov3640_write_reg(0x8A4C,0x20);
+	ov3640_write_reg(0x8A4D,0xF0);
+	ov3640_write_reg(0x8A4E,0x90);
+	ov3640_write_reg(0x8A4F,0x37);
+	ov3640_write_reg(0x8A50,0x00);
+	ov3640_write_reg(0x8A51,0x74);
+	ov3640_write_reg(0x8A52,0xFF);
+	ov3640_write_reg(0x8A53,0xF0);
+	ov3640_write_reg(0x8A54,0xA3);
+	ov3640_write_reg(0x8A55,0xF0);
+	ov3640_write_reg(0x8A56,0x90);
+	ov3640_write_reg(0x8A57,0x37);
+	ov3640_write_reg(0x8A58,0x00);
+	ov3640_write_reg(0x8A59,0xE0);
+	ov3640_write_reg(0x8A5A,0x54);
+	ov3640_write_reg(0x8A5B,0xF7);
+	ov3640_write_reg(0x8A5C,0xF0);
+	ov3640_write_reg(0x8A5D,0x90);
+	ov3640_write_reg(0x8A5E,0x31);
+	ov3640_write_reg(0x8A5F,0x0F);
+	ov3640_write_reg(0x8A60,0x74);
+	ov3640_write_reg(0x8A61,0x3F);
+	ov3640_write_reg(0x8A62,0xF0);
+	ov3640_write_reg(0x8A63,0xA3);
+	ov3640_write_reg(0x8A64,0xE4);
+	ov3640_write_reg(0x8A65,0xF0);
+	ov3640_write_reg(0x8A66,0xA3);
+	ov3640_write_reg(0x8A67,0x74);
+	ov3640_write_reg(0x8A68,0x3F);
+	ov3640_write_reg(0x8A69,0xF0);
+	ov3640_write_reg(0x8A6A,0xA3);
+	ov3640_write_reg(0x8A6B,0x74);
+	ov3640_write_reg(0x8A6C,0x01);
+	ov3640_write_reg(0x8A6D,0xF0);
+	ov3640_write_reg(0x8A6E,0x90);
+	ov3640_write_reg(0x8A6F,0x37);
+	ov3640_write_reg(0x8A70,0x00);
+	ov3640_write_reg(0x8A71,0xE0);
+	ov3640_write_reg(0x8A72,0x54);
+	ov3640_write_reg(0x8A73,0xFD);
+	ov3640_write_reg(0x8A74,0xF0);
+	ov3640_write_reg(0x8A75,0xE0);
+	ov3640_write_reg(0x8A76,0x54);
+	ov3640_write_reg(0x8A77,0xFE);
+	ov3640_write_reg(0x8A78,0xF0);
+	ov3640_write_reg(0x8A79,0x75);
+	ov3640_write_reg(0x8A7A,0xA8);
+	ov3640_write_reg(0x8A7B,0x01);
+	ov3640_write_reg(0x8A7C,0x22);
+	ov3640_write_reg(0x8A7D,0x85);
+	ov3640_write_reg(0x8A7E,0x40);
+	ov3640_write_reg(0x8A7F,0x0D);
+	ov3640_write_reg(0x8A80,0xE5);
+	ov3640_write_reg(0x8A81,0x0D);
+	ov3640_write_reg(0x8A82,0x12);
+	ov3640_write_reg(0x8A83,0x0C);
+	ov3640_write_reg(0x8A84,0x48);
+	ov3640_write_reg(0x8A85,0x0A);
+	ov3640_write_reg(0x8A86,0xAA);
+	ov3640_write_reg(0x8A87,0x00);
+	ov3640_write_reg(0x8A88,0x0A);
+	ov3640_write_reg(0x8A89,0xAC);
+	ov3640_write_reg(0x8A8A,0x46);
+	ov3640_write_reg(0x8A8B,0x0A);
+	ov3640_write_reg(0x8A8C,0xAA);
+	ov3640_write_reg(0x8A8D,0x47);
+	ov3640_write_reg(0x8A8E,0x0A);
+	ov3640_write_reg(0x8A8F,0xAC);
+	ov3640_write_reg(0x8A90,0x4A);
+	ov3640_write_reg(0x8A91,0x0A);
+	ov3640_write_reg(0x8A92,0xAA);
+	ov3640_write_reg(0x8A93,0x4B);
+	ov3640_write_reg(0x8A94,0x0A);
+	ov3640_write_reg(0x8A95,0xAA);
+	ov3640_write_reg(0x8A96,0x4E);
+	ov3640_write_reg(0x8A97,0x0A);
+	ov3640_write_reg(0x8A98,0xC7);
+	ov3640_write_reg(0x8A99,0x65);
+	ov3640_write_reg(0x8A9A,0x0A);
+	ov3640_write_reg(0x8A9B,0xC7);
+	ov3640_write_reg(0x8A9C,0x69);
+	ov3640_write_reg(0x8A9D,0x0A);
+	ov3640_write_reg(0x8A9E,0xAA);
+	ov3640_write_reg(0x8A9F,0x80);
+	ov3640_write_reg(0x8AA0,0x0A);
+	ov3640_write_reg(0x8AA1,0xB8);
+	ov3640_write_reg(0x8AA2,0xC6);
+	ov3640_write_reg(0x8AA3,0x0A);
+	ov3640_write_reg(0x8AA4,0xB8);
+	ov3640_write_reg(0x8AA5,0xCA);
+	ov3640_write_reg(0x8AA6,0x00);
+	ov3640_write_reg(0x8AA7,0x00);
+	ov3640_write_reg(0x8AA8,0x0A);
+	ov3640_write_reg(0x8AA9,0xAA);
+	ov3640_write_reg(0x8AAA,0x80);
+	ov3640_write_reg(0x8AAB,0x30);
+	ov3640_write_reg(0x8AAC,0x90);
+	ov3640_write_reg(0x8AAD,0x33);
+	ov3640_write_reg(0x8AAE,0xB3);
+	ov3640_write_reg(0x8AAF,0xE4);
+	ov3640_write_reg(0x8AB0,0xF0);
+	ov3640_write_reg(0x8AB1,0xA3);
+	ov3640_write_reg(0x8AB2,0xF0);
+	ov3640_write_reg(0x8AB3,0xA3);
+	ov3640_write_reg(0x8AB4,0xF0);
+	ov3640_write_reg(0x8AB5,0xA3);
+	ov3640_write_reg(0x8AB6,0x80);
+	ov3640_write_reg(0x8AB7,0x1E);
+	ov3640_write_reg(0x8AB8,0x90);
+	ov3640_write_reg(0x8AB9,0x33);
+	ov3640_write_reg(0x8ABA,0xB3);
+	ov3640_write_reg(0x8ABB,0xE4);
+	ov3640_write_reg(0x8ABC,0xF0);
+	ov3640_write_reg(0x8ABD,0xA3);
+	ov3640_write_reg(0x8ABE,0xF0);
+	ov3640_write_reg(0x8ABF,0xA3);
+	ov3640_write_reg(0x8AC0,0x74);
+	ov3640_write_reg(0x8AC1,0xFF);
+	ov3640_write_reg(0x8AC2,0xF0);
+	ov3640_write_reg(0x8AC3,0xA3);
+	ov3640_write_reg(0x8AC4,0xE4);
+	ov3640_write_reg(0x8AC5,0x80);
+	ov3640_write_reg(0x8AC6,0x0F);
+	ov3640_write_reg(0x8AC7,0x90);
+	ov3640_write_reg(0x8AC8,0x33);
+	ov3640_write_reg(0x8AC9,0xB3);
+	ov3640_write_reg(0x8ACA,0x74);
+	ov3640_write_reg(0x8ACB,0xFF);
+	ov3640_write_reg(0x8ACC,0xF0);
+	ov3640_write_reg(0x8ACD,0xA3);
+	ov3640_write_reg(0x8ACE,0x74);
+	ov3640_write_reg(0x8ACF,0x80);
+	ov3640_write_reg(0x8AD0,0xF0);
+	ov3640_write_reg(0x8AD1,0xA3);
+	ov3640_write_reg(0x8AD2,0xF0);
+	ov3640_write_reg(0x8AD3,0xA3);
+	ov3640_write_reg(0x8AD4,0x74);
+	ov3640_write_reg(0x8AD5,0xFF);
+	ov3640_write_reg(0x8AD6,0xF0);
+	ov3640_write_reg(0x8AD7,0x75);
+	ov3640_write_reg(0x8AD8,0x0E);
+	ov3640_write_reg(0x8AD9,0x01);
+	ov3640_write_reg(0x8ADA,0x80);
+	ov3640_write_reg(0x8ADB,0x03);
+	ov3640_write_reg(0x8ADC,0xE4);
+	ov3640_write_reg(0x8ADD,0xF5);
+	ov3640_write_reg(0x8ADE,0x0E);
+	ov3640_write_reg(0x8ADF,0x12);
+	ov3640_write_reg(0x8AE0,0x0D);
+	ov3640_write_reg(0x8AE1,0x13);
+	ov3640_write_reg(0x8AE2,0x22);
+	ov3640_write_reg(0x8AE3,0xE4);
+	ov3640_write_reg(0x8AE4,0xF5);
+	ov3640_write_reg(0x8AE5,0x4F);
+	ov3640_write_reg(0x8AE6,0x75);
+	ov3640_write_reg(0x8AE7,0x40);
+	ov3640_write_reg(0x8AE8,0x80);
+	ov3640_write_reg(0x8AE9,0x75);
+	ov3640_write_reg(0x8AEA,0x3B);
+	ov3640_write_reg(0x8AEB,0x32);
+	ov3640_write_reg(0x8AEC,0x75);
+	ov3640_write_reg(0x8AED,0x4C);
+	ov3640_write_reg(0x8AEE,0x1E);
+	ov3640_write_reg(0x8AEF,0xF5);
+	ov3640_write_reg(0x8AF0,0x35);
+	ov3640_write_reg(0x8AF1,0x75);
+	ov3640_write_reg(0x8AF2,0x36);
+	ov3640_write_reg(0x8AF3,0xC8);
+	ov3640_write_reg(0x8AF4,0x75);
+	ov3640_write_reg(0x8AF5,0x49);
+	ov3640_write_reg(0x8AF6,0x01);
+	ov3640_write_reg(0x8AF7,0x75);
+	ov3640_write_reg(0x8AF8,0x4A);
+	ov3640_write_reg(0x8AF9,0x5E);
+	ov3640_write_reg(0x8AFA,0x75);
+	ov3640_write_reg(0x8AFB,0x4D);
+	ov3640_write_reg(0x8AFC,0x03);
+	ov3640_write_reg(0x8AFD,0x75);
+	ov3640_write_reg(0x8AFE,0x4E);
+	ov3640_write_reg(0x8AFF,0x20);
+	ov3640_write_reg(0x8B00,0xF5);
+	ov3640_write_reg(0x8B01,0x41);
+	ov3640_write_reg(0x8B02,0x75);
+	ov3640_write_reg(0x8B03,0x42);
+	ov3640_write_reg(0x8B04,0x28);
+	ov3640_write_reg(0x8B05,0x90);
+	ov3640_write_reg(0x8B06,0x3F);
+	ov3640_write_reg(0x8B07,0x00);
+	ov3640_write_reg(0x8B08,0xE0);
+	ov3640_write_reg(0x8B09,0x30);
+	ov3640_write_reg(0x8B0A,0xE7);
+	ov3640_write_reg(0x8B0B,0x06);
+	ov3640_write_reg(0x8B0C,0xE0);
+	ov3640_write_reg(0x8B0D,0xF5);
+	ov3640_write_reg(0x8B0E,0x0D);
+	ov3640_write_reg(0x8B0F,0x12);
+	ov3640_write_reg(0x8B10,0x05);
+	ov3640_write_reg(0x8B11,0x7E);
+	ov3640_write_reg(0x8B12,0xE4);
+	ov3640_write_reg(0x8B13,0xF5);
+	ov3640_write_reg(0x8B14,0x4B);
+	ov3640_write_reg(0x8B15,0x90);
+	ov3640_write_reg(0x8B16,0x3F);
+	ov3640_write_reg(0x8B17,0x01);
+	ov3640_write_reg(0x8B18,0xE5);
+	ov3640_write_reg(0x8B19,0x40);
+	ov3640_write_reg(0x8B1A,0xF0);
+	ov3640_write_reg(0x8B1B,0xE4);
+	ov3640_write_reg(0x8B1C,0xF5);
+	ov3640_write_reg(0x8B1D,0x47);
+	ov3640_write_reg(0x8B1E,0xF5);
+	ov3640_write_reg(0x8B1F,0x48);
+	ov3640_write_reg(0x8B20,0xF5);
+	ov3640_write_reg(0x8B21,0x4F);
+	ov3640_write_reg(0x8B22,0x85);
+	ov3640_write_reg(0x8B23,0x47);
+	ov3640_write_reg(0x8B24,0x0D);
+	ov3640_write_reg(0x8B25,0x85);
+	ov3640_write_reg(0x8B26,0x48);
+	ov3640_write_reg(0x8B27,0x0E);
+	ov3640_write_reg(0x8B28,0xF5);
+	ov3640_write_reg(0x8B29,0x0F);
+	ov3640_write_reg(0x8B2A,0xF5);
+	ov3640_write_reg(0x8B2B,0x10);
+	ov3640_write_reg(0x8B2C,0x12);
+	ov3640_write_reg(0x8B2D,0x0B);
+	ov3640_write_reg(0x8B2E,0x41);
+	ov3640_write_reg(0x8B2F,0x50);
+	ov3640_write_reg(0x8B30,0x07);
+	ov3640_write_reg(0x8B31,0xE4);
+	ov3640_write_reg(0x8B32,0xF5);
+	ov3640_write_reg(0x8B33,0x40);
+	ov3640_write_reg(0x8B34,0xD2);
+	ov3640_write_reg(0x8B35,0xAF);
+	ov3640_write_reg(0x8B36,0x80);
+	ov3640_write_reg(0x8B37,0x02);
+	ov3640_write_reg(0x8B38,0xC2);
+	ov3640_write_reg(0x8B39,0xAF);
+	ov3640_write_reg(0x8B3A,0x90);
+	ov3640_write_reg(0x8B3B,0x3F);
+	ov3640_write_reg(0x8B3C,0x01);
+	ov3640_write_reg(0x8B3D,0xE5);
+	ov3640_write_reg(0x8B3E,0x40);
+	ov3640_write_reg(0x8B3F,0xF0);
+	ov3640_write_reg(0x8B40,0x22);
+	ov3640_write_reg(0x8B41,0x85);
+	ov3640_write_reg(0x8B42,0x0D);
+	ov3640_write_reg(0x8B43,0x11);
+	ov3640_write_reg(0x8B44,0x85);
+	ov3640_write_reg(0x8B45,0x0E);
+	ov3640_write_reg(0x8B46,0x12);
+	ov3640_write_reg(0x8B47,0xE5);
+	ov3640_write_reg(0x8B48,0x10);
+	ov3640_write_reg(0x8B49,0x24);
+	ov3640_write_reg(0x8B4A,0x32);
+	ov3640_write_reg(0x8B4B,0xFF);
+	ov3640_write_reg(0x8B4C,0xE4);
+	ov3640_write_reg(0x8B4D,0x35);
+	ov3640_write_reg(0x8B4E,0x0F);
+	ov3640_write_reg(0x8B4F,0xFE);
+	ov3640_write_reg(0x8B50,0xD3);
+	ov3640_write_reg(0x8B51,0xE5);
+	ov3640_write_reg(0x8B52,0x12);
+	ov3640_write_reg(0x8B53,0x9F);
+	ov3640_write_reg(0x8B54,0xE5);
+	ov3640_write_reg(0x8B55,0x11);
+	ov3640_write_reg(0x8B56,0x9E);
+	ov3640_write_reg(0x8B57,0x40);
+	ov3640_write_reg(0x8B58,0x1F);
+	ov3640_write_reg(0x8B59,0x74);
+	ov3640_write_reg(0x8B5A,0xE2);
+	ov3640_write_reg(0x8B5B,0x25);
+	ov3640_write_reg(0x8B5C,0x12);
+	ov3640_write_reg(0x8B5D,0xF5);
+	ov3640_write_reg(0x8B5E,0x12);
+	ov3640_write_reg(0x8B5F,0x74);
+	ov3640_write_reg(0x8B60,0xFF);
+	ov3640_write_reg(0x8B61,0x35);
+	ov3640_write_reg(0x8B62,0x11);
+	ov3640_write_reg(0x8B63,0xF5);
+	ov3640_write_reg(0x8B64,0x11);
+	ov3640_write_reg(0x8B65,0xF5);
+	ov3640_write_reg(0x8B66,0x13);
+	ov3640_write_reg(0x8B67,0x85);
+	ov3640_write_reg(0x8B68,0x12);
+	ov3640_write_reg(0x8B69,0x14);
+	ov3640_write_reg(0x8B6A,0x12);
+	ov3640_write_reg(0x8B6B,0x0B);
+	ov3640_write_reg(0x8B6C,0x86);
+	ov3640_write_reg(0x8B6D,0x40);
+	ov3640_write_reg(0x8B6E,0x01);
+	ov3640_write_reg(0x8B6F,0x22);
+	ov3640_write_reg(0x8B70,0x75);
+	ov3640_write_reg(0x8B71,0x13);
+	ov3640_write_reg(0x8B72,0x02);
+	ov3640_write_reg(0x8B73,0x12);
+	ov3640_write_reg(0x8B74,0x0C);
+	ov3640_write_reg(0x8B75,0xF9);
+	ov3640_write_reg(0x8B76,0x80);
+	ov3640_write_reg(0x8B77,0xCF);
+	ov3640_write_reg(0x8B78,0x85);
+	ov3640_write_reg(0x8B79,0x0F);
+	ov3640_write_reg(0x8B7A,0x13);
+	ov3640_write_reg(0x8B7B,0x85);
+	ov3640_write_reg(0x8B7C,0x10);
+	ov3640_write_reg(0x8B7D,0x14);
+	ov3640_write_reg(0x8B7E,0x12);
+	ov3640_write_reg(0x8B7F,0x0B);
+	ov3640_write_reg(0x8B80,0x86);
+	ov3640_write_reg(0x8B81,0x40);
+	ov3640_write_reg(0x8B82,0x01);
+	ov3640_write_reg(0x8B83,0x22);
+	ov3640_write_reg(0x8B84,0xD3);
+	ov3640_write_reg(0x8B85,0x22);
+	ov3640_write_reg(0x8B86,0xE5);
+	ov3640_write_reg(0x8B87,0x13);
+	ov3640_write_reg(0x8B88,0x54);
+	ov3640_write_reg(0x8B89,0x03);
+	ov3640_write_reg(0x8B8A,0xFC);
+	ov3640_write_reg(0x8B8B,0xAD);
+	ov3640_write_reg(0x8B8C,0x14);
+	ov3640_write_reg(0x8B8D,0xED);
+	ov3640_write_reg(0x8B8E,0xC4);
+	ov3640_write_reg(0x8B8F,0xF8);
+	ov3640_write_reg(0x8B90,0x54);
+	ov3640_write_reg(0x8B91,0x0F);
+	ov3640_write_reg(0x8B92,0xC8);
+	ov3640_write_reg(0x8B93,0x68);
+	ov3640_write_reg(0x8B94,0xFF);
+	ov3640_write_reg(0x8B95,0xEC);
+	ov3640_write_reg(0x8B96,0xC4);
+	ov3640_write_reg(0x8B97,0x54);
+	ov3640_write_reg(0x8B98,0xF0);
+	ov3640_write_reg(0x8B99,0x48);
+	ov3640_write_reg(0x8B9A,0xAB);
+	ov3640_write_reg(0x8B9B,0x07);
+	ov3640_write_reg(0x8B9C,0xFA);
+	ov3640_write_reg(0x8B9D,0x43);
+	ov3640_write_reg(0x8B9E,0x03);
+	ov3640_write_reg(0x8B9F,0x0D);
+	ov3640_write_reg(0x8BA0,0xEC);
+	ov3640_write_reg(0x8BA1,0x90);
+	ov3640_write_reg(0x8BA2,0x3F);
+	ov3640_write_reg(0x8BA3,0x05);
+	ov3640_write_reg(0x8BA4,0xF0);
+	ov3640_write_reg(0x8BA5,0xA3);
+	ov3640_write_reg(0x8BA6,0xE5);
+	ov3640_write_reg(0x8BA7,0x14);
+	ov3640_write_reg(0x8BA8,0xF0);
+	ov3640_write_reg(0x8BA9,0x45);
+	ov3640_write_reg(0x8BAA,0x13);
+	ov3640_write_reg(0x8BAB,0x70);
+	ov3640_write_reg(0x8BAC,0x03);
+	ov3640_write_reg(0x8BAD,0x7A);
+	ov3640_write_reg(0x8BAE,0x80);
+	ov3640_write_reg(0x8BAF,0xFB);
+	ov3640_write_reg(0x8BB0,0x8A);
+	ov3640_write_reg(0x8BB1,0x15);
+	ov3640_write_reg(0x8BB2,0x8B);
+	ov3640_write_reg(0x8BB3,0x16);
+	ov3640_write_reg(0x8BB4,0x12);
+	ov3640_write_reg(0x8BB5,0x0B);
+	ov3640_write_reg(0x8BB6,0xC5);
+	ov3640_write_reg(0x8BB7,0x40);
+	ov3640_write_reg(0x8BB8,0x01);
+	ov3640_write_reg(0x8BB9,0x22);
+	ov3640_write_reg(0x8BBA,0xE5);
+	ov3640_write_reg(0x8BBB,0x13);
+	ov3640_write_reg(0x8BBC,0x54);
+	ov3640_write_reg(0x8BBD,0x03);
+	ov3640_write_reg(0x8BBE,0xF5);
+	ov3640_write_reg(0x8BBF,0x1D);
+	ov3640_write_reg(0x8BC0,0x85);
+	ov3640_write_reg(0x8BC1,0x14);
+	ov3640_write_reg(0x8BC2,0x1E);
+	ov3640_write_reg(0x8BC3,0xD3);
+	ov3640_write_reg(0x8BC4,0x22);
+	ov3640_write_reg(0x8BC5,0xE4);
+	ov3640_write_reg(0x8BC6,0xF5);
+	ov3640_write_reg(0x8BC7,0x17);
+	ov3640_write_reg(0x8BC8,0x12);
+	ov3640_write_reg(0x8BC9,0x0C);
+	ov3640_write_reg(0x8BCA,0x6E);
+	ov3640_write_reg(0x8BCB,0x75);
+	ov3640_write_reg(0x8BCC,0x18);
+	ov3640_write_reg(0x8BCD,0x18);
+	ov3640_write_reg(0x8BCE,0x12);
+	ov3640_write_reg(0x8BCF,0x09);
+	ov3640_write_reg(0x8BD0,0x8D);
+	ov3640_write_reg(0x8BD1,0x40);
+	ov3640_write_reg(0x8BD2,0x02);
+	ov3640_write_reg(0x8BD3,0x80);
+	ov3640_write_reg(0x8BD4,0x14);
+	ov3640_write_reg(0x8BD5,0xE5);
+	ov3640_write_reg(0x8BD6,0x15);
+	ov3640_write_reg(0x8BD7,0xF5);
+	ov3640_write_reg(0x8BD8,0x18);
+	ov3640_write_reg(0x8BD9,0x12);
+	ov3640_write_reg(0x8BDA,0x09);
+	ov3640_write_reg(0x8BDB,0x8D);
+	ov3640_write_reg(0x8BDC,0x40);
+	ov3640_write_reg(0x8BDD,0x02);
+	ov3640_write_reg(0x8BDE,0x80);
+	ov3640_write_reg(0x8BDF,0x09);
+	ov3640_write_reg(0x8BE0,0xE5);
+	ov3640_write_reg(0x8BE1,0x16);
+	ov3640_write_reg(0x8BE2,0xF5);
+	ov3640_write_reg(0x8BE3,0x18);
+	ov3640_write_reg(0x8BE4,0x12);
+	ov3640_write_reg(0x8BE5,0x09);
+	ov3640_write_reg(0x8BE6,0x8D);
+	ov3640_write_reg(0x8BE7,0x40);
+	ov3640_write_reg(0x8BE8,0x05);
+	ov3640_write_reg(0x8BE9,0x12);
+	ov3640_write_reg(0x8BEA,0x0C);
+	ov3640_write_reg(0x8BEB,0xA3);
+	ov3640_write_reg(0x8BEC,0x80);
+	ov3640_write_reg(0x8BED,0x05);
+	ov3640_write_reg(0x8BEE,0x12);
+	ov3640_write_reg(0x8BEF,0x0C);
+	ov3640_write_reg(0x8BF0,0xA3);
+	ov3640_write_reg(0x8BF1,0xD3);
+	ov3640_write_reg(0x8BF2,0x22);
+	ov3640_write_reg(0x8BF3,0x05);
+	ov3640_write_reg(0x8BF4,0x17);
+	ov3640_write_reg(0x8BF5,0xE5);
+	ov3640_write_reg(0x8BF6,0x17);
+	ov3640_write_reg(0x8BF7,0xC3);
+	ov3640_write_reg(0x8BF8,0x94);
+	ov3640_write_reg(0x8BF9,0x0A);
+	ov3640_write_reg(0x8BFA,0x40);
+	ov3640_write_reg(0x8BFB,0xCC);
+	ov3640_write_reg(0x8BFC,0xC3);
+	ov3640_write_reg(0x8BFD,0x22);
+	ov3640_write_reg(0x8BFE,0x12);
+	ov3640_write_reg(0x8BFF,0x0A);
+	ov3640_write_reg(0x8C00,0x06);
+	ov3640_write_reg(0x8C01,0x12);
+	ov3640_write_reg(0x8C02,0x0A);
+	ov3640_write_reg(0x8C03,0xE3);
+	ov3640_write_reg(0x8C04,0x12);
+	ov3640_write_reg(0x8C05,0x06);
+	ov3640_write_reg(0x8C06,0xD6);
+	ov3640_write_reg(0x8C07,0x12);
+	ov3640_write_reg(0x8C08,0x02);
+	ov3640_write_reg(0x8C09,0x45);
+	ov3640_write_reg(0x8C0A,0x30);
+	ov3640_write_reg(0x8C0B,0x09);
+	ov3640_write_reg(0x8C0C,0xFA);
+	ov3640_write_reg(0x8C0D,0xE5);
+	ov3640_write_reg(0x8C0E,0x40);
+	ov3640_write_reg(0x8C0F,0x54);
+	ov3640_write_reg(0x8C10,0x03);
+	ov3640_write_reg(0x8C11,0xFF);
+	ov3640_write_reg(0x8C12,0xBF);
+	ov3640_write_reg(0x8C13,0x01);
+	ov3640_write_reg(0x8C14,0x05);
+	ov3640_write_reg(0x8C15,0x12);
+	ov3640_write_reg(0x8C16,0x00);
+	ov3640_write_reg(0x8C17,0x06);
+	ov3640_write_reg(0x8C18,0x80);
+	ov3640_write_reg(0x8C19,0x18);
+	ov3640_write_reg(0x8C1A,0xE5);
+	ov3640_write_reg(0x8C1B,0x40);
+	ov3640_write_reg(0x8C1C,0x64);
+	ov3640_write_reg(0x8C1D,0x4A);
+	ov3640_write_reg(0x8C1E,0x60);
+	ov3640_write_reg(0x8C1F,0x05);
+	ov3640_write_reg(0x8C20,0xE5);
+	ov3640_write_reg(0x8C21,0x40);
+	ov3640_write_reg(0x8C22,0xB4);
+	ov3640_write_reg(0x8C23,0xCA);
+	ov3640_write_reg(0x8C24,0x05);
+	ov3640_write_reg(0x8C25,0x12);
+	ov3640_write_reg(0x8C26,0x09);
+	ov3640_write_reg(0x8C27,0x0C);
+	ov3640_write_reg(0x8C28,0x80);
+	ov3640_write_reg(0x8C29,0x08);
+	ov3640_write_reg(0x8C2A,0xE5);
+	ov3640_write_reg(0x8C2B,0x40);
+	ov3640_write_reg(0x8C2C,0xB4);
+	ov3640_write_reg(0x8C2D,0x4E);
+	ov3640_write_reg(0x8C2E,0x03);
+	ov3640_write_reg(0x8C2F,0x12);
+	ov3640_write_reg(0x8C30,0x04);
+	ov3640_write_reg(0x8C31,0x97);
+	ov3640_write_reg(0x8C32,0xC2);
+	ov3640_write_reg(0x8C33,0x09);
+	ov3640_write_reg(0x8C34,0x80);
+	ov3640_write_reg(0x8C35,0xD1);
+	ov3640_write_reg(0x8C36,0xEF);
+	ov3640_write_reg(0x8C37,0x8D);
+	ov3640_write_reg(0x8C38,0xF0);
+	ov3640_write_reg(0x8C39,0xA4);
+	ov3640_write_reg(0x8C3A,0xA8);
+	ov3640_write_reg(0x8C3B,0xF0);
+	ov3640_write_reg(0x8C3C,0xCF);
+	ov3640_write_reg(0x8C3D,0x8C);
+	ov3640_write_reg(0x8C3E,0xF0);
+	ov3640_write_reg(0x8C3F,0xA4);
+	ov3640_write_reg(0x8C40,0x28);
+	ov3640_write_reg(0x8C41,0xCE);
+	ov3640_write_reg(0x8C42,0x8D);
+	ov3640_write_reg(0x8C43,0xF0);
+	ov3640_write_reg(0x8C44,0xA4);
+	ov3640_write_reg(0x8C45,0x2E);
+	ov3640_write_reg(0x8C46,0xFE);
+	ov3640_write_reg(0x8C47,0x22);
+	ov3640_write_reg(0x8C48,0xD0);
+	ov3640_write_reg(0x8C49,0x83);
+	ov3640_write_reg(0x8C4A,0xD0);
+	ov3640_write_reg(0x8C4B,0x82);
+	ov3640_write_reg(0x8C4C,0xF8);
+	ov3640_write_reg(0x8C4D,0xE4);
+	ov3640_write_reg(0x8C4E,0x93);
+	ov3640_write_reg(0x8C4F,0x70);
+	ov3640_write_reg(0x8C50,0x12);
+	ov3640_write_reg(0x8C51,0x74);
+	ov3640_write_reg(0x8C52,0x01);
+	ov3640_write_reg(0x8C53,0x93);
+	ov3640_write_reg(0x8C54,0x70);
+	ov3640_write_reg(0x8C55,0x0D);
+	ov3640_write_reg(0x8C56,0xA3);
+	ov3640_write_reg(0x8C57,0xA3);
+	ov3640_write_reg(0x8C58,0x93);
+	ov3640_write_reg(0x8C59,0xF8);
+	ov3640_write_reg(0x8C5A,0x74);
+	ov3640_write_reg(0x8C5B,0x01);
+	ov3640_write_reg(0x8C5C,0x93);
+	ov3640_write_reg(0x8C5D,0xF5);
+	ov3640_write_reg(0x8C5E,0x82);
+	ov3640_write_reg(0x8C5F,0x88);
+	ov3640_write_reg(0x8C60,0x83);
+	ov3640_write_reg(0x8C61,0xE4);
+	ov3640_write_reg(0x8C62,0x73);
+	ov3640_write_reg(0x8C63,0x74);
+	ov3640_write_reg(0x8C64,0x02);
+	ov3640_write_reg(0x8C65,0x93);
+	ov3640_write_reg(0x8C66,0x68);
+	ov3640_write_reg(0x8C67,0x60);
+	ov3640_write_reg(0x8C68,0xEF);
+	ov3640_write_reg(0x8C69,0xA3);
+	ov3640_write_reg(0x8C6A,0xA3);
+	ov3640_write_reg(0x8C6B,0xA3);
+	ov3640_write_reg(0x8C6C,0x80);
+	ov3640_write_reg(0x8C6D,0xDF);
+	ov3640_write_reg(0x8C6E,0xC2);
+	ov3640_write_reg(0x8C6F,0xAF);
+	ov3640_write_reg(0x8C70,0xD2);
+	ov3640_write_reg(0x8C71,0x01);
+	ov3640_write_reg(0x8C72,0xD2);
+	ov3640_write_reg(0x8C73,0x00);
+	ov3640_write_reg(0x8C74,0x90);
+	ov3640_write_reg(0x8C75,0x30);
+	ov3640_write_reg(0x8C76,0xB4);
+	ov3640_write_reg(0x8C77,0xE5);
+	ov3640_write_reg(0x8C78,0x20);
+	ov3640_write_reg(0x8C79,0xF0);
+	ov3640_write_reg(0x8C7A,0x7F);
+	ov3640_write_reg(0x8C7B,0x0A);
+	ov3640_write_reg(0x8C7C,0xAE);
+	ov3640_write_reg(0x8C7D,0x07);
+	ov3640_write_reg(0x8C7E,0x1F);
+	ov3640_write_reg(0x8C7F,0xEE);
+	ov3640_write_reg(0x8C80,0x70);
+	ov3640_write_reg(0x8C81,0xFA);
+	ov3640_write_reg(0x8C82,0xC2);
+	ov3640_write_reg(0x8C83,0x01);
+	ov3640_write_reg(0x8C84,0x90);
+	ov3640_write_reg(0x8C85,0x30);
+	ov3640_write_reg(0x8C86,0xB4);
+	ov3640_write_reg(0x8C87,0xE5);
+	ov3640_write_reg(0x8C88,0x20);
+	ov3640_write_reg(0x8C89,0xF0);
+	ov3640_write_reg(0x8C8A,0x7F);
+	ov3640_write_reg(0x8C8B,0x05);
+	ov3640_write_reg(0x8C8C,0xAE);
+	ov3640_write_reg(0x8C8D,0x07);
+	ov3640_write_reg(0x8C8E,0x1F);
+	ov3640_write_reg(0x8C8F,0xEE);
+	ov3640_write_reg(0x8C90,0x70);
+	ov3640_write_reg(0x8C91,0xFA);
+	ov3640_write_reg(0x8C92,0xC2);
+	ov3640_write_reg(0x8C93,0x00);
+	ov3640_write_reg(0x8C94,0x90);
+	ov3640_write_reg(0x8C95,0x30);
+	ov3640_write_reg(0x8C96,0xB4);
+	ov3640_write_reg(0x8C97,0xE5);
+	ov3640_write_reg(0x8C98,0x20);
+	ov3640_write_reg(0x8C99,0xF0);
+	ov3640_write_reg(0x8C9A,0x7F);
+	ov3640_write_reg(0x8C9B,0x05);
+	ov3640_write_reg(0x8C9C,0xAE);
+	ov3640_write_reg(0x8C9D,0x07);
+	ov3640_write_reg(0x8C9E,0x1F);
+	ov3640_write_reg(0x8C9F,0xEE);
+	ov3640_write_reg(0x8CA0,0x70);
+	ov3640_write_reg(0x8CA1,0xFA);
+	ov3640_write_reg(0x8CA2,0x22);
+	ov3640_write_reg(0x8CA3,0xC2);
+	ov3640_write_reg(0x8CA4,0x01);
+	ov3640_write_reg(0x8CA5,0x90);
+	ov3640_write_reg(0x8CA6,0x30);
+	ov3640_write_reg(0x8CA7,0xB4);
+	ov3640_write_reg(0x8CA8,0xE5);
+	ov3640_write_reg(0x8CA9,0x20);
+	ov3640_write_reg(0x8CAA,0xF0);
+	ov3640_write_reg(0x8CAB,0x7F);
+	ov3640_write_reg(0x8CAC,0x05);
+	ov3640_write_reg(0x8CAD,0xAE);
+	ov3640_write_reg(0x8CAE,0x07);
+	ov3640_write_reg(0x8CAF,0x1F);
+	ov3640_write_reg(0x8CB0,0xEE);
+	ov3640_write_reg(0x8CB1,0x70);
+	ov3640_write_reg(0x8CB2,0xFA);
+	ov3640_write_reg(0x8CB3,0xD2);
+	ov3640_write_reg(0x8CB4,0x00);
+	ov3640_write_reg(0x8CB5,0x90);
+	ov3640_write_reg(0x8CB6,0x30);
+	ov3640_write_reg(0x8CB7,0xB4);
+	ov3640_write_reg(0x8CB8,0xE5);
+	ov3640_write_reg(0x8CB9,0x20);
+	ov3640_write_reg(0x8CBA,0xF0);
+	ov3640_write_reg(0x8CBB,0x7F);
+	ov3640_write_reg(0x8CBC,0x05);
+	ov3640_write_reg(0x8CBD,0xAE);
+	ov3640_write_reg(0x8CBE,0x07);
+	ov3640_write_reg(0x8CBF,0x1F);
+	ov3640_write_reg(0x8CC0,0xEE);
+	ov3640_write_reg(0x8CC1,0x70);
+	ov3640_write_reg(0x8CC2,0xFA);
+	ov3640_write_reg(0x8CC3,0xD2);
+	ov3640_write_reg(0x8CC4,0x01);
+	ov3640_write_reg(0x8CC5,0x90);
+	ov3640_write_reg(0x8CC6,0x30);
+	ov3640_write_reg(0x8CC7,0xB4);
+	ov3640_write_reg(0x8CC8,0xE5);
+	ov3640_write_reg(0x8CC9,0x20);
+	ov3640_write_reg(0x8CCA,0xF0);
+	ov3640_write_reg(0x8CCB,0xD2);
+	ov3640_write_reg(0x8CCC,0xAF);
+	ov3640_write_reg(0x8CCD,0x7F);
+	ov3640_write_reg(0x8CCE,0x05);
+	ov3640_write_reg(0x8CCF,0xAE);
+	ov3640_write_reg(0x8CD0,0x07);
+	ov3640_write_reg(0x8CD1,0x1F);
+	ov3640_write_reg(0x8CD2,0xEE);
+	ov3640_write_reg(0x8CD3,0x70);
+	ov3640_write_reg(0x8CD4,0xFA);
+	ov3640_write_reg(0x8CD5,0x22);
+	ov3640_write_reg(0x8CD6,0x90);
+	ov3640_write_reg(0x8CD7,0x30);
+	ov3640_write_reg(0x8CD8,0xB2);
+	ov3640_write_reg(0x8CD9,0xE0);
+	ov3640_write_reg(0x8CDA,0x44);
+	ov3640_write_reg(0x8CDB,0x18);
+	ov3640_write_reg(0x8CDC,0xF0);
+	ov3640_write_reg(0x8CDD,0x90);
+	ov3640_write_reg(0x8CDE,0x30);
+	ov3640_write_reg(0x8CDF,0xB0);
+	ov3640_write_reg(0x8CE0,0xE0);
+	ov3640_write_reg(0x8CE1,0x44);
+	ov3640_write_reg(0x8CE2,0x03);
+	ov3640_write_reg(0x8CE3,0xF0);
+	ov3640_write_reg(0x8CE4,0xA3);
+	ov3640_write_reg(0x8CE5,0xE0);
+	ov3640_write_reg(0x8CE6,0x44);
+	ov3640_write_reg(0x8CE7,0xC0);
+	ov3640_write_reg(0x8CE8,0xF0);
+	ov3640_write_reg(0x8CE9,0x90);
+	ov3640_write_reg(0x8CEA,0x30);
+	ov3640_write_reg(0x8CEB,0xB4);
+	ov3640_write_reg(0x8CEC,0xE0);
+	ov3640_write_reg(0x8CED,0x44);
+	ov3640_write_reg(0x8CEE,0x0F);
+	ov3640_write_reg(0x8CEF,0xF0);
+	ov3640_write_reg(0x8CF0,0xE0);
+	ov3640_write_reg(0x8CF1,0x54);
+	ov3640_write_reg(0x8CF2,0xF7);
+	ov3640_write_reg(0x8CF3,0xF0);
+	ov3640_write_reg(0x8CF4,0xE0);
+	ov3640_write_reg(0x8CF5,0x44);
+	ov3640_write_reg(0x8CF6,0x04);
+	ov3640_write_reg(0x8CF7,0xF0);
+	ov3640_write_reg(0x8CF8,0x22);
+	ov3640_write_reg(0x8CF9,0xE4);
+	ov3640_write_reg(0x8CFA,0xFF);
+	ov3640_write_reg(0x8CFB,0xEF);
+	ov3640_write_reg(0x8CFC,0xC3);
+	ov3640_write_reg(0x8CFD,0x95);
+	ov3640_write_reg(0x8CFE,0x13);
+	ov3640_write_reg(0x8CFF,0x50);
+	ov3640_write_reg(0x8D00,0x11);
+	ov3640_write_reg(0x8D01,0x7D);
+	ov3640_write_reg(0x8D02,0x82);
+	ov3640_write_reg(0x8D03,0x7C);
+	ov3640_write_reg(0x8D04,0x00);
+	ov3640_write_reg(0x8D05,0xED);
+	ov3640_write_reg(0x8D06,0x1D);
+	ov3640_write_reg(0x8D07,0xAA);
+	ov3640_write_reg(0x8D08,0x04);
+	ov3640_write_reg(0x8D09,0x70);
+	ov3640_write_reg(0x8D0A,0x01);
+	ov3640_write_reg(0x8D0B,0x1C);
+	ov3640_write_reg(0x8D0C,0x4A);
+	ov3640_write_reg(0x8D0D,0x70);
+	ov3640_write_reg(0x8D0E,0xF6);
+	ov3640_write_reg(0x8D0F,0x0F);
+	ov3640_write_reg(0x8D10,0x80);
+	ov3640_write_reg(0x8D11,0xE9);
+	ov3640_write_reg(0x8D12,0x22);
+	ov3640_write_reg(0x8D13,0x30);
+	ov3640_write_reg(0x8D14,0x08);
+	ov3640_write_reg(0x8D15,0x10);
+	ov3640_write_reg(0x8D16,0xE5);
+	ov3640_write_reg(0x8D17,0x0E);
+	ov3640_write_reg(0x8D18,0x90);
+	ov3640_write_reg(0x8D19,0x33);
+	ov3640_write_reg(0x8D1A,0x00);
+	ov3640_write_reg(0x8D1B,0x60);
+	ov3640_write_reg(0x8D1C,0x05);
+	ov3640_write_reg(0x8D1D,0xE0);
+	ov3640_write_reg(0x8D1E,0x44);
+	ov3640_write_reg(0x8D1F,0x40);
+	ov3640_write_reg(0x8D20,0xF0);
+	ov3640_write_reg(0x8D21,0x22);
+	ov3640_write_reg(0x8D22,0xE0);
+	ov3640_write_reg(0x8D23,0x54);
+	ov3640_write_reg(0x8D24,0xBF);
+	ov3640_write_reg(0x8D25,0xF0);
+	ov3640_write_reg(0x8D26,0x22);
+	ov3640_write_reg(0x8D27,0xC3);
+	ov3640_write_reg(0x8D28,0xEE);
+	ov3640_write_reg(0x8D29,0x64);
+	ov3640_write_reg(0x8D2A,0x80);
+	ov3640_write_reg(0x8D2B,0x94);
+	ov3640_write_reg(0x8D2C,0x80);
+	ov3640_write_reg(0x8D2D,0x40);
+	ov3640_write_reg(0x8D2E,0x02);
+	ov3640_write_reg(0x8D2F,0x80);
+	ov3640_write_reg(0x8D30,0x07);
+	ov3640_write_reg(0x8D31,0xC3);
+	ov3640_write_reg(0x8D32,0xE4);
+	ov3640_write_reg(0x8D33,0x9F);
+	ov3640_write_reg(0x8D34,0xFF);
+	ov3640_write_reg(0x8D35,0xE4);
+	ov3640_write_reg(0x8D36,0x9E);
+	ov3640_write_reg(0x8D37,0xFE);
+	ov3640_write_reg(0x8D38,0x22);
+	ov3640_write_reg(0x8D39,0x01);
+	ov3640_write_reg(0x8D3A,0x50);
+	ov3640_write_reg(0x8D3B,0x00);
+	ov3640_write_reg(0x8D3C,0x01);
+	ov3640_write_reg(0x8D3D,0x24);
+	ov3640_write_reg(0x8D3E,0x00);
+	ov3640_write_reg(0x8D3F,0x01);
+	ov3640_write_reg(0x8D40,0x31);
+	ov3640_write_reg(0x8D41,0x00);
+	ov3640_write_reg(0x8D42,0x01);
+	ov3640_write_reg(0x8D43,0x32);
+	ov3640_write_reg(0x8D44,0x00);
+	ov3640_write_reg(0x8D45,0x02);
+	ov3640_write_reg(0x8D46,0x33);
+	ov3640_write_reg(0x8D47,0x00);
+	ov3640_write_reg(0x8D48,0x00);
+	ov3640_write_reg(0x8D49,0x00);
+	ov3640_write_reg(0x8D4A,0x90);
+	ov3640_write_reg(0x8D4B,0x30);
+	ov3640_write_reg(0x8D4C,0x1B);
+	ov3640_write_reg(0x8D4D,0xE0);
+	ov3640_write_reg(0x8D4E,0xFF);
+	ov3640_write_reg(0x8D4F,0x65);
+	ov3640_write_reg(0x8D50,0x50);
+	ov3640_write_reg(0x8D51,0x60);
+	ov3640_write_reg(0x8D52,0x04);
+	ov3640_write_reg(0x8D53,0x8F);
+	ov3640_write_reg(0x8D54,0x50);
+	ov3640_write_reg(0x8D55,0xD3);
+	ov3640_write_reg(0x8D56,0x22);
+	ov3640_write_reg(0x8D57,0xC3);
+	ov3640_write_reg(0x8D58,0x22);
+	ov3640_write_reg(0x3104,0x00);
+	check_sequence	= ENABLE;
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	ov3640_frame_interval_support
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Control the frame rate based on the user request 
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_frame_interval_support(cam_data *cam)
+{
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT32 frame_interval_based_on_mode	= DISABLE;
+			UINT32 usr_width	= cam->cam_sensor.frame_interval_frm_user->width;
+			UINT32 usr_height	= cam->cam_sensor.frame_interval_frm_user->height;
+			UINT32 pixel_format	= cam->cam_sensor.frame_interval_frm_user->pixel_format;
+
+			for(	frame_interval_based_on_mode	= DISABLE	;				\
+				frame_interval_based_on_mode	< cam->cam_sensor.total_frm_interval_support;	\
+				frame_interval_based_on_mode++)
+			{
+				if(	(usr_width <= cam->cam_sensor						\
+						.frm_interval_support[frame_interval_based_on_mode].width)	&&
+					(usr_height <= cam->cam_sensor						\
+						.frm_interval_support[frame_interval_based_on_mode].height))
+				{
+					break;
+				}
+			}
+
+			if(frame_interval_based_on_mode	>=cam->cam_sensor.total_frm_interval_support)
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+
+			memcpy(	cam->cam_sensor.frame_interval_frm_user,					\
+				&cam->cam_sensor.frm_interval_support[frame_interval_based_on_mode],		\
+				sizeof(struct v4l2_frmivalenum));
+			cam->cam_sensor.frame_interval_frm_user->width		= usr_width;
+			cam->cam_sensor.frame_interval_frm_user->height		= usr_height;
+			cam->cam_sensor.frame_interval_frm_user->pixel_format	= pixel_format;
+		}break;
+
+		case SET_DATA:
+		{
+		}break;
+
+		case QUERY_DATA:
+		{
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	ov3640_format_support
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Control the frame rate based on the user request 
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_format_support(cam_data *cam)
+{
+	UINT32 pix_fmt_count	= DISABLE;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT32 pixel_format	= cam->cam_sensor.fmt_frm_user->pixel_format;
+			if(cam->cam_sensor.fmt_frm_user->index	>= cam->cam_sensor.total_frms_support)
+			{
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+
+			for(	pix_fmt_count	= DISABLE;					\
+				pix_fmt_count < cam->cam_sensor.total_fmt_desc;			\
+				pix_fmt_count++)
+			{
+				if(cam->cam_sensor.fmt_frm_user->pixel_format == 		\
+						cam->cam_sensor.formats[pix_fmt_count].pixelformat)
+				{
+					break;
+				}
+			}
+
+			/*
+			 * Check for pixel format support. If the pixel format is not
+			 * supported! return the format is error value as Invalid data
+			 */
+
+			if(pix_fmt_count	>= (cam->cam_sensor.total_frms_support))
+			{
+
+				TRACE_ERR_AND_RET(-EINVAL);
+			}
+
+			memcpy(	cam->cam_sensor.fmt_frm_user,					\
+				&cam->cam_sensor.frms[cam->cam_sensor.fmt_frm_user->index],	\
+				sizeof(struct v4l2_frmsizeenum));
+			cam->cam_sensor.fmt_frm_user->pixel_format	= pixel_format;
+		}break;
+
+		case SET_DATA:
+		{
+		}break;
+
+		case QUERY_DATA:
+		{
+		}break;
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	ov3640_limit_pclk_max_limit
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Control the pclk rate based on the user request 
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_limit_pclk_max_limit(cam_data *cam)
+{
+	UINT8 regval_300e,rx_pll;
+	UINT8 regval_300f;
+	UINT8 freq_div,inDiv;
+	UINT8 freq_div_num	= 1;
+	UINT8 freq_div_den	= 1;
+	UINT8 inDiv_num		= 1;
+	UINT8 inDiv_den		= 1;
+
+	UINT8 regval_3010,sens_div,sens_div_val;
+	UINT8 regval_3011,clk;
+	UINT8 regval_304c,unknown;
+	UINT32 pclk	= SENS_MAX_PCLK_SUPPORT;
+
+	for(;sens_max_pclk < pclk;)
+	{
+		ov3640_read_reg(0x300e, &regval_300e);
+		ov3640_read_reg(0x300f, &regval_300f);
+		ov3640_read_reg(0x3010, &regval_3010);
+		ov3640_read_reg(0x3011, &regval_3011);
+		ov3640_read_reg(0x304c, &regval_304c);
+				
+		rx_pll		= (regval_300e & 0x3F);
+		freq_div	= (regval_300f & 0xC0) >> 6;	// [7:6]
+		switch(freq_div)
+		{
+			case 0:
+			{
+				freq_div_num	= 1;
+				freq_div_den	= 1;
+			}break;
+			case 1:
+			{
+				freq_div_num	= 3;
+				freq_div_den	= 2;
+			}break;
+			case 2:
+			{
+				freq_div_num	= 2;
+				freq_div_den	= 1;
+			}break;
+			case 3:
+			{
+				freq_div_num	= 3;
+				freq_div_den	= 1;
+			}break;
+		}
+
+		inDiv		= (regval_300f & 0x03);		// [1:0]
+		switch(inDiv)
+		{
+			case 0:
+			{
+				inDiv_num	= 1;
+				inDiv_den	= 1;
+			}break;
+			case 1:
+			{
+				inDiv_num	= 3;
+				inDiv_den	= 2;
+			}break;
+			case 2:
+			{
+				inDiv_num	= 2;
+				inDiv_den	= 1;
+			}break;
+			case 3:
+			{
+				inDiv_num	= 3;
+				inDiv_den	= 1;
+			}break;
+		}
+		sens_div	= (regval_3010 & 0x10) >> 4;
+		sens_div_val	= (sens_div == 0)?1:2;
+		clk		= (regval_3011 & 0x3F);
+		unknown		= (regval_304c & 0x1F);
+		
+		pclk		= (64 - rx_pll)*freq_div_num/freq_div_den*24000000/	\
+				  inDiv_num*inDiv_den/sens_div_val/(clk+1)/2/unknown;
+
+//		pclk		= (64-0x300e[5:0])*0x300f[7:6]*
+//					MCLK/0x300f[1:0]/0x3010[4]/(0x3011[5:0]+1)/2/0x304c[4:0];
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+		printk(KERN_DEBUG "----------------------------------------\n");
+		printk(KERN_DEBUG "rx_pll %d \n",rx_pll);
+		printk(KERN_DEBUG "freq_div_num %d \n",freq_div_num);
+		printk(KERN_DEBUG "freq_div_den %d \n",freq_div_den);
+		printk(KERN_DEBUG "inDiv_num %d \n",inDiv_num);
+		printk(KERN_DEBUG "inDiv_den %d \n",inDiv_den);
+		printk(KERN_DEBUG "sens_div_val %d \n",sens_div_val);
+		printk(KERN_DEBUG "clk %d \n",clk);
+		printk(KERN_DEBUG "unknown %d \n",unknown);
+		printk(KERN_DEBUG "Pclk value as per calaculation is %d \n",pclk);
+		printk(KERN_DEBUG "----------------------------------------\n");
+#endif
+		if(sens_max_pclk < pclk)
+		{
+			clk++;
+			ov3640_write_reg(0x3011 ,clk);
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	ov3640_frame_rate_ctrl
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Control the frame rate based on the user request 
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_frame_rate_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+
+	/*
+	 * Sensor Will take mclk from input ranges from 6Mhz t0 27 Mhz (V3640_COB_USA.pdf)
+	 */
+#if 0
+	UINT32 clk_set		= DISABLE;
+#endif
+	UINT8 regval_3011	= DISABLE;
+	UINT32 fps		= DISABLE;
+	UINT32 fps_need		= DISABLE;
+
+	if(cam->cam_sensor.s_parm.type	!= V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	{
+		TRACE_ERR_AND_RET(-EINVAL);
+	}
+
+	ov3640_read_reg(0x3011,&regval_3011);
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			if(	(cam->cam_sensor.fmt.fmt.pix.width < MODE_XGA_WIDTH) && 	\
+			(cam->cam_sensor.fmt.fmt.pix.height < MODE_XGA_HEIGHT))
+			{
+				fps		= 30 / (regval_3011 +1);
+			}else
+			{
+				fps		= 7 / (regval_3011 +1);
+			}
+			cam->cam_sensor.s_parm.parm.capture.timeperframe.denominator	= fps;
+			cam->cam_sensor.s_parm.parm.capture.timeperframe.numerator	= 1;
+		}break;
+
+		case SET_DATA:
+		{
+			if(	(cam->cam_sensor.fmt.fmt.pix.width < MODE_XGA_WIDTH) && 	\
+			(cam->cam_sensor.fmt.fmt.pix.height < MODE_XGA_HEIGHT))
+			{
+				fps		= 30 / (regval_3011 +1);
+				fps_need	= (cam->cam_sensor.s_parm.parm.capture.timeperframe.denominator/	\
+						cam->cam_sensor.s_parm.parm.capture.timeperframe.numerator);
+
+				if(fps_need	 > 30)
+				{
+					fps_need	= 30;
+				}	
+				regval_3011	= (30 / fps_need) -1;
+			}else
+			{
+				fps		= 7 / (regval_3011 +1);
+				fps_need	= (cam->cam_sensor.s_parm.parm.capture.timeperframe.denominator/	\
+							cam->cam_sensor.s_parm.parm.capture.timeperframe.numerator);
+				if(fps_need	 > 7)
+				{
+					fps_need	= 7;
+				}
+				regval_3011	= (7 / fps_need) -1;
+			}
+
+			ov3640_write_reg(0x3011,regval_3011);
+			ret_val	= ov3640_limit_pclk_max_limit(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);		
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+		}break;
+	}
+/*
+ * TODO :
+ * 	Fine tune the Mclk to acheive more accurate frame rate from the sensor
+ */
+
+#if 0
+	if(cam->modify_mclk_to_sensor)
+	{
+		ret_val	= cam->modify_mclk_to_sensor(cam,xclk,&clk_set);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);		
+		}
+	}
+#endif
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_15
+ *  Name	:	ov3640_sens_strobe
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	External flash light strobe signal control be enabled (or) disabled here 
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_sens_strobe(cam_data *cam)
+{
+	if((cam->ctrl.value) && (cam->cam_sensor.sens_strobe_en))
+	{
+		ov3640_write_reg(0x307A ,0x8F);	
+	}else
+	{
+		ov3640_write_reg(0x307A ,0x0F);	
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_16
+ *  Name	:	ov3640_focus
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Autofocus related feature available here
+ *  Comments	:  	Ov3640 truly module firmware supports
+ *  			1. Manual focus
+ *  			2. Absolute focus
+ *  			3. Relative focus
+ *  			4. Automatic continous focus
+ *  			5. Single Auto focus
+ ************************************************************************************************************/
+FNRESLT ov3640_focus(cam_data *cam)
+{
+	af_status reg_data;
+	UINT8 reg_value;
+	static INT32 restore_focus_absolute;
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_FOCUS_ABSOLUTE:
+				case V4L2_CID_FOCUS_RELATIVE:
+				{
+					ov3640_read_reg(0x3f01,&reg_data.reg_data);
+					if(reg_data.focus.mode != MODE_STEP_MODE)
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+					ov3640_read_reg(0x3f05,&reg_value);				
+					cam->ctrl.value	= (0x03 & reg_value) << 8;
+
+					ov3640_read_reg(0x3f06,&reg_value);
+					cam->ctrl.value|= (0xFF & reg_value);
+					restore_focus_absolute	= cam->ctrl.value;
+				}break;
+
+				case V4L2_CID_FOCUS_AUTO:
+				{
+					ov3640_read_reg(0x3f01,&reg_data.reg_data);
+					if(reg_data.focus.mode == MODE_CONTINOUS_FOCUS)
+					{
+						cam->ctrl.value = reg_data.focus.mode_step;
+					}else
+					{
+						cam->ctrl.value = DISABLE;
+					}
+				}break;
+
+				case V4L2_SENS_TRIG_FOCUS:
+				{
+					ov3640_read_reg(0x3f01,&reg_data.reg_data);
+					if(reg_data.focus.mode == MODE_SINGLE_FOCUS)
+					{
+						cam->ctrl.value = reg_data.focus.mode_step;
+					}else
+					{
+						cam->ctrl.value = DISABLE;
+					}
+				}break;
+				default:
+				{
+					TRACE_ERR_AND_RET(-EINVAL);	
+				}	
+			}		
+		}break;
+
+		case RESTORE_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_FOCUS_ABSOLUTE:
+				{
+					cam->ctrl.value	= restore_focus_absolute;
+				}break;
+			}
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			ov3640_write_reg(0x3f00,0x09);
+
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_FOCUS_ABSOLUTE:
+				{
+					ov3640_read_reg(0x3f01,&reg_data.reg_data);
+					if(reg_data.focus.mode != MODE_STEP_MODE)
+					{
+						ov3640_write_reg(0x3f00,0x08);
+						ov3640_write_reg(0x3f00,0x05);
+					}
+					ov3640_write_reg(0x3f05,STEP_ABSOLUTE | (0x3 & ((cam->ctrl.value) >> 8)));
+					ov3640_write_reg(0x3f06,(0xFF & cam->ctrl.value));
+					restore_focus_absolute	= cam->ctrl.value;
+				}break;
+
+				case V4L2_CID_FOCUS_RELATIVE:
+				{
+					ov3640_read_reg(0x3f01,&reg_data.reg_data);
+					if(reg_data.focus.mode != MODE_STEP_MODE)
+					{
+						ov3640_write_reg(0x3f00,0x08);
+						ov3640_write_reg(0x3f00,0x05);
+					}
+					if(cam->ctrl.value > 0)
+					{
+						ov3640_write_reg(0x3f05,STEP_FORWARD | (0x3 & ((cam->ctrl.value) >> 8)));
+						ov3640_write_reg(0x3f06,(0xFF & cam->ctrl.value));
+					}else
+					{
+						cam->ctrl.value = -cam->ctrl.value;
+						ov3640_write_reg(0x3f05,STEP_BACKWARD | (0x3 & ((cam->ctrl.value) >> 8)));
+						ov3640_write_reg(0x3f06,(0xFF & cam->ctrl.value));
+					}	
+				}break;
+				case V4L2_CID_FOCUS_AUTO:
+				{
+					ov3640_write_reg(0x3f00,0x08);
+					ov3640_write_reg(0x3f00,0x04);
+				}break;
+				case V4L2_SENS_TRIG_FOCUS:
+				{
+					ov3640_write_reg(0x3f00,0x08);
+					ov3640_write_reg(0x3f00,0x03);
+				}break;
+		
+				case V4L2_SENS_FCS_OLAY:
+				{
+					if(cam->ctrl.value)
+					{
+						ov3640_write_reg(0x3f00,0x01);
+					}else
+					{
+						ov3640_write_reg(0x3f00,0x02);
+					}
+
+				}break;
+
+				case V4L2_SENS_FOCUS_FREEZE:
+				{
+					ov3640_write_reg(0x3f00,0x06);					
+				}break;
+
+				case V4L2_SENS_FOCUS_UNFREEZE:
+				{
+					ov3640_write_reg(0x3f00,0x07);					
+				}break;
+
+				case V4L2_SENS_FOCUS_DISABLE:
+				{
+					ov3640_write_reg(0x3f00,0x08);					
+				}break;			
+			}		
+		}break;
+
+		case QUERY_DATA:
+		{
+			switch(cam->ctrl.id)
+			{
+				case V4L2_CID_FOCUS_ABSOLUTE:
+				{
+					cam->qctrl.id	= V4L2_CID_FOCUS_ABSOLUTE;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+					strncpy(cam->qctrl.name,"Manual focus",strlen("Manual focus"));
+					cam->qctrl.minimum = 0;
+					cam->qctrl.maximum = 1023;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+					cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+				}break;
+
+				case V4L2_CID_FOCUS_RELATIVE:
+				{
+					cam->qctrl.id	= V4L2_CID_FOCUS_RELATIVE;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+					strncpy(cam->qctrl.name,"Relative Manual focus",	\
+							strlen("Relative Manual focus"));
+					cam->qctrl.minimum = -1023;
+					cam->qctrl.maximum = 1023;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+					cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+				}break;
+
+				case V4L2_CID_FOCUS_AUTO:
+				{
+					cam->qctrl.id	= V4L2_CID_FOCUS_AUTO;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+					strncpy(cam->qctrl.name,"Autofocus",strlen("Autofocus"));
+					cam->qctrl.minimum = 0;
+					cam->qctrl.maximum = 1;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+				}break;
+
+				case V4L2_SENS_TRIG_FOCUS:
+				{
+					cam->qctrl.id	= V4L2_SENS_TRIG_FOCUS;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+					strncpy(cam->qctrl.name,"Single Auto focus",	\
+							strlen("Single Auto focus"));
+					cam->qctrl.minimum = 0;
+					cam->qctrl.maximum = 1;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+				}break;
+
+				case V4L2_SENS_FCS_OLAY:
+				{
+					cam->qctrl.id	= V4L2_SENS_FCS_OLAY;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+					strncpy(cam->qctrl.name,"Focus Overlay",strlen("Focus Overlay"));
+					cam->qctrl.minimum = 0;
+					cam->qctrl.maximum = 1;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+				}break;
+
+				case V4L2_SENS_FOCUS_DISABLE:
+				{
+					cam->qctrl.id	= V4L2_SENS_FOCUS_DISABLE;
+					cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+					strncpy(cam->qctrl.name,"Focus complete",strlen("Focus complete"));
+					cam->qctrl.minimum = 0;
+					cam->qctrl.maximum = 1;
+					cam->qctrl.step = 1;
+					cam->qctrl.default_value = 0;
+				}break;
+			}			
+		}break;
+
+		default:
+		{
+			TRACE_ERR_AND_RET(-EINVAL);	
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	ov3640_color_pattern
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Color bar pattern available from the sensor
+ ************************************************************************************************************/
+FNRESLT ov3640_color_pattern(cam_data *cam)
+{
+	static UINT32 color_pattern		= TEST_PATTERN_DISABLE;
+	static INT32 restore_color_pattern	= TEST_PATTERN_DISABLE;
+
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= color_pattern;
+			restore_color_pattern	= cam->ctrl.value;
+		}break;
+
+		case RESTORE_DATA:
+		{
+			cam->ctrl.value	= restore_color_pattern;
+		}/* Intentionally Break is missed */
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= TEST_PATTERN_COLOR_BAR) && (cam->ctrl.value <= TEST_PATTERN_DISABLE))
+			{
+				color_pattern	= cam->ctrl.value;
+				switch (cam->ctrl.value)
+				{
+/*
+ * Color bar
+ */
+					case TEST_PATTERN_COLOR_BAR:
+					{
+						ov3640_write_reg(0x3300 ,0x08);
+					}break;
+
+					case TEST_PATTERN_DISABLE:
+					{
+						ov3640_write_reg(0x3300 ,0x13);
+						color_pattern	= TEST_PATTERN_DISABLE;
+					}
+				}
+				restore_color_pattern	= cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_TEST_PATTERN;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"Test pattern",strlen("Test pattern"));
+			cam->qctrl.minimum = TEST_PATTERN_COLOR_BAR;
+			cam->qctrl.maximum = TEST_PATTERN_DISABLE;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = TEST_PATTERN_DISABLE;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_17
+ *  Name	:	ov3640_i2c_client_xfer
+ *  Parameter1	:	INT32 addr	- Slave address (7-bit) address
+ *  Parameter2	:	PINT8 reg	- Ov3640 Register address base address
+ *  Parameter3	:	PINT8 buf	- Ov3640 Register data base address
+ *  Parameter4	:	INT32 num	- Number of data need to read/write in i2c transation
+ *  Parameter5	:	INT32 tran_flag	- 0- Write,1-read
+ *
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	Perform read/write data through i2c bus
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_i2c_client_xfer(	INT32 addr, PINT8 reg, PINT8 buf, INT32 num,	\
+				INT32 tran_flag)
+{
+	struct i2c_msg msg[2];
+	FNRESLT ret_val;
+	INT32 ret;
+	cam_data *cam	= NULL;
+	UINT8 reg_addr_data[3];
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to get the camera base pointer \n");
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+
+	if(cam->cam_sensor.client == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);		
+	}
+/*
+ * FIXME:
+ * 	
+ * 	I2C Write:
+ *	 	In i2c msg[0] "address part in write is success" but if we put data in msg [1] 
+ * 		that is not properly sent to device.
+ *
+ * 		so in the msg[0] part itself the data also sent here.
+ *
+ * 	I2CRead:
+ * 		But in read No problem is found and working fine
+ */
+	if(tran_flag & I2C_FLAG_READ)
+	{
+		msg[0].addr	= addr;
+		msg[0].len	= 2;
+		msg[0].buf	= reg;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		msg[1].addr	= addr;
+		msg[1].len	= num;
+		msg[1].buf	= buf;
+		msg[1].flags	= tran_flag;
+
+		if (tran_flag & I2C_FLAG_READ)
+		{
+			msg[1].flags |= I2C_M_RD;
+		}else
+		{
+			msg[1].flags &= ~I2C_M_RD;
+		}
+
+		if (cam->cam_sensor.client->adapter == NULL)
+		{
+			printk(KERN_ERR "%s:adapter error\n", __func__);
+			return -1;
+		}
+
+		ret = i2c_transfer(cam->cam_sensor.client->adapter, msg, 2);
+		if (ret >= 0)
+		{
+			return SUCCESS;
+		}
+	}else
+	{
+		reg_addr_data[0]	= reg[0];
+		reg_addr_data[1]	= reg[1];
+		reg_addr_data[2]	= buf[0];
+
+		msg[0].addr	= addr;
+		msg[0].len	= 3;
+		msg[0].buf	= reg_addr_data;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		ret = i2c_transfer(cam->cam_sensor.client->adapter, msg, 1);
+		if (ret >= 0)
+		{
+			return SUCCESS;
+		}
+	}
+	printk(KERN_ERR "%s:i2c transfer error:%d\n", __func__, ret);
+	TRACE_ERR_AND_RET(FAIL);
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_18	
+ *  Name	:	ov3640_write_reg
+ *  Parameter1	:	UINT16 reg_address	- Ov3640 register address
+ *  Parameter2	:	UINT8 reg_data		- Ov3640 register data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	This function write the data in the mentioned register address of ov3640 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_write_reg(UINT16 reg_address,UINT8 reg_data)
+{
+	UINT8 retry_count	= 3;
+	UINT8 reg_addr[2];
+	UINT8 reg_data_bw	= reg_data;
+	UINT8 reg_data_aw	= 0;
+	FNRESLT ret_val;
+
+
+	reg_addr[0]	= 0xFF & (reg_address >> 8);
+	reg_addr[1]	= 0xFF & reg_address;
+	
+	for(;retry_count;retry_count--)
+	{
+		udelay(100);
+		ret_val	= ov3640_i2c_client_xfer(OV3640_I2C_ADDRESS,reg_addr, &reg_data_bw, 1, 0);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			return I2C_WRITE_FAIL;
+		}
+
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+		printk(KERN_DEBUG "write : addr=%x, val=%x ",reg_address, reg_data_bw);
+#endif
+		if(check_sequence == ENABLE)
+		{
+
+			if((reg_address != 0x3f00) && (reg_address != 0x3012))
+			{
+				udelay(100);
+				ret_val	= ov3640_read_reg(reg_address,&reg_data_aw);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					return I2C_WRITE_FAIL;
+				}
+			}else
+			{
+				reg_data_aw	= reg_data_bw;
+			}
+
+
+			if(reg_data_bw == reg_data_aw)
+			{
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+				printk(KERN_DEBUG "  SUCCESS \n");
+#endif
+				break;
+			}else
+			{
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+				printk(KERN_DEBUG "  FAIL    \n");
+#endif
+				if(retry_count != 1)
+				{
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+					printk(KERN_DEBUG "  RETRY 	:    ");
+#endif
+				}			
+			}
+		}else
+		{
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+			printk(KERN_DEBUG "\n");
+#endif
+		}
+	}
+	
+	return I2C_WRITE_SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: SENS_OV3640_19	
+ *  Name	:	ov3640_read_reg
+ *  Parameter1	:	UINT16 reg_address	- Ov3640 register address
+ *  Parameter2	:	UPINT8 reg_data		- Ov3640 register data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	This function read the data in the mentioned register address of ov3640
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_read_reg(UINT16 reg_address,UPINT8 reg_data)
+{
+	UINT8 reg_addr[2];
+	reg_addr[0]	= 0xFF & (reg_address >> 8);
+	reg_addr[1]	= 0xFF & reg_address;
+
+	if (ov3640_i2c_client_xfer(OV3640_I2C_ADDRESS,reg_addr,reg_data, 1, 1) < 0)
+	{
+		printk("%s:read reg error: reg=%x, val=%x\n",__func__,reg_address ,*reg_data);
+		return -1;
+	}
+#if defined(CONFIG_DEBUG_E_CAM_DRIVER)
+	printk(KERN_DEBUG " read : addr=%x, val=%x",reg_address,*reg_data);
+#endif
+	udelay(100);
+
+	return I2C_WRITE_SUCCESS;
+
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_probe
+ *  Parameter1	:	struct i2c_client *client
+ *  Parameter2	:	const struct i2c_device_id *id
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	Configure the gpio levels for ov3640 driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+static INT32 ov3640_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	cam_data *cam	= NULL;
+	FNRESLT ret_val;
+
+	if (i2c_get_clientdata(client))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		goto exit;
+	}
+	
+/*
+ * 	set the client data 
+ */
+	cam->cam_sensor.client =	client;
+
+/*
+ * Make sure the mclk clock is enabled 
+ */
+
+/*
+ * Configure the gpio levels
+ */
+
+	gpio_request(RESET_GPIO,"ov3640");
+	gpio_request(STANDBY_GPIO,"ov3640");
+
+	gpio_direction_output(RESET_GPIO, true);
+	gpio_direction_output(STANDBY_GPIO, true);
+	/* Turn ON Omnivision sensor */
+	gpio_set_value(RESET_GPIO, ENABLE);
+	gpio_set_value(STANDBY_GPIO, DISABLE);
+	udelay(100);
+
+	/* RESET Omnivision sensor */
+	gpio_set_value(RESET_GPIO, DISABLE);
+	udelay(100);
+	gpio_set_value(RESET_GPIO, ENABLE);
+
+/*
+ *	TODO: Description for udelay(100)
+ *	 We faced poweron time delay with ov5642 on 15APR2010.
+ *	 So we hard coded 100 micro second delay on ov3640 also 
+ *	 to be on the Safer side.
+ *
+ *	 But this can be done better (If reading the register failed then put the
+ *	 delay and read again in the probing sequence only).
+ */
+	udelay(100);
+
+	return SUCCESS;
+	exit:
+	{
+		TRACE_ERR_AND_RET(-ENODEV);
+	}	
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_remove
+ *  Parameter1	:	struct i2c_client *client
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	remove routine of ov3640 i2c driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+static INT32 ov3640_remove(struct i2c_client *client)
+{
+	if (!client->adapter)
+	{
+		/* our client isn't attached */
+		TRACE_ERR_AND_RET(-ENODEV);
+	}	
+
+	i2c_set_clientdata(client, NULL);
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_init	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	ov3640 init part of code done here
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+#define OV3640_DRIVER_NAME	"ov3640"
+/*
+ * i2c driver init
+ */
+static const struct i2c_device_id ov3640_id[] =			\
+{
+	{ OV3640_DRIVER_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c_0, ov3640_id);
+
+FNRESLT ov3640_init(cam_data *cam)
+{
+	FNRESLT  ret_val;
+	UINT32	index			= DISABLE;
+	UINT32	fmt_index		= DISABLE;
+	UINT32	frame_rate_index	= DISABLE;
+	
+	cam->cam_sensor.i2c_driver.driver.name	= OV3640_DRIVER_NAME;
+	cam->cam_sensor.i2c_driver.driver.owner	= THIS_MODULE;
+	cam->cam_sensor.i2c_driver.probe	= ov3640_probe;
+	cam->cam_sensor.i2c_driver.remove	= __exit_p(ov3640_remove);
+	cam->cam_sensor.i2c_driver.id_table	= ov3640_id;
+
+
+
+	if(i2c_add_driver(&cam->cam_sensor.i2c_driver))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	if(cam->cam_sensor.find_device)
+	{
+		ret_val	= cam->cam_sensor.find_device(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			ov3640_exit(cam);
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+
+/*
+ * init the sensor capability
+ */
+	
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"RGB565",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_RGB565;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"UYVY, packed",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_UYVY;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"YUYV, packed",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_YUYV;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"BA81, BGBG",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_SBGGR8;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"YUV444, packed",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_YUV444;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+#if 0	
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"YUV420, packed",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_YUV420;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+#endif
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"RGB555",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_RGB555;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.formats[index].index		= index;
+	memcpy(	cam->cam_sensor.formats[index].description,	\
+		"BGR888",					\
+		sizeof(cam->cam_sensor.formats[index].description));
+
+	cam->cam_sensor.formats[index].pixelformat	= V4L2_PIX_FMT_BGR32;
+	cam->cam_sensor.formats[index].type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	index++;
+
+	cam->cam_sensor.total_fmt_desc	= index;
+
+/*
+ * init the sensor capable formats
+ */
+	cam->cam_sensor.frms[fmt_index].index			= fmt_index;
+//	cam->cam_sensor.frms[fmt_index].pixel_format		= All pixel formates supported;
+	cam->cam_sensor.frms[fmt_index].type			= V4L2_FRMSIZE_TYPE_STEPWISE;
+
+	cam->cam_sensor.frms[fmt_index].stepwise.min_width	= MIN_OV3640_WIDTH;
+	cam->cam_sensor.frms[fmt_index].stepwise.max_width	= MODE_XGA_WIDTH;
+	cam->cam_sensor.frms[fmt_index].stepwise.step_width	= 32;
+	cam->cam_sensor.frms[fmt_index].stepwise.min_height	= MIN_OV3640_HEIGHT;
+	cam->cam_sensor.frms[fmt_index].stepwise.max_height	= MODE_XGA_HEIGHT;
+	cam->cam_sensor.frms[fmt_index].stepwise.step_height	= 32;
+	fmt_index++;
+
+	cam->cam_sensor.frms[fmt_index].index			= fmt_index;
+//	cam->cam_sensor.frms[fmt_index].pixel_format		= All pixel formates supported;
+	cam->cam_sensor.frms[fmt_index].type			= V4L2_FRMSIZE_TYPE_DISCRETE;
+
+	cam->cam_sensor.frms[fmt_index].discrete.width		= MAX_OV3640_WIDTH;
+	cam->cam_sensor.frms[fmt_index].discrete.height		= MAX_OV3640_HEIGHT;
+	fmt_index++;
+	cam->cam_sensor.total_frms_support	= fmt_index;
+
+/*
+ * initialize the frame interval capability of the sensor
+ */
+	cam->cam_sensor.frm_interval_support[frame_rate_index].index			= frame_rate_index;
+//	cam->cam_sensor.frm_interval_support[frame_rate_index].pixel_format		= Support all formats;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].width			= MODE_XGA_WIDTH;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].height			= MODE_XGA_HEIGHT;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].type			= V4L2_FRMSIZE_TYPE_STEPWISE;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.min.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.min.denominator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.max.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.max.denominator	= SENS_MAX_FPS;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.step.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.step.denominator= 1;
+	frame_rate_index++;
+
+	cam->cam_sensor.frm_interval_support[frame_rate_index].index			= frame_rate_index;
+//	cam->cam_sensor.frm_interval_support[frame_rate_index].pixel_format		= Support all formats;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].width			= MAX_OV3640_WIDTH;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].height			= MAX_OV3640_HEIGHT;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].type			= V4L2_FRMSIZE_TYPE_STEPWISE;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.min.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.min.denominator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.max.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.max.denominator	= 7;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.step.numerator	= 1;
+	cam->cam_sensor.frm_interval_support[frame_rate_index].stepwise.step.denominator= 1;
+	frame_rate_index++;
+
+	cam->cam_sensor.total_frm_interval_support	= frame_rate_index;
+
+/*
+ * configure the sensor
+ */
+	ret_val	= ov3640_init_config(cam);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+/*
+ * Dump autofocus firmware the sensor
+ */
+
+	if(cam->cam_sensor.auto_focus_init)
+	{
+		ret_val	= cam->cam_sensor.auto_focus_init(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{	
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+
+	cam->capture.s_parm.parm.capture.timeperframe.denominator	= 	\
+	cam->cam_sensor.s_parm.parm.capture.timeperframe.denominator 	= 30;
+	cam->capture.s_parm.parm.capture.timeperframe.numerator		=	\
+	cam->cam_sensor.s_parm.parm.capture.timeperframe.numerator	= 1;
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_detect_device
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_detect_device(cam_data *cam)
+{
+	FNRESLT ret_val;
+	UINT8 reg_data_aw	= 0x00;
+
+	ret_val	= ov3640_read_reg(0x300a,&reg_data_aw);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}	
+
+	if(reg_data_aw != OV3640_DEVICE_ID)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}else
+	{
+		printk(KERN_INFO "\nov3640 found: product id is 0x%02X \n",reg_data_aw);
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_exit
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_exit(cam_data *cam)
+{
+	i2c_del_driver(&cam->cam_sensor.i2c_driver);
+	memset(&cam->cam_sensor,0x00,sizeof(struct camera_sensor));
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_reset_config
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT ov3640_reset_config(cam_data *cam)
+{
+	return SUCCESS;
+	
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	chk_pix_format_support
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT chk_pix_format_support(cam_data *cam)
+{
+	switch(cam->cam_sensor.fmt.fmt.pix.pixelformat)	
+	{
+		case V4L2_PIX_FMT_UYVY:
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_RGB555:
+		{
+			cam->cam_sensor.fmt.fmt.pix.bytesperline	= cam->cam_sensor.fmt.fmt.pix.width * 2;
+
+			cam->cam_sensor.fmt.fmt.pix.sizeimage		= cam->cam_sensor.fmt.fmt.pix.bytesperline *	\
+									cam->cam_sensor.fmt.fmt.pix.height;
+		}break;
+#if 0		
+		case V4L2_PIX_FMT_YUV420:
+		{
+			cam->cam_sensor.fmt.fmt.pix.bytesperline	= cam->cam_sensor.fmt.fmt.pix.width * 2;
+
+			cam->cam_sensor.fmt.fmt.pix.sizeimage		= cam->cam_sensor.fmt.fmt.pix.bytesperline *	\
+									cam->cam_sensor.fmt.fmt.pix.height *3/4;
+
+		}break;
+#endif
+		case V4L2_PIX_FMT_YUV444:
+		case V4L2_PIX_FMT_BGR32:
+		{
+			cam->cam_sensor.fmt.fmt.pix.bytesperline	= cam->cam_sensor.fmt.fmt.pix.width * 3;
+			cam->cam_sensor.fmt.fmt.pix.sizeimage		= cam->cam_sensor.fmt.fmt.pix.bytesperline *	\
+									cam->cam_sensor.fmt.fmt.pix.height;
+		}break;
+
+		case V4L2_PIX_FMT_SBGGR8:
+		{
+			cam->cam_sensor.fmt.fmt.pix.bytesperline	= cam->cam_sensor.fmt.fmt.pix.width;
+
+			cam->cam_sensor.fmt.fmt.pix.sizeimage		= cam->cam_sensor.fmt.fmt.pix.bytesperline *	\
+									cam->cam_sensor.fmt.fmt.pix.height;
+			
+		}break;
+		default:
+		{
+			printk(KERN_INFO "chk_pix_format_support Searching for %c%c%c%c\n",				\
+							(INT8)(0xFF&(cam->cam_sensor.fmt.fmt.pix.pixelformat)),	\
+							(INT8)(0xFF&(cam->cam_sensor.fmt.fmt.pix.pixelformat>>8)),	\
+							(INT8)(0xFF&(cam->cam_sensor.fmt.fmt.pix.pixelformat>>16)),	\
+							(INT8)(0xFF&(cam->cam_sensor.fmt.fmt.pix.pixelformat>>24)));
+
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_query_formats
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_query_formats(cam_data *cam)
+{
+	switch(cam->cam_sensor.qfmt.type)
+	{
+		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		{
+			if(	(cam->cam_sensor.qfmt.fmt.pix.width > MAX_OV3640_WIDTH)		|| 	\
+				(cam->cam_sensor.qfmt.fmt.pix.width < MIN_OV3640_WIDTH)		||	\
+				(cam->cam_sensor.qfmt.fmt.pix.height > MAX_OV3640_HEIGHT)	||	\
+				(cam->cam_sensor.qfmt.fmt.pix.height < MIN_OV3640_HEIGHT)
+			)
+			{
+					TRACE_ERR_AND_RET(FAIL);
+			}
+
+#if 0
+/*
+ * FIXME:
+ * 	From sensor uxga frame corruoption is happening,
+ * 	So we fixed in the driver to exclude the problemmatic dimension.
+ */
+				(((cam->cam_sensor.qfmt.fmt.pix.width > FRM_CRPT_OV3640_WIDTH)	||  	\
+				(cam->cam_sensor.qfmt.fmt.pix.height > FRM_CRPT_OV3640_HEIGHT))	&&	\
+				((cam->cam_sensor.qfmt.fmt.pix.width < MAX_OV3640_WIDTH)		||	\
+				(cam->cam_sensor.qfmt.fmt.pix.height < MAX_OV3640_HEIGHT))))
+			{
+				TRACE_ERR_AND_RET(FAIL);					
+			}
+#endif
+			switch(cam->cam_sensor.qfmt.fmt.pix.pixelformat)	
+			{
+				case V4L2_PIX_FMT_UYVY:
+				case V4L2_PIX_FMT_YUYV:
+				case V4L2_PIX_FMT_RGB565:
+				case V4L2_PIX_FMT_SBGGR8:
+				{
+					break;
+				}
+		
+				default:
+				{
+					printk(KERN_INFO "chk_pix_format_support Searching for %c%c%c%c\n",		\
+							(INT8)(0xFF&(cam->cam_sensor.qfmt.fmt.pix.pixelformat)),	\
+							(INT8)(0xFF&(cam->cam_sensor.qfmt.fmt.pix.pixelformat>>8)),	\
+							(INT8)(0xFF&(cam->cam_sensor.qfmt.fmt.pix.pixelformat>>16)),	\
+							(INT8)(0xFF&(cam->cam_sensor.qfmt.fmt.pix.pixelformat>>24)));
+
+					TRACE_ERR_AND_RET(FAIL);
+				}
+			}
+		}break;
+		default:
+		{
+			printk(KERN_DEBUG "Unsupported format type : %x \n",cam->cam_sensor.qfmt.type);
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	ov3640_fix_supported_formats
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+FNRESLT ov3640_fix_supported_formats(cam_data *cam)
+{
+	FNRESLT ret_val;
+
+	switch(cam->cam_sensor.fmt.type)
+	{
+		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		{
+/*
+ * FIXME:
+ * 	From sensor uxga frame corruoption is happening,
+ * 	So we fixed in the driver to exclude the problemmatic dimension.
+ */
+			if(											\
+				(((cam->cam_sensor.fmt.fmt.pix.width > MODE_XGA_WIDTH)		||  		\
+				(cam->cam_sensor.fmt.fmt.pix.height > MODE_XGA_HEIGHT))		&&		\
+				((cam->cam_sensor.fmt.fmt.pix.width < MAX_OV3640_WIDTH)		||		\
+				(cam->cam_sensor.fmt.fmt.pix.height < MAX_OV3640_HEIGHT))))
+			{
+				cam->cam_sensor.fmt.fmt.pix.width	= MAX_OV3640_WIDTH;
+				cam->cam_sensor.fmt.fmt.pix.height	= MAX_OV3640_HEIGHT;
+			}
+/*
+ * Fixing the sensor frame supported limits
+ */
+			cam->cam_sensor.fmt.fmt.pix.width		+=((cam->cam_sensor.fmt.fmt.pix.width%16)?
+										(16-(cam->cam_sensor.fmt.fmt.pix.width%16)):0);
+			if(cam->cam_sensor.fmt.fmt.pix.width	> MAX_OV3640_WIDTH)
+			{
+				cam->cam_sensor.fmt.fmt.pix.width	= MAX_OV3640_WIDTH;
+			}else if(cam->cam_sensor.fmt.fmt.pix.width < MIN_OV3640_WIDTH)
+			{
+				cam->cam_sensor.fmt.fmt.pix.width	= MIN_OV3640_WIDTH;
+			}
+			
+			if(cam->cam_sensor.fmt.fmt.pix.height > MAX_OV3640_HEIGHT)
+			{
+				cam->cam_sensor.fmt.fmt.pix.height	= MAX_OV3640_HEIGHT;
+			}else if(cam->cam_sensor.fmt.fmt.pix.height < MIN_OV3640_HEIGHT)
+			{
+				cam->cam_sensor.fmt.fmt.pix.height	= MIN_OV3640_HEIGHT;
+			}
+
+			ret_val	= chk_pix_format_support(cam);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				TRACE_ERR_AND_RET(FAIL);					
+			}
+			return SUCCESS;
+		}break;
+#if 0
+		case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+		{
+			
+		}break;
+#endif		
+		default:
+		{
+			printk(KERN_DEBUG "Unsupported format type : %x \n",cam->cam_sensor.fmt.type);
+			TRACE_ERR_AND_RET(FAIL);					
+
+		}
+	}
+
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	: 
+ *  Name	:	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer 
+ *  
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ ************************************************************************************************************/
+FNRESLT ov3640_register_access(cam_data *cam)
+{
+	FNRESLT ret_val;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			UINT32 reg_address;
+			UINT8 reg_value;
+
+			reg_address	= (cam->ctrl.value & 0xFFFF0000)>>16;
+			ret_val	= ov3640_read_reg(reg_address,&reg_value);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				return ret_val;
+			}
+			cam->ctrl.value	= (0xFFFF0000 & (reg_address << 16)) | reg_value;
+		}break;
+
+		case SET_DATA:
+		{
+			UINT32 reg_address;
+			UINT8 reg_value;
+			FNRESLT ret_val;
+
+			reg_address	= (cam->ctrl.value & 0xFFFF0000)>>16;
+			reg_value	= (cam->ctrl.value & 0x000000FF);
+			ret_val	= ov3640_write_reg(reg_address,reg_value);
+			if(CHECK_IN_FAIL_LIMIT(ret_val))
+			{
+				return ret_val;
+			}
+		}
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	register_sensor_bus
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT register_sensor_bus(cam_data *cam)
+{
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	cam->cam_sensor.init			= ov3640_init;
+	cam->cam_sensor.exit			= ov3640_exit;
+	cam->cam_sensor.find_device		= ov3640_detect_device;
+
+	cam->cam_sensor.reset			= ov3640_reset_config;
+	cam->cam_sensor.config_dim		= ov3640_change_dim_config;
+	cam->cam_sensor.brightness		= ov3640_brightness;			
+	cam->cam_sensor.contrast		= ov3640_contrast;
+	cam->cam_sensor.saturation		= ov3640_saturation;
+	cam->cam_sensor.hue			= NULL;
+	cam->cam_sensor.whitebalance		= ov3640_white_balance;
+	cam->cam_sensor.colour_balance		= NULL;
+	cam->cam_sensor.exposure		= ov3640_exposure;
+	cam->cam_sensor.gain			= NULL;
+	cam->cam_sensor.v_flip			= ov3640_vertical_flip;
+	cam->cam_sensor.h_mirror		= ov3640_horizontal_mirror;
+	cam->cam_sensor.sharpness		= ov3640_sharpness;
+	cam->cam_sensor.sens_strobe		= ov3640_sens_strobe;
+	cam->cam_sensor.auto_focus_init		= ov3640_af_firmware_dump;
+	cam->cam_sensor.focus			= ov3640_focus;
+	cam->cam_sensor.test_color_pattern	= ov3640_color_pattern;
+	cam->cam_sensor.effects			= ov3640_effects;
+	cam->cam_sensor.antishake		= ov3640_antishake_firmware_ctrl;
+	cam->cam_sensor.frame_rate_ctrl		= ov3640_frame_rate_ctrl;
+	cam->cam_sensor.supported_formats	= ov3640_format_support;
+	cam->cam_sensor.frame_interval		= ov3640_frame_interval_support;
+
+	cam->cam_sensor.crop			= ov3640_crop;
+	cam->cam_sensor.fix_fmt_support		= ov3640_fix_supported_formats;
+	cam->cam_sensor.qfmt_support		= ov3640_query_formats;
+
+	cam->cam_sensor.reg_access		= ov3640_register_access;
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/ov3640/sens_ov3640.h linux-ths/drivers/media/video/ecam32/ov3640/sens_ov3640.h
--- linux-org/drivers/media/video/ecam32/ov3640/sens_ov3640.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/ov3640/sens_ov3640.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,136 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+#define RESET_GPIO			98
+
+#if (	defined(CONFIG_BOARD_e_CAM32_OMAP35x_MICRON)			| \
+	defined(CONFIG_BOARD_e_CAM32_DM37x))
+	#define STANDBY_GPIO		157
+#elif (defined(CONFIG_BOARD_e_CAM32_OMAP35x) | defined(CONFIG_BOARD_e_CAM32_OMAP_GSTIX))
+	#define STANDBY_GPIO		167
+#endif
+
+#define OV3640_DEVICE_ID		0x36
+/*
+ * I2C
+ */
+
+#define OV3640_I2C_ADDRESS		0x3C
+#define I2C_SLAVE_ADDRESS		OV3640_I2C_ADDRESS
+
+
+#define FRM_CRPT_OV3640_WIDTH		1280
+#define FRM_CRPT_OV3640_HEIGHT		1024
+
+#define MAX_OV3640_WIDTH		2048
+#define MAX_OV3640_HEIGHT		1536
+
+#define MIN_OV3640_WIDTH		 160
+#define MIN_OV3640_HEIGHT		 120
+
+#define MODE_XGA_WIDTH			1024
+#define MODE_XGA_HEIGHT			 768
+
+#define SENS_MAX_FPS			  30
+#define SENS_MAX_PCLK_SUPPORT	    56000000
+
+#define SENS_DEFAULT_WIDTH		MIN_OV3640_WIDTH
+#define SENS_DEFAULT_HEIGHT		MIN_OV3640_HEIGHT
+
+/*
+ * Auto focus status register
+ */
+#define STEP_FORWARD			(1 << 7)
+#define STEP_BACKWARD			(1 << 6)
+#define STEP_ABSOLUTE			(1 << 5)
+
+#define MODE_STEP_INSTRUCTION		0x00
+#define MODE_STEP_FOCUSING		0x01
+#define MODE_STEP_FOCUSED		0x02
+#define MODE_STEP_CAPTURE		0x03
+
+#define MODE_IDLE			0x00
+#define MODE_SINGLE_FOCUS		0x01
+#define MODE_CONTINOUS_FOCUS		0x02
+#define MODE_STEP_MODE			0x03
+
+typedef union _auto_focus_register_status
+{
+	UINT8 reg_data;
+	struct
+	{
+/*
+ * Mode Step
+ * 	0 0	- Instruction 
+ * 	0 1	- Focusing
+ * 	1 0 	- Focused
+ * 	1 1	- Capture	 
+ */
+		UINT8 mode_step	:2;
+/*
+ * Mode
+ * 	0 0 	- Idle Mode
+ * 	0 1 	- Single Focus Mode
+ * 	1 0 	- Continue Focus Mode
+ * 	1 1 	- Step Mode
+ */
+
+
+		UINT8 mode		:2;
+		UINT8 RESERVED		:1;
+		UINT8 capture_mask	:1;
+		UINT8 mode_chg_mask	:1;
+/*
+ * 	Step State 
+ * 	1	- Failed 
+ * 	0	- Success
+ */
+		UINT8 step_state	:1;
+	}focus;
+}af_status;
+
+enum __effects
+{
+	EFFECT_NORMAL,
+	EFFECT_SEPIA,
+	EFFECT_MONOCHROME,
+	EFFECT_NEGATIVE,
+	EFFECT_BLUISH,
+	EFFECT_GREENISH,
+	EFFECT_REDDISH,
+	EFFECT_YELLOWISH,
+};
+
+enum __test_pattern
+{
+	TEST_PATTERN_COLOR_BAR,
+	TEST_PATTERN_DISABLE,
+};
+
diff -Naur linux-org/drivers/media/video/ecam32/resource/include/error.h linux-ths/drivers/media/video/ecam32/resource/include/error.h
--- linux-org/drivers/media/video/ecam32/resource/include/error.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/include/error.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,259 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :         Error code management                                                *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 0.0.0.0   code development                                                         Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+/******************************************************************************
+ *  			GENDRAL ERROR TYPE DEFINITION
+ *				
+ *  Author	:	E-consystems
+ *
+ *
+ ******************************************************************************/
+
+#define TRACE_ERROR(ARG1) 											\
+{														\
+	trace_error(__FILE__,(PINT8)__FUNCTION__,__LINE__,ARG1);						\
+}
+
+#define TRACE_ERR_AND_RET(ARG1) 										\
+{														\
+	trace_error(__FILE__,(PINT8)__FUNCTION__,__LINE__,ARG1);						\
+	return ARG1;												\
+}
+
+/******************************************************************************
+ * 			Device structure register 
+ *
+ ******************************************************************************/
+
+#define REGISTER_DATA			0x00000001			
+#define UNREGISTER_CLEAR_ENTRY		0x00000002
+#define GET_REGISTERED_DATA		0x00000003
+
+#define NO_DATA				0x00000000
+#define RESET_TIME			0x00000001
+
+#define ERROR_BLOCK			0x00100000
+
+/******************************************************************************
+ *  				API RETURN TYPE Definition 
+ *				
+ *  Author		:	E-consystems
+ *
+ *  APPLICATION SPECIFIC SUCCESS      RANGE - (0x0000_0000 - 0x3FFF_FFFF)
+ *  =========================================================================
+ *
+ *
+ *  DRIVER SPECIFIC SUCCESS BASES     RANGE - (0x4000_0000 - 0x7FFF_FFFF)
+ *  =========================================================================
+ *  BASIC SUCCESS	:	0x7EE0_0000 - 0x7EEF_FFFF
+ *  I2C SUCCESS		:	0x7ED0_0000 - 0x7EDF_FFFF
+ *
+ *  ----------------------------------------------------------------------------
+ *
+ *
+ *  DRIVER SPECIFIC ERRORS            RANGE - (0x8000_0000 - 0xBFFF_FFFF)
+ *  =========================================================================
+ *  BASIC ERRORS	:	0x8000_0000 - 0x800F_FFFF
+ *  I2C ERROR		:	0x8010_0000 - 0x801F_FFFF
+ *  MEMORY ERROR	:	0x8020_0000 - 0x802F_FFFF
+ *
+ *  APPLICATION SPECIFIC ERRORS BASES:RANGE - (0xC000_0000 - 0xFF7F_FFFF)
+ *  =========================================================================
+ *  BASIC ERROR 	:	0xC000_0000 - 0xC00F_FFFF
+ *  READ ERROR		:	0xC010_0000 - 0xC01F_FFFF 
+ *  WRITE ERROR 	:	0xC020_0000 - 0xC02F_FFFF 
+ *  memory ERROR	:	0xC030_0000 - 0xC03F_FFFF
+ *  Ioctls ERROR	:	0xC040_0000 - 0xC04F_FFFF
+ *  =========================================================================
+ *
+ *
+ *  SPECIAL ERROR	:	0xFF80_0000 - 0xFFFF_FFFF
+ *
+ ******************************************************************************/
+
+
+enum __error_base_macro
+{
+	APP_BASE_SUC_START	= 0x00000000,
+	APP_BASE_SUC_END	= 0x3FFFFFFF,
+	DRI_BASE_SUC_START	= 0x40000000,
+	DRI_BASE_SUC_END	= 0x7FFFFFFF,
+
+	DRI_BASE_ERR_START	= 0x80000000,
+	DRI_BASIC_ERR		= DRI_BASE_ERR_START,
+	DRI_I2C_ERROR		= (DRI_BASIC_ERR + ERROR_BLOCK),
+	DRI_MEM_ERROR		= (DRI_I2C_ERROR + ERROR_BLOCK),
+
+	DRI_BASE_ERR_END	= 0xBFFFFFFF,
+
+	APP_BASE_ERR_START	= 0xC0000000,
+	APP_BASIC_ERR		= APP_BASE_ERR_START,
+	APP_READ_ERR		= (APP_BASIC_ERR	+ ERROR_BLOCK),
+	APP_WRITE_ERR		= (APP_READ_ERR		+ ERROR_BLOCK),
+	APP_MEMORY_ERR		= (APP_WRITE_ERR	+ ERROR_BLOCK),
+	APP_IOCTL_ERR		= (APP_MEMORY_ERR	+ ERROR_BLOCK),
+	APP_BASE_ERR_END	= 0xFF7FFFFF,
+
+	SPECIAL_ERROR_START	= 0xFF800000,
+	SPECIAL_ERROR_END	= 0xFFFFFFFF,
+};
+
+#define CHECK_IN_SUCCESS_LIMIT(x)			((x >= (FNRESLT)APP_BASE_SUC_START) && (x <= (FNRESLT)DRI_BASE_SUC_END))
+#define CHECK_IN_FAIL_LIMIT(x)				((x >= (FNRESLT)DRI_BASE_ERR_START ) && (x <= (FNRESLT)SPECIAL_ERROR_END))
+
+enum __error_base
+{
+/****************************************************************************
+ *
+ * 		Application Specific SUCCESS code definitions
+ *
+ ****************************************************************************/
+
+	SUCCESS				= APP_BASE_SUC_START,
+
+/****************************************************************************
+ *
+ * 		Driver Specific SUCCESS code definitions
+ *
+ ****************************************************************************/
+	I2C_INIT_SUCCESS		= DRI_BASE_SUC_START,
+	I2C_TX_EMPTY_SEND_SUCCESS,
+	I2C_WRITE_SUCCESS,
+	I2C_RX_FULL_SUCCESS,
+	I2C_READ_SUCCESS,
+	I2C_CAM_READ_REGISTER_SUCCESS,
+	I2C_PROTO_READ_ID_SUCCESS,
+	PAGE_0_REG_ACCESS_SUCCESS,
+	PAGE_1_REG_ACCESS_SUCCESS,
+	PAGE_2_REG_ACCESS_SUCCESS,
+	MT9D111_DUMP_ALL_SUCCESS,
+	MT9D111_SOFT_RESET_SUCCESS,
+	I2C_BUS_AVAILABLE,
+
+/****************************************************************************
+ *
+ * 		Driver Specific Error code definitions
+ *
+ ****************************************************************************/
+
+/*
+ * BASIC ERROR definition
+ */
+	DRIVER_MEMORY_NOT_AVAILABLE	= DRI_BASIC_ERR,
+
+/*
+ * I2C ERROR definition
+ */
+	I2C_INIT_FAIL			= DRI_I2C_ERROR,
+	I2C_TX_EMPTY_SEND_FAIL,
+	I2C_WRITE_FAIL,
+	I2C_RX_FULL_FAIL,
+	I2C_READ_FAIL,
+	I2C_CAM_READ_REGISTER_FAIL,
+	I2C_PROTO_READ_ID_FAIL,
+	PAGE_0_REG_ACCESS_FAIL,
+	PAGE_1_REG_ACCESS_FAIL,
+	PAGE_2_REG_ACCESS_FAIL,
+	MT9D111_SOFT_RESET_FAIL,
+	CLK_BYPASS_PLL_FAIL,
+	MCU_RESET_VALUE_FAIL,
+	RESET_EN_REG_VALUE_FAIL,
+	RESET_DIS_REG_VALUE_FAIL,
+	I2C_BUS_BUSY,
+
+/*
+ * Memory Error definition
+ */
+	MEM_KERN_OVERLAP		= DRI_MEM_ERROR,
+	
+/****************************************************************************
+ *
+ *			Application based error types
+ *
+ ****************************************************************************/
+
+/*
+ * BASIC ERROR definition
+ */
+
+	PORT_OPEN_FAILURE		= APP_BASIC_ERR,
+	FILE_OPEN_FAILURE,
+
+/*
+ * READ ERROR definition
+ */
+
+	READ_ERROR			= APP_READ_ERR,
+	LOOSING_BYTES_IN_READ,
+	LESS_NUM_BYTE_READ,
+	MORE_NUM_BYTE_READ,
+	LESS_NUMBER_BYTE_IN_PORT,
+	READ_FROM_DEVICE_FAIL,
+
+/*
+ * WRITE ERROR definition
+ */
+	WRITE_ERROR			= APP_WRITE_ERR,
+	LESS_NUM_BYTE_WRITE,
+	MORE_NUM_BYTE_WRITE,
+	FAILED_TO_WRITE_TO_PORT,
+
+
+/*
+ * MEMORY ERROR definition
+ */
+	MEMORY_ERROR			= APP_MEMORY_ERR,
+	ALLOCATION_MEMORY_FAILED,
+	MEMORY_NOT_VALID,
+
+/*
+ * IOCTLS ERROR definition
+ */
+	IOCTLS_ERROR			= APP_IOCTL_ERR,
+	DATA_FRM_PORT_NOT_VALID,
+	IOCTL_GET_DATA_FAILED,
+	IOCTL_LOGING_DATA_FAILED,
+
+/*
+ * Special type of Errors
+ */
+	CAPTURE_FORMAT_NOT_AVAILABLE	= SPECIAL_ERROR_START,
+	MAPPING_FAILED,
+	POINTER_NOT_REGISTERED,
+	ALLOCATION_MEMORY_FAILED_BASED_POINTER,
+
+
+	PORT_OPEN_ERROR			= -1,
+	FAIL				= -1,
+
+};
+
+
diff -Naur linux-org/drivers/media/video/ecam32/resource/include/fn_res_protype.h linux-ths/drivers/media/video/ecam32/resource/include/fn_res_protype.h
--- linux-org/drivers/media/video/ecam32/resource/include/fn_res_protype.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/include/fn_res_protype.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,72 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :         Error code management                                                *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 0.0.0.0   code development                                                         Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * *********************************************************************************************************
+ *
+ * 			FUNCTION PROTO TYPE USED IN THE RESOURCE PROJECT
+ *
+ * *********************************************************************************************************
+ */
+
+/*
+ * common.c
+ */
+
+PINT0 map_kernel_space(ULINT32 physaddr, UINT32 size);
+INT32 unmap_kernel_space(volatile PINT0 start, size_t length);
+FNRESLT printstring(IN UPINT8 string,IN UINT32 string_length);
+
+/*
+ * error.c
+ */
+
+FNRESLT_NONE trace_error(PINT8 file_name,PINT8 function_name,UINT32 line_no,UINT32 Error_num);
+
+/*
+ * memory_monitor.c
+ */
+
+PINT0 wrapper_memory_api(UPINT8 function_name,UINT32 lineno,UDPINT32 address,UINT32 size,UINT32 block,UINT32 status);
+FNRESLT check_pointer_availability(UPINT32 list_memory,UINT32 count,UPINT32 pointer,UPINT32 current_record);
+FNRESLT maintain_log(UPINT8 function_name,UINT32 lineno,UDPINT32 pointer,UINT32 allocation_memory_size,UINT32 block_size,UINT32 status);
+
+#if defined(CONFIG_DRIVER)
+/*
+ * phy_mem.c
+ */
+	FNRESLT list_all_phy_struct(INT0);
+	FNRESLT free_all_phy_struct(INT0);
+	FNRESLT free_phy_mem(UINT32 phy_addr);
+	FNRESLT get_free_phy_mem(UINT32 size,UPINT32 phy_addr,UPINT32 vir_addr);
+	FNRESLT init_phy_mem(INT0);
+	FNRESLT exit_phy_mem(INT0);
+
+#endif
diff -Naur linux-org/drivers/media/video/ecam32/resource/include/Headerfile.h linux-ths/drivers/media/video/ecam32/resource/include/Headerfile.h
--- linux-org/drivers/media/video/ecam32/resource/include/Headerfile.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/include/Headerfile.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,218 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :      Gendral Header file incluton                                            *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 0.0.0.0   code development                                                         Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * Custom header file
+ */
+#include "typedef.h"
+
+
+/*
+ * Application Part Header 
+ */
+
+
+#ifdef CONFIG_APPLICATION
+/*
+ * Standard Header file
+ */
+
+	#ifdef HAVE_CONFIG_H
+		#include <config.h>
+	#endif
+
+	#include <stdio.h>
+	#include <stdlib.h>
+	#include <string.h>
+	#include <fcntl.h>
+	#include <termios.h>
+	#include <unistd.h>
+
+	#include <sys/types.h>
+	#include <sys/stat.h>
+	#include <sys/time.h>
+	#include <sys/ioctl.h>
+	#include <sys/mman.h>
+
+/*
+ * include custom header file
+ */
+	#ifdef HAVE_IOCTL_DEF 
+		#include "ioctls_def.h"
+	#endif
+#endif
+
+/*
+ * Driver Part Header file 
+ */
+#ifdef CONFIG_DRIVER
+	#include <linux/init.h>
+	#include <linux/module.h>
+	#include <linux/kernel.h> 		// printk() 
+	#include <linux/slab.h> 		// kmalloc() 
+	#include <linux/fs.h> 			// everything\ldots{} 
+	#include <linux/errno.h> 		// error codes 
+	#include <linux/types.h> 		// size_t 
+	#include <linux/proc_fs.h>
+	#include <linux/fcntl.h>		// O_ACCMODE 
+	#include <linux/ioport.h>
+	#include <asm/system.h>			// cli(), *_flags 
+	#include <asm/uaccess.h>		// copy_from/to_user 
+	#include <asm/io.h>			// inb, outb 
+	#include <linux/interrupt.h>
+	#include <linux/types.h>
+	#include <asm/types.h>
+	#include <linux/delay.h>		// for udelay()
+	#include <asm/delay.h>
+	#include <linux/unistd.h>
+	#include <linux/device.h>
+	#include <asm/dma.h>
+	#include <linux/version.h>
+	#include <linux/i2c.h>
+	#include <linux/platform_device.h>
+	#include <linux/clk.h>
+	#include <linux/page-flags.h>
+	#include <linux/mm.h>
+
+	#ifdef USE_KERNEL_MEMORY_MANAGE
+		#include "kernel/phy_mem.h"
+	#endif
+
+	#ifdef USE_KERNEL_THREAD
+		#include <linux/kthread.h>
+		#include <linux/mutex.h>
+	#endif
+
+	#ifdef KERNEL_ARM_PXA270
+		#include <asm/arch/pxa-regs.h>
+		#include <asm/arch/irqs.h>
+		#include <asm-arm/arch-pxa/dma.h>
+		#include <asm-arm/page.h>
+
+		#ifdef CONFIG_KERNEL_2_6_15_2
+			#include <linux/config.h>
+		#else
+			#include <linux/autoconf.h>
+		#endif
+
+	#endif
+
+	#ifdef KERNEL_ARM_OMAP
+		#ifdef KERNEL_ARM_OMAP3530
+		#endif
+	#endif
+
+	#ifdef KERNEL_ARM_IMX31
+		#ifdef CONFIG_KERNEL_2_6_19_2
+		#endif
+
+		#ifdef CONFIG_KERNEL_2_6_22
+			#include <asm/arch/mx31_pins.h>
+			
+			#ifndef __MACH_MX31_IOMUX_H__
+				#define __MACH_MX31_IOMUX_H__
+			#endif
+			#include <asm/arch/mxc_i2c.h>
+			#include <asm/arch/pmic_power.h>
+			
+		#endif
+	#endif
+#endif
+
+/*
+ * boot loader part header file
+ */
+#if defined(CONFIG_BOOT_LOADER)
+	#if defined(CONFIG_BOOT_UBOOT_1_1_3)
+		#include <common.h>
+		#include <command.h>
+		#include <asm/io.h>
+		#include <asm/arch/hardware.h> 
+		#include <asm/sizes.h>
+		#include <malloc.h>
+
+	#endif
+#endif
+
+/*
+ * custom definition here
+ */
+#define OUT
+#define IN
+
+#define DISABLE		0x0
+#define ENABLE		0x1
+
+
+/*
+ * include custom header file
+ */
+#include "error.h"
+
+#ifdef CONFIG_USE_MEMORY_MONITOR
+	#include "memory_monitor.h"
+
+	#define malloc(alloc_size) 									\
+			wrapper_memory_api((UPINT8)__FUNCTION__,__LINE__,				\
+			NULL,alloc_size,1,MALLOC_MEMORY)
+
+	#define calloc(alloc_size,alloc_block) 								\
+			wrapper_memory_api((UPINT8)__FUNCTION__,__LINE__,				\
+			NULL,alloc_size,alloc_block,CALLOC_MEMORY);
+
+	#define realloc(ptr,alloc_size) 								\
+			wrapper_memory_api((UPINT8)__FUNCTION__,__LINE__,				\
+			(UDPINT32)&ptr,alloc_size,1,REALLOC_MEMORY);
+
+	#define free(address) 										\
+			wrapper_memory_api((UPINT8)__FUNCTION__,__LINE__,				\
+			(UDPINT32)&address,0,0,FREE_MEMORY);
+#endif
+
+#include "fn_res_protype.h"
+
+#if defined(CONFIG_RETURN_APPLICATION_DEBUG)
+	#define return  										\
+	{												\
+		TRACE_ERROR(ret_val);									\
+		#if defined(CONFIG_APPLICATION_TRACE)							\
+		{											\
+		}											\
+		#endif											\
+	}return	
+#endif
+
+#define ENABLED			0x01
+#define DISABLED		0x00
+
+#define SET_ADDRESS 		0x01
+#define GET_ADDRESS 		0x02
+#define MAKE_ADDRESS_INVALID	0x04
+#define CREATE_ADDRESS		0x08
diff -Naur linux-org/drivers/media/video/ecam32/resource/include/kernel/phy_mem.h linux-ths/drivers/media/video/ecam32/resource/include/kernel/phy_mem.h
--- linux-org/drivers/media/video/ecam32/resource/include/kernel/phy_mem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/include/kernel/phy_mem.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,54 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        Memory Management in kernel level                                     *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+#ifndef __PHY_MEM_
+#define __PHY_MEM_
+
+#define GET_MEM_NODE				0x01
+#define SET_MEM_NODE				0x02
+
+#define ENABLE					0x1
+#define DISABLE					0x0
+
+struct dma_memory
+{
+	struct dma_memory *next;
+
+	UINT32 size;
+
+	UINT32 virtual_address;
+	UINT32 address_start;
+
+	UINT32 address_end;
+
+	struct dma_memory *back;
+};
+
+#endif
diff -Naur linux-org/drivers/media/video/ecam32/resource/include/typedef.h linux-ths/drivers/media/video/ecam32/resource/include/typedef.h
--- linux-org/drivers/media/video/ecam32/resource/include/typedef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/include/typedef.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,117 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems.                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        Defined variable types                                                *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 0.0.0.0   code development                                                         Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*		
+ *		Char
+ */
+
+typedef char			INT8;
+typedef unsigned char		UINT8;
+typedef signed char		SINT8;
+
+typedef char*			PINT8;
+typedef unsigned char*		UPINT8;
+typedef signed char*		SPINT8;
+
+typedef char**			DPINT8;
+typedef unsigned char**		UDPINT8;
+typedef signed char**		SDPINT8;
+typedef const char*		CPINT8;
+
+typedef UINT8			BOOL;
+
+/*
+ * 		Int
+ */
+typedef int			INT32;
+typedef unsigned int		UINT32;
+typedef signed int		SINT32;
+
+typedef int*			PINT32;
+typedef unsigned int*		UPINT32;
+typedef signed int*		SPINT32;
+
+typedef int**			DPINT32;
+typedef unsigned int**		UDPINT32;
+typedef signed int**		SDPINT32;
+
+typedef volatile unsigned int	UVINT32;
+typedef INT32			FNRESLT;
+
+
+/*
+ *	Long
+ */
+
+typedef long			LINT32;
+typedef unsigned long		ULINT32;
+/*
+ *	long long int
+ */
+typedef long long int		INT64;
+typedef long long int*		PINT64;
+typedef unsigned long long int	UINT64;
+typedef unsigned long long int* UPINT64;
+
+/*
+ *		short
+ */
+typedef short			INT16;
+typedef unsigned short		UINT16;
+typedef signed short		SINT16;
+
+typedef short*			PINT16;
+typedef unsigned short*		UPINT16;
+typedef signed short*		SPINT16;
+
+typedef short**			DPINT16;
+typedef unsigned short**	UDPINT16;
+typedef signed short**		SDPINT16;
+
+typedef volatile unsigned short	UVINT16;
+
+
+/*
+ *		void
+ */
+typedef void			INT0;
+typedef void*			PINT0;
+typedef void**			DPINT0;
+typedef INT0			FNRESLT_NONE;
+
+typedef unsigned short 		WORD;
+typedef unsigned int		DWORD;
+typedef int 			LONG;
+
+/*
+ * 		float
+ */
+
+
diff -Naur linux-org/drivers/media/video/ecam32/resource/src/error.c linux-ths/drivers/media/video/ecam32/resource/src/error.c
--- linux-org/drivers/media/video/ecam32/resource/src/error.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/src/error.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,384 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :          Error code management                                               *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :                                                                              *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ *
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * Header file inclution part
+ */
+
+#include "../../inc_header.h"
+#ifdef CONFIG_APPLICATION
+	#define printf(x...) printf(x)
+	#define KERN_DEBUG ""
+#endif
+#ifdef CONFIG_DRIVER
+	#define printf(x...) printk(KERN_DEBUG x)	
+#endif	
+/******************************************************************************
+ *  				 Function 
+ *				
+ *  Name	:	trace_error
+ *  Author	:	E-consystems
+ *  Parameter1	:	UINT32 - Error number
+ *  Returns	:	NONE
+ *  Description	:	error from various device are classified into groups and 
+ *  			debugged over here 
+ *  Comments	:  				 	
+ ******************************************************************************/
+#define TEP(file_name,function_name,line_no,Error_number,Error_number_in_string,Reason_in_string) 			\
+															\
+	case Error_number:												\
+	{														\
+		printf(KERN_DEBUG "-------------------------------------------------------------------------------\n");	\
+		printf(KERN_ERR   "ERROR!\n");										\
+		printf(KERN_DEBUG "From            : %s\n",MODULE_NAME);						\
+		printf(KERN_DEBUG "File            : %s\n",file_name);							\
+		printf(KERN_ERR   "Function        : %s\n",function_name);						\
+		printf(KERN_ERR   "Line number     : %u\n",line_no);							\
+		printf(KERN_DEBUG "Error name      : %s\n",Error_number_in_string);					\
+		printf(KERN_DEBUG "Error number Dec: %lld Hex: 0x%X \n",(INT64)Error_number,(INT32)Error_number);	\
+		printf(KERN_ERR   "Reason          : %s\n",Reason_in_string);						\
+		printf(KERN_DEBUG "------------------------------------------------------------------------------\n");	\
+		break;													\
+	}	
+
+#define TEP_DEFAULT(file_name,function_name,line_no,Error_number_in_string,Reason_in_string) 				\
+															\
+	default :													\
+	{														\
+		printf(KERN_DEBUG "------------------------------------------------------------------------------\n");	\
+		printf(KERN_ERR   "ERROR!\n");										\
+		printf(KERN_DEBUG "From            : %s\n",MODULE_NAME);						\
+		printf(KERN_DEBUG "File            : %s\n",file_name);							\
+		printf(KERN_ERR   "Function        : %s\n",function_name);						\
+		printf(KERN_ERR   "Line number     : %u\n",line_no);							\
+		printf(KERN_ERR   "Reason          : %s\n",Reason_in_string);						\
+		printf(KERN_DEBUG "------------------------------------------------------------------------------\n");	\
+		break;													\
+	}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	trace_error 
+ *  Parameter1	:	PINT8 file_name 
+ *  Parameter2	:	PINT8 function_name 
+ *  Parameter3	:	UINT32 line_no
+ *  Parameter4	:	UINT32 Error_num
+ *  
+ *  Returns	:	FNRESLT_NONE
+ *  Description	: 	
+ *  Comments	:  	Based on the error Number, Debug prints will be called.
+ ************************************************************************************************************/
+FNRESLT_NONE trace_error(PINT8 file_name,PINT8 function_name,UINT32 line_no,UINT32 Error_num)
+{
+	switch(Error_num)
+	{
+/*
+ * Success return Values
+ */
+		TEP(file_name,function_name,line_no,SUCCESS,"SUCCESS",							\
+				"Got a positive feedback from the module just debug lines");
+/*
+ * Special type of Errors
+ */
+#if 0
+		TEP(file_name,function_name,line_no,-EPERM,"EPERM",							\
+				"Operation not permitted ");
+#endif
+
+#if defined(CONFIG_KERNEL_ERR_INCLUDED)
+		TEP(file_name,function_name,line_no,-ENOENT,"ENOENT",							\
+				"No such file or directory ");
+		TEP(file_name,function_name,line_no,-ESRCH,"ESRCH",							\
+				"No such process");
+		TEP(file_name,function_name,line_no,-EINTR,"EINTR",							\
+				"Interrupted system call");
+		TEP(file_name,function_name,line_no,-EIO,"EIO",								\
+				"I/O error");
+		TEP(file_name,function_name,line_no,-ENXIO,"ENXIO",							\
+				"No such device or address");
+		TEP(file_name,function_name,line_no,-E2BIG,"E2BIG",							\
+				"Argument list too long");
+		TEP(file_name,function_name,line_no,-ENOEXEC,"ENOEXEC",							\
+				"Exec format error ");
+		TEP(file_name,function_name,line_no,-EBADF,"EBADF",							\
+				"Bad file number");
+		TEP(file_name,function_name,line_no,-ECHILD,"ECHILD",							\
+				"No child processes");
+		TEP(file_name,function_name,line_no,-EAGAIN,"EAGAIN",							\
+				"Try again");
+		TEP(file_name,function_name,line_no,-ENOMEM,"ENOMEM",							\
+				"Out of memory");
+		TEP(file_name,function_name,line_no,-EACCES,"EACCES",							\
+				"Permission denied");
+		TEP(file_name,function_name,line_no,-EFAULT,"EFAULT",							\
+				"Bad address");
+		TEP(file_name,function_name,line_no,-ENOTBLK,"ENOTBLK",							\
+				"Block device required");
+		TEP(file_name,function_name,line_no,-EBUSY,"EBUSY",							\
+				"Device or resource busy");
+		TEP(file_name,function_name,line_no,-EEXIST,"EEXIST",							\
+				"File exists");
+		TEP(file_name,function_name,line_no,-EXDEV,"EXDEV",							\
+				"Cross-device link");
+		TEP(file_name,function_name,line_no,-ENODEV,"ENODEV",							\
+				"No such device");
+		TEP(file_name,function_name,line_no,-ENOTDIR,"ENOTDIR",							\
+				"Not a directory");
+		TEP(file_name,function_name,line_no,-EISDIR,"EISDIR",							\
+				"Is a directory");
+		TEP(file_name,function_name,line_no,-EINVAL,"EINVAL",							\
+				"Invalid argument");
+		TEP(file_name,function_name,line_no,-ENFILE,"ENFILE",							\
+				"File table overflow");
+		TEP(file_name,function_name,line_no,-EMFILE,"EMFILE",							\
+				"Too many open files");
+		TEP(file_name,function_name,line_no,-ENOTTY,"ENOTTY",							\
+				"Not a typewriter");
+		TEP(file_name,function_name,line_no,-ETXTBSY,"ETXTBSY",							\
+				"Text file busy");
+		TEP(file_name,function_name,line_no,-EFBIG,"EFBIG",							\
+				"File too large");
+		TEP(file_name,function_name,line_no,-ENOSPC,"ENOSPC",							\
+				"No space left on device");
+		TEP(file_name,function_name,line_no,-ESPIPE,"ESPIPE",							\
+				"Illegal seek");
+		TEP(file_name,function_name,line_no,-EROFS,"EROFS",							\
+				"Read-only file system");
+		TEP(file_name,function_name,line_no,-EMLINK,"EMLINK",							\
+				"Too many links");
+		TEP(file_name,function_name,line_no,-EPIPE,"EPIPE",							\
+				"Broken pipe");
+		TEP(file_name,function_name,line_no,-EDOM,"EDOM",							\
+				"Math argument out of domain of func");
+		TEP(file_name,function_name,line_no,-ERANGE,"ERANGE",							\
+				"Math result not representable");
+#endif
+/*
+ *
+ * BASIC ERROR definition
+ */
+
+		TEP(file_name,function_name,line_no,FAIL,"1. PORT_OPEN_ERROR 2. FAIL 3.EPERM",				\
+				"1. unknown cause of failure								\
+			\n\t\t 2. Failed to open the port may be driver is not properly inserted or file not found	\
+			\n\t\t 3. Operation not permitted");
+
+		TEP(file_name,function_name,line_no,PORT_OPEN_FAILURE,"PORT_OPEN_FAILURE",				\
+				"Cannot open the port, Driver is not properly inserted or device entry missing");
+
+		TEP(file_name,function_name,line_no,FILE_OPEN_FAILURE,"FILE_OPEN_FAILURE",				\
+				"Unable to open the file. Check the file presence");
+/*
+ * READ ERROR definition
+ */
+
+		TEP(file_name,function_name,line_no,LOOSING_BYTES_IN_READ,"LOOSING_BYTES_IN_READ",			\
+				"Some other device or thread reading the character form the allocated port ");
+
+		TEP(file_name,function_name,line_no,LESS_NUM_BYTE_READ,"LESS_NUM_BYTE_READ",				\
+				"less number of bytes read from the device from the checked one");
+
+		TEP(file_name,function_name,line_no,MORE_NUM_BYTE_READ,"MORE_NUM_BYTE_READ",				\
+				"More number of bytes read from the device from the checked one");
+
+		TEP(file_name,function_name,line_no,LESS_NUMBER_BYTE_IN_PORT,"LESS_NUMBER_BYTE_IN_PORT",		\
+				"In Port less number of bytes than expected one");
+/*
+ * WRITE ERROR definition
+ */
+
+		TEP(file_name,function_name,line_no,LESS_NUM_BYTE_WRITE,"LESS_NUM_BYTE_WRITE",				\
+				"less number of bytes Writted to the device");
+
+		TEP(file_name,function_name,line_no,MORE_NUM_BYTE_WRITE,"MORE_NUM_BYTE_WRITE",				\
+				"more number of bytes Writted to the device");
+
+		TEP(file_name,function_name,line_no,FAILED_TO_WRITE_TO_PORT,"FAILED_TO_WRITE_TO_PORT",			\
+				"Failed to write to device please try after some time");
+
+/*
+ * MEMORY ERROR definition
+ */
+		TEP(file_name,function_name,line_no,ALLOCATION_MEMORY_FAILED,"ALLOCATION_MEMORY_FAILED",		\
+				"Memory needed by the application not available under run time");
+		TEP(file_name,function_name,line_no,MEMORY_NOT_VALID,"MEMORY_NOT_VALID",				\
+				"Memory wish to access is invalid.. please try with valid memory");
+
+
+/*
+ * IOCTLS ERROR definition
+ */
+		TEP(file_name,function_name,line_no,DATA_FRM_PORT_NOT_VALID,"DATA_FRM_PORT_NOT_VALID",			\
+				"Not a vaid data from the ioctl");
+
+		TEP(file_name,function_name,line_no,IOCTL_GET_DATA_FAILED,"IOCTL_GET_DATA_FAILED",			\
+				"Getting data from ioctl failed please check the file descriptor");
+
+/*
+ * SPECIAL_APLICATION_ERROR definition
+ */
+
+		TEP(file_name,function_name,line_no,CAPTURE_FORMAT_NOT_AVAILABLE,"CAPTURE_FORMAT_NOT_AVAILABLE",	\
+				"Zoom value is too high so the output value is more than the available one");
+
+		TEP(file_name,function_name,line_no,MAPPING_FAILED,"MAPPING_FAILED",					\
+				"Mapping kernel space area to user space area failed");
+
+
+
+/******************************************************************************
+ *
+ * 		Driver Specific Error code definitions
+ *
+ ******************************************************************************/
+
+
+/*
+ * I2C definition
+ */
+		TEP(file_name,function_name,line_no,I2C_INIT_SUCCESS,"I2C_INIT_SUCCESS",				\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_TX_EMPTY_SEND_SUCCESS,"I2C_TX_EMPTY_SEND_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_WRITE_SUCCESS,"I2C_WRITE_SUCCESS",				\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_RX_FULL_SUCCESS,"I2C_RX_FULL_SUCCESS",				\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_READ_SUCCESS,"I2C_READ_SUCCESS",				\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_CAM_READ_REGISTER_SUCCESS,"I2C_CAM_READ_REGISTER_SUCCESS",	\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_PROTO_READ_ID_SUCCESS,"I2C_PROTO_READ_ID_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_0_REG_ACCESS_SUCCESS,"PAGE_0_REG_ACCESS_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_1_REG_ACCESS_SUCCESS,"PAGE_1_REG_ACCESS_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_2_REG_ACCESS_SUCCESS,"PAGE_2_REG_ACCESS_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,MT9D111_DUMP_ALL_SUCCESS,"MT9D111_DUMP_ALL_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,MT9D111_SOFT_RESET_SUCCESS,"MT9D111_SOFT_RESET_SUCCESS",		\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_INIT_FAIL,"I2C_INIT_FAIL",					\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_TX_EMPTY_SEND_FAIL,"I2C_TX_EMPTY_SEND_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_WRITE_FAIL,"I2C_WRITE_FAIL",					\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_RX_FULL_FAIL,"I2C_RX_FULL_FAIL",				\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_READ_FAIL,"I2C_READ_FAIL",					\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_CAM_READ_REGISTER_FAIL,"I2C_CAM_READ_REGISTER_FAIL",		\
+				"");
+
+		TEP(file_name,function_name,line_no,I2C_PROTO_READ_ID_FAIL,"I2C_PROTO_READ_ID_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_0_REG_ACCESS_FAIL,"PAGE_0_REG_ACCESS_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_1_REG_ACCESS_FAIL,"PAGE_1_REG_ACCESS_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,PAGE_2_REG_ACCESS_FAIL,"PAGE_2_REG_ACCESS_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,MT9D111_SOFT_RESET_FAIL,"MT9D111_SOFT_RESET_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,CLK_BYPASS_PLL_FAIL,"CLK_BYPASS_PLL_FAIL",				\
+				"");
+
+		TEP(file_name,function_name,line_no,MCU_RESET_VALUE_FAIL,"MCU_RESET_VALUE_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,RESET_EN_REG_VALUE_FAIL,"RESET_EN_REG_VALUE_FAIL",			\
+				"");
+
+		TEP(file_name,function_name,line_no,RESET_DIS_REG_VALUE_FAIL,"RESET_DIS_REG_VALUE_FAIL",		\
+				"");
+/*
+ * Memory Error definition
+ */
+
+		TEP(file_name,function_name,line_no,MEM_KERN_OVERLAP,"MEM_KERN_OVERLAP",				\
+				"Kernel memory region is getting overlaped with the reserved memory region");
+
+
+/*
+ *
+ * Basic error types
+ */
+
+		TEP(file_name,function_name,line_no,DRIVER_MEMORY_NOT_AVAILABLE,"DRIVER_MEMORY_NOT_AVAILABLE",		\
+				"Memory size wish to allocate is not available, please increase the memory size");
+
+
+#if 0
+
+
+		TEP(file_name,function_name,line_no,,"",								\
+				"");
+
+		TEP(file_name,function_name,line_no,,"",								\
+				"");
+
+		TEP(file_name,function_name,line_no,,"",								\
+				"");
+#endif
+/*
+ * Unknown error 
+ */
+		TEP_DEFAULT(file_name,function_name,line_no,"UN KNOWN ERROR",						\
+				"An unidentified error is happening.. please report to code developer!");
+	}
+}
+
diff -Naur linux-org/drivers/media/video/ecam32/resource/src/kernel/phy_mem.c linux-ths/drivers/media/video/ecam32/resource/src/kernel/phy_mem.c
--- linux-org/drivers/media/video/ecam32/resource/src/kernel/phy_mem.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/resource/src/kernel/phy_mem.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,602 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                 *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        Memory Management in kernel level                                     *
+ *   MODULE NAME           :                                                                              *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * Include Header file
+ */
+
+#include "../../../inc_header.h"
+
+/*
+ * Global variables
+ */
+static DEFINE_MUTEX(phy_memory_mutex);
+static UINT32 phy_addr_start	= DISABLE;
+static UINT32 phy_addr_end	= DISABLE;
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT get_mem_node(struct dma_memory **phy_mem ,UINT8 cond)
+{
+	static UINT32 phy_mem_res;
+
+	switch(cond)
+	{
+		case GET_MEM_NODE:
+		{
+			if(phy_mem == NULL)
+			{
+				TRACE_ERR_AND_RET(FAIL);
+			}
+	
+			if(phy_mem_res)
+			{
+				*phy_mem	= (struct dma_memory *)phy_mem_res;
+			}
+		}break;
+	
+		case SET_MEM_NODE:
+		{
+			phy_mem_res = (UINT32)*phy_mem;
+		}break;
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT list_all_phy_struct()
+{
+	struct dma_memory *phy_mem	= NULL;
+	struct dma_memory *phy_mem_next	= NULL;
+	FNRESLT ret_val;
+	UINT32 i;
+
+	ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return ret_val;
+	}
+
+	printk("\n\n\nMem.no             Memstart                    Memend            Virtual address       Size\n");
+	for(i	= 0;phy_mem;i++)
+	{
+		phy_mem_next = phy_mem->next;
+		printk("%d                 0x%x                  0x%x        0x%x         0x%x          0x%x  0x%x\n",	\
+			i,(UINT32)phy_mem->address_start,(UINT32)phy_mem->address_end,(UINT32)phy_mem->virtual_address,	\
+			(UINT32)phy_mem->size,(UINT32)phy_mem,(UINT32)phy_mem_next);
+		phy_mem	= phy_mem_next;
+	}
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(list_all_phy_struct);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+
+FNRESLT get_free_phy_mem(UINT32 size,UPINT32 phy_addr,UPINT32 vir_addr)
+{
+	UINT32 addr_start		= phy_addr_start;
+	UINT32 addr_end			= phy_addr_end;
+	UINT32 mem_fnode_st;
+	UINT8 mem_fnode_flag		= DISABLE;
+
+	FNRESLT ret_val;
+
+	struct dma_memory *phy_mem	= NULL;
+	struct dma_memory *phy_mem_next	= NULL;
+	struct dma_memory *phy_new;
+	UINT32 case_link;
+
+	mutex_lock(&phy_memory_mutex);
+	{
+
+		ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			{
+			}mutex_unlock(&phy_memory_mutex);
+
+			return ret_val;
+		}
+
+//-----------------------------------------------------------------------------------------------------
+		if(addr_start&0xFFF)
+		{
+			addr_start	= addr_start + (0x1000 - (addr_start&0xFFF));
+		}
+//-----------------------------------------------------------------------------------------------------
+
+		if(phy_mem)
+		{
+			mem_fnode_st		= phy_mem->address_start -1;
+			if((mem_fnode_st > addr_start) && ((mem_fnode_st - addr_start) > size))
+			{
+				mem_fnode_flag = ENABLE;
+			}
+		}
+
+		for(;(phy_mem != NULL) && (mem_fnode_flag == DISABLE);)
+		{
+	
+			phy_mem_next		= phy_mem->next;
+			addr_start		= phy_mem->address_end +1;
+		
+			if(phy_mem_next)
+			{
+				addr_end	= phy_mem_next->address_start;
+			}else
+			{
+				addr_end	= phy_addr_end;
+			}
+//-----------------------------------------------------------------------------------------------------
+			if(addr_start&0xFFF)
+			{
+				addr_start	= addr_start + (0x1000 - (addr_start&0xFFF));
+			}
+//-----------------------------------------------------------------------------------------------------
+			if((addr_end > addr_start) && ((addr_end - addr_start) > size))
+			{
+				break;
+			}else if(phy_mem_next)
+			{
+				phy_mem		= phy_mem_next;
+			}else
+			{
+				list_all_phy_struct();
+				TRACE_ERR_AND_RET(FAIL);
+			}
+		}
+
+		if(mem_fnode_flag)
+		{	
+			case_link	= 4;
+		}else 
+		{
+			if(phy_mem)
+			{
+				if((phy_mem) && (phy_mem->next))
+				{
+				case_link	= 1;
+				}else
+				{
+					case_link	= 2;
+				}
+
+			}else
+			{
+				case_link	= 3;
+			}
+		}
+
+		phy_new	= kmalloc(sizeof(struct dma_memory),GFP_KERNEL);		
+		if(phy_new == NULL)
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+		memset(phy_new,0x00,sizeof(struct dma_memory));
+	
+		switch(case_link)
+		{
+			case 4:
+			{
+				phy_mem->back		= phy_new;
+				phy_new->back		= NULL;
+				phy_new->next		= phy_mem;
+				get_mem_node(&phy_new,SET_MEM_NODE);
+			
+			}break;
+			case 3:
+			{
+				phy_mem			= phy_new;
+				phy_mem->next		= NULL;
+				phy_mem->back		= NULL;
+				get_mem_node(&phy_mem,SET_MEM_NODE);
+
+				break;
+			}
+			case 2:
+			{
+				phy_new->next		= NULL;
+				phy_new->back		= phy_mem;
+				phy_mem->next		= phy_new;
+				break;
+			}
+			case 1:
+			{
+				phy_new->next		= phy_mem->next;
+				phy_new->back		= phy_mem;
+				phy_mem->next->back	= phy_new;
+				phy_mem->next		= phy_new;
+				break;
+			}
+		}
+	
+		phy_new->address_start			= addr_start;
+		phy_new->address_end			= phy_new->address_start+size-1;
+		phy_new->size				= size;
+		phy_new->virtual_address		= (UINT32)ioremap(addr_start,size);
+
+		if(vir_addr)
+		{
+			*vir_addr			= phy_new->virtual_address;
+		}
+
+		if(phy_addr)
+		{
+			*phy_addr			= phy_new->address_start;
+		}
+	}mutex_unlock(&phy_memory_mutex);
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(get_free_phy_mem);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	INT0
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT get_adress(UPINT32 phy_addr,UPINT32 vir_addr, UPINT32 addr)
+{
+	FNRESLT ret_val;
+	struct dma_memory *phy_mem	= NULL;
+
+	*addr	= DISABLE;
+
+	mutex_lock(&phy_memory_mutex);
+	{
+		ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			{
+			}mutex_unlock(&phy_memory_mutex);
+
+			return ret_val;
+		}
+
+		for(;phy_mem;)
+		{
+			if(phy_addr)
+			{
+				if(phy_addr	== (UPINT32)phy_mem->address_start)
+				{
+					*addr	= phy_mem->virtual_address;
+					break;
+				}
+			}
+			if(vir_addr)
+			{
+				if(vir_addr	== (UPINT32)phy_mem->virtual_address)
+				{
+					*addr	= phy_mem->address_start;				
+					break;
+				}
+			}
+
+			phy_mem		= phy_mem->next;
+		}
+
+		if(*addr	== DISABLE)
+		{
+			printk(KERN_ERR"\n" KERN_ERR "Memory Invalid : physical memory not allocated from phy_mem\n");
+			list_all_phy_struct();
+			{
+			}mutex_unlock(&phy_memory_mutex);
+
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}mutex_unlock(&phy_memory_mutex);
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(get_adress);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	INT0
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+
+FNRESLT free_phy_mem(UINT32 phy_addr)
+{
+	struct dma_memory *phy_mem	= NULL;
+	struct dma_memory *phy_mem_last	= NULL;
+	FNRESLT ret_val;
+
+	mutex_lock(&phy_memory_mutex);
+	{
+		ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			{
+			}mutex_unlock(&phy_memory_mutex);
+			
+			return ret_val;
+		}
+
+
+		for(;phy_mem;)
+		{
+			if(phy_addr	== phy_mem->address_start)
+			{
+				break;
+			}else
+			{
+				phy_mem		= phy_mem->next;
+			}
+		}
+		if(phy_mem)
+		{
+	
+			if(phy_mem->next)
+			{
+				phy_mem->next->back	= phy_mem->back;
+				phy_mem_last		= phy_mem->next;
+			}
+
+			if(phy_mem->back)
+			{
+				phy_mem->back->next	= phy_mem->next;
+				iounmap((PINT0)phy_mem->virtual_address);
+				kfree(phy_mem);
+			}else
+			{
+			
+				ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					{
+					}mutex_unlock(&phy_memory_mutex);
+	
+					return ret_val;
+				}
+
+				iounmap((PINT0)phy_mem->virtual_address);
+				kfree(phy_mem);
+
+				if(phy_mem_last)
+				{
+					phy_mem	= phy_mem_last;
+					ret_val	= get_mem_node(&phy_mem,SET_MEM_NODE);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						{
+						}mutex_unlock(&phy_memory_mutex);
+
+						return ret_val;
+					}
+	
+				}else
+				{
+					phy_mem	= NULL;			
+					ret_val	= get_mem_node(&phy_mem,SET_MEM_NODE);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						{
+						}mutex_unlock(&phy_memory_mutex);
+						return ret_val;
+					}
+				}
+			}
+
+		}else
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}mutex_unlock(&phy_memory_mutex);
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(free_phy_mem);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	INT0
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT free_all_phy_struct()
+{
+	struct dma_memory *phy_mem	= NULL;
+	struct dma_memory *phy_mem_next	= NULL;
+	FNRESLT ret_val;
+
+	mutex_lock(&phy_memory_mutex);
+	{
+		ret_val	= get_mem_node(&phy_mem,GET_MEM_NODE);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			{
+			}mutex_unlock(&phy_memory_mutex);
+			return ret_val;
+		}
+
+		for(;phy_mem;)
+		{
+			phy_mem_next = phy_mem->next;
+
+			iounmap((PINT0)phy_mem->virtual_address);
+			kfree(phy_mem);
+
+			phy_mem	= phy_mem_next;
+		}
+
+		phy_mem	= NULL;
+		ret_val	= get_mem_node(&phy_mem,SET_MEM_NODE);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			{
+			}mutex_unlock(&phy_memory_mutex);
+
+			return ret_val;
+		}
+	
+	}mutex_unlock(&phy_memory_mutex);
+
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(free_all_phy_struct);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT init_phy_mem()
+{
+	UINT32 phys_end_kernel;
+
+	if((phy_addr_start	== DISABLE) && (phy_addr_end == DISABLE))
+	{
+		phy_addr_start	= PHY_MEM_START;
+		phy_addr_end	= PHY_MEM_END;
+
+	}
+/*
+ * Find the kernel memory range
+ */
+	phys_end_kernel = (UINT32)virt_to_phys((PINT0)PAGE_OFFSET) +(num_physpages << PAGE_SHIFT);
+	if(phys_end_kernel > phy_addr_start)
+	{
+		printk(KERN_INFO "\n");
+		printk(KERN_INFO "Memory overlap detected between camera reserved memory and kernel memory\n");
+		printk(KERN_INFO "phy_addr_start  0x%x \n",phy_addr_start);
+		printk(KERN_INFO "phy_addr_end    0x%x \n",phy_addr_end);
+		printk(KERN_INFO "phys_end_kernel 0x%x \n",phys_end_kernel);
+		printk(KERN_INFO "\n");
+
+#ifndef CONFIG_ALLOW_DRIVER_PHY_MEMORY_OVERLAP
+ 		TRACE_ERR_AND_RET(MEM_KERN_OVERLAP);
+#endif
+	}
+
+	printk(KERN_INFO "Using Reserved memory for " MODULE_NAME "\n");
+	printk(KERN_INFO "From Start address - 0x%08x \n",phy_addr_start);
+	printk(KERN_INFO "To End address - 0x%08x \n",phy_addr_end);
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *
+ *  Name	:	
+ *
+ *  Parameter1	:	
+ *
+ *  Returns	:	FNRESLT
+ *  Description	: 	 
+ *  Comments	:  				 	
+ *
+ ************************************************************************************************************/
+FNRESLT exit_phy_mem()
+{
+	FNRESLT ret_val;
+	ret_val	= free_all_phy_struct();
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+module_param(phy_addr_start,int, 0444);
+module_param(phy_addr_end,int, 0444);
diff -Naur linux-org/drivers/media/video/ecam32/stcf03/stcf03_flash.c linux-ths/drivers/media/video/ecam32/stcf03/stcf03_flash.c
--- linux-org/drivers/media/video/ecam32/stcf03/stcf03_flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/stcf03/stcf03_flash.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,613 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ *
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+#include "../inc_header.h"
+/*
+ * local variables
+ */
+static INT32 torch_lum_value;
+static INT32 flash_lum_value;
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	flash_i2c_client_xfer
+ *  Parameter1	:	INT32 addr
+ *  Parameter2	:	UPINT8 reg
+ *  Parameter3	:	PINT8 buf
+ *  Parameter4	:	INT32 num
+ *  Parameter5	:	INT32 tran_flag
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT flash_i2c_client_xfer(INT32 addr, UPINT8 reg, PINT8 buf, INT32 num, INT32 tran_flag)
+{
+
+	struct i2c_msg msg[2];
+	FNRESLT ret_val;
+	INT32 ret;
+	cam_data *cam	= NULL;
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		TRACE_ERR_AND_RET(FAIL);	
+	}
+
+/*
+ * FIXME:
+ * 	
+ * 	I2C Write:
+ *	 	In i2c msg[0] "address part in write is success" but if we put data in msg [1] 
+ * 		that is not properly sent to device.
+ *
+ * 		so in the msg[0] part itself the data also sent here.
+ *
+ * 	I2CRead:
+ * 		But in read No problem is found and working fine
+ */
+
+	if(tran_flag & I2C_FLAG_READ)
+	{
+
+		msg[0].addr	= addr;
+		msg[0].len	= 1;
+		msg[0].buf	= reg;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		msg[1].addr	= addr;
+		msg[1].len	= num;
+		msg[1].buf	= buf;
+		msg[1].flags	= tran_flag;
+
+		if (tran_flag & I2C_FLAG_READ)
+		{
+			msg[1].flags |= I2C_M_RD;
+		}else
+		{
+			msg[1].flags &= ~I2C_M_RD;
+		}
+
+		if (cam->cam_flash.client->adapter == NULL)
+		{
+			printk("%s:adapter error\n", __func__);
+			return -1;
+		}
+
+		ret = i2c_transfer(cam->cam_flash.client->adapter, msg, 2);
+		if (ret >= 0)
+		{
+			/* printk("%s:i2c transfer num:%d\n", __func__, ret); */
+			return SUCCESS;
+		}
+
+	}else
+	{
+		UINT8 reg_addr_data[2];
+		
+		reg_addr_data[0] = *reg;
+		reg_addr_data[1] = *buf;
+		
+		msg[0].addr	= addr;
+		msg[0].len	= 2;
+		msg[0].buf	= reg_addr_data;
+		msg[0].flags	= tran_flag;
+		msg[0].flags	&= ~I2C_M_RD;
+
+		ret = i2c_transfer(cam->cam_flash.client->adapter, msg, 1);
+		if (ret >= 0)
+		{
+			/* printk("%s:i2c transfer num:%d\n", __func__, ret); */
+			return SUCCESS;
+		}
+	}
+	printk("%s:i2c transfer error:%d\n", __func__, ret);
+	return FAIL;
+
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_write
+ *  Parameter1	:	UINT8 reg
+ *  Parameter2	:	UINT8 data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_write(UINT8 reg,UINT8 data)
+{
+	printk(KERN_DEBUG "stcf03: write : Address : %x Data %x \n",reg,data);
+
+	if (flash_i2c_client_xfer(STCF03_SLAVE_ADDRESS,&reg,&data, 0, 0) < 0)
+	{
+		printk("Flash write failed :%s: reg=%x",__func__, reg);
+		return FAIL;
+	}	
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_read
+ *  Parameter1	:	UINT8 reg
+ *  Parameter2	:	UPINT8 data
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_read(UINT8 reg,UPINT8 data)
+{
+	if (flash_i2c_client_xfer(STCF03_SLAVE_ADDRESS,&reg, data, 1, 1) < 0)
+	{
+		printk("Flash write failed :%s: reg=%x",__func__, reg);
+		return FAIL;
+	}
+	printk(KERN_DEBUG "stcf03: read : Address : %x Data %x \n",reg,*data);
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_probe
+ *  Parameter1	:	struct i2c_client *client
+ *  Parameter2	:	const struct i2c_device_id *id
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	Configure the gpio levels for ov3640 driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+static INT32 __init stcf03_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	cam_data *cam	= NULL;
+	FNRESLT ret_val;
+
+	if (i2c_get_clientdata(client))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	ret_val	= v4l2_base_struct(&cam,GET_ADDRESS);
+	if(CHECK_IN_FAIL_LIMIT(ret_val))
+	{
+		printk(KERN_ERR "Failed to register the camera device\n");
+		goto exit;
+	}
+	
+/*
+ * 	set the client data 
+ */
+	cam->cam_flash.client =	client;
+
+	return 0;
+	exit:
+	{
+		return -EINVAL;
+	}	
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_remove
+ *  Parameter1	:	struct i2c_client *client
+ *  Returns	:	LINT32	- On sucess returns 0
+ *  				- On Failure a negative number be returned
+ *
+ *  Description	: 	remove routine of ov3640 i2c driver
+ *  Comments	:  	
+ ************************************************************************************************************/
+
+static INT32 __exit stcf03_remove(struct i2c_client *client)
+{
+	if (!client->adapter)
+		return -ENODEV;	/* our client isn't attached */
+
+	i2c_set_clientdata(client, NULL);
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_init
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_init(cam_data *cam)
+{
+	FNRESLT ret_val;
+/*
+ * i2c driver init
+ */
+	static const struct i2c_device_id stcf03_id[] =			\
+	{
+		{ STCF03_DRIVER_NAME, 0 },
+		{ },
+	};
+	MODULE_DEVICE_TABLE(i2c, stcf03_id);
+	
+	cam->cam_flash.i2c.driver.name	= STCF03_DRIVER_NAME;
+	cam->cam_flash.i2c.driver.owner	= THIS_MODULE;
+	cam->cam_flash.i2c.probe	= stcf03_probe;
+	cam->cam_flash.i2c.remove	= __exit_p(stcf03_remove);
+	cam->cam_flash.i2c.id_table	= stcf03_id;
+
+	if(i2c_add_driver(&cam->cam_flash.i2c))
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	if(cam->cam_flash.client	== NULL)
+	{
+		ret_val	= cam->cam_flash.exit(cam);
+		if(CHECK_IN_FAIL_LIMIT(ret_val))
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+		return SUCCESS;
+	}
+
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_exit
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_exit(cam_data *cam)
+{
+	if(cam->cam_flash.client)
+	{
+		stcf03_write(0x00,0x00);		
+	}
+
+	i2c_del_driver(&cam->cam_flash.i2c);
+	memset(&cam->cam_flash,0x00,sizeof(struct _flash_driver));
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_flash
+ *  Parameter1	:	cam_data *cam
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_flash(cam_data *cam)
+{
+	FNRESLT ret_val;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= cam->cam_sensor.sens_strobe_en;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 1))
+			{
+				if(cam->ctrl.value)
+				{
+/*
+ * Flash (or) Torch can be enabled, So proper routine to disable torch
+ */
+					cam->cmd	= SET_DATA;
+					cam->ctrl.value	= DISABLE;
+					ret_val = cam->cam_flash.torch(cam);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+
+					cam->cam_sensor.sens_strobe_en	= ENABLE;
+					ret_val = stcf03_write(0x00,0xCF);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+				}else
+				{
+					cam->cam_sensor.sens_strobe_en	= DISABLE;
+				}
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_FLASH;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"flash ctrl",strlen("flash ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_torch
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_torch(cam_data *cam)
+{
+	FNRESLT ret_val;
+	static UINT32 torch_value;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= torch_value;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 1))
+			{
+				if(cam->ctrl.value)
+				{
+/*
+ * Flash (or) Torch can be enabled, So proper routine to disable flash
+ */
+					cam->cmd	= SET_DATA;
+					cam->ctrl.value	= DISABLE;
+					ret_val = cam->cam_flash.flash(cam);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+
+					torch_value	= ENABLE;
+					ret_val=stcf03_write(0x00,0xAF);
+					if(CHECK_IN_FAIL_LIMIT(ret_val))
+					{
+						TRACE_ERR_AND_RET(FAIL);
+					}
+				}else
+				{
+					if(cam->cam_sensor.sens_strobe_en	== DISABLE)
+					{
+						ret_val = stcf03_write(0x00,0x00);
+						if(CHECK_IN_FAIL_LIMIT(ret_val))
+						{
+							TRACE_ERR_AND_RET(FAIL);
+						}
+					}
+					torch_value	= DISABLE;
+				}
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_TORCH;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_BOOLEAN;
+			strncpy(cam->qctrl.name,"torch ctrl",strlen("torch ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 1;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+		}break;
+	}
+	return SUCCESS;
+
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_lum_ctrl
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_flash_lum_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= flash_lum_value;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 15))
+			{
+				ret_val	= stcf03_write(0x01,(0xF0 & torch_lum_value) | (0xF & cam->ctrl.value));
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(FAIL);
+				}
+				flash_lum_value	= cam->ctrl.value;
+			}
+
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_FLASH_LUM;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"flash lum ctrl",strlen("flash lum ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 15;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+	return SUCCESS;
+}
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	stcf03_lum_ctrl
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT stcf03_torch_lum_ctrl(cam_data *cam)
+{
+	FNRESLT ret_val;
+	switch(cam->cmd)
+	{
+		case GET_DATA:
+		{
+			cam->ctrl.value	= torch_lum_value;
+		}break;
+
+		case SET_DATA:
+		{
+			if((cam->ctrl.value >= 0) && (cam->ctrl.value <= 15))
+			{
+				ret_val = stcf03_write(0x01,(0x0F & flash_lum_value) | ((0xF & cam->ctrl.value)<<4));
+				if(CHECK_IN_FAIL_LIMIT(ret_val))
+				{
+					TRACE_ERR_AND_RET(FAIL);
+				}
+				torch_lum_value	= cam->ctrl.value;
+			}
+		}break;
+
+		case QUERY_DATA:
+		{
+			cam->qctrl.id	= V4L2_SENS_FLASH_TORCH_LUM;
+			cam->qctrl.type	= V4L2_CTRL_TYPE_INTEGER;
+			strncpy(cam->qctrl.name,"torch lum ctrl",strlen("torch lum ctrl"));
+			cam->qctrl.minimum = 0;
+			cam->qctrl.maximum = 15;
+			cam->qctrl.step = 1;
+			cam->qctrl.default_value = 0;
+			cam->qctrl.flags = V4L2_CTRL_FLAG_SLIDER;
+		}break;
+	}
+	return SUCCESS;
+}
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	register_flash_driver
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT register_flash_driver(cam_data *cam)
+{
+	cam->cam_flash.init		= stcf03_init;
+	cam->cam_flash.exit		= stcf03_exit;
+	cam->cam_flash.flash		= stcf03_flash;
+	cam->cam_flash.torch		= stcf03_torch;
+	cam->cam_flash.flash_lum_ctrl	= stcf03_flash_lum_ctrl;
+	cam->cam_flash.torch_lum_ctrl	= stcf03_torch_lum_ctrl;
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/stcf03/stcf03_flash.h linux-ths/drivers/media/video/ecam32/stcf03/stcf03_flash.h
--- linux-org/drivers/media/video/ecam32/stcf03/stcf03_flash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/stcf03/stcf03_flash.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,50 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2009 by e-con Systems                                                                  *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :     OMAP Camera development                                                  *
+ *   MODULE NAME           :     OV3640                                                                   *
+ *   MODULE VERSION        :     VER 1.0                                                                  *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.0.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ *
+ *
+ *
+ *==========================================================================================================
+ */
+
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+#define STCF03_DRIVER_NAME	"stcf03"
+
+/*
+ * Slave address
+ */
+
+#define STCF03_SLAVE_ADDRESS	0x30
+
+/*
+ * Function protype
+ */
+FNRESLT register_flash_driver(cam_data *cam);
diff -Naur linux-org/drivers/media/video/ecam32/svn_revision.h linux-ths/drivers/media/video/ecam32/svn_revision.h
--- linux-org/drivers/media/video/ecam32/svn_revision.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/svn_revision.h	2012-07-19 08:55:28.872585226 +0200
@@ -0,0 +1,5 @@
+#define PRODUCT_NAME "e-CAM32_OMAP_GSTIX"
+#define SVN_REVISION "356"
+#define SVN_DATE "2011-12-27"
+#define SVN_TIME "13:59:38"
+#define THS_VERSION "001"
diff -Naur linux-org/drivers/media/video/ecam32/v4l2_driver_base.c linux-ths/drivers/media/video/ecam32/v4l2_driver_base.c
--- linux-org/drivers/media/video/ecam32/v4l2_driver_base.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/v4l2_driver_base.c	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,170 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems .                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+/*
+ * ----------------------------------------------------------------------------------------------------------
+ *
+ * 					Header files inclusion part
+ *
+ * ----------------------------------------------------------------------------------------------------------
+ */
+
+#include "inc_header.h"
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	v4l2_base_struct
+ *  Parameter1	:	cam_data **cam	- pointer need to register
+ *  Parameter2	:	UINT8 option	- set or get the address
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT v4l2_base_struct(cam_data **cam,UINT8 option)
+{
+
+/*
+ * SET_ADDRESS 
+ * GET_ADDRESS 
+ * MAKE_ADDRESS_INVALID
+ */
+	static UINT32 g_cam_st_addr;
+
+	if(cam == NULL)
+	{
+		TRACE_ERROR(MEMORY_NOT_VALID);	
+		return MEMORY_NOT_VALID;
+	}
+
+	if(option == SET_ADDRESS)
+	{
+		g_cam_st_addr =(UINT32)*cam;
+	}else if(option == GET_ADDRESS)
+	{
+		if(g_cam_st_addr)
+		{
+			*cam	= (cam_data *)g_cam_st_addr;
+		}else
+		{
+			TRACE_ERR_AND_RET(FAIL);
+		}
+	}else if(option == MAKE_ADDRESS_INVALID)
+	{
+		g_cam_st_addr =0;
+		kfree(*cam);
+	}else
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+		
+	return SUCCESS;
+}
+EXPORT_SYMBOL(v4l2_base_struct);
+
+/************************************************************************************************************
+ *  
+ *  MODULE TYPE	:	FUNCTION				MODULE ID	:	
+ *  Name	:	init_v4l2_base_struct	
+ *  Parameter1	:	cam_data *cam	- Base address of camera structure pointer
+ *  Parameter2	:	
+ *  Returns	:	FNRESLT		- On Success Zero (or) positive value be returned to the calling
+ *  					  Functions and On error a negative value be returned
+ *
+ *  					  Note: 
+ *  					  	For more detail about the return values please refer
+ *  					  error.c and error.h file available in the current project
+ *  Description	: 	
+ *  Comments	:  	
+ ************************************************************************************************************/
+FNRESLT init_v4l2_base_struct(cam_data *cam)
+{
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+	static struct v4l2_file_operations omap_v4l_fops = 	\
+	{
+		.owner		= THIS_MODULE,
+		.ioctl		= omap_v4l2_ioctl,
+//		.poll		= ,
+		.mmap		= omap_mmap,
+		.open		= omap_v4l2_open,
+		.release	= omap_v4l2_close,
+		.read		= omap_v4l2_read,
+
+	};
+#else
+	static struct file_operations omap_v4l_fops = 	\
+	{
+		.owner		= THIS_MODULE,
+		.ioctl		= omap_v4l2_ioctl,
+//		.poll		= ,
+		.mmap		= omap_mmap,
+		.open		= omap_v4l2_open,
+		.release	= omap_v4l2_close,
+		.read		= omap_v4l2_read,
+
+	};
+
+#endif
+	static struct video_device omap_v4l_template =		\
+	{
+		.minor		= -1,
+		.fops		= &omap_v4l_fops,
+		.ioctl_ops	= NULL,
+
+		.name		= "omap camera",
+//		.type		= 0,
+//		.type2		= VID_TYPE_CAPTURE,
+		.release	= video_device_release,
+	};
+
+	if(cam == NULL)
+	{
+		TRACE_ERR_AND_RET(FAIL);
+	}
+
+	cam->video_dev		= video_device_alloc();
+	if (cam->video_dev == NULL)
+	{
+		return ALLOCATION_MEMORY_FAILED;
+	}
+
+	*(cam->video_dev)	= omap_v4l_template;
+	video_set_drvdata(cam->video_dev, cam);
+	cam->video_dev->minor	= -1;
+
+
+	return SUCCESS;
+}
diff -Naur linux-org/drivers/media/video/ecam32/v4l2_driver_base.h linux-ths/drivers/media/video/ecam32/v4l2_driver_base.h
--- linux-org/drivers/media/video/ecam32/v4l2_driver_base.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/ecam32/v4l2_driver_base.h	2012-07-10 15:57:59.000000000 +0200
@@ -0,0 +1,254 @@
+/**********************************************************************************************************
+ *   Copyright (C) 2007 by e-con Systems.                                                                *
+ *   www.e-consystems.com                                                                                 *
+ *                                                                                                        *
+ *   This file is licensed under the terms of the GNU General Public License                              *
+ *   version 2. This program is licensed "as is" without any warranty of any                              *
+ *   kind, whether express or implied.                                                                    *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   PROJECT	           :        OMAP Camera development                                               *
+ *   MODULE NAME           :        OV3640                                                                *
+ *   MODULE VERSION        :        VER 1.0                                                               *
+ *                                                                                                        *
+ *                                                                                                        *
+ *                                                                                                        *
+ *   Version No	: 000-0001                                                          CODE_REV  : 0.0.1.0   *
+ **********************************************************************************************************/
+
+/*
+ *==========================================================================================================
+ *                                        REVISION HISTORY                                  
+ *----------------------------------------------------------------------------------------------------------
+ * CODE_REV  REASON FOR MODIFICATION                MODIFIED FUNCTION NAME  	            AUTHOR
+ *----------------------------------------------------------------------------------------------------------
+ * 
+ * 0.0.1.0   ------------------------ Driver development ---------------------------- Ananthapadmanaban
+ *
+ *
+ *==========================================================================================================
+ */
+
+#ifndef __BUF_MANAGE_H
+#define __BUF_MANAGE_H
+
+#define __link_node(base_ptr, new_node) 			\
+{								\
+	if(base_ptr == NULL)					\
+	{							\
+		base_ptr	= new_node;			\
+	}else							\
+	{							\
+		typeof(*base_ptr) *tmp = base_ptr;		\
+		for(;tmp->next;)				\
+		{						\
+			tmp	= tmp->next;			\
+		}						\
+		tmp->next	= new_node;			\
+	}							\
+}
+
+#define __update_base(base_ptr)					\
+{								\
+	base_ptr	= (base_ptr)?base_ptr->next:NULL;	\
+}
+
+#endif
+
+/*
+ * Global definitions
+ */
+#define MAX_FRAME_SUPPORT			10
+#define MAX_PIX_FORMAT_SUPPORTED		10
+#define MACRO_MAX_DISCREATE_FROMAT_SUPPORT	10
+
+enum __commands
+{
+	GET_DATA	= 1,
+	SET_DATA,
+	QUERY_DATA,
+	RESTORE_DATA,
+};
+
+typedef struct __cam_base_data
+{
+	struct video_device			*video_dev;
+
+	struct v4l2_capability			v4l2_cap;		// capture capability
+	struct v4l2_control			ctrl;			// ctrl based
+	struct v4l2_input 			vinp;
+	union
+	{
+		UINT8			task_state;
+		struct
+		{
+			UINT8			still	:1;
+			UINT8			capture	:1;
+		}bit;
+	}task;
+
+	struct
+	{
+		struct v4l2_format		v2f;			// v4l2 format 
+		struct v4l2_crop		crop;			// crop structure
+		struct v4l2_streamparm 		s_parm;			// stream parameter  
+
+//		struct v4l2_requestbuffers 	req_buf;
+		SINT32				available_buf;		// This will represet the Number of buffer
+									// chain can be formed in the qbuf - dqbuf process
+
+		INT32				using_buf;		// This will represet the current buffer 
+									// used by ccdc unit
+
+		INT32				valid_buf;		// This will mention the current valid buffer
+
+		UINT64				buffer_sequence;	// Total number of effective buffer delivered be
+									// available in this byte.
+		wait_queue_head_t 		capture_frame_complete;
+
+		struct __capture_dq_buf
+		{
+			struct __capture_dq_buf *next;
+
+			UINT32			width;
+			UINT32			height;
+			UINT32			size;
+
+			struct v4l2_buffer	buffer;			// physical address to be
+									// updated in m.offset
+		}frame[MAX_FRAME_SUPPORT];
+
+		struct __capture_dq_buf *Need_to_be_filled;
+		struct __capture_dq_buf *filled;
+		struct __capture_dq_buf *processing;
+	}capture;
+
+	struct
+	{
+		UINT8				wait_queue_head_t_dma_frame_complete_still;
+
+		wait_queue_head_t 		dma_frame_complete_still;
+		UINT32				frame_count;
+
+		UINT32				phy_addr;
+		UINT32				vir_addr;
+	}still;
+
+	cam_interface_pin_config		*pin;
+	isp_reg_bit_access			*isp;
+
+/*
+ * Place the platform specific content here
+ */
+	struct platform_driver omap3isp_driver;
+	struct device *dev;
+
+/*
+ * camera irq routine will be obtained from platform data
+ */
+	struct platform_device 			*pdev;
+	struct resource				*mem;
+	UINT32					irq;
+
+	UINT8					clk_enable;
+	struct clk 				*cam_mclk;
+	struct clk 				*cam_ick;
+	struct clk 				*cam_dpll4;
+/*
+ * S_CTRL, G_CTRL and QUERY_CTRL use this flag as base
+ */
+	UINT8	cmd;
+	struct v4l2_queryctrl qctrl;
+	
+/*
+ * Board specific function callbacks
+ */
+	FNRESLT (*modify_mclk_to_sensor)	(struct __cam_base_data *cam,UINT32 clk_need,UPINT32 clk_set); 
+
+/*
+ * sensor specific 
+ */
+	struct camera_sensor
+	{
+/*
+ * platform specific data
+ */
+		struct i2c_driver i2c_driver;
+		
+		UINT32 total_fmt_desc;
+		struct v4l2_fmtdesc formats[MAX_PIX_FORMAT_SUPPORTED];
+		struct v4l2_cropcap cropcap;
+		struct v4l2_crop scrop;
+		struct v4l2_streamparm s_parm;
+
+		UINT32 total_frms_support;
+		struct v4l2_frmsizeenum frms[MACRO_MAX_DISCREATE_FROMAT_SUPPORT],*fmt_frm_user;
+
+		UINT32 total_frm_interval_support;
+		struct v4l2_frmivalenum frm_interval_support[MACRO_MAX_DISCREATE_FROMAT_SUPPORT],*frame_interval_frm_user;
+
+		struct i2c_client 			*client;
+
+		FNRESLT (*find_device) 			(struct __cam_base_data *cam); 
+		FNRESLT (*init) 			(struct __cam_base_data *cam); 
+		FNRESLT (*reset) 			(struct __cam_base_data *cam); 
+		FNRESLT (*config_dim) 			(struct __cam_base_data *cam);
+		FNRESLT (*brightness) 			(struct __cam_base_data *cam);
+		FNRESLT (*contrast) 			(struct __cam_base_data *cam);
+		FNRESLT (*saturation) 			(struct __cam_base_data *cam);
+		FNRESLT (*hue) 				(struct __cam_base_data *cam);
+		FNRESLT (*whitebalance) 		(struct __cam_base_data *cam);
+		FNRESLT (*colour_balance) 		(struct __cam_base_data *cam);
+		FNRESLT (*exposure) 			(struct __cam_base_data *cam);
+		FNRESLT (*gain) 			(struct __cam_base_data *cam);
+		FNRESLT (*v_flip) 			(struct __cam_base_data *cam);
+		FNRESLT (*h_mirror) 			(struct __cam_base_data *cam);
+		FNRESLT (*sharpness) 			(struct __cam_base_data *cam);
+
+		UINT8	sens_strobe_en;
+		FNRESLT (*sens_strobe) 			(struct __cam_base_data *cam);
+		FNRESLT (*test_color_pattern) 		(struct __cam_base_data *cam);
+
+		FNRESLT (*auto_focus_init) 		(struct __cam_base_data *cam);
+		FNRESLT (*focus) 			(struct __cam_base_data *cam);
+		FNRESLT (*effects) 			(struct __cam_base_data *cam);
+		FNRESLT (*antishake) 			(struct __cam_base_data *cam);
+
+		FNRESLT (*frame_rate_ctrl) 		(struct __cam_base_data *cam);
+		FNRESLT (*supported_formats) 		(struct __cam_base_data *cam);
+		FNRESLT (*frame_interval) 		(struct __cam_base_data *cam);
+
+		FNRESLT (*lens_correction) 		(struct __cam_base_data *cam);
+
+		FNRESLT (*crop) 			(struct __cam_base_data *cam);
+		FNRESLT (*exit)				(struct __cam_base_data *cam); 
+
+		FNRESLT (*reg_access) 			(struct __cam_base_data *cam);
+
+/*
+ * Query sensor
+ */
+		struct v4l2_format			fmt,qfmt;	 
+		FNRESLT (*qfmt_support) 		(struct __cam_base_data *cam);
+		FNRESLT (*fix_fmt_support) 		(struct __cam_base_data *cam);
+
+	}cam_sensor;
+
+/*
+ * Flash specific feature
+ */
+
+	struct _flash_driver
+	{
+		struct i2c_driver 			i2c;
+		struct i2c_client 			*client;
+
+		FNRESLT (*init)				(struct __cam_base_data *cam); 
+		FNRESLT (*flash)			(struct __cam_base_data *cam);
+		FNRESLT (*flash_lum_ctrl)		(struct __cam_base_data *cam);
+		FNRESLT (*torch)			(struct __cam_base_data *cam);
+		FNRESLT (*torch_lum_ctrl)		(struct __cam_base_data *cam);
+		FNRESLT (*exit)				(struct __cam_base_data *cam); 
+	}cam_flash;
+
+}cam_data;
diff -Naur linux-org/drivers/media/video/Kconfig linux-ths/drivers/media/video/Kconfig
--- linux-org/drivers/media/video/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/Kconfig	2012-07-19 09:13:30.784585097 +0200
@@ -0,0 +1,1243 @@
+#
+# Generic video config states
+#
+
+config VIDEO_V4L2
+	tristate
+	depends on VIDEO_DEV && VIDEO_V4L2_COMMON
+	default VIDEO_DEV && VIDEO_V4L2_COMMON
+
+config VIDEOBUF_GEN
+	tristate
+
+config VIDEOBUF_DMA_SG
+	depends on HAS_DMA
+	select VIDEOBUF_GEN
+	tristate
+
+config VIDEOBUF_VMALLOC
+	select VIDEOBUF_GEN
+	tristate
+
+config VIDEOBUF_DMA_CONTIG
+	depends on HAS_DMA
+	select VIDEOBUF_GEN
+	tristate
+
+config VIDEOBUF_DVB
+	tristate
+	select VIDEOBUF_GEN
+
+config VIDEO_BTCX
+	depends on PCI
+	tristate
+
+config VIDEO_TVEEPROM
+	tristate
+	depends on I2C
+
+config VIDEO_TUNER
+	tristate
+	depends on MEDIA_TUNER
+
+config V4L2_MEM2MEM_DEV
+	tristate
+	depends on VIDEOBUF2_CORE
+
+config VIDEOBUF2_CORE
+	tristate
+
+config VIDEOBUF2_MEMOPS
+	tristate
+
+config VIDEOBUF2_DMA_CONTIG
+	select VIDEOBUF2_CORE
+	select VIDEOBUF2_MEMOPS
+	tristate
+
+config VIDEOBUF2_VMALLOC
+	select VIDEOBUF2_CORE
+	select VIDEOBUF2_MEMOPS
+	tristate
+
+
+config VIDEOBUF2_DMA_SG
+	#depends on HAS_DMA
+	select VIDEOBUF2_CORE
+	select VIDEOBUF2_MEMOPS
+	tristate
+#
+# Multimedia Video device configuration
+#
+
+menuconfig VIDEO_CAPTURE_DRIVERS
+	bool "Video capture adapters"
+	depends on VIDEO_V4L2
+	default y
+	---help---
+	  Say Y here to enable selecting the video adapters for
+	  webcams, analog TV, and hybrid analog/digital TV.
+	  Some of those devices also supports FM radio.
+
+if VIDEO_CAPTURE_DRIVERS && VIDEO_V4L2
+
+config VIDEO_ADV_DEBUG
+	bool "Enable advanced debug functionality"
+	default n
+	---help---
+	  Say Y here to enable advanced debugging functionality on some
+	  V4L devices.
+	  In doubt, say N.
+
+config VIDEO_FIXED_MINOR_RANGES
+	bool "Enable old-style fixed minor ranges for video devices"
+	default n
+	---help---
+	  Say Y here to enable the old-style fixed-range minor assignments.
+	  Only useful if you rely on the old behavior and use mknod instead of udev.
+
+	  When in doubt, say N.
+
+config VIDEO_HELPER_CHIPS_AUTO
+	bool "Autoselect pertinent encoders/decoders and other helper chips"
+	default y if !EXPERT
+	---help---
+	  Most video cards may require additional modules to encode or
+	  decode audio/video standards. This option will autoselect
+	  all pertinent modules to each selected video module.
+
+	  Unselect this only if you know exactly what you are doing, since
+	  it may break support on some boards.
+
+	  In doubt, say Y.
+
+config VIDEO_IR_I2C
+	tristate "I2C module for IR" if !VIDEO_HELPER_CHIPS_AUTO
+	depends on I2C && RC_CORE
+	default y
+	---help---
+	  Most boards have an IR chip directly connected via GPIO. However,
+	  some video boards have the IR connected via I2C bus.
+
+	  If your board doesn't have an I2C IR chip, you may disable this
+	  option.
+
+	  In doubt, say Y.
+
+#
+# Encoder / Decoder module configuration
+#
+
+menu "Encoders, decoders, sensors and other helper chips"
+	visible if !VIDEO_HELPER_CHIPS_AUTO
+
+comment "Audio decoders, processors and mixers"
+
+config VIDEO_TVAUDIO
+	tristate "Simple audio decoder chips"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for several audio decoder chips found on some bt8xx boards:
+	  Philips: tda9840, tda9873h, tda9874h/a, tda9850, tda985x, tea6300,
+		   tea6320, tea6420, tda8425, ta8874z.
+	  Microchip: pic16c54 based design on ProVideo PV951 board.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tvaudio.
+
+config VIDEO_TDA7432
+	tristate "Philips TDA7432 audio processor"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for tda7432 audio decoder chip found on some bt8xx boards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tda7432.
+
+config VIDEO_TDA9840
+	tristate "Philips TDA9840 audio processor"
+	depends on I2C
+	---help---
+	  Support for tda9840 audio decoder chip found on some Zoran boards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tda9840.
+
+config VIDEO_TEA6415C
+	tristate "Philips TEA6415C audio processor"
+	depends on I2C
+	---help---
+	  Support for tea6415c audio decoder chip found on some bt8xx boards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tea6415c.
+
+config VIDEO_TEA6420
+	tristate "Philips TEA6420 audio processor"
+	depends on I2C
+	---help---
+	  Support for tea6420 audio decoder chip found on some bt8xx boards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tea6420.
+
+config VIDEO_MSP3400
+	tristate "Micronas MSP34xx audio decoders"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Micronas MSP34xx series of audio decoders.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called msp3400.
+
+config VIDEO_CS5345
+	tristate "Cirrus Logic CS5345 audio ADC"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Cirrus Logic CS5345 24-bit, 192 kHz
+	  stereo A/D converter.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cs5345.
+
+config VIDEO_CS53L32A
+	tristate "Cirrus Logic CS53L32A audio ADC"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Cirrus Logic CS53L32A low voltage
+	  stereo A/D converter.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cs53l32a.
+
+config VIDEO_TLV320AIC23B
+	tristate "Texas Instruments TLV320AIC23B audio codec"
+	depends on VIDEO_V4L2 && I2C && EXPERIMENTAL
+	---help---
+	  Support for the Texas Instruments TLV320AIC23B audio codec.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tlv320aic23b.
+
+config VIDEO_WM8775
+	tristate "Wolfson Microelectronics WM8775 audio ADC with input mixer"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Wolfson Microelectronics WM8775 high
+	  performance stereo A/D Converter with a 4 channel input mixer.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called wm8775.
+
+config VIDEO_WM8739
+	tristate "Wolfson Microelectronics WM8739 stereo audio ADC"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Wolfson Microelectronics WM8739
+	  stereo A/D Converter.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called wm8739.
+
+config VIDEO_VP27SMPX
+	tristate "Panasonic VP27s internal MPX"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the internal MPX of the Panasonic VP27s tuner.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vp27smpx.
+
+comment "RDS decoders"
+
+config VIDEO_SAA6588
+	tristate "SAA6588 Radio Chip RDS decoder support"
+	depends on VIDEO_V4L2 && I2C
+
+	help
+	  Support for this Radio Data System (RDS) decoder. This allows
+	  seeing radio station identification transmitted using this
+	  standard.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called saa6588.
+
+comment "Video decoders"
+
+config VIDEO_ADV7180
+	tristate "Analog Devices ADV7180 decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Analog Devices ADV7180 video decoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called adv7180.
+
+config VIDEO_ADV7183
+	tristate "Analog Devices ADV7183 decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  V4l2 subdevice driver for the Analog Devices
+	  ADV7183 video decoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called adv7183.
+
+config VIDEO_BT819
+	tristate "BT819A VideoStream decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for BT819A video decoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called bt819.
+
+config VIDEO_BT856
+	tristate "BT856 VideoStream decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for BT856 video decoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called bt856.
+
+config VIDEO_BT866
+	tristate "BT866 VideoStream decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for BT866 video decoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called bt866.
+
+config VIDEO_KS0127
+	tristate "KS0127 video decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for KS0127 video decoder.
+
+	  This chip is used on AverMedia AVS6EYES Zoran-based MJPEG
+	  cards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ks0127.
+
+config VIDEO_SAA7110
+	tristate "Philips SAA7110 video decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Philips SAA7110 video decoders.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called saa7110.
+
+config VIDEO_SAA711X
+	tristate "Philips SAA7111/3/4/5 video decoders"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Philips SAA7111/3/4/5 video decoders.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called saa7115.
+
+config VIDEO_SAA7191
+	tristate "Philips SAA7191 video decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Philips SAA7191 video decoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called saa7191.
+
+config VIDEO_TVP514X
+	tristate "Texas Instruments TVP514x video decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the TI TVP5146/47
+	  decoder. It is currently working with the TI OMAP3 camera
+	  controller.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tvp514x.
+
+config VIDEO_TVP5150
+	tristate "Texas Instruments TVP5150 video decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Texas Instruments TVP5150 video decoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tvp5150.
+
+config VIDEO_TVP7002
+	tristate "Texas Instruments TVP7002 video decoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Texas Instruments TVP7002 video decoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tvp7002.
+
+config VIDEO_VPX3220
+	tristate "vpx3220a, vpx3216b & vpx3214c video decoders"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for VPX322x video decoders.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpx3220.
+
+comment "Video and audio decoders"
+
+config VIDEO_SAA717X
+	tristate "Philips SAA7171/3/4 audio/video decoders"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Philips SAA7171/3/4 audio/video decoders.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called saa717x.
+
+source "drivers/media/video/cx25840/Kconfig"
+
+comment "MPEG video encoders"
+
+config VIDEO_CX2341X
+	tristate "Conexant CX2341x MPEG encoders"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_COMMON
+	---help---
+	  Support for the Conexant CX23416 MPEG encoders
+	  and CX23415 MPEG encoder/decoders.
+
+	  This module currently supports the encoding functions only.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cx2341x.
+
+comment "Video encoders"
+
+config VIDEO_SAA7127
+	tristate "Philips SAA7127/9 digital video encoders"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Philips SAA7127/9 digital video encoders.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called saa7127.
+
+config VIDEO_SAA7185
+	tristate "Philips SAA7185 video encoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Philips SAA7185 video encoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called saa7185.
+
+config VIDEO_ADV7170
+	tristate "Analog Devices ADV7170 video encoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Analog Devices ADV7170 video encoder driver
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called adv7170.
+
+config VIDEO_ADV7175
+	tristate "Analog Devices ADV7175 video encoder"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the Analog Devices ADV7175 video encoder driver
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called adv7175.
+
+config VIDEO_ADV7343
+	tristate "ADV7343 video encoder"
+	depends on I2C
+	help
+	  Support for Analog Devices I2C bus based ADV7343 encoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called adv7343.
+
+config VIDEO_AK881X
+	tristate "AK8813/AK8814 video encoders"
+	depends on I2C
+	help
+	  Video output driver for AKM AK8813 and AK8814 TV encoders
+
+comment "Camera sensor devices"
+
+config VIDEO_APTINA_PLL
+	tristate
+
+config VIDEO_OV7670
+	tristate "OmniVision OV7670 sensor support"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV7670 VGA camera.  It currently only works with the M88ALP01
+	  controller.
+
+config VIDEO_VS6624
+	tristate "ST VS6624 sensor support"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the ST VS6624
+	  camera.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vs6624.
+
+config VIDEO_MT9M032
+	tristate "MT9M032 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	select VIDEO_APTINA_PLL
+	---help---
+	  This driver supports MT9M032 camera sensors from Aptina, monochrome
+	  models only.
+
+config VIDEO_MT9P031
+	tristate "Aptina MT9P031 support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	select VIDEO_APTINA_PLL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Aptina
+	  (Micron) mt9p031 5 Mpixel camera.
+
+config VIDEO_MT9T001
+	tristate "Aptina MT9T001 support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Aptina
+	  (Micron) mt0t001 3 Mpixel camera.
+
+config VIDEO_MT9V011
+	tristate "Micron mt9v011 sensor support"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Micron
+	  mt0v011 1.3 Mpixel camera.  It currently only works with the
+	  em28xx driver.
+
+config VIDEO_MT9V032
+	tristate "Micron MT9V032 sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Micron
+	  MT9V032 752x480 CMOS sensor.
+
+config VIDEO_TCM825X
+	tristate "TCM825x camera sensor support"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a driver for the Toshiba TCM825x VGA camera sensor.
+	  It is used for example in Nokia N800.
+
+config VIDEO_SR030PC30
+	tristate "Siliconfile SR030PC30 sensor support"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This driver supports SR030PC30 VGA camera from Siliconfile
+
+config VIDEO_NOON010PC30
+	tristate "Siliconfile NOON010PC30 sensor support"
+	depends on I2C && VIDEO_V4L2 && EXPERIMENTAL && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This driver supports NOON010PC30 CIF camera from Siliconfile
+
+source "drivers/media/video/m5mols/Kconfig"
+
+config VIDEO_S5K6AA
+	tristate "Samsung S5K6AAFX sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This is a V4L2 sensor-level driver for Samsung S5K6AA(FX) 1.3M
+	  camera sensor with an embedded SoC image signal processor.
+
+comment "Flash devices"
+
+config VIDEO_ADP1653
+	tristate "ADP1653 flash support"
+	depends on I2C && VIDEO_V4L2 && MEDIA_CONTROLLER
+	---help---
+	  This is a driver for the ADP1653 flash controller. It is used for
+	  example in Nokia N900.
+
+config VIDEO_AS3645A
+	tristate "AS3645A flash driver support"
+	depends on I2C && VIDEO_V4L2 && MEDIA_CONTROLLER
+	---help---
+	  This is a driver for the AS3645A and LM3555 flash controllers. It has
+	  build in control for flash, torch and indicator LEDs.
+
+comment "Video improvement chips"
+
+config VIDEO_UPD64031A
+	tristate "NEC Electronics uPD64031A Ghost Reduction"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the NEC Electronics uPD64031A Ghost Reduction
+	  video chip. It is most often found in NTSC TV cards made for
+	  Japan and is used to reduce the 'ghosting' effect that can
+	  be present in analog TV broadcasts.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called upd64031a.
+
+config VIDEO_UPD64083
+	tristate "NEC Electronics uPD64083 3-Dimensional Y/C separation"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  Support for the NEC Electronics uPD64083 3-Dimensional Y/C
+	  separation video chip. It is used to improve the quality of
+	  the colors of a composite signal.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called upd64083.
+
+comment "Miscelaneous helper chips"
+
+config VIDEO_THS7303
+	tristate "THS7303 Video Amplifier"
+	depends on I2C
+	help
+	  Support for TI THS7303 video amplifier
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ths7303.
+
+config VIDEO_M52790
+	tristate "Mitsubishi M52790 A/V switch"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	 Support for the Mitsubishi M52790 A/V switch.
+
+	 To compile this driver as a module, choose M here: the
+	 module will be called m52790.
+
+endmenu # encoder / decoder chips
+
+config VIDEO_VIVI
+	tristate "Virtual Video Driver"
+	depends on VIDEO_DEV && VIDEO_V4L2 && !SPARC32 && !SPARC64
+	depends on FRAMEBUFFER_CONSOLE || STI_CONSOLE
+	select FONT_8x16
+	select VIDEOBUF2_VMALLOC
+	default n
+	---help---
+	  Enables a virtual video driver. This device shows a color bar
+	  and a timestamp, as a real device would generate by using V4L2
+	  api.
+	  Say Y here if you want to test video apps or debug V4L devices.
+	  In doubt, say N.
+
+#
+# USB Multimedia device configuration
+#
+
+menuconfig V4L_USB_DRIVERS
+	bool "V4L USB devices"
+	depends on USB
+	default y
+
+if V4L_USB_DRIVERS
+
+source "drivers/media/video/uvc/Kconfig"
+
+source "drivers/media/video/gspca/Kconfig"
+
+source "drivers/media/video/pvrusb2/Kconfig"
+
+source "drivers/media/video/hdpvr/Kconfig"
+
+source "drivers/media/video/em28xx/Kconfig"
+
+source "drivers/media/video/tlg2300/Kconfig"
+
+source "drivers/media/video/cx231xx/Kconfig"
+
+source "drivers/media/video/tm6000/Kconfig"
+
+source "drivers/media/video/usbvision/Kconfig"
+
+source "drivers/media/video/et61x251/Kconfig"
+
+source "drivers/media/video/sn9c102/Kconfig"
+
+source "drivers/media/video/pwc/Kconfig"
+
+source "drivers/media/video/cpia2/Kconfig"
+
+config USB_ZR364XX
+	tristate "USB ZR364XX Camera support"
+	depends on VIDEO_V4L2
+	select VIDEOBUF_GEN
+	select VIDEOBUF_VMALLOC
+	---help---
+	  Say Y here if you want to connect this type of camera to your
+	  computer's USB port.
+	  See <file:Documentation/video4linux/zr364xx.txt> for more info
+	  and list of supported cameras.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called zr364xx.
+
+config USB_STKWEBCAM
+	tristate "USB Syntek DC1125 Camera support"
+	depends on VIDEO_V4L2 && EXPERIMENTAL
+	---help---
+	  Say Y here if you want to use this type of camera.
+	  Supported devices are typically found in some Asus laptops,
+	  with USB id 174f:a311 and 05e1:0501. Other Syntek cameras
+	  may be supported by the stk11xx driver, from which this is
+	  derived, see <http://sourceforge.net/projects/syntekdriver/>
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called stkwebcam.
+
+config USB_S2255
+	tristate "USB Sensoray 2255 video capture device"
+	depends on VIDEO_V4L2
+	select VIDEOBUF_VMALLOC
+	default n
+	help
+	  Say Y here if you want support for the Sensoray 2255 USB device.
+	  This driver can be compiled as a module, called s2255drv.
+
+endif # V4L_USB_DRIVERS
+
+#
+# PCI drivers configuration
+#
+
+menuconfig V4L_PCI_DRIVERS
+	bool "V4L PCI(e) devices"
+	depends on PCI
+	default y
+	---help---
+	  Say Y here to enable support for these PCI(e) drivers.
+
+if V4L_PCI_DRIVERS
+
+source "drivers/media/video/au0828/Kconfig"
+
+source "drivers/media/video/bt8xx/Kconfig"
+
+source "drivers/media/video/cx18/Kconfig"
+
+source "drivers/media/video/cx23885/Kconfig"
+
+source "drivers/media/video/cx25821/Kconfig"
+
+source "drivers/media/video/cx88/Kconfig"
+
+config VIDEO_HEXIUM_GEMINI
+	tristate "Hexium Gemini frame grabber"
+	depends on PCI && VIDEO_V4L2 && I2C
+	select VIDEO_SAA7146_VV
+	---help---
+	  This is a video4linux driver for the Hexium Gemini frame
+	  grabber card by Hexium. Please note that the Gemini Dual
+	  card is *not* fully supported.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called hexium_gemini.
+
+config VIDEO_HEXIUM_ORION
+	tristate "Hexium HV-PCI6 and Orion frame grabber"
+	depends on PCI && VIDEO_V4L2 && I2C
+	select VIDEO_SAA7146_VV
+	---help---
+	  This is a video4linux driver for the Hexium HV-PCI6 and
+	  Orion frame grabber cards by Hexium.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called hexium_orion.
+
+source "drivers/media/video/ivtv/Kconfig"
+
+config VIDEO_MEYE
+	tristate "Sony Vaio Picturebook Motion Eye Video For Linux"
+	depends on PCI && SONY_LAPTOP && VIDEO_V4L2
+	---help---
+	  This is the video4linux driver for the Motion Eye camera found
+	  in the Vaio Picturebook laptops. Please read the material in
+	  <file:Documentation/video4linux/meye.txt> for more information.
+
+	  If you say Y or M here, you need to say Y or M to "Sony Laptop
+	  Extras" in the misc device section.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called meye.
+
+config VIDEO_MXB
+	tristate "Siemens-Nixdorf 'Multimedia eXtension Board'"
+	depends on PCI && VIDEO_V4L2 && I2C
+	select VIDEO_SAA7146_VV
+	select VIDEO_TUNER
+	select VIDEO_SAA711X if VIDEO_HELPER_CHIPS_AUTO
+	select VIDEO_TDA9840 if VIDEO_HELPER_CHIPS_AUTO
+	select VIDEO_TEA6415C if VIDEO_HELPER_CHIPS_AUTO
+	select VIDEO_TEA6420 if VIDEO_HELPER_CHIPS_AUTO
+	---help---
+	  This is a video4linux driver for the 'Multimedia eXtension Board'
+	  TV card by Siemens-Nixdorf.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mxb.
+
+source "drivers/media/video/saa7134/Kconfig"
+
+source "drivers/media/video/saa7164/Kconfig"
+
+source "drivers/media/video/zoran/Kconfig"
+
+endif # V4L_PCI_DRIVERS
+
+#
+# ISA & parallel port drivers configuration
+#
+
+menuconfig V4L_ISA_PARPORT_DRIVERS
+	bool "V4L ISA and parallel port devices"
+	depends on ISA || PARPORT
+	default n
+	---help---
+	  Say Y here to enable support for these ISA and parallel port drivers.
+
+if V4L_ISA_PARPORT_DRIVERS
+
+config VIDEO_BWQCAM
+	tristate "Quickcam BW Video For Linux"
+	depends on PARPORT && VIDEO_V4L2
+	help
+	  Say Y have if you the black and white version of the QuickCam
+	  camera. See the next option for the color version.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called bw-qcam.
+
+config VIDEO_CQCAM
+	tristate "QuickCam Colour Video For Linux"
+	depends on PARPORT && VIDEO_V4L2
+	help
+	  This is the video4linux driver for the colour version of the
+	  Connectix QuickCam.  If you have one of these cameras, say Y here,
+	  otherwise say N.  This driver does not work with the original
+	  monochrome QuickCam, QuickCam VC or QuickClip.  It is also available
+	  as a module (c-qcam).
+	  Read <file:Documentation/video4linux/CQcam.txt> for more information.
+
+config VIDEO_PMS
+	tristate "Mediavision Pro Movie Studio Video For Linux"
+	depends on ISA && VIDEO_V4L2
+	help
+	  Say Y if you have the ISA Mediavision Pro Movie Studio
+	  capture card.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called pms.
+
+config VIDEO_W9966
+	tristate "W9966CF Webcam (FlyCam Supra and others) Video For Linux"
+	depends on PARPORT_1284 && PARPORT && VIDEO_V4L2
+	help
+	  Video4linux driver for Winbond's w9966 based Webcams.
+	  Currently tested with the LifeView FlyCam Supra.
+	  If you have one of these cameras, say Y here
+	  otherwise say N.
+	  This driver is also available as a module (w9966).
+
+	  Check out <file:Documentation/video4linux/w9966.txt> for more
+	  information.
+
+endif # V4L_ISA_PARPORT_DRIVERS
+
+menuconfig V4L_PLATFORM_DRIVERS
+	bool "V4L platform devices"
+	default n
+	---help---
+	  Say Y here to enable support for platform-specific V4L drivers.
+
+if V4L_PLATFORM_DRIVERS
+
+source "drivers/media/video/marvell-ccic/Kconfig"
+
+config VIDEO_VIA_CAMERA
+	tristate "VIAFB camera controller support"
+	depends on FB_VIA
+	select VIDEOBUF_DMA_SG
+	select VIDEO_OV7670
+	help
+	   Driver support for the integrated camera controller in VIA
+	   Chrome9 chipsets.  Currently only tested on OLPC xo-1.5 systems
+	   with ov7670 sensors.
+
+#
+# Platform multimedia device configuration
+#
+
+source "drivers/media/video/davinci/Kconfig"
+
+source "drivers/media/video/omap/Kconfig"
+
+source "drivers/media/video/blackfin/Kconfig"
+
+config VIDEO_SH_VOU
+	tristate "SuperH VOU video output driver"
+	depends on VIDEO_DEV && ARCH_SHMOBILE
+	select VIDEOBUF_DMA_CONTIG
+	help
+	  Support for the Video Output Unit (VOU) on SuperH SoCs.
+
+config VIDEO_VIU
+	tristate "Freescale VIU Video Driver"
+	depends on VIDEO_V4L2 && PPC_MPC512x
+	select VIDEOBUF_DMA_CONTIG
+	default y
+	---help---
+	  Support for Freescale VIU video driver. This device captures
+	  video data, or overlays video on DIU frame buffer.
+
+	  Say Y here if you want to enable VIU device on MPC5121e Rev2+.
+	  In doubt, say N.
+
+config VIDEO_TIMBERDALE
+	tristate "Support for timberdale Video In/LogiWIN"
+	depends on VIDEO_V4L2 && I2C && DMADEVICES
+	select DMA_ENGINE
+	select TIMB_DMA
+	select VIDEO_ADV7180
+	select VIDEOBUF_DMA_CONTIG
+	---help---
+	  Add support for the Video In peripherial of the timberdale FPGA.
+
+config VIDEO_VINO
+	tristate "SGI Vino Video For Linux"
+	depends on I2C && SGI_IP22 && VIDEO_V4L2
+	select VIDEO_SAA7191 if VIDEO_HELPER_CHIPS_AUTO
+	help
+	  Say Y here to build in support for the Vino video input system found
+	  on SGI Indy machines.
+
+config VIDEO_M32R_AR
+	tristate "AR devices"
+	depends on M32R && VIDEO_V4L2
+	---help---
+	  This is a video4linux driver for the Renesas AR (Artificial Retina)
+	  camera module.
+
+config VIDEO_M32R_AR_M64278
+	tristate "AR device with color module M64278(VGA)"
+	depends on PLAT_M32700UT
+	select VIDEO_M32R_AR
+	---help---
+	  This is a video4linux driver for the Renesas AR (Artificial
+	  Retina) with M64278E-800 camera module.
+	  This module supports VGA(640x480 pixels) resolutions.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called arv.
+
+config VIDEO_OMAP3
+	tristate "OMAP 3 Camera support (EXPERIMENTAL)"
+	depends on OMAP_IOVMM && VIDEO_V4L2 && I2C && VIDEO_V4L2_SUBDEV_API && ARCH_OMAP3 && EXPERIMENTAL
+	---help---
+	  Driver for an OMAP 3 camera controller.
+
+config VIDEO_OMAP3_DEBUG
+	bool "OMAP 3 Camera debug messages"
+	depends on VIDEO_OMAP3
+	---help---
+	  Enable debug messages on OMAP 3 camera controller driver.
+
+config SOC_CAMERA
+	tristate "SoC camera support"
+	depends on VIDEO_V4L2 && HAS_DMA && I2C
+	select VIDEOBUF_GEN
+	select VIDEOBUF2_CORE
+	help
+	  SoC Camera is a common API to several cameras, not connecting
+	  over a bus like PCI or USB. For example some i2c camera connected
+	  directly to the data bus of an SoC.
+
+config SOC_CAMERA_IMX074
+	tristate "imx074 support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This driver supports IMX074 cameras from Sony
+
+config SOC_CAMERA_MT9M001
+	tristate "mt9m001 support"
+	depends on SOC_CAMERA && I2C
+	select GPIO_PCA953X if MT9M001_PCA9536_SWITCH
+	help
+	  This driver supports MT9M001 cameras from Micron, monochrome
+	  and colour models.
+
+config SOC_CAMERA_MT9M111
+	tristate "mt9m111, mt9m112 and mt9m131 support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This driver supports MT9M111, MT9M112 and MT9M131 cameras from
+	  Micron/Aptina
+
+config SOC_CAMERA_MT9T031
+	tristate "mt9t031 support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This driver supports MT9T031 cameras from Micron.
+
+config SOC_CAMERA_MT9T112
+	tristate "mt9t112 support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This driver supports MT9T112 cameras from Aptina.
+
+config SOC_CAMERA_MT9V022
+	tristate "mt9v022 support"
+	depends on SOC_CAMERA && I2C
+	select GPIO_PCA953X if MT9V022_PCA9536_SWITCH
+	help
+	  This driver supports MT9V022 cameras from Micron
+
+config SOC_CAMERA_RJ54N1
+	tristate "rj54n1cb0c support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a rj54n1cb0c video driver
+
+config SOC_CAMERA_TW9910
+	tristate "tw9910 support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a tw9910 video driver
+
+config SOC_CAMERA_PLATFORM
+	tristate "platform camera support"
+	depends on SOC_CAMERA
+	help
+	  This is a generic SoC camera platform driver, useful for testing
+
+config SOC_CAMERA_OV2640
+	tristate "ov2640 camera support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a ov2640 camera driver
+
+config SOC_CAMERA_OV5642
+	tristate "ov5642 camera support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a V4L2 camera driver for the OmniVision OV5642 sensor
+
+config SOC_CAMERA_OV6650
+	tristate "ov6650 sensor support"
+	depends on SOC_CAMERA && I2C
+	---help---
+	  This is a V4L2 SoC camera driver for the OmniVision OV6650 sensor
+
+config SOC_CAMERA_OV772X
+	tristate "ov772x camera support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a ov772x camera driver
+
+config SOC_CAMERA_OV9640
+	tristate "ov9640 camera support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a ov9640 camera driver
+
+config SOC_CAMERA_OV9740
+	tristate "ov9740 camera support"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a ov9740 camera driver
+
+config MX1_VIDEO
+	bool
+
+config VIDEO_MX1
+	tristate "i.MX1/i.MXL CMOS Sensor Interface driver"
+	depends on VIDEO_DEV && ARCH_MX1 && SOC_CAMERA
+	select FIQ
+	select VIDEOBUF_DMA_CONTIG
+	select MX1_VIDEO
+	---help---
+	  This is a v4l2 driver for the i.MX1/i.MXL CMOS Sensor Interface
+
+config MX3_VIDEO
+	bool
+
+config VIDEO_MX3
+	tristate "i.MX3x Camera Sensor Interface driver"
+	depends on VIDEO_DEV && MX3_IPU && SOC_CAMERA
+	select VIDEOBUF2_DMA_CONTIG
+	select MX3_VIDEO
+	---help---
+	  This is a v4l2 driver for the i.MX3x Camera Sensor Interface
+
+config VIDEO_PXA27x
+	tristate "PXA27x Quick Capture Interface driver"
+	depends on VIDEO_DEV && PXA27x && SOC_CAMERA
+	select VIDEOBUF_DMA_SG
+	---help---
+	  This is a v4l2 driver for the PXA27x Quick Capture Interface
+
+config VIDEO_SH_MOBILE_CSI2
+	tristate "SuperH Mobile MIPI CSI-2 Interface driver"
+	depends on VIDEO_DEV && SOC_CAMERA && HAVE_CLK
+	---help---
+	  This is a v4l2 driver for the SuperH MIPI CSI-2 Interface
+
+config VIDEO_SH_MOBILE_CEU
+	tristate "SuperH Mobile CEU Interface driver"
+	depends on VIDEO_DEV && SOC_CAMERA && HAS_DMA && HAVE_CLK
+	select VIDEOBUF2_DMA_CONTIG
+	---help---
+	  This is a v4l2 driver for the SuperH Mobile CEU Interface
+
+config VIDEO_OMAP1
+	tristate "OMAP1 Camera Interface driver"
+	depends on VIDEO_DEV && ARCH_OMAP1 && SOC_CAMERA
+	select VIDEOBUF_DMA_CONTIG
+	select VIDEOBUF_DMA_SG
+	---help---
+	  This is a v4l2 driver for the TI OMAP1 camera interface
+
+config VIDEO_OMAP2
+	tristate "OMAP2 Camera Capture Interface driver"
+	depends on VIDEO_DEV && ARCH_OMAP2
+	select VIDEOBUF_DMA_SG
+	---help---
+	  This is a v4l2 driver for the TI OMAP2 camera capture interface
+
+config VIDEO_MX2_HOSTSUPPORT
+	bool
+
+config VIDEO_MX2
+	tristate "i.MX27/i.MX25 Camera Sensor Interface driver"
+	depends on VIDEO_DEV && SOC_CAMERA && (MACH_MX27 || ARCH_MX25)
+	select VIDEOBUF2_DMA_CONTIG
+	select VIDEO_MX2_HOSTSUPPORT
+	---help---
+	  This is a v4l2 driver for the i.MX27 and the i.MX25 Camera Sensor
+	  Interface
+
+config  VIDEO_SAMSUNG_S5P_FIMC
+	tristate "Samsung S5P and EXYNOS4 camera interface driver (EXPERIMENTAL)"
+	depends on VIDEO_V4L2 && I2C && PLAT_S5P && PM_RUNTIME && \
+		VIDEO_V4L2_SUBDEV_API && EXPERIMENTAL
+	select VIDEOBUF2_DMA_CONTIG
+	select V4L2_MEM2MEM_DEV
+	---help---
+	  This is a v4l2 driver for Samsung S5P and EXYNOS4 camera
+	  host interface and video postprocessor.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called s5p-fimc.
+
+config VIDEO_ATMEL_ISI
+	tristate "ATMEL Image Sensor Interface (ISI) support"
+	depends on VIDEO_DEV && SOC_CAMERA && ARCH_AT91
+	select VIDEOBUF2_DMA_CONTIG
+	---help---
+	  This module makes the ATMEL Image Sensor Interface available
+	  as a v4l2 device.
+
+config VIDEO_S5P_MIPI_CSIS
+	tristate "Samsung S5P and EXYNOS4 MIPI CSI receiver driver"
+	depends on VIDEO_V4L2 && PM_RUNTIME && PLAT_S5P
+	depends on VIDEO_V4L2_SUBDEV_API && REGULATOR
+	---help---
+	  This is a v4l2 driver for Samsung S5P/EXYNOS4 MIPI-CSI receiver.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called s5p-csis.
+
+config VIDEO_ECAM32
+	tristate "ECAM32 camera support (EXPERIMENTAL)"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API && VIDEO_OMAP3 && EXPERIMENTAL
+	select VIDEO_OMAP34XX
+	help
+	  Driver for an ECAM32 camera controller.
+
+config VIDEO_ECAM32_DEBUG
+	bool "ECAM32 Camera debug messages"
+	depends on VIDEO_ECAM32
+	help
+	  Enable debug messages on ECAM32 camera driver.
+
+config VIDEO_OMAP34XX
+	tristate "OMAP34XX old camera support (EXPERIMENTAL)"
+	depends on VIDEO_ECAM32
+	help
+	  Required for ECAM32 camera controller.
+
+source "drivers/media/video/s5p-tv/Kconfig"
+
+endif # V4L_PLATFORM_DRIVERS
+endif # VIDEO_CAPTURE_DRIVERS
+
+menuconfig V4L_MEM2MEM_DRIVERS
+	bool "Memory-to-memory multimedia devices"
+	depends on VIDEO_V4L2
+	default n
+	---help---
+	  Say Y here to enable selecting drivers for V4L devices that
+	  use system memory for both source and destination buffers, as opposed
+	  to capture and output drivers, which use memory buffers for just
+	  one of those.
+
+if V4L_MEM2MEM_DRIVERS
+
+config VIDEO_MEM2MEM_TESTDEV
+	tristate "Virtual test device for mem2mem framework"
+	depends on VIDEO_DEV && VIDEO_V4L2
+	select VIDEOBUF2_VMALLOC
+	select V4L2_MEM2MEM_DEV
+	default n
+	---help---
+	  This is a virtual test device for the memory-to-memory driver
+	  framework.
+
+config VIDEO_SAMSUNG_S5P_G2D
+	tristate "Samsung S5P and EXYNOS4 G2D 2d graphics accelerator driver"
+	depends on VIDEO_DEV && VIDEO_V4L2 && PLAT_S5P
+	select VIDEOBUF2_DMA_CONTIG
+	select V4L2_MEM2MEM_DEV
+	default n
+	---help---
+	  This is a v4l2 driver for Samsung S5P and EXYNOS4 G2D
+	  2d graphics accelerator.
+
+config VIDEO_SAMSUNG_S5P_JPEG
+	tristate "Samsung S5P/Exynos4 JPEG codec driver (EXPERIMENTAL)"
+	depends on VIDEO_DEV && VIDEO_V4L2 && PLAT_S5P && EXPERIMENTAL
+	select VIDEOBUF2_DMA_CONTIG
+	select V4L2_MEM2MEM_DEV
+	---help---
+	  This is a v4l2 driver for Samsung S5P and EXYNOS4 JPEG codec
+
+config VIDEO_SAMSUNG_S5P_MFC
+	tristate "Samsung S5P MFC 5.1 Video Codec"
+	depends on VIDEO_DEV && VIDEO_V4L2 && PLAT_S5P
+	select VIDEOBUF2_DMA_CONTIG
+	default n
+	help
+	    MFC 5.1 driver for V4L2.
+
+config VIDEO_MX2_EMMAPRP
+	tristate "MX2 eMMa-PrP support"
+	depends on VIDEO_DEV && VIDEO_V4L2 && SOC_IMX27
+	select VIDEOBUF2_DMA_CONTIG
+	select V4L2_MEM2MEM_DEV
+	help
+	    MX2X chips have a PrP that can be used to process buffers from
+	    memory to memory. Operations include resizing and format
+	    conversion.
+
+endif # V4L_MEM2MEM_DRIVERS
diff -Naur linux-org/drivers/media/video/Makefile linux-ths/drivers/media/video/Makefile
--- linux-org/drivers/media/video/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/Makefile	2012-07-19 07:30:52.000000000 +0200
@@ -0,0 +1,217 @@
+#
+# Makefile for the video capture/playback device drivers.
+#
+
+tuner-objs	:=	tuner-core.o
+
+msp3400-objs	:=	msp3400-driver.o msp3400-kthreads.o
+
+stkwebcam-objs	:=	stk-webcam.o stk-sensor.o
+
+omap2cam-objs	:=	omap24xxcam.o omap24xxcam-dma.o
+
+videodev-objs	:=	v4l2-dev.o v4l2-ioctl.o v4l2-device.o v4l2-fh.o \
+			v4l2-event.o v4l2-ctrls.o v4l2-subdev.o
+ifeq ($(CONFIG_COMPAT),y)
+  videodev-objs += v4l2-compat-ioctl32.o
+endif
+
+# V4L2 core modules
+
+obj-$(CONFIG_VIDEO_DEV) += videodev.o v4l2-int-device.o
+obj-$(CONFIG_VIDEO_V4L2_COMMON) += v4l2-common.o
+
+# Helper modules
+
+obj-$(CONFIG_VIDEO_APTINA_PLL) += aptina-pll.o
+
+# All i2c modules must come first:
+
+obj-$(CONFIG_VIDEO_TUNER) += tuner.o
+obj-$(CONFIG_VIDEO_TVAUDIO) += tvaudio.o
+obj-$(CONFIG_VIDEO_TDA7432) += tda7432.o
+obj-$(CONFIG_VIDEO_SAA6588) += saa6588.o
+obj-$(CONFIG_VIDEO_TDA9840) += tda9840.o
+obj-$(CONFIG_VIDEO_TEA6415C) += tea6415c.o
+obj-$(CONFIG_VIDEO_TEA6420) += tea6420.o
+obj-$(CONFIG_VIDEO_SAA7110) += saa7110.o
+obj-$(CONFIG_VIDEO_SAA711X) += saa7115.o
+obj-$(CONFIG_VIDEO_SAA717X) += saa717x.o
+obj-$(CONFIG_VIDEO_SAA7127) += saa7127.o
+obj-$(CONFIG_VIDEO_SAA7185) += saa7185.o
+obj-$(CONFIG_VIDEO_SAA7191) += saa7191.o
+obj-$(CONFIG_VIDEO_ADV7170) += adv7170.o
+obj-$(CONFIG_VIDEO_ADV7175) += adv7175.o
+obj-$(CONFIG_VIDEO_ADV7180) += adv7180.o
+obj-$(CONFIG_VIDEO_ADV7183) += adv7183.o
+obj-$(CONFIG_VIDEO_ADV7343) += adv7343.o
+obj-$(CONFIG_VIDEO_VPX3220) += vpx3220.o
+obj-$(CONFIG_VIDEO_VS6624)  += vs6624.o
+obj-$(CONFIG_VIDEO_BT819) += bt819.o
+obj-$(CONFIG_VIDEO_BT856) += bt856.o
+obj-$(CONFIG_VIDEO_BT866) += bt866.o
+obj-$(CONFIG_VIDEO_KS0127) += ks0127.o
+obj-$(CONFIG_VIDEO_THS7303) += ths7303.o
+obj-$(CONFIG_VIDEO_VINO) += indycam.o
+obj-$(CONFIG_VIDEO_TVP5150) += tvp5150.o
+obj-$(CONFIG_VIDEO_TVP514X) += tvp514x.o
+obj-$(CONFIG_VIDEO_TVP7002) += tvp7002.o
+obj-$(CONFIG_VIDEO_MSP3400) += msp3400.o
+obj-$(CONFIG_VIDEO_CS5345) += cs5345.o
+obj-$(CONFIG_VIDEO_CS53L32A) += cs53l32a.o
+obj-$(CONFIG_VIDEO_M52790) += m52790.o
+obj-$(CONFIG_VIDEO_TLV320AIC23B) += tlv320aic23b.o
+obj-$(CONFIG_VIDEO_WM8775) += wm8775.o
+obj-$(CONFIG_VIDEO_WM8739) += wm8739.o
+obj-$(CONFIG_VIDEO_VP27SMPX) += vp27smpx.o
+obj-$(CONFIG_VIDEO_CX25840) += cx25840/
+obj-$(CONFIG_VIDEO_UPD64031A) += upd64031a.o
+obj-$(CONFIG_VIDEO_UPD64083) += upd64083.o
+obj-$(CONFIG_VIDEO_OV7670) 	+= ov7670.o
+obj-$(CONFIG_VIDEO_TCM825X) += tcm825x.o
+obj-$(CONFIG_VIDEO_TVEEPROM) += tveeprom.o
+obj-$(CONFIG_VIDEO_MT9M032) += mt9m032.o
+obj-$(CONFIG_VIDEO_MT9P031) += mt9p031.o
+obj-$(CONFIG_VIDEO_MT9T001) += mt9t001.o
+obj-$(CONFIG_VIDEO_MT9V011) += mt9v011.o
+obj-$(CONFIG_VIDEO_MT9V032) += mt9v032.o
+obj-$(CONFIG_VIDEO_SR030PC30)	+= sr030pc30.o
+obj-$(CONFIG_VIDEO_NOON010PC30)	+= noon010pc30.o
+obj-$(CONFIG_VIDEO_M5MOLS)	+= m5mols/
+obj-$(CONFIG_VIDEO_S5K6AA)	+= s5k6aa.o
+obj-$(CONFIG_VIDEO_ADP1653)	+= adp1653.o
+obj-$(CONFIG_VIDEO_AS3645A)	+= as3645a.o
+
+obj-$(CONFIG_SOC_CAMERA_IMX074)		+= imx074.o
+obj-$(CONFIG_SOC_CAMERA_MT9M001)	+= mt9m001.o
+obj-$(CONFIG_SOC_CAMERA_MT9M111)	+= mt9m111.o
+obj-$(CONFIG_SOC_CAMERA_MT9T031)	+= mt9t031.o
+obj-$(CONFIG_SOC_CAMERA_MT9T112)	+= mt9t112.o
+obj-$(CONFIG_SOC_CAMERA_MT9V022)	+= mt9v022.o
+obj-$(CONFIG_SOC_CAMERA_OV2640)		+= ov2640.o
+obj-$(CONFIG_SOC_CAMERA_OV5642)		+= ov5642.o
+obj-$(CONFIG_SOC_CAMERA_OV6650)		+= ov6650.o
+obj-$(CONFIG_SOC_CAMERA_OV772X)		+= ov772x.o
+obj-$(CONFIG_SOC_CAMERA_OV9640)		+= ov9640.o
+obj-$(CONFIG_SOC_CAMERA_OV9740)		+= ov9740.o
+obj-$(CONFIG_SOC_CAMERA_RJ54N1)		+= rj54n1cb0c.o
+obj-$(CONFIG_SOC_CAMERA_TW9910)		+= tw9910.o
+
+# And now the v4l2 drivers:
+
+obj-$(CONFIG_VIDEO_BT848) += bt8xx/
+obj-$(CONFIG_VIDEO_ZORAN) += zoran/
+obj-$(CONFIG_VIDEO_CQCAM) += c-qcam.o
+obj-$(CONFIG_VIDEO_BWQCAM) += bw-qcam.o
+obj-$(CONFIG_VIDEO_W9966) += w9966.o
+obj-$(CONFIG_VIDEO_PMS) += pms.o
+obj-$(CONFIG_VIDEO_VINO) += vino.o
+obj-$(CONFIG_VIDEO_MEYE) += meye.o
+obj-$(CONFIG_VIDEO_SAA7134) += saa7134/
+obj-$(CONFIG_VIDEO_CX88) += cx88/
+obj-$(CONFIG_VIDEO_EM28XX) += em28xx/
+obj-$(CONFIG_VIDEO_TLG2300) += tlg2300/
+obj-$(CONFIG_VIDEO_CX231XX) += cx231xx/
+obj-$(CONFIG_VIDEO_CX25821) += cx25821/
+obj-$(CONFIG_VIDEO_USBVISION) += usbvision/
+obj-$(CONFIG_VIDEO_PVRUSB2) += pvrusb2/
+obj-$(CONFIG_VIDEO_CPIA2) += cpia2/
+obj-$(CONFIG_VIDEO_TM6000) += tm6000/
+obj-$(CONFIG_VIDEO_MXB) += mxb.o
+obj-$(CONFIG_VIDEO_HEXIUM_ORION) += hexium_orion.o
+obj-$(CONFIG_VIDEO_HEXIUM_GEMINI) += hexium_gemini.o
+obj-$(CONFIG_VIDEO_TIMBERDALE)	+= timblogiw.o
+
+obj-$(CONFIG_VIDEOBUF_GEN) += videobuf-core.o
+obj-$(CONFIG_VIDEOBUF_DMA_SG) += videobuf-dma-sg.o
+obj-$(CONFIG_VIDEOBUF_DMA_CONTIG) += videobuf-dma-contig.o
+obj-$(CONFIG_VIDEOBUF_VMALLOC) += videobuf-vmalloc.o
+obj-$(CONFIG_VIDEOBUF_DVB) += videobuf-dvb.o
+obj-$(CONFIG_VIDEO_BTCX)  += btcx-risc.o
+
+obj-$(CONFIG_VIDEOBUF2_CORE)		+= videobuf2-core.o
+obj-$(CONFIG_VIDEOBUF2_MEMOPS)		+= videobuf2-memops.o
+obj-$(CONFIG_VIDEOBUF2_VMALLOC)		+= videobuf2-vmalloc.o
+obj-$(CONFIG_VIDEOBUF2_DMA_CONTIG)	+= videobuf2-dma-contig.o
+obj-$(CONFIG_VIDEOBUF2_DMA_SG)		+= videobuf2-dma-sg.o
+
+obj-$(CONFIG_V4L2_MEM2MEM_DEV) += v4l2-mem2mem.o
+
+obj-$(CONFIG_VIDEO_M32R_AR_M64278) += arv.o
+
+obj-$(CONFIG_VIDEO_CX2341X) += cx2341x.o
+
+obj-$(CONFIG_VIDEO_CAFE_CCIC) += marvell-ccic/
+obj-$(CONFIG_VIDEO_MMP_CAMERA) += marvell-ccic/
+
+obj-$(CONFIG_VIDEO_VIA_CAMERA) += via-camera.o
+
+obj-$(CONFIG_VIDEO_OMAP3)       += omap3isp/
+
+obj-$(CONFIG_VIDEO_ECAM32)      += ecam32/
+obj-$(CONFIG_VIDEO_OMAP34XX)    += omap34xxcam.o
+
+obj-$(CONFIG_USB_ZR364XX)       += zr364xx.o
+obj-$(CONFIG_USB_STKWEBCAM)     += stkwebcam.o
+
+obj-$(CONFIG_USB_SN9C102)       += sn9c102/
+obj-$(CONFIG_USB_ET61X251)      += et61x251/
+obj-$(CONFIG_USB_PWC)           += pwc/
+obj-$(CONFIG_USB_GSPCA)         += gspca/
+
+obj-$(CONFIG_VIDEO_HDPVR)	+= hdpvr/
+
+obj-$(CONFIG_USB_S2255)		+= s2255drv.o
+
+obj-$(CONFIG_VIDEO_IVTV) += ivtv/
+obj-$(CONFIG_VIDEO_CX18) += cx18/
+
+obj-$(CONFIG_VIDEO_VIU) += fsl-viu.o
+obj-$(CONFIG_VIDEO_VIVI) += vivi.o
+obj-$(CONFIG_VIDEO_MEM2MEM_TESTDEV) += mem2mem_testdev.o
+obj-$(CONFIG_VIDEO_CX23885) += cx23885/
+
+obj-$(CONFIG_VIDEO_AK881X)		+= ak881x.o
+
+obj-$(CONFIG_VIDEO_OMAP2)		+= omap2cam.o
+obj-$(CONFIG_SOC_CAMERA)		+= soc_camera.o soc_mediabus.o
+obj-$(CONFIG_SOC_CAMERA_PLATFORM)	+= soc_camera_platform.o
+# soc-camera host drivers have to be linked after camera drivers
+obj-$(CONFIG_VIDEO_MX1)			+= mx1_camera.o
+obj-$(CONFIG_VIDEO_MX2)			+= mx2_camera.o
+obj-$(CONFIG_VIDEO_MX3)			+= mx3_camera.o
+obj-$(CONFIG_VIDEO_PXA27x)		+= pxa_camera.o
+obj-$(CONFIG_VIDEO_SH_MOBILE_CSI2)	+= sh_mobile_csi2.o
+obj-$(CONFIG_VIDEO_SH_MOBILE_CEU)	+= sh_mobile_ceu_camera.o
+obj-$(CONFIG_VIDEO_OMAP1)		+= omap1_camera.o
+obj-$(CONFIG_VIDEO_ATMEL_ISI)		+= atmel-isi.o
+
+obj-$(CONFIG_VIDEO_MX2_EMMAPRP)		+= mx2_emmaprp.o
+
+obj-$(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) 	+= s5p-fimc/
+obj-$(CONFIG_VIDEO_SAMSUNG_S5P_JPEG)	+= s5p-jpeg/
+obj-$(CONFIG_VIDEO_SAMSUNG_S5P_MFC)	+= s5p-mfc/
+obj-$(CONFIG_VIDEO_SAMSUNG_S5P_TV)	+= s5p-tv/
+
+obj-$(CONFIG_VIDEO_SAMSUNG_S5P_G2D)	+= s5p-g2d/
+
+obj-$(CONFIG_BLACKFIN)                  += blackfin/
+
+obj-$(CONFIG_ARCH_DAVINCI)		+= davinci/
+
+obj-$(CONFIG_VIDEO_SH_VOU)		+= sh_vou.o
+
+obj-$(CONFIG_VIDEO_AU0828) += au0828/
+
+obj-$(CONFIG_USB_VIDEO_CLASS)	+= uvc/
+obj-$(CONFIG_VIDEO_SAA7164)     += saa7164/
+
+obj-$(CONFIG_VIDEO_IR_I2C)  += ir-kbd-i2c.o
+
+obj-y	+= davinci/
+
+obj-$(CONFIG_ARCH_OMAP)	+= omap/
+
+ccflags-y += -I$(srctree)/drivers/media/dvb/dvb-core
+ccflags-y += -I$(srctree)/drivers/media/dvb/frontends
+ccflags-y += -I$(srctree)/drivers/media/common/tuners
diff -Naur linux-org/drivers/media/video/omap34xxcam.c linux-ths/drivers/media/video/omap34xxcam.c
--- linux-org/drivers/media/video/omap34xxcam.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/omap34xxcam.c	2012-07-12 13:27:53.000000000 +0200
@@ -0,0 +1,2284 @@
+/*
+ * omap34xxcam.c
+ *
+ * Copyright (C) 2006--2009 Nokia Corporation
+ * Copyright (C) 2007--2009 Texas Instruments
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *          Tuukka Toivonen <tuukka.o.toivonen@nokia.com>
+ *
+ * Originally based on the OMAP 2 camera driver.
+ *
+ * Written by Sakari Ailus <sakari.ailus@nokia.com>
+ *            Tuukka Toivonen <tuukka.o.toivonen@nokia.com>
+ *            Sergio Aguirre <saaguirre@ti.com>
+ *            Mohit Jalori
+ *            Sameer Venkatraman
+ *            Leonides Martinez
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/videodev2.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+
+#include <media/v4l2-common.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-int-device.h>
+#include <media/tvp514x-int.h>
+
+#include "omap34xxcam.h"
+#include "isp/isp.h"
+
+#define OMAP34XXCAM_VERSION KERNEL_VERSION(0, 0, 0)
+
+/* global variables */
+static struct omap34xxcam_device *omap34xxcam;
+
+/*
+ *
+ * Sensor handling.
+ *
+ */
+
+/**
+ * omap34xxcam_slave_power_set - set slave power state
+ * @vdev: per-video device data structure
+ * @power: new power state
+ */
+static int omap34xxcam_slave_power_set(struct omap34xxcam_videodev *vdev,
+				       enum v4l2_power power,
+				       int mask)
+{
+	int rval = 0, i = 0;
+
+	BUG_ON(!mutex_is_locked(&vdev->mutex));
+
+#ifdef OMAP34XXCAM_POWEROFF_DELAY
+	vdev->power_state_wish = -1;
+#endif
+
+	for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++) {
+		if (vdev->slave[i] == v4l2_int_device_dummy())
+			continue;
+
+		if (!(mask & (1 << i))
+		    || power == vdev->power_state[i])
+			continue;
+
+		rval = vidioc_int_s_power(vdev->slave[i], power);
+
+		if (rval && power != V4L2_POWER_OFF) {
+			power = V4L2_POWER_OFF;
+			goto out;
+		}
+
+		vdev->power_state[i] = power;
+	}
+
+	return 0;
+
+out:
+	for (i--; i >= 0; i--) {
+		if (vdev->slave[i] == v4l2_int_device_dummy())
+			continue;
+
+		if (!(mask & (1 << i)))
+			continue;
+
+		vidioc_int_s_power(vdev->slave[i], power);
+		vdev->power_state[i] = power;
+	}
+
+	return rval;
+}
+
+#ifdef OMAP34XXCAM_POWEROFF_DELAY
+static void omap34xxcam_slave_power_work(struct work_struct *work)
+{
+	struct omap34xxcam_videodev *vdev =
+		container_of(work, struct omap34xxcam_videodev, poweroff_work);
+
+	mutex_lock(&vdev->mutex);
+
+	if (vdev->power_state_wish != -1)
+		omap34xxcam_slave_power_set(vdev, vdev->power_state_wish,
+					    vdev->power_state_mask);
+
+	mutex_unlock(&vdev->mutex);
+}
+
+static void omap34xxcam_slave_power_timer(unsigned long ptr)
+{
+	struct omap34xxcam_videodev *vdev = (void *)ptr;
+
+	schedule_work(&vdev->poweroff_work);
+}
+
+/**
+ * omap34xxcam_slave_power_suggest - delayed power state change
+ *
+ * @vdev: per-video device data structure
+ * @power: new power state
+ */
+static void omap34xxcam_slave_power_suggest(struct omap34xxcam_videodev *vdev,
+					    enum v4l2_power power,
+					    int mask)
+{
+	BUG_ON(!mutex_is_locked(&vdev->mutex));
+
+	del_timer(&vdev->poweroff_timer);
+
+	vdev->power_state_wish = power;
+	vdev->power_state_mask = mask;
+
+	mod_timer(&vdev->poweroff_timer, jiffies + OMAP34XXCAM_POWEROFF_DELAY);
+}
+#else /* OMAP34XXCAM_POWEROFF_DELAY */
+#define omap34xxcam_slave_power_suggest(a, b, c) do {} while (0)
+#endif /* OMAP34XXCAM_POWEROFF_DELAY */
+
+/**
+ * omap34xxcam_update_vbq - Updates VBQ with completed input buffer
+ * @vb: ptr. to standard V4L2 video buffer structure
+ *
+ * Updates video buffer queue with completed buffer passed as
+ * input parameter.  Also updates ISP H3A timestamp and field count
+ * statistics.
+ */
+void omap34xxcam_vbq_complete(struct videobuf_buffer *vb, void *priv)
+{
+	struct omap34xxcam_fh *fh = priv;
+
+	do_gettimeofday(&vb->ts);
+	vb->field_count = atomic_add_return(2, &fh->field_count);
+
+	wake_up(&vb->done);
+}
+
+/**
+ * omap34xxcam_vbq_setup - Calcs size and num of buffs allowed in queue
+ * @vbq: ptr. to standard V4L2 video buffer queue structure
+ * @cnt: ptr to location to hold the count of buffers to be in the queue
+ * @size: ptr to location to hold the size of a frame
+ *
+ * Calculates the number of buffers of current image size that can be
+ * supported by the available capture memory.
+ */
+static int omap34xxcam_vbq_setup(struct videobuf_queue *vbq, unsigned int *cnt,
+				 unsigned int *size)
+{
+	struct omap34xxcam_fh *fh = vbq->priv_data;
+	struct omap34xxcam_videodev *vdev = fh->vdev;
+
+	if (*cnt <= 0)
+		*cnt = VIDEO_MAX_FRAME;	/* supply a default number of buffers */
+
+	if (*cnt > VIDEO_MAX_FRAME)
+		*cnt = VIDEO_MAX_FRAME;
+
+	*size = vdev->pix.sizeimage;
+
+	while (*size * *cnt > fh->vdev->vdev_sensor_config.capture_mem)
+		(*cnt)--;
+
+	return isp_vbq_setup(vdev->cam->isp, vbq, cnt, size);
+}
+
+/**
+ * omap34xxcam_vbq_release - Free resources for input VBQ and VB
+ * @vbq: ptr. to standard V4L2 video buffer queue structure
+ * @vb: ptr to standard V4L2 video buffer structure
+ *
+ * Unmap and free all memory associated with input VBQ and VB, also
+ * unmap the address in ISP MMU.  Reset the VB state.
+ */
+static void omap34xxcam_vbq_release(struct videobuf_queue *vbq,
+				    struct videobuf_buffer *vb)
+{
+	struct omap34xxcam_fh *fh = vbq->priv_data;
+	struct omap34xxcam_videodev *vdev = fh->vdev;
+	struct device *isp = vdev->cam->isp;
+
+	if (!vbq->streaming || vb->memory != V4L2_MEMORY_MMAP) {
+		isp_vbq_release(isp, vbq, vb);
+		videobuf_dma_unmap(vbq, videobuf_to_dma(vb));
+		videobuf_dma_free(videobuf_to_dma(vb));
+		vb->state = VIDEOBUF_NEEDS_INIT;
+	}
+}
+
+
+
+/*
+ * This function is work around for the videobuf_iolock API,
+ * for User memory allocated with ioremap (VM_IO flag) the API
+ * get_user_pages fails.
+ *
+ * To fulfill this requirement, we have completely ignored VM layer of
+ * Linux, and configuring the ISP MMU with physical address.
+ */
+static int omap_videobuf_dma_init_user(struct videobuf_buffer *vb,
+		unsigned long physp, unsigned long asize)
+{
+	struct videobuf_dmabuf *dma;
+	struct scatterlist *sglist;
+	unsigned long data, first, last;
+	int i = 0;
+
+	dma = videobuf_to_dma(vb);
+	data = vb->baddr;
+
+	first = (data & PAGE_MASK) >> PAGE_SHIFT;
+	last  = ((data+asize-1) & PAGE_MASK) >> PAGE_SHIFT;
+	dma->offset   = data & ~PAGE_MASK;
+	dma->nr_pages = last-first+1;
+
+	dma->direction = DMA_FROM_DEVICE;
+
+	BUG_ON(0 == dma->nr_pages);
+	/*
+	 * Allocate array of sglen + 1, to add entry of extra page
+	 * for input buffer. Driver always uses 0th buffer as input buffer.
+	 */
+	sglist = vmalloc(dma->nr_pages * sizeof(*sglist));
+	if (NULL == sglist)
+		return -ENOMEM;
+
+	sg_init_table(sglist, dma->nr_pages);
+
+	sglist[0].offset = 0;
+	sglist[0].length = PAGE_SIZE - dma->offset;
+	sglist[0].dma_address = (dma_addr_t)physp;
+	physp += sglist[0].length;
+	/*
+	 * Iterate in a loop for the number of pages
+	 */
+	for (i = 1; i < dma->nr_pages; i++) {
+		sglist[i].offset = 0;
+		sglist[i].length = PAGE_SIZE;
+		sglist[i].dma_address = (dma_addr_t)physp;
+		physp += PAGE_SIZE;
+	}
+	dma->sglist = sglist;
+	dma->sglen = dma->nr_pages;
+
+	return 0;
+
+}
+
+/**
+ * omap34xxcam_vbq_prepare - V4L2 video ops buf_prepare handler
+ * @vbq: ptr. to standard V4L2 video buffer queue structure
+ * @vb: ptr to standard V4L2 video buffer structure
+ * @field: standard V4L2 field enum
+ *
+ * Verifies there is sufficient locked memory for the requested
+ * buffer, or if there is not, allocates, locks and initializes
+ * it.
+ */
+static int omap34xxcam_vbq_prepare(struct videobuf_queue *vbq,
+				   struct videobuf_buffer *vb,
+				   enum v4l2_field field)
+{
+	struct omap34xxcam_fh *fh = vbq->priv_data;
+	struct omap34xxcam_videodev *vdev = fh->vdev;
+	struct device *isp = vdev->cam->isp;
+
+	int err = 0;
+
+	/*
+	 * Accessing pix here is okay since it's constant while
+	 * streaming is on (and we only get called then).
+	 */
+	if (vb->baddr) {
+		/* This is a userspace buffer. */
+		if (vdev->pix.sizeimage > vb->bsize ||
+				vb->baddr != (vb->baddr & ~0x1F))
+			/* The buffer isn't big enough. */
+			return -EINVAL;
+	} else {
+		if (vb->state != VIDEOBUF_NEEDS_INIT
+		    && vdev->pix.sizeimage > vb->bsize)
+			/*
+			 * We have a kernel bounce buffer that has
+			 * already been allocated.
+			 */
+			omap34xxcam_vbq_release(vbq, vb);
+	}
+
+	vb->size = vdev->pix.bytesperline * vdev->pix.height;
+	vb->width = vdev->pix.width;
+	vb->height = vdev->pix.height;
+	vb->field = field;
+
+	if (vb->state == VIDEOBUF_NEEDS_INIT) {
+		struct videobuf_dmabuf *dma;
+		struct vm_area_struct *vma;
+		dma = videobuf_to_dma(vb);
+		vma = find_vma(current->mm, vb->baddr);
+		if ((vma) && (vma->vm_flags & VM_IO) && (vma->vm_pgoff)) {
+			/* This will catch ioremaped buffers to the kernel.
+			 *  It gives two possible scenarios -
+			 *  - Driver allocates buffer using either
+			 *    dma_alloc_coherent or get_free_pages,
+			 *    and maps to user space using
+			 *    io_remap_pfn_range/remap_pfn_range
+			 *  - Drivers maps memory outside from Linux using
+			 *    io_remap
+			 */
+			unsigned long physp = 0;
+			if ((vb->baddr + vb->bsize) > vma->vm_end) {
+				dev_err(&vdev->vfd->dev,
+						"User Buffer Allocation:" \
+						"err=%lu[%u]\n",\
+						(vma->vm_end - vb->baddr),
+						vb->bsize);
+				return -ENOMEM;
+			}
+			physp = (vma->vm_pgoff << PAGE_SHIFT) +
+				(vb->baddr - vma->vm_start);
+			err = omap_videobuf_dma_init_user(vb, physp, vb->bsize);
+		} else {
+			err = videobuf_iolock(vbq, vb, NULL);
+		}
+
+		if (!err) {
+			/* isp_addr will be stored locally inside isp code */
+			err = isp_vbq_prepare(isp, vbq, vb, field);
+		}
+	}
+
+	if (!err)
+		vb->state = VIDEOBUF_PREPARED;
+	else
+		omap34xxcam_vbq_release(vbq, vb);
+
+	return err;
+}
+
+/**
+ * omap34xxcam_vbq_queue - V4L2 video ops buf_queue handler
+ * @vbq: ptr. to standard V4L2 video buffer queue structure
+ * @vb: ptr to standard V4L2 video buffer structure
+ *
+ * Maps the video buffer to sgdma and through the isp, sets
+ * the isp buffer done callback and sets the video buffer state
+ * to active.
+ */
+static void omap34xxcam_vbq_queue(struct videobuf_queue *vbq,
+				  struct videobuf_buffer *vb)
+{
+	struct omap34xxcam_fh *fh = vbq->priv_data;
+	struct omap34xxcam_videodev *vdev = fh->vdev;
+	struct device *isp = vdev->cam->isp;
+
+	isp_buf_queue(isp, vb, omap34xxcam_vbq_complete, (void *)fh);
+}
+
+static struct videobuf_queue_ops omap34xxcam_vbq_ops = {
+	.buf_setup = omap34xxcam_vbq_setup,
+	.buf_prepare = omap34xxcam_vbq_prepare,
+	.buf_queue = omap34xxcam_vbq_queue,
+	.buf_release = omap34xxcam_vbq_release,
+};
+
+/*
+ *
+ * IOCTL interface.
+ *
+ */
+
+/**
+ * vidioc_querycap - V4L2 query capabilities IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @cap: ptr to standard V4L2 capability structure
+ *
+ * Fill in the V4L2 capabliity structure for the camera device
+ */
+static int vidioc_querycap(struct file *file, void *fh,
+			   struct v4l2_capability *cap)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+
+	strlcpy(cap->driver, CAM_SHORT_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, vdev->vfd->name, sizeof(cap->card));
+	cap->version = OMAP34XXCAM_VERSION;
+	if (vdev->vdev_sensor != v4l2_int_device_dummy())
+		cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+
+	return 0;
+}
+
+/**
+ * vidioc_enum_fmt_vid_cap - V4L2 enumerate format capabilities IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @f: ptr to standard V4L2 format description structure
+ *
+ * Fills in enumerate format capabilities information for sensor (if SOC
+ * sensor attached) or ISP (if raw sensor attached).
+ */
+static int vidioc_enum_fmt_vid_cap(struct file *file, void *fh,
+				   struct v4l2_fmtdesc *f)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval;
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
+	if (vdev->vdev_sensor_mode)
+		rval = isp_enum_fmt_cap(f);
+	else if (vdev->vdev_sensor_config.sensor_isp)
+		rval = vidioc_int_enum_fmt_cap(vdev->vdev_sensor, f);
+	else
+		rval = isp_enum_fmt_cap(f);
+
+	return rval;
+}
+
+/**
+ * vidioc_g_fmt_vid_cap - V4L2 get format capabilities IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @f: ptr to standard V4L2 format structure
+ *
+ * Fills in format capabilities for sensor (if SOC sensor attached) or ISP
+ * (if raw sensor attached).
+ */
+static int vidioc_g_fmt_vid_cap(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
+	mutex_lock(&vdev->mutex);
+	f->fmt.pix = vdev->pix;
+	mutex_unlock(&vdev->mutex);
+
+	return 0;
+}
+
+static int try_pix_parm(struct omap34xxcam_videodev *vdev,
+			struct v4l2_pix_format *best_pix_in,
+			struct v4l2_pix_format *wanted_pix_out,
+			struct v4l2_fract *best_ival)
+{
+	int fps;
+	int fmtd_index;
+	int rval;
+	struct v4l2_pix_format best_pix_out;
+	struct device *isp = vdev->cam->isp;
+
+	if (best_ival->numerator == 0
+	    || best_ival->denominator == 0)
+		*best_ival = vdev->vdev_sensor_config.ival_default;
+
+	fps = best_ival->denominator / best_ival->numerator;
+
+	memset(best_pix_in, 0, sizeof(*best_pix_in));
+
+	best_ival->denominator = 0;
+	best_pix_out.height = INT_MAX >> 1;
+	best_pix_out.width = best_pix_out.height;
+
+	for (fmtd_index = 0; ; fmtd_index++) {
+		int size_index;
+		struct v4l2_fmtdesc fmtd;
+
+		fmtd.index = fmtd_index;
+		fmtd.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		rval = vidioc_int_enum_fmt_cap(vdev->vdev_sensor, &fmtd);
+		if (rval)
+			break;
+		dev_dbg(&vdev->vfd->dev, "trying fmt %8.8x (%d)\n",
+			fmtd.pixelformat, fmtd_index);
+		/*
+		 * Get supported resolutions.
+		 */
+		for (size_index = 0; ; size_index++) {
+			struct v4l2_frmsizeenum frms;
+			struct v4l2_pix_format pix_tmp_in, pix_tmp_out;
+			int ival_index;
+
+			frms.index = size_index;
+			frms.pixel_format = fmtd.pixelformat;
+
+			rval = vidioc_int_enum_framesizes(vdev->vdev_sensor,
+							  &frms);
+			if (rval)
+				break;
+
+			pix_tmp_in.pixelformat = frms.pixel_format;
+			pix_tmp_in.width = frms.discrete.width;
+			pix_tmp_in.height = frms.discrete.height;
+			pix_tmp_out = *wanted_pix_out;
+			/* Don't do upscaling. */
+			if (pix_tmp_out.width > pix_tmp_in.width)
+				pix_tmp_out.width = pix_tmp_in.width;
+			if (pix_tmp_out.height > pix_tmp_in.height)
+				pix_tmp_out.height = pix_tmp_in.height;
+			rval = isp_try_fmt_cap(isp, &pix_tmp_in, &pix_tmp_out);
+			if (rval)
+				return rval;
+
+			dev_dbg(&vdev->vfd->dev, "this w %d\th %d\tfmt %8.8x\t"
+				"-> w %d\th %d\t fmt %8.8x"
+				"\twanted w %d\th %d\t fmt %8.8x\n",
+				pix_tmp_in.width, pix_tmp_in.height,
+				pix_tmp_in.pixelformat,
+				pix_tmp_out.width, pix_tmp_out.height,
+				pix_tmp_out.pixelformat,
+				wanted_pix_out->width, wanted_pix_out->height,
+				wanted_pix_out->pixelformat);
+
+#define IS_SMALLER_OR_EQUAL(pix1, pix2)				\
+			((pix1)->width + (pix1)->height		\
+			 < (pix2)->width + (pix2)->height)
+#define SIZE_DIFF(pix1, pix2)						\
+			(abs((pix1)->width - (pix2)->width)		\
+			 + abs((pix1)->height - (pix2)->height))
+
+			/*
+			 * Don't use modes that are farther from wanted size
+			 * that what we already got.
+			 */
+			if (SIZE_DIFF(&pix_tmp_out, wanted_pix_out)
+			    > SIZE_DIFF(&best_pix_out, wanted_pix_out)) {
+				dev_dbg(&vdev->vfd->dev, "size diff bigger: "
+					"w %d\th %d\tw %d\th %d\n",
+					pix_tmp_out.width, pix_tmp_out.height,
+					best_pix_out.width,
+					best_pix_out.height);
+				continue;
+			}
+
+			/*
+			 * There's an input mode that can provide output
+			 * closer to wanted.
+			 */
+			if (SIZE_DIFF(&pix_tmp_out, wanted_pix_out)
+			    < SIZE_DIFF(&best_pix_out, wanted_pix_out)) {
+				/* Force renegotation of fps etc. */
+				best_ival->denominator = 0;
+				dev_dbg(&vdev->vfd->dev, "renegotiate: "
+					"w %d\th %d\tw %d\th %d\n",
+					pix_tmp_out.width, pix_tmp_out.height,
+					best_pix_out.width,
+					best_pix_out.height);
+			}
+
+			for (ival_index = 0; ; ival_index++) {
+				struct v4l2_frmivalenum frmi;
+
+				frmi.index = ival_index;
+				frmi.pixel_format = frms.pixel_format;
+				frmi.width = frms.discrete.width;
+				frmi.height = frms.discrete.height;
+				/* FIXME: try to fix standard... */
+				frmi.reserved[0] = 0xdeafbeef;
+
+				rval = vidioc_int_enum_frameintervals(
+					vdev->vdev_sensor, &frmi);
+				if (rval)
+					break;
+
+				dev_dbg(&vdev->vfd->dev, "fps %d\n",
+					frmi.discrete.denominator
+					/ frmi.discrete.numerator);
+
+				if (best_ival->denominator == 0)
+					goto do_it_now;
+
+				if (best_pix_in->width == 0)
+					goto do_it_now;
+
+				/*
+				 * We aim to use maximum resolution
+				 * from the sensor, provided that the
+				 * fps is at least as close as on the
+				 * current mode.
+				 */
+#define FPS_ABS_DIFF(fps, ival) abs(fps - (ival).denominator / (ival).numerator)
+
+				/* Select mode with closest fps. */
+				if (FPS_ABS_DIFF(fps, frmi.discrete)
+				    < FPS_ABS_DIFF(fps, *best_ival)) {
+					dev_dbg(&vdev->vfd->dev, "closer fps: "
+						"fps %ld\t fps %ld\n",
+						FPS_ABS_DIFF(fps,
+							      frmi.discrete),
+						FPS_ABS_DIFF(fps, *best_ival));
+					goto do_it_now;
+				}
+
+				/*
+				 * Select bigger resolution if it's available
+				 * at same fps.
+				 */
+				if (frmi.width + frmi.height
+				    > best_pix_in->width + best_pix_in->height
+				    && FPS_ABS_DIFF(fps, frmi.discrete)
+				    <= FPS_ABS_DIFF(fps, *best_ival)) {
+					dev_dbg(&vdev->vfd->dev, "bigger res, "
+						"same fps: "
+						"w %d\th %d\tw %d\th %d\n",
+						frmi.width, frmi.height,
+						best_pix_in->width,
+						best_pix_in->height);
+					goto do_it_now;
+				}
+
+				dev_dbg(&vdev->vfd->dev, "falling through\n");
+
+				continue;
+
+do_it_now:
+				*best_ival = frmi.discrete;
+				best_pix_out = pix_tmp_out;
+				best_pix_in->width = frmi.width;
+				best_pix_in->height = frmi.height;
+				best_pix_in->pixelformat = frmi.pixel_format;
+
+				dev_dbg(&vdev->vfd->dev,
+					"best_pix_in: w %d\th %d\tfmt %8.8x"
+					"\tival %d/%d\n",
+					best_pix_in->width,
+					best_pix_in->height,
+					best_pix_in->pixelformat,
+					best_ival->numerator,
+					best_ival->denominator);
+			}
+		}
+	}
+
+	if (best_ival->denominator == 0)
+		return -EINVAL;
+
+	*wanted_pix_out = best_pix_out;
+
+	dev_dbg(&vdev->vfd->dev, "w %d, h %d, fmt %8.8x -> w %d, h %d\n",
+		best_pix_in->width, best_pix_in->height,
+		best_pix_in->pixelformat,
+		best_pix_out.width, best_pix_out.height);
+
+	return 0;
+}
+
+static int s_pix_parm(struct omap34xxcam_videodev *vdev,
+		      struct v4l2_pix_format *best_pix,
+		      struct v4l2_pix_format *pix,
+		      struct v4l2_fract *best_ival)
+{
+	struct device *isp = vdev->cam->isp;
+	struct v4l2_streamparm a;
+	struct v4l2_format fmt;
+	struct v4l2_format old_fmt;
+	int rval;
+
+	rval = try_pix_parm(vdev, best_pix, pix, best_ival);
+	if (rval)
+		return rval;
+
+	rval = isp_s_fmt_cap(isp, best_pix, pix);
+	if (rval)
+		return rval;
+
+	fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fmt.fmt.pix = *best_pix;
+	vidioc_int_g_fmt_cap(vdev->vdev_sensor, &old_fmt);
+	rval = vidioc_int_s_fmt_cap(vdev->vdev_sensor, &fmt);
+	if (rval)
+		return rval;
+
+	a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	a.parm.capture.timeperframe = *best_ival;
+	rval = vidioc_int_s_parm(vdev->vdev_sensor, &a);
+
+	return rval;
+}
+
+/**
+ * vidioc_s_fmt_vid_cap - V4L2 set format capabilities IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @f: ptr to standard V4L2 format structure
+ *
+ * Attempts to set input format with the sensor driver (first) and then the
+ * ISP.  Returns the return code from vidioc_g_fmt_vid_cap().
+ */
+static int vidioc_s_fmt_vid_cap(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct v4l2_pix_format pix_tmp;
+	struct v4l2_fract timeperframe;
+	int rval;
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->streaming) {
+		rval = -EBUSY;
+		goto out;
+	}
+
+	if (vdev->vdev_sensor_mode) {
+		struct v4l2_format input_fmt = *f;
+		struct v4l2_pix_format *pix = &f->fmt.pix;
+		struct device *isp = vdev->cam->isp;
+
+		rval = isp_try_fmt_cap(isp, pix, pix);
+		if (rval)
+			goto out;
+		/* Always negotiate with the sensor first */
+		rval = vidioc_int_s_fmt_cap(vdev->vdev_sensor, &input_fmt);
+		if (rval)
+			goto out;
+		pix->width = input_fmt.fmt.pix.width;
+		pix->height = input_fmt.fmt.pix.height;
+		pix->pixelformat = input_fmt.fmt.pix.pixelformat;
+		pix->field = input_fmt.fmt.pix.field;
+		pix->bytesperline = input_fmt.fmt.pix.bytesperline;
+		pix->colorspace = input_fmt.fmt.pix.colorspace;
+		pix->sizeimage = input_fmt.fmt.pix.sizeimage;
+		/* Negotiate with OMAP3 ISP */
+		rval = isp_s_fmt_cap(isp, pix, pix);
+		if (!rval)
+			vdev->pix = f->fmt.pix;
+	} else {
+		vdev->want_pix = f->fmt.pix;
+
+		timeperframe = vdev->want_timeperframe;
+
+		rval = s_pix_parm(vdev, &pix_tmp, &f->fmt.pix, &timeperframe);
+		if (!rval)
+			vdev->pix = f->fmt.pix;
+	}
+out:
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_try_fmt_vid_cap - V4L2 try format capabilities IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @f: ptr to standard V4L2 format structure
+ *
+ * Checks if the given format is supported by the sensor driver and
+ * by the ISP.
+ */
+static int vidioc_try_fmt_vid_cap(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct v4l2_pix_format pix_tmp;
+	struct v4l2_fract timeperframe;
+	int rval;
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
+	mutex_lock(&vdev->mutex);
+
+	timeperframe = vdev->want_timeperframe;
+
+	rval = try_pix_parm(vdev, &pix_tmp, &f->fmt.pix, &timeperframe);
+
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_reqbufs - V4L2 request buffers IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @b: ptr to standard V4L2 request buffers structure
+ *
+ * Attempts to get a buffer from the buffer queue associated with the
+ * fh through the video buffer library API.
+ */
+static int vidioc_reqbufs(struct file *file, void *fh,
+			  struct v4l2_requestbuffers *b)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval;
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->streaming) {
+		mutex_unlock(&vdev->mutex);
+		return -EBUSY;
+	}
+
+	rval = videobuf_reqbufs(&ofh->vbq, b);
+
+	mutex_unlock(&vdev->mutex);
+
+	/*
+	 * Either videobuf_reqbufs failed or the buffers are not
+	 * memory-mapped (which would need special attention).
+	 */
+	if (rval < 0 || b->memory != V4L2_MEMORY_MMAP)
+		goto out;
+
+out:
+	return rval;
+}
+
+/**
+ * vidioc_querybuf - V4L2 query buffer IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @b: ptr to standard V4L2 buffer structure
+ *
+ * Attempts to fill in the v4l2_buffer structure for the buffer queue
+ * associated with the fh through the video buffer library API.
+ */
+static int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct omap34xxcam_fh *ofh = fh;
+
+	return videobuf_querybuf(&ofh->vbq, b);
+}
+
+/**
+ * vidioc_qbuf - V4L2 queue buffer IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @b: ptr to standard V4L2 buffer structure
+ *
+ * Attempts to queue the v4l2_buffer on the buffer queue
+ * associated with the fh through the video buffer library API.
+ */
+static int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct omap34xxcam_fh *ofh = fh;
+
+	return videobuf_qbuf(&ofh->vbq, b);
+}
+
+/**
+ * vidioc_dqbuf - V4L2 dequeue buffer IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @b: ptr to standard V4L2 buffer structure
+ *
+ * Attempts to dequeue the v4l2_buffer from the buffer queue
+ * associated with the fh through the video buffer library API.  If the
+ * buffer is a user space buffer, then this function will also requeue it,
+ * as user does not expect to do this.
+ */
+static int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	int rval;
+
+videobuf_dqbuf_again:
+	rval = videobuf_dqbuf(&ofh->vbq, b, file->f_flags & O_NONBLOCK);
+
+	/*
+	 * This is a hack. We don't want to show -EIO to the user
+	 * space. Requeue the buffer and try again if we're not doing
+	 * this in non-blocking mode.
+	 */
+	if (rval == -EIO) {
+		videobuf_qbuf(&ofh->vbq, b);
+		if (!(file->f_flags & O_NONBLOCK))
+			goto videobuf_dqbuf_again;
+		/*
+		 * We don't have a videobuf_buffer now --- maybe next
+		 * time...
+		 */
+		rval = -EAGAIN;
+	}
+
+	return rval;
+}
+
+/**
+ * vidioc_streamon - V4L2 streamon IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @i: V4L2 buffer type
+ *
+ * Attempts to start streaming by enabling the sensor interface and turning
+ * on video buffer streaming through the video buffer library API.  Upon
+ * success the function returns 0, otherwise an error code is returned.
+ */
+static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct device *isp = vdev->cam->isp;
+	int rval;
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->streaming) {
+		rval = -EBUSY;
+		goto out;
+	}
+
+	rval = omap34xxcam_slave_power_set(vdev, V4L2_POWER_ON,
+					   OMAP34XXCAM_SLAVE_POWER_SENSOR_LENS);
+	if (rval) {
+		dev_dbg(&vdev->vfd->dev,
+			"omap34xxcam_slave_power_set failed\n");
+		goto out;
+	}
+
+	isp_start(isp);
+
+	rval = videobuf_streamon(&ofh->vbq);
+	if (rval) {
+		isp_stop(isp);
+		omap34xxcam_slave_power_set(
+			vdev, V4L2_POWER_OFF,
+			OMAP34XXCAM_SLAVE_POWER_SENSOR_LENS);
+	} else
+		vdev->streaming = file;
+
+out:
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_streamoff - V4L2 streamoff IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @i: V4L2 buffer type
+ *
+ * Attempts to stop streaming by flushing all scheduled work, waiting on
+ * any queued buffers to complete and then stopping the ISP and turning
+ * off video buffer streaming through the video buffer library API.  Upon
+ * success the function returns 0, otherwise an error code is returned.
+ */
+static int vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct device *isp = vdev->cam->isp;
+	struct videobuf_queue *q = &ofh->vbq;
+	int rval;
+
+	mutex_lock(&vdev->mutex);
+
+	if (vdev->streaming == file)
+		isp_stop(isp);
+
+	rval = videobuf_streamoff(q);
+	if (!rval) {
+		vdev->streaming = NULL;
+
+		omap34xxcam_slave_power_set(vdev, V4L2_POWER_STANDBY,
+					    OMAP34XXCAM_SLAVE_POWER_SENSOR);
+		omap34xxcam_slave_power_suggest(vdev, V4L2_POWER_STANDBY,
+						OMAP34XXCAM_SLAVE_POWER_LENS);
+	}
+
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_enum_input - V4L2 enumerate input IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @inp: V4L2 input type information structure
+ *
+ * Fills in v4l2_input structure.  Returns 0.
+ */
+static int vidioc_enum_input(struct file *file, void *fh,
+			     struct v4l2_input *inp)
+{
+	struct omap34xxcam_videodev *vdev = ((struct omap34xxcam_fh *)fh)->vdev;
+
+	if (vdev->vdev_sensor_mode) {
+		if (inp->index == 0) {
+			strlcpy(inp->name, "COMPOSITE", sizeof(inp->name));
+			inp->type = V4L2_INPUT_TYPE_CAMERA;
+		} else if (inp->index == 1) {
+			strlcpy(inp->name, "S-VIDEO", sizeof(inp->name));
+			inp->type = V4L2_INPUT_TYPE_CAMERA;
+		} else
+			return -EINVAL;
+	} else {
+		if (inp->index > 0)
+			return -EINVAL;
+		strlcpy(inp->name, "camera", sizeof(inp->name));
+		inp->type = V4L2_INPUT_TYPE_CAMERA;
+	}
+
+	return 0;
+}
+
+/**
+ * vidioc_g_input - V4L2 get input IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @i: address to hold index of input supported
+ *
+ * Sets index to 0.
+ */
+static int vidioc_g_input(struct file *file, void *fh, unsigned int *i)
+{
+	struct omap34xxcam_videodev *vdev = ((struct omap34xxcam_fh *)fh)->vdev;
+	int rval = 0;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->vdev_sensor_mode) {
+		if (vdev->slave_config[OMAP34XXCAM_SLAVE_SENSOR].cur_input
+				== INPUT_CVBS_VI4A)
+			*i = 0;
+		else if (vdev->slave_config[OMAP34XXCAM_SLAVE_SENSOR].cur_input
+				== INPUT_SVIDEO_VI2C_VI1C)
+			*i = 1;
+	} else {
+		*i = 0;
+	}
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_s_input - V4L2 set input IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @i: index of input selected
+ *
+ * 0 is only index supported.
+ */
+static int vidioc_s_input(struct file *file, void *fh, unsigned int i)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval = 0;
+	struct v4l2_routing route;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->vdev_sensor_mode) {
+		if (i == 0)
+			route.input = INPUT_CVBS_VI4A;
+		else
+			route.input = INPUT_SVIDEO_VI2C_VI1C;
+
+		route.output = 0;
+		rval = vidioc_int_s_video_routing(vdev->vdev_sensor, &route);
+		if (!rval)
+			vdev->slave_config[OMAP34XXCAM_SLAVE_SENSOR].cur_input
+				= route.input;
+	} else {
+		if (i > 0)
+			rval = -EINVAL;
+	}
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_queryctrl - V4L2 query control IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @a: standard V4L2 query control ioctl structure
+ *
+ * If the requested control is supported, returns the control information
+ * in the v4l2_queryctrl structure.  Otherwise, returns -EINVAL if the
+ * control is not supported.  If the sensor being used is a "smart sensor",
+ * this request is passed to the sensor driver, otherwise the ISP is
+ * queried and if it does not support the requested control, the request
+ * is forwarded to the "raw" sensor driver to see if it supports it.
+ */
+static int vidioc_queryctrl(struct file *file, void *fh,
+			    struct v4l2_queryctrl *a)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct v4l2_queryctrl a_tmp;
+	int best_slave = -1;
+	u32 best_ctrl = (u32)-1;
+	int i;
+
+	if (vdev->vdev_sensor_config.sensor_isp)
+		return vidioc_int_queryctrl(vdev->vdev_sensor, a);
+
+	/* No next flags: try slaves directly. */
+	if (!(a->id & V4L2_CTRL_FLAG_NEXT_CTRL)) {
+		for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++) {
+			if (!vidioc_int_queryctrl(vdev->slave[i], a))
+				return 0;
+		}
+		return isp_queryctrl(a);
+	}
+
+	/* Find slave with smallest next control id. */
+	for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++) {
+		a_tmp = *a;
+
+		if (vidioc_int_queryctrl(vdev->slave[i], &a_tmp))
+			continue;
+
+		if (a_tmp.id < best_ctrl) {
+			best_slave = i;
+			best_ctrl = a_tmp.id;
+		}
+	}
+
+	a_tmp = *a;
+	if (!isp_queryctrl(&a_tmp)) {
+		if (a_tmp.id < best_ctrl) {
+			*a = a_tmp;
+
+			return 0;
+		}
+	}
+
+	if (best_slave == -1)
+		return -EINVAL;
+
+	a->id = best_ctrl;
+	return vidioc_int_queryctrl(vdev->slave[best_slave], a);
+}
+
+/**
+ * vidioc_querymenu - V4L2 query menu IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @a: standard V4L2 query menu ioctl structure
+ *
+ * If the requested control is supported, returns the menu information
+ * in the v4l2_querymenu structure.  Otherwise, returns -EINVAL if the
+ * control is not supported or is not a menu.  If the sensor being used
+ * is a "smart sensor", this request is passed to the sensor driver,
+ * otherwise the ISP is queried and if it does not support the requested
+ * menu control, the request is forwarded to the "raw" sensor driver to
+ * see if it supports it.
+ */
+static int vidioc_querymenu(struct file *file, void *fh,
+			    struct v4l2_querymenu *a)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int i;
+
+	if (vdev->vdev_sensor_config.sensor_isp)
+		return vidioc_int_querymenu(vdev->vdev_sensor, a);
+
+	/* Try slaves directly. */
+	for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++) {
+		if (!vidioc_int_querymenu(vdev->slave[i], a))
+			return 0;
+	}
+	return isp_querymenu(a);
+}
+
+static int vidioc_g_ext_ctrls(struct file *file, void *fh,
+			      struct v4l2_ext_controls *a)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct device *isp = vdev->cam->isp;
+	int i, ctrl_idx, rval = 0;
+
+	mutex_lock(&vdev->mutex);
+
+	for (ctrl_idx = 0; ctrl_idx < a->count; ctrl_idx++) {
+		struct v4l2_control ctrl;
+
+		ctrl.id = a->controls[ctrl_idx].id;
+
+		if (vdev->vdev_sensor_config.sensor_isp) {
+			rval = vidioc_int_g_ctrl(vdev->vdev_sensor, &ctrl);
+		} else {
+			for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++) {
+				rval = vidioc_int_g_ctrl(vdev->slave[i], &ctrl);
+				if (!rval)
+					break;
+			}
+		}
+
+		if (rval)
+			rval = isp_g_ctrl(isp, &ctrl);
+
+		if (rval) {
+			a->error_idx = ctrl_idx;
+			break;
+		}
+
+		a->controls[ctrl_idx].value = ctrl.value;
+	}
+
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+static int vidioc_s_ext_ctrls(struct file *file, void *fh,
+			      struct v4l2_ext_controls *a)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct device *isp = vdev->cam->isp;
+	int i, ctrl_idx, rval = 0;
+
+	mutex_lock(&vdev->mutex);
+
+	for (ctrl_idx = 0; ctrl_idx < a->count; ctrl_idx++) {
+		struct v4l2_control ctrl;
+
+		ctrl.id = a->controls[ctrl_idx].id;
+		ctrl.value = a->controls[ctrl_idx].value;
+
+		if (vdev->vdev_sensor_config.sensor_isp) {
+			rval = vidioc_int_s_ctrl(vdev->vdev_sensor, &ctrl);
+		} else {
+			for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++) {
+				rval = vidioc_int_s_ctrl(vdev->slave[i], &ctrl);
+				if (!rval)
+					break;
+			}
+		}
+
+		if (rval)
+			rval = isp_s_ctrl(isp, &ctrl);
+
+		if (rval) {
+			a->error_idx = ctrl_idx;
+			break;
+		}
+
+		a->controls[ctrl_idx].value = ctrl.value;
+	}
+
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_g_parm - V4L2 get parameters IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @a: standard V4L2 stream parameters structure
+ *
+ * If request is for video capture buffer type, handles request by
+ * forwarding to sensor driver.
+ */
+static int vidioc_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	mutex_lock(&vdev->mutex);
+	rval = vidioc_int_g_parm(vdev->vdev_sensor, a);
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_s_parm - V4L2 set parameters IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @a: standard V4L2 stream parameters structure
+ *
+ * If request is for video capture buffer type, handles request by
+ * first getting current stream parameters from sensor, then forwarding
+ * request to set new parameters to sensor driver.  It then attempts to
+ * enable the sensor interface with the new parameters.  If this fails, it
+ * reverts back to the previous parameters.
+ */
+static int vidioc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct v4l2_pix_format pix_tmp_sensor, pix_tmp;
+	int rval;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->streaming) {
+		rval = -EBUSY;
+		goto out;
+	}
+
+	vdev->want_timeperframe = a->parm.capture.timeperframe;
+
+	pix_tmp = vdev->want_pix;
+
+	rval = s_pix_parm(vdev, &pix_tmp_sensor, &pix_tmp,
+			  &a->parm.capture.timeperframe);
+
+out:
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_cropcap - V4L2 crop capture IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @a: standard V4L2 crop capture structure
+ *
+ * If using a "smart" sensor, just forwards request to the sensor driver,
+ * otherwise fills in the v4l2_cropcap values locally.
+ */
+static int vidioc_cropcap(struct file *file, void *fh, struct v4l2_cropcap *a)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct v4l2_cropcap *cropcap = a;
+	int rval;
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
+	mutex_lock(&vdev->mutex);
+
+	rval = vidioc_int_cropcap(vdev->vdev_sensor, a);
+
+	if (rval && !vdev->vdev_sensor_config.sensor_isp) {
+		struct v4l2_format f;
+
+		/* cropcap failed, try to do this via g_fmt_cap */
+		rval = vidioc_int_g_fmt_cap(vdev->vdev_sensor, &f);
+		if (!rval) {
+			cropcap->bounds.top = 0;
+			cropcap->bounds.left = 0;
+			cropcap->bounds.width = f.fmt.pix.width;
+			cropcap->bounds.height = f.fmt.pix.height;
+			cropcap->defrect = cropcap->bounds;
+			cropcap->pixelaspect.numerator = 1;
+			cropcap->pixelaspect.denominator = 1;
+		}
+	}
+
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_g_crop - V4L2 get capture crop IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @a: standard V4L2 crop structure
+ *
+ * If using a "smart" sensor, just forwards request to the sensor driver,
+ * otherwise calls the isp functions to fill in current crop values.
+ */
+static int vidioc_g_crop(struct file *file, void *fh, struct v4l2_crop *a)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct device *isp = vdev->cam->isp;
+	int rval = 0;
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
+	mutex_lock(&vdev->mutex);
+
+	if (vdev->vdev_sensor_config.sensor_isp)
+		rval = vidioc_int_g_crop(vdev->vdev_sensor, a);
+	else
+		rval = isp_g_crop(isp, a);
+
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_s_crop - V4L2 set capture crop IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @a: standard V4L2 crop structure
+ *
+ * If using a "smart" sensor, just forwards request to the sensor driver,
+ * otherwise calls the isp functions to set the current crop values.
+ */
+static int vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *a)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct device *isp = vdev->cam->isp;
+	int rval = 0;
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy())
+		return -EINVAL;
+
+	mutex_lock(&vdev->mutex);
+
+	if (vdev->vdev_sensor_config.sensor_isp)
+		rval = vidioc_int_s_crop(vdev->vdev_sensor, a);
+	else
+		rval = isp_s_crop(isp, a);
+
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+static int vidioc_enum_framesizes(struct file *file, void *fh,
+				  struct v4l2_frmsizeenum *frms)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	u32 pixel_format;
+	int rval;
+
+	mutex_lock(&vdev->mutex);
+
+	if (vdev->vdev_sensor_config.sensor_isp) {
+		rval = vidioc_int_enum_framesizes(vdev->vdev_sensor, frms);
+	} else {
+		pixel_format = frms->pixel_format;
+		frms->pixel_format = -1;	/* ISP does format conversion */
+		rval = vidioc_int_enum_framesizes(vdev->vdev_sensor, frms);
+		frms->pixel_format = pixel_format;
+	}
+
+	mutex_unlock(&vdev->mutex);
+	return rval;
+}
+
+static int vidioc_enum_frameintervals(struct file *file, void *fh,
+				      struct v4l2_frmivalenum *frmi)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	u32 pixel_format;
+	int rval;
+
+	mutex_lock(&vdev->mutex);
+
+	if (vdev->vdev_sensor_config.sensor_isp) {
+		rval = vidioc_int_enum_frameintervals(vdev->vdev_sensor, frmi);
+	} else {
+		pixel_format = frmi->pixel_format;
+		frmi->pixel_format = -1;	/* ISP does format conversion */
+		rval = vidioc_int_enum_frameintervals(vdev->vdev_sensor, frmi);
+		frmi->pixel_format = pixel_format;
+	}
+
+	mutex_unlock(&vdev->mutex);
+	return rval;
+}
+
+/**
+ * vidioc_querystd - V4L2 query current standard IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @std: standard V4L2 v4l2_std_id enum
+ *
+ * If using a "smart" sensor, just forwards request to the sensor driver,
+ * otherwise returns error
+ */
+static int vidioc_querystd(struct file *file, void *fh, v4l2_std_id *std)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval = 0;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->vdev_sensor_mode) {
+		rval = vidioc_int_querystd(vdev->vdev_sensor, std);
+		if (rval == 0)
+			vdev->vfd->current_norm = *std;
+	} else
+		rval = -EINVAL;
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_s_std - V4L2 set standard IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @std: standard V4L2 v4l2_std_id enum
+ *
+ * If using a "smart" sensor, just forwards request to the sensor driver,
+ * otherwise returns error
+ */
+static int vidioc_s_std(struct file *file, void *fh, v4l2_std_id *std)
+{
+	struct omap34xxcam_fh *ofh = fh;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	int rval = 0;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->vdev_sensor_mode) {
+		rval = vidioc_int_s_std(vdev->vdev_sensor, std);
+		if (rval == 0)
+			vdev->vfd->current_norm = *std;
+	} else
+		rval = -EINVAL;
+	mutex_unlock(&vdev->mutex);
+
+	return rval;
+}
+
+/**
+ * vidioc_default - private IOCTL handler
+ * @file: ptr. to system file structure
+ * @fh: ptr to hold address of omap34xxcam_fh struct (per-filehandle data)
+ * @cmd: ioctl cmd value
+ * @arg: ioctl arg value
+ *
+ * If the sensor being used is a "smart sensor", this request is returned to
+ * caller with -EINVAL err code.  Otherwise if the control id is the private
+ * VIDIOC_PRIVATE_ISP_AEWB_REQ to update the analog gain or exposure,
+ * then this request is forwared directly to the sensor to incorporate the
+ * feedback. The request is then passed on to the ISP private IOCTL handler,
+ * isp_handle_private()
+ */
+static long vidioc_default(struct file *file, void *fh, int cmd, void *arg)
+{
+	struct omap34xxcam_fh *ofh = file->private_data;
+	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct device *isp = vdev->cam->isp;
+	int rval;
+
+	if (cmd == VIDIOC_PRIVATE_OMAP34XXCAM_SENSOR_INFO) {
+		u32 pixclk;
+		struct v4l2_pix_format active_size, full_size;
+		struct omap34xxcam_sensor_info *ret_sensor_info;
+
+		ret_sensor_info = (struct omap34xxcam_sensor_info *)arg;
+		mutex_lock(&vdev->mutex);
+		rval = vidioc_int_priv_g_pixclk(vdev->vdev_sensor, &pixclk);
+		mutex_unlock(&vdev->mutex);
+		if (rval)
+			goto out;
+		mutex_lock(&vdev->mutex);
+		rval = vidioc_int_priv_g_activesize(vdev->vdev_sensor,
+					    &active_size);
+		mutex_unlock(&vdev->mutex);
+		if (rval)
+			goto out;
+		mutex_lock(&vdev->mutex);
+		rval = vidioc_int_priv_g_fullsize(vdev->vdev_sensor,
+						  &full_size);
+		mutex_unlock(&vdev->mutex);
+		if (rval)
+			goto out;
+		ret_sensor_info->current_xclk = pixclk;
+		memcpy(&ret_sensor_info->active_size, &active_size,
+			sizeof(struct v4l2_pix_format));
+		memcpy(&ret_sensor_info->full_size, &full_size,
+			sizeof(struct v4l2_pix_format));
+		rval = 0;
+		goto out;
+	}
+
+	if (vdev->vdev_sensor_config.sensor_isp) {
+		rval = -EINVAL;
+	} else {
+		switch (cmd) {
+		case VIDIOC_PRIVATE_ISP_AEWB_REQ:
+		{
+			/* Need to update sensor first */
+			struct isph3a_aewb_data *data;
+			struct v4l2_control vc;
+
+			data = (struct isph3a_aewb_data *) arg;
+			if (data->update & SET_EXPOSURE) {
+				dev_dbg(&vdev->vfd->dev, "using "
+					"VIDIOC_PRIVATE_ISP_AEWB_REQ to set "
+					"exposure is deprecated!\n");
+				vc.id = V4L2_CID_EXPOSURE;
+				vc.value = data->shutter;
+				mutex_lock(&vdev->mutex);
+				rval = vidioc_int_s_ctrl(vdev->vdev_sensor,
+							 &vc);
+				mutex_unlock(&vdev->mutex);
+				if (rval)
+					goto out;
+			}
+			if (data->update & SET_ANALOG_GAIN) {
+				dev_dbg(&vdev->vfd->dev, "using "
+					"VIDIOC_PRIVATE_ISP_AEWB_REQ to set "
+					"gain is deprecated!\n");
+				vc.id = V4L2_CID_GAIN;
+				vc.value = data->gain;
+				mutex_lock(&vdev->mutex);
+				rval = vidioc_int_s_ctrl(vdev->vdev_sensor,
+							 &vc);
+				mutex_unlock(&vdev->mutex);
+				if (rval)
+					goto out;
+			}
+		}
+		break;
+		case VIDIOC_PRIVATE_ISP_AF_REQ: {
+			/* Need to update lens first */
+			struct isp_af_data *data;
+			struct v4l2_control vc;
+
+			if (!vdev->vdev_lens) {
+				rval = -EINVAL;
+				goto out;
+			}
+			data = (struct isp_af_data *) arg;
+			if (data->update & LENS_DESIRED_POSITION) {
+				dev_dbg(&vdev->vfd->dev, "using "
+					"VIDIOC_PRIVATE_ISP_AF_REQ to set "
+					"lens position is deprecated!\n");
+				vc.id = V4L2_CID_FOCUS_ABSOLUTE;
+				vc.value = data->desired_lens_direction;
+				mutex_lock(&vdev->mutex);
+				rval = vidioc_int_s_ctrl(vdev->vdev_lens, &vc);
+				mutex_unlock(&vdev->mutex);
+				if (rval)
+					goto out;
+			}
+		}
+			break;
+		}
+
+		mutex_lock(&vdev->mutex);
+		rval = isp_handle_private(isp, cmd, arg);
+		mutex_unlock(&vdev->mutex);
+	}
+out:
+	return rval;
+}
+
+/*
+ *
+ * File operations.
+ *
+ */
+
+/**
+ * omap34xxcam_poll - file operations poll handler
+ * @file: ptr. to system file structure
+ * @wait: system poll table structure
+ *
+ */
+static unsigned int omap34xxcam_poll(struct file *file,
+				     struct poll_table_struct *wait)
+{
+	struct omap34xxcam_fh *fh = file->private_data;
+	struct omap34xxcam_videodev *vdev = fh->vdev;
+	struct videobuf_buffer *vb;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->streaming != file) {
+		mutex_unlock(&vdev->mutex);
+		return POLLERR;
+	}
+	mutex_unlock(&vdev->mutex);
+
+	mutex_lock(&fh->vbq.vb_lock);
+	if (list_empty(&fh->vbq.stream)) {
+		mutex_unlock(&fh->vbq.vb_lock);
+		return POLLERR;
+	}
+	vb = list_entry(fh->vbq.stream.next, struct videobuf_buffer, stream);
+	mutex_unlock(&fh->vbq.vb_lock);
+
+	poll_wait(file, &vb->done, wait);
+
+	if (vb->state == VIDEOBUF_DONE || vb->state == VIDEOBUF_ERROR)
+		return POLLIN | POLLRDNORM;
+
+	return 0;
+}
+
+/**
+ * omap34xxcam_mmap - file operations mmap handler
+ * @file: ptr. to system file structure
+ * @vma: system virt. mem. area structure
+ *
+ * Maps a virtual memory area via the video buffer API
+ */
+static int omap34xxcam_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct omap34xxcam_fh *fh = file->private_data;
+	return videobuf_mmap_mapper(&fh->vbq, vma);
+}
+
+/**
+ * omap34xxcam_open - file operations open handler
+ * @inode: ptr. to system inode structure
+ * @file: ptr. to system file structure
+ *
+ * Allocates and initializes the per-filehandle data (omap34xxcam_fh),
+ * enables the sensor, opens/initializes the ISP interface and the
+ * video buffer queue.  Note that this function will allow multiple
+ * file handles to be open simultaneously, however only the first
+ * handle opened will initialize the ISP.  It is the application
+ * responsibility to only use one handle for streaming and the others
+ * for control only.
+ * This function returns 0 upon success and -ENODEV upon error.
+ */
+static int omap34xxcam_open(struct file *file)
+{
+	int rval = 0;
+	struct omap34xxcam_videodev *vdev = NULL;
+	struct omap34xxcam_device *cam = omap34xxcam;
+	struct device *isp;
+	struct omap34xxcam_fh *fh;
+	struct v4l2_format sensor_format;
+	int first_user = 0;
+	int i;
+
+	for (i = 0; i < OMAP34XXCAM_VIDEODEVS; i++) {
+		if (cam->vdevs[i].vfd
+		    && cam->vdevs[i].vfd->minor ==
+		    iminor(file->f_dentry->d_inode)) {
+			vdev = &cam->vdevs[i];
+			break;
+		}
+	}
+
+	if (!vdev || !vdev->vfd)
+		return -ENODEV;
+
+	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+	if (fh == NULL)
+		return -ENOMEM;
+
+	fh->vdev = vdev;
+
+	mutex_lock(&vdev->mutex);
+	for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++) {
+		if (vdev->slave[i] != v4l2_int_device_dummy()
+		    && !try_module_get(vdev->slave[i]->module)) {
+			mutex_unlock(&vdev->mutex);
+			dev_err(&vdev->vfd->dev, "can't try_module_get %s\n",
+				vdev->slave[i]->name);
+			rval = -ENODEV;
+			goto out_try_module_get;
+		}
+	}
+
+	if (atomic_inc_return(&vdev->users) == 1) {
+		first_user = 1;
+		isp = isp_get();
+		if (!isp) {
+			rval = -EBUSY;
+			dev_err(&vdev->vfd->dev, "can't get isp\n");
+			goto out_isp_get;
+		}
+		cam->isp = isp;
+		if (omap34xxcam_slave_power_set(vdev, V4L2_POWER_ON,
+						OMAP34XXCAM_SLAVE_POWER_ALL)) {
+			dev_err(&vdev->vfd->dev, "can't power up slaves\n");
+			rval = -EBUSY;
+			goto out_slave_power_set_standby;
+		}
+		omap34xxcam_slave_power_set(
+			vdev, V4L2_POWER_STANDBY,
+			OMAP34XXCAM_SLAVE_POWER_SENSOR);
+		omap34xxcam_slave_power_suggest(
+			vdev, V4L2_POWER_STANDBY,
+			OMAP34XXCAM_SLAVE_POWER_LENS);
+	}
+
+	if (vdev->vdev_sensor == v4l2_int_device_dummy() || !first_user)
+		goto out_no_pix;
+
+	if (vdev->vdev_sensor_config.sensor_isp) {
+		if ((vdev->slave_config[OMAP34XXCAM_SLAVE_SENSOR].cur_input
+					!= INPUT_CVBS_VI4A) &&
+				(vdev->slave_config[OMAP34XXCAM_SLAVE_SENSOR].
+				 cur_input != INPUT_SVIDEO_VI2C_VI1C)) {
+			struct v4l2_routing route;
+			int rval;
+			route.input = INPUT_CVBS_VI4A;
+			route.output = 0;
+			rval = vidioc_int_s_video_routing(vdev->vdev_sensor,
+					&route);
+			if (rval) {
+				route.input = INPUT_SVIDEO_VI2C_VI1C;
+				rval = vidioc_int_s_video_routing(
+						vdev->vdev_sensor, &route);
+			}
+			if (!rval)
+				vdev->slave_config[OMAP34XXCAM_SLAVE_SENSOR]
+					.cur_input = route.input;
+		}
+		sensor_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	}
+
+	/* Get the format the sensor is using. */
+	rval = vidioc_int_g_fmt_cap(vdev->vdev_sensor, &sensor_format);
+	if (rval) {
+		dev_err(&vdev->vfd->dev,
+			"can't get current pix from sensor!\n");
+		goto out_vidioc_int_g_fmt_cap;
+	}
+
+	if (!vdev->pix.width)
+		vdev->pix = sensor_format.fmt.pix;
+
+	if (!vdev->vdev_sensor_config.sensor_isp) {
+		struct v4l2_pix_format pix;
+		struct v4l2_fract timeperframe =
+			vdev->want_timeperframe;
+
+		rval = s_pix_parm(vdev, &pix, &vdev->pix, &timeperframe);
+		if (rval) {
+			dev_err(&vdev->vfd->dev,
+				"isp doesn't like the sensor!\n");
+			goto out_isp_s_fmt_cap;
+		}
+	}
+
+out_no_pix:
+	mutex_unlock(&vdev->mutex);
+
+	file->private_data = fh;
+
+	spin_lock_init(&fh->vbq_lock);
+
+	videobuf_queue_sg_init(&fh->vbq, &omap34xxcam_vbq_ops, NULL,
+				&fh->vbq_lock, V4L2_BUF_TYPE_VIDEO_CAPTURE,
+				V4L2_FIELD_NONE,
+				sizeof(struct videobuf_buffer), fh);
+
+	return 0;
+
+out_isp_s_fmt_cap:
+out_vidioc_int_g_fmt_cap:
+	omap34xxcam_slave_power_set(vdev, V4L2_POWER_OFF,
+				    OMAP34XXCAM_SLAVE_POWER_ALL);
+out_slave_power_set_standby:
+	isp_put();
+
+out_isp_get:
+	atomic_dec(&vdev->users);
+	mutex_unlock(&vdev->mutex);
+
+out_try_module_get:
+	for (i--; i >= 0; i--)
+		if (vdev->slave[i] != v4l2_int_device_dummy())
+			module_put(vdev->slave[i]->module);
+
+	kfree(fh);
+
+	return rval;
+}
+
+/**
+ * omap34xxcam_release - file operations release handler
+ * @inode: ptr. to system inode structure
+ * @file: ptr. to system file structure
+ *
+ * Complement of omap34xxcam_open.  This function will flush any scheduled
+ * work, disable the sensor, close the ISP interface, stop the
+ * video buffer queue from streaming and free the per-filehandle data
+ * (omap34xxcam_fh).  Note that because multiple open file handles
+ * are allowed, this function will only close the ISP and disable the
+ * sensor when the last open file handle (by count) is closed.
+ * This function returns 0.
+ */
+static int omap34xxcam_release(struct file *file)
+{
+	struct omap34xxcam_fh *fh = file->private_data;
+	struct omap34xxcam_videodev *vdev = fh->vdev;
+	struct device *isp = vdev->cam->isp;
+	int i;
+
+	mutex_lock(&vdev->mutex);
+	if (vdev->streaming == file) {
+		isp_stop(isp);
+		videobuf_streamoff(&fh->vbq);
+		omap34xxcam_slave_power_set(
+			vdev, V4L2_POWER_STANDBY,
+			OMAP34XXCAM_SLAVE_POWER_SENSOR);
+		omap34xxcam_slave_power_suggest(
+			vdev, V4L2_POWER_STANDBY,
+			OMAP34XXCAM_SLAVE_POWER_LENS);
+		vdev->streaming = NULL;
+	}
+
+	if (atomic_dec_return(&vdev->users) == 0) {
+		omap34xxcam_slave_power_set(vdev, V4L2_POWER_OFF,
+					    OMAP34XXCAM_SLAVE_POWER_ALL);
+		isp_put();
+	}
+	mutex_unlock(&vdev->mutex);
+
+	file->private_data = NULL;
+
+	for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++)
+		if (vdev->slave[i] != v4l2_int_device_dummy())
+			module_put(vdev->slave[i]->module);
+
+	kfree(fh);
+
+	return 0;
+}
+
+static struct v4l2_file_operations omap34xxcam_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = video_ioctl2,
+	.poll = omap34xxcam_poll,
+	.mmap = omap34xxcam_mmap,
+	.open = omap34xxcam_open,
+	.release = omap34xxcam_release,
+};
+
+static void omap34xxcam_vfd_name_update(struct omap34xxcam_videodev *vdev)
+{
+	struct video_device *vfd = vdev->vfd;
+	int i;
+
+	strlcpy(vfd->name, CAM_SHORT_NAME, sizeof(vfd->name));
+	for (i = 0; i <= OMAP34XXCAM_SLAVE_FLASH; i++) {
+		strlcat(vfd->name, "/", sizeof(vfd->name));
+		if (vdev->slave[i] == v4l2_int_device_dummy())
+			continue;
+		strlcat(vfd->name, vdev->slave[i]->name, sizeof(vfd->name));
+	}
+	dev_dbg(&vdev->vfd->dev, "video%d is now %s\n", vfd->num, vfd->name);
+}
+
+/**
+ * omap34xxcam_device_unregister - V4L2 detach handler
+ * @s: ptr. to standard V4L2 device information structure
+ *
+ * Detach sensor and unregister and release the video device.
+ */
+static void omap34xxcam_device_unregister(struct v4l2_int_device *s)
+{
+	struct omap34xxcam_videodev *vdev = s->u.slave->master->priv;
+	struct omap34xxcam_hw_config hwc;
+
+	BUG_ON(vidioc_int_g_priv(s, &hwc) < 0);
+
+	mutex_lock(&vdev->mutex);
+
+	if (vdev->slave[hwc.dev_type] != v4l2_int_device_dummy()) {
+		vdev->slave[hwc.dev_type] = v4l2_int_device_dummy();
+		vdev->slaves--;
+		omap34xxcam_vfd_name_update(vdev);
+	}
+
+	if (vdev->slaves == 0 && vdev->vfd) {
+		if (vdev->vfd->minor == -1) {
+			/*
+			 * The device was never registered, so release the
+			 * video_device struct directly.
+			 */
+			video_device_release(vdev->vfd);
+		} else {
+			/*
+			 * The unregister function will release the
+			 * video_device struct as well as
+			 * unregistering it.
+			 */
+			video_unregister_device(vdev->vfd);
+		}
+		vdev->vfd = NULL;
+	}
+
+	mutex_unlock(&vdev->mutex);
+}
+
+static const struct v4l2_ioctl_ops omap34xxcam_ioctl_ops = {
+	.vidioc_querycap		= vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap	= vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap		= vidioc_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap		= vidioc_s_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap		= vidioc_try_fmt_vid_cap,
+	.vidioc_reqbufs			= vidioc_reqbufs,
+	.vidioc_querybuf		= vidioc_querybuf,
+	.vidioc_qbuf			= vidioc_qbuf,
+	.vidioc_dqbuf			= vidioc_dqbuf,
+	.vidioc_streamon		= vidioc_streamon,
+	.vidioc_streamoff		= vidioc_streamoff,
+	.vidioc_enum_input		= vidioc_enum_input,
+	.vidioc_g_input			= vidioc_g_input,
+	.vidioc_s_input			= vidioc_s_input,
+	.vidioc_queryctrl		= vidioc_queryctrl,
+	.vidioc_querymenu		= vidioc_querymenu,
+	.vidioc_g_ext_ctrls		= vidioc_g_ext_ctrls,
+	.vidioc_s_ext_ctrls		= vidioc_s_ext_ctrls,
+	.vidioc_g_parm			= vidioc_g_parm,
+	.vidioc_s_parm			= vidioc_s_parm,
+	.vidioc_cropcap			= vidioc_cropcap,
+	.vidioc_g_crop			= vidioc_g_crop,
+	.vidioc_s_crop			= vidioc_s_crop,
+	.vidioc_enum_framesizes		= vidioc_enum_framesizes,
+	.vidioc_enum_frameintervals	= vidioc_enum_frameintervals,
+	.vidioc_s_std			= vidioc_s_std,
+	.vidioc_querystd		= vidioc_querystd,
+	.vidioc_default			= vidioc_default,
+};
+
+/**
+ * omap34xxcam_device_register - V4L2 attach handler
+ * @s: ptr. to standard V4L2 device information structure
+ *
+ * Allocates and initializes the V4L2 video_device structure, initializes
+ * the sensor, and finally
+ registers the device with V4L2 based on the
+ * video_device structure.
+ *
+ * Returns 0 on success, otherwise an appropriate error code on
+ * failure.
+ */
+static int omap34xxcam_device_register(struct v4l2_int_device *s)
+{
+	struct omap34xxcam_videodev *vdev = s->u.slave->master->priv;
+	struct omap34xxcam_hw_config hwc;
+	struct v4l2_ifparm ifparm;
+	struct device *isp;
+	int rval;
+
+	/* We need to check rval just once. The place is here. */
+	if (vidioc_int_g_priv(s, &hwc))
+		return -ENODEV;
+
+	if (vdev->index != hwc.dev_index)
+		return -ENODEV;
+
+	if (hwc.dev_type < 0 || hwc.dev_type > OMAP34XXCAM_SLAVE_FLASH)
+		return -EINVAL;
+
+	if (vdev->slave[hwc.dev_type] != v4l2_int_device_dummy())
+		return -EBUSY;
+
+	mutex_lock(&vdev->mutex);
+	if (atomic_read(&vdev->users)) {
+		printk(KERN_ERR "%s: we're open (%d), can't register\n",
+		       __func__, atomic_read(&vdev->users));
+		mutex_unlock(&vdev->mutex);
+		return -EBUSY;
+	}
+
+	vdev->slaves++;
+
+	vdev->slave[hwc.dev_type] = s;
+	vdev->slave_config[hwc.dev_type] = hwc;
+
+	if (hwc.dev_type == OMAP34XXCAM_SLAVE_SENSOR) {
+		isp = isp_get();
+		if (!isp) {
+			rval = -EBUSY;
+			printk(KERN_ERR "%s: can't get ISP, "
+			       "sensor init failed\n", __func__);
+			goto err;
+		}
+		vdev->cam->isp = isp;
+	}
+	rval = omap34xxcam_slave_power_set(vdev, V4L2_POWER_ON,
+					   1 << hwc.dev_type);
+	if (rval)
+		goto err_omap34xxcam_slave_power_set;
+	if (hwc.dev_type == OMAP34XXCAM_SLAVE_SENSOR) {
+		struct v4l2_format format;
+
+		format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		rval = vidioc_int_g_fmt_cap(vdev->vdev_sensor, &format);
+		if (rval)
+			rval = -EBUSY;
+
+		vdev->want_pix = format.fmt.pix;
+	}
+	omap34xxcam_slave_power_set(vdev, V4L2_POWER_OFF, 1 << hwc.dev_type);
+	if (hwc.dev_type == OMAP34XXCAM_SLAVE_SENSOR)
+		isp_put();
+
+	if (rval)
+		goto err;
+
+	/* Are we the first slave? */
+	if (vdev->slaves == 1) {
+		/* initialize the video_device struct */
+		vdev->vfd = video_device_alloc();
+		if (!vdev->vfd) {
+			printk(KERN_ERR "%s: could not allocate "
+			       "video device struct\n", __func__);
+			rval = -ENOMEM;
+			goto err;
+		}
+		vdev->vfd->release	= video_device_release;
+		vdev->vfd->minor	= -1;
+		vdev->vfd->fops		= &omap34xxcam_fops;
+		vdev->vfd->ioctl_ops	= &omap34xxcam_ioctl_ops;
+		video_set_drvdata(vdev->vfd, vdev);
+
+		if (video_register_device(vdev->vfd, VFL_TYPE_GRABBER,
+					  hwc.dev_minor) < 0) {
+			printk(KERN_ERR "%s: could not register V4L device\n",
+				__func__);
+			vdev->vfd->minor = -1;
+			rval = -EBUSY;
+			goto err;
+		}
+	}
+	/*Determine whether the slave connected is BT656 decoder or a sensor*/
+	if (!vidioc_int_g_ifparm(s, &ifparm)) {
+		if (ifparm.if_type == V4L2_IF_TYPE_BT656) {
+			vdev->vfd->current_norm = V4L2_STD_NTSC;
+			vdev->vfd->tvnorms	= V4L2_STD_NTSC | V4L2_STD_PAL;
+			if ((ifparm.u.bt656.mode ==
+					V4L2_IF_TYPE_BT656_MODE_BT_8BIT) ||
+					(ifparm.u.bt656.mode ==
+					 V4L2_IF_TYPE_BT656_MODE_BT_10BIT))
+				vdev->slave_mode[hwc.dev_type] = 1;
+		}
+	}
+	omap34xxcam_vfd_name_update(vdev);
+
+	mutex_unlock(&vdev->mutex);
+
+	return 0;
+
+err_omap34xxcam_slave_power_set:
+	if (hwc.dev_type == OMAP34XXCAM_SLAVE_SENSOR)
+		isp_put();
+
+err:
+	if (s == vdev->slave[hwc.dev_type]) {
+		vdev->slave[hwc.dev_type] = v4l2_int_device_dummy();
+		vdev->slaves--;
+	}
+
+	mutex_unlock(&vdev->mutex);
+	omap34xxcam_device_unregister(s);
+
+	return rval;
+}
+
+static struct v4l2_int_master omap34xxcam_master = {
+	.attach = omap34xxcam_device_register,
+	.detach = omap34xxcam_device_unregister,
+};
+
+/*
+ *
+ * Module initialisation and deinitialisation
+ *
+ */
+
+static void omap34xxcam_exit(void)
+{
+	struct omap34xxcam_device *cam = omap34xxcam;
+	int i;
+
+	if (!cam)
+		return;
+
+	for (i = 0; i < OMAP34XXCAM_VIDEODEVS; i++) {
+		if (cam->vdevs[i].cam == NULL)
+			continue;
+
+		v4l2_int_device_unregister(&cam->vdevs[i].master);
+		cam->vdevs[i].cam = NULL;
+	}
+
+	omap34xxcam = NULL;
+
+	kfree(cam);
+}
+
+static int __init omap34xxcam_init(void)
+{
+	struct omap34xxcam_device *cam;
+	int i;
+
+	cam = kzalloc(sizeof(*cam), GFP_KERNEL);
+	if (!cam) {
+		printk(KERN_ERR "%s: could not allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	omap34xxcam = cam;
+
+	for (i = 0; i < OMAP34XXCAM_VIDEODEVS; i++) {
+		struct omap34xxcam_videodev *vdev = &cam->vdevs[i];
+		struct v4l2_int_device *m = &vdev->master;
+
+		m->module       = THIS_MODULE;
+		strlcpy(m->name, CAM_NAME, sizeof(m->name));
+		m->type         = v4l2_int_type_master;
+		m->u.master     = &omap34xxcam_master;
+		m->priv		= vdev;
+
+		mutex_init(&vdev->mutex);
+		vdev->index             = i;
+		vdev->cam               = cam;
+		vdev->vdev_sensor =
+			vdev->vdev_lens =
+			vdev->vdev_flash = v4l2_int_device_dummy();
+#ifdef OMAP34XXCAM_POWEROFF_DELAY
+		setup_timer(&vdev->poweroff_timer,
+			    omap34xxcam_slave_power_timer, (unsigned long)vdev);
+		INIT_WORK(&vdev->poweroff_work, omap34xxcam_slave_power_work);
+#endif /* OMAP34XXCAM_POWEROFF_DELAY */
+
+		if (v4l2_int_device_register(m))
+			goto err;
+	}
+
+	return 0;
+
+err:
+	omap34xxcam_exit();
+	return -ENODEV;
+}
+
+MODULE_AUTHOR("Sakari Ailus <sakari.ailus@nokia.com>");
+MODULE_DESCRIPTION("OMAP34xx Video for Linux camera driver");
+MODULE_LICENSE("GPL");
+
+late_initcall(omap34xxcam_init);
+module_exit(omap34xxcam_exit);
diff -Naur linux-org/drivers/media/video/omap34xxcam.h linux-ths/drivers/media/video/omap34xxcam.h
--- linux-org/drivers/media/video/omap34xxcam.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-ths/drivers/media/video/omap34xxcam.h	2012-07-12 13:27:53.000000000 +0200
@@ -0,0 +1,190 @@
+/*
+ * omap34xxcam.h
+ *
+ * Copyright (C) 2006--2009 Nokia Corporation
+ * Copyright (C) 2007--2009 Texas Instruments
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *          Tuukka Toivonen <tuukka.o.toivonen@nokia.com>
+ *
+ * Originally based on the OMAP 2 camera driver.
+ *
+ * Written by Sakari Ailus <sakari.ailus@nokia.com>
+ *            Tuukka Toivonen <tuukka.o.toivonen@nokia.com>
+ *            Sergio Aguirre <saaguirre@ti.com>
+ *            Mohit Jalori
+ *            Sameer Venkatraman
+ *            Leonides Martinez
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef OMAP34XXCAM_H
+#define OMAP34XXCAM_H
+
+#include <media/v4l2-int-device.h>
+#include "isp/isp.h"
+
+#define CAM_NAME			"omap34xxcam"
+#define CAM_SHORT_NAME			"omap3"
+
+#define OMAP34XXCAM_XCLK_NONE	-1
+#define OMAP34XXCAM_XCLK_A	0
+#define OMAP34XXCAM_XCLK_B	1
+
+#define OMAP34XXCAM_SLAVE_SENSOR	0
+#define OMAP34XXCAM_SLAVE_LENS		1
+#define OMAP34XXCAM_SLAVE_FLASH		2 /* This is the last slave! */
+
+/* mask for omap34xxcam_slave_power_set */
+#define OMAP34XXCAM_SLAVE_POWER_SENSOR	(1 << OMAP34XXCAM_SLAVE_SENSOR)
+#define OMAP34XXCAM_SLAVE_POWER_LENS	(1 << OMAP34XXCAM_SLAVE_LENS)
+#define OMAP34XXCAM_SLAVE_POWER_SENSOR_LENS \
+	(OMAP34XXCAM_SLAVE_POWER_SENSOR | OMAP34XXCAM_SLAVE_POWER_LENS)
+#define OMAP34XXCAM_SLAVE_POWER_FLASH	(1 << OMAP34XXCAM_SLAVE_FLASH)
+#define OMAP34XXCAM_SLAVE_POWER_ALL	-1
+
+#define OMAP34XXCAM_VIDEODEVS		4
+
+/* #define OMAP34XXCAM_POWEROFF_DELAY (2 * HZ) */
+
+struct omap34xxcam_device;
+struct omap34xxcam_videodev;
+
+/**
+ * struct omap34xxcam_sensor_config - struct for vidioc_int_g_priv ioctl
+ * @sensor_isp: Is sensor smart/SOC or raw
+ * @capture_mem: Size limit to mmap buffers.
+ * @ival_default: Default frame interval for sensor.
+ */
+struct omap34xxcam_sensor_config {
+	int sensor_isp;
+	u32 capture_mem;
+	struct v4l2_fract ival_default;
+};
+
+struct omap34xxcam_lens_config {
+};
+
+struct omap34xxcam_flash_config {
+};
+
+struct omap34xxcam_hw_config {
+	int dev_index; /* Index in omap34xxcam_sensors */
+	int dev_minor; /* Video device minor number */
+	int dev_type; /* OMAP34XXCAM_SLAVE_* */
+	union {
+		struct omap34xxcam_sensor_config sensor;
+		struct omap34xxcam_lens_config lens;
+		struct omap34xxcam_flash_config flash;
+	} u;
+	int cur_input;
+};
+
+/**
+ * struct omap34xxcam_videodev - per /dev/video* structure
+ * @mutex: serialises access to this structure
+ * @cam: pointer to cam hw structure
+ * @master: we are v4l2_int_device master
+ * @sensor: sensor device
+ * @lens: lens device
+ * @flash: flash device
+ * @slaves: how many slaves we have at the moment
+ * @vfd: our video device
+ * @index: index of this structure in cam->vdevs
+ * @users: how many users we have
+ * @power_state: Current power state
+ * @power_state_wish: New power state when poweroff_timer expires
+ * @power_state_mask: Bitmask of devices to set the new power state
+ * @poweroff_timer: Timer for dispatching poweroff_work
+ * @poweroff_work: Work for slave power state change
+ * @sensor_config: ISP-speicific sensor configuration
+ * @lens_config: ISP-speicific lens configuration
+ * @flash_config: ISP-speicific flash configuration
+ * @streaming: streaming file handle, if streaming is enabled
+ * @want_timeperframe: Desired timeperframe
+ * @want_pix: Desired pix
+ * @pix: Current pix
+ */
+struct omap34xxcam_videodev {
+	struct mutex mutex; /* serialises access to this structure */
+
+	struct omap34xxcam_device *cam;
+	struct v4l2_int_device master;
+
+#define vdev_sensor slave[OMAP34XXCAM_SLAVE_SENSOR]
+#define vdev_lens slave[OMAP34XXCAM_SLAVE_LENS]
+#define vdev_flash slave[OMAP34XXCAM_SLAVE_FLASH]
+	struct v4l2_int_device *slave[OMAP34XXCAM_SLAVE_FLASH + 1];
+
+	/* number of slaves attached */
+	int slaves;
+
+	/*** video device parameters ***/
+	struct video_device *vfd;
+
+	/*** general driver state information ***/
+	int index;
+	atomic_t users;
+	enum v4l2_power power_state[OMAP34XXCAM_SLAVE_FLASH + 1];
+#ifdef OMAP34XXCAM_POWEROFF_DELAY
+	enum v4l2_power power_state_wish;
+	int power_state_mask;
+	struct timer_list poweroff_timer;
+	struct work_struct poweroff_work;
+#endif /* OMAP34XXCAM_POWEROFF_DELAY */
+
+#define vdev_sensor_config slave_config[OMAP34XXCAM_SLAVE_SENSOR].u.sensor
+#define vdev_lens_config slave_config[OMAP34XXCAM_SLAVE_LENS].u.lens
+#define vdev_flash_config slave_config[OMAP34XXCAM_SLAVE_FLASH].u.flash
+	struct omap34xxcam_hw_config slave_config[OMAP34XXCAM_SLAVE_FLASH + 1];
+
+#define vdev_sensor_mode slave_mode[OMAP34XXCAM_SLAVE_SENSOR]
+#define vdev_lens_mode slave_mode[OMAP34XXCAM_SLAVE_LENS]
+#define vdev_flash_mode slave_mode[OMAP34XXCAM_SLAVE_FLASH]
+	int slave_mode[OMAP34XXCAM_SLAVE_FLASH + 1];
+
+	/*** capture data ***/
+	struct file *streaming;
+	struct v4l2_fract want_timeperframe;
+	struct v4l2_pix_format want_pix;
+	struct v4l2_pix_format pix;
+};
+
+/**
+ * struct omap34xxcam_device - per-device data structure
+ * @vdevs: /dev/video specific structures
+ */
+struct omap34xxcam_device {
+	struct omap34xxcam_videodev vdevs[OMAP34XXCAM_VIDEODEVS];
+	struct device *isp;
+};
+
+/**
+ * struct omap34xxcam_fh - per-filehandle data structure
+ * @vbq_lock: spinlock for the videobuf queue
+ * @vbq: V4L2 video buffer queue structure
+ * @field_count: field counter for videobuf_buffer
+ * @vdev: our /dev/video specific structure
+ */
+struct omap34xxcam_fh {
+	spinlock_t vbq_lock; /* spinlock for the videobuf queue */
+	struct videobuf_queue vbq;
+	atomic_t field_count;
+	struct omap34xxcam_videodev *vdev;
+};
+
+#endif /* ifndef OMAP34XXCAM_H */
