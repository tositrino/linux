diff -Naur org/arch/arm/mach-exynos/cpu-exynos4.c ths/arch/arm/mach-exynos/cpu-exynos4.c
--- org/arch/arm/mach-exynos/cpu-exynos4.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/arch/arm/mach-exynos/cpu-exynos4.c	2013-07-11 14:49:11.000000000 +0200
@@ -8,6 +8,9 @@
  * published by the Free Software Foundation.
 */
 
+#include <linux/kernel.h>
+#include <linux/module.h>
+
 #include <linux/sched.h>
 #include <linux/sysdev.h>
 #include <linux/delay.h>
@@ -26,7 +29,15 @@
 #include <plat/exynos4.h>
 #include <plat/sdhci.h>
 #include <plat/mshci.h>
+#include <plat/mshci.h>
 #include <plat/fimc-core.h>
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#include <media/s5p_fimc.h>
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+#include <plat/fimc.h>
+#endif
+
 #include <plat/adc-core.h>
 #include <plat/pm.h>
 #include <plat/iic-core.h>
@@ -41,6 +52,8 @@
 
 unsigned int gic_bank_offset __read_mostly;
 
+extern void s3c_fimc_setname(int , char *);
+
 extern int combiner_init(unsigned int combiner_nr, void __iomem *base,
 			 unsigned int irq_start);
 extern void combiner_cascade_irq(unsigned int combiner_nr, unsigned int irq);
diff -Naur org/arch/arm/mach-exynos/mach-odroid-q.c ths/arch/arm/mach-exynos/mach-odroid-q.c
--- org/arch/arm/mach-exynos/mach-odroid-q.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/arch/arm/mach-exynos/mach-odroid-q.c	2013-07-12 11:27:54.000000000 +0200
@@ -54,12 +54,16 @@
 #include <plat/ehci.h>
 #include <plat/usbgadget.h>
 #include <plat/s3c64xx-spi.h>
-#if defined(CONFIG_VIDEO_FIMC)
+
+#if defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
 #include <plat/fimc.h>
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
-#include <plat/fimc-core.h>
+#endif
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 #include <media/s5p_fimc.h>
+#include <plat/fimc-core.h>
 #endif
+
 #if defined(CONFIG_VIDEO_FIMC_MIPI)
 #include <plat/csis.h>
 #elif defined(CONFIG_VIDEO_S5P_MIPI_CSIS)
@@ -73,10 +77,11 @@
 #if defined(CONFIG_VIDEO_SAMSUNG_S5P_MFC) || defined(CONFIG_VIDEO_MFC5X)
 #include <plat/s5p-mfc.h>
 #endif
-#include <media/s5k4ecgx_platform.h>
 #include <media/exynos_flite.h>
 #include <media/exynos_fimc_is.h>
 #include <video/platform_lcd.h>
+#include <media/s5k4ecgx_platform.h>
+#include <media/dohofpga_platform.h>
 #include "media/mt9m113_platform.h"
 #include <mach/board_rev.h>
 #include <mach/map.h>
@@ -102,11 +107,6 @@
 #include <plat/fimg2d.h>
 #include <mach/dev-sysmmu.h>
 
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
-#include <plat/fimc-core.h>
-#include <media/s5p_fimc.h>
-#endif
-
 #ifdef CONFIG_VIDEO_JPEG_V2X
 #include <plat/jpeg.h>
 #endif
@@ -171,12 +171,12 @@
 
 #define WRITEBACK_ENABLED
 
-#ifdef CONFIG_VIDEO_FIMC
+#ifdef CONFIG_VIDEO_FIMC || defined(CONFIG_VIDEO_FIMC_MODULE)
 
 /* hardkernel mt9m113 */
-#ifdef CONFIG_VIDEO_MT9M113
-
-static int hdkl_odroidq_cam0_reset(int dummy)
+#if defined(CONFIG_VIDEO_MT9M113) || defined(CONFIG_VIDEO_MT9M113_MODULE)
+#warning MT9M113 code enabled
+static int hdkl_odroid_cam0_reset(int dummy)
 {
 	int err;
 	/* Camera A */
@@ -219,11 +219,27 @@
 
 static struct s3c_platform_camera mt9m113 = {
 
+#if defined(CONFIG_MT9M113_CSI_D)
+#define CONFIG_CSI_D
+	.id		= CAMERA_CSI_D,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_MT9M113_CSI_C)
+#define CONFIG_CSI_C
+	.id		= CAMERA_CSI_C,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_MT9M113_ITU_B)
+#define CONFIG_ITU_B
+	.id		= CAMERA_PAR_B,
+	.type		= CAM_TYPE_ITU,
+#else
+#define CONFIG_ITU_A
 	.id		= CAMERA_PAR_A,
+	.type		= CAM_TYPE_ITU,
+#endif
+
 	.clk_name	= "sclk_cam0",
-	.cam_power	= hdkl_odroidq_cam0_reset,
+	.cam_power	= hdkl_odroid_cam0_reset,
 	.i2c_busnum = 5,
-	.type		= CAM_TYPE_ITU,
 	.fmt		= ITU_601_YCBCR422_8BIT,
 	.order422	= CAM_ORDER422_8BIT_CBYCRY,
 	.info		= &mt9m113_i2c_info,
@@ -255,6 +271,107 @@
 };
 #endif
 
+/* dohofpga3 */
+#if defined(CONFIG_VIDEO_DOHOFPGA) || defined(CONFIG_VIDEO_DOHOFPGA_MODULE)
+#warning DOHOFPGA code enabled
+
+static int doho_odroid_cam0_reset(int dummy)
+{
+	int err;
+	/* Camera A */
+	err = gpio_request(EXYNOS4_GPX2(7), "GPX2"); //reset
+	if (err)
+		printk(KERN_ERR "#### failed to request GPX1_2 ####\n");
+
+	err = gpio_request(EXYNOS4212_GPJ1(4), "GPJ1"); //stnby
+	if (err)
+		printk(KERN_ERR "#### failed to request GPJ1_4 ####\n");
+
+	s3c_gpio_setpull(EXYNOS4_GPX2(7), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(EXYNOS4212_GPJ1(4), S3C_GPIO_PULL_NONE);
+
+	gpio_direction_output(EXYNOS4212_GPJ1(4), 1);
+	gpio_direction_output(EXYNOS4_GPX2(7), 0);
+	msleep(50);
+	gpio_direction_output(EXYNOS4_GPX2(7), 1);
+	msleep(100);
+	gpio_direction_output(EXYNOS4212_GPJ1(4), 0);
+	
+	gpio_free(EXYNOS4_GPX2(7));
+	gpio_free(EXYNOS4212_GPJ1(4));
+	
+	printk("Cam0 Reset\n");
+	return 0;
+}
+
+static struct dohofpga_platform_data dohofpga_plat = {
+	.default_width = 1920,
+	.default_height = 1080,
+	.pixelformat = V4L2_PIX_FMT_UYVY,//V4L2_PIX_FMT_GREY,//
+	.freq = 50000000,//24000000,
+	.is_mipi = 0,
+};
+static struct i2c_board_info dohofpga_i2c_info = {
+	I2C_BOARD_INFO("DOHOFPGA", 0x7a>>1),
+	.platform_data = &dohofpga_plat,
+};
+
+static struct s3c_platform_camera dohofpga = 
+{
+
+#if defined(CONFIG_DOHOFPGA_CSI_D)
+#define CONFIG_CSI_D
+	.id		= CAMERA_CSI_D,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_DOHOFPGA_CSI_C)
+#define CONFIG_CSI_C
+	.id		= CAMERA_CSI_C,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_DOHOFPGA_ITU_B)
+#define CONFIG_ITU_B
+	.id		= CAMERA_PAR_B,
+	.type		= CAM_TYPE_ITU,
+#else
+#define CONFIG_ITU_A
+	.id		= CAMERA_PAR_A,
+	.type		= CAM_TYPE_ITU,
+#endif
+
+	.clk_name	= "sclk_cam0",
+	.cam_power	= doho_odroid_cam0_reset,
+	.i2c_busnum = 5,
+	.fmt		= ITU_601_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_CBYCRY,
+	.info		= &dohofpga_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,//
+	.srclk_name	= "xusbxti",
+
+	.clk_rate	= 50000000,//24000000,
+	.line_length	= 1920,
+	.width		= 640,
+	.height		= 480,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 640,
+		.height	= 480,
+	},
+
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 24,
+
+	/* Polarity */
+	.inv_pclk	= 1,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+	.use_isp	= 0,
+	.initialized	= 0,
+};
+#endif
+
+
 /* hardkernel s5k4ecgx */
 #ifdef CONFIG_VIDEO_S5K4ECGX
 static int s5k4ecgx_power(int enable)
@@ -363,29 +480,44 @@
 /* Interface setting */
 static struct s3c_platform_fimc fimc_plat = {
 #ifdef CONFIG_ITU_A
+#warning default camera is PAR_A
 	.default_cam	= CAMERA_PAR_A,
 #endif
 #ifdef CONFIG_ITU_B
+#warning default camera is PAR_B
 	.default_cam	= CAMERA_PAR_B,
 #endif
 #ifdef CONFIG_CSI_C
+#warning default camera is CSI_C
 	.default_cam	= CAMERA_CSI_C,
 #endif
 #ifdef CONFIG_CSI_D
+#warning default camera is ICSI_D
 	.default_cam	= CAMERA_CSI_D,
 #endif
 #ifdef WRITEBACK_ENABLED
+#warning default camera is CAMERA_WB
 	.default_cam	= CAMERA_WB,
 #endif
 	.camera		= {
 
-#ifdef CONFIG_VIDEO_S5K4ECGX
-		&s5k4ecgx,
+#if defined(CONFIG_VIDEO_DOHOFPGA) || defined(CONFIG_VIDEO_DOHOFPGA_MODULE)
+#warning added dohofpga
+		&dohofpga,
 #endif
-#ifdef CONFIG_VIDEO_MT9M113	
+
+#if defined(CONFIG_VIDEO_MT9M113) || defined(CONFIG_VIDEO_MT9M113_MODULE)
+#warning added mt9m113
 		&mt9m113,
 #endif
+
+#ifdef CONFIG_VIDEO_S5K4ECGX
+#warning added s5k4ecgx
+		&s5k4ecgx,
+#endif
+
 #ifdef WRITEBACK_ENABLED
+#warning added writeback
 		&writeback,
 #endif
 	},
@@ -394,7 +526,7 @@
 #endif /* CONFIG_VIDEO_FIMC */
 
 /* for mainline fimc interface */
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 #ifdef WRITEBACK_ENABLED
 struct writeback_mbus_platform_data {
 	int id;
@@ -405,7 +537,6 @@
 	I2C_BOARD_INFO("writeback", 0x0),
 };
 #endif
-
 #endif /* CONFIG_VIDEO_SAMSUNG_S5P_FIMC */
 
 #ifdef CONFIG_S3C64XX_DEV_SPI
@@ -1328,18 +1459,21 @@
 	&s5p_device_mixer,
 	&s5p_device_cec,
 #endif
-#if defined(CONFIG_VIDEO_FIMC)
-	&s3c_device_fimc0,
-	&s3c_device_fimc1,
-	&s3c_device_fimc2,
-	&s3c_device_fimc3,
-/* CONFIG_VIDEO_SAMSUNG_S5P_FIMC is the feature for mainline */
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#warning setup s5p_device_fimcX devices
 	&s5p_device_fimc0,
 	&s5p_device_fimc1,
 	&s5p_device_fimc2,
 	&s5p_device_fimc3,
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+#warning setup s3c_device_fimcX devices
+	&s3c_device_fimc0,
+	&s3c_device_fimc1,
+	&s3c_device_fimc2,
+	&s3c_device_fimc3,
 #endif
+
 #if defined(CONFIG_VIDEO_FIMC_MIPI)
 	&s3c_device_csis0,
 	&s3c_device_csis1,
@@ -1462,7 +1596,7 @@
 };
 #endif
 
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 static struct s5p_fimc_isp_info isp_info[] = {
 #if defined(WRITEBACK_ENABLED)
 	{
@@ -1802,17 +1936,23 @@
 	sysmmu_set_owner(&SYSMMU_PLATDEV(mfc_l).dev, &s5p_device_mfc.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(mfc_r).dev, &s5p_device_mfc.dev);
 #endif
-#if defined(CONFIG_VIDEO_FIMC)
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#warning sysmmu_set_owner for s5p_device_fimcX
+    printk(KERN_INFO "exynos_sysmmu_init: sysmmu_set_owner for s5p_device_fimcX\n");
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s5p_device_fimc0.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s5p_device_fimc1.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s5p_device_fimc2.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s5p_device_fimc3.dev);
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+#warning sysmmu_set_owner for s3c_device_fimcX
+    printk(KERN_INFO "exynos_sysmmu_init: sysmmu_set_owner for s3c_device_fimcX\n");
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
 #endif
+
 #ifdef CONFIG_VIDEO_EXYNOS_TV
 	sysmmu_set_owner(&SYSMMU_PLATDEV(tv).dev, &s5p_device_mixer.dev);
 #endif
@@ -2069,7 +2209,12 @@
 #ifdef CONFIG_EXYNOS_THERMAL
 	exynos_tmu_set_platdata(&exynos_tmu_data);
 #endif
-#ifdef CONFIG_VIDEO_FIMC
+
+#warning expect problems here
+
+#warning odroid_machine_init - set platformdata for s3c_device_fimcX
+    printk(KERN_INFO "odroid_machine_init: set platformdata for s3c_device_fimcX\n");
+#if defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
 	s3c_fimc0_set_platdata(&fimc_plat);
 	s3c_fimc1_set_platdata(&fimc_plat);
 	s3c_fimc2_set_platdata(&fimc_plat);
@@ -2083,6 +2228,7 @@
 	secmem.parent = &exynos4_device_pd[PD_CAM].dev;
 #endif
 #endif
+
 #ifdef CONFIG_VIDEO_FIMC_MIPI
 	s3c_csis0_set_platdata(NULL);
 	s3c_csis1_set_platdata(NULL);
@@ -2091,9 +2237,11 @@
 	s3c_device_csis1.dev.parent = &exynos4_device_pd[PD_CAM].dev;
 #endif
 #endif
-#endif /* CONFIG_VIDEO_FIMC */
+#endif /* if defined(CONFIG_VIDEO_FIMC) */
 
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#warning odroid_machine_init - dev_set_name for s5p_device_fimcX
+    printk(KERN_INFO "odroid_machine_init: dev_set_name for s5p_device_fimcX\n");
 	smdk4x12_camera_config();
 	smdk4x12_subdev_config();
 
diff -Naur org/arch/arm/mach-exynos/mach-odroid-u.c ths/arch/arm/mach-exynos/mach-odroid-u.c
--- org/arch/arm/mach-exynos/mach-odroid-u.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/arch/arm/mach-exynos/mach-odroid-u.c	2013-07-12 11:27:37.000000000 +0200
@@ -55,12 +55,15 @@
 #include <plat/usbgadget.h>
 #include <plat/s3c64xx-spi.h>
 
-#if defined(CONFIG_VIDEO_FIMC)
+#if defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
 #include <plat/fimc.h>
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
-#include <plat/fimc-core.h>
+#endif
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 #include <media/s5p_fimc.h>
+#include <plat/fimc-core.h>
 #endif
+
 #if defined(CONFIG_VIDEO_FIMC_MIPI)
 #include <plat/csis.h>
 #elif defined(CONFIG_VIDEO_S5P_MIPI_CSIS)
@@ -75,10 +78,12 @@
 #if defined(CONFIG_VIDEO_SAMSUNG_S5P_MFC) || defined(CONFIG_VIDEO_MFC5X)
 #include <plat/s5p-mfc.h>
 #endif
-#include <media/s5k4ecgx_platform.h>
 #include <media/exynos_flite.h>
 #include <media/exynos_fimc_is.h>
 #include <video/platform_lcd.h>
+#include <media/s5k4ecgx_platform.h>
+#include <media/dohofpga_platform.h>
+#include "media/mt9m113_platform.h"
 #include <mach/board_rev.h>
 #include <mach/map.h>
 #include <mach/spi-clocks.h>
@@ -103,10 +108,6 @@
 #include <plat/fimg2d.h>
 #include <mach/dev-sysmmu.h>
 
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
-#include <plat/fimc-core.h>
-#include <media/s5p_fimc.h>
-#endif
 
 #ifdef CONFIG_VIDEO_JPEG_V2X
 #include <plat/jpeg.h>
@@ -172,7 +173,207 @@
 
 #define WRITEBACK_ENABLED
 
-#ifdef CONFIG_VIDEO_FIMC
+#ifdef CONFIG_VIDEO_FIMC || defined(CONFIG_VIDEO_FIMC_MODULE)
+
+/* hardkernel mt9m113 */
+#if defined(CONFIG_VIDEO_MT9M113) || defined(CONFIG_VIDEO_MT9M113_MODULE)
+#warning MT9M113 code enabled
+static int hdkl_odroid_cam0_reset(int dummy)
+{
+	int err;
+	/* Camera A */
+	err = gpio_request(EXYNOS4_GPX2(7), "GPX2"); //reset
+	if (err)
+		printk(KERN_ERR "#### failed to request GPX1_2 ####\n");
+
+	err = gpio_request(EXYNOS4212_GPJ1(4), "GPJ1"); //stnby
+	if (err)
+		printk(KERN_ERR "#### failed to request GPJ1_4 ####\n");
+
+	s3c_gpio_setpull(EXYNOS4_GPX2(7), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(EXYNOS4212_GPJ1(4), S3C_GPIO_PULL_NONE);
+
+	gpio_direction_output(EXYNOS4212_GPJ1(4), 1);
+	gpio_direction_output(EXYNOS4_GPX2(7), 0);
+	msleep(50);
+	gpio_direction_output(EXYNOS4_GPX2(7), 1);
+	msleep(100);
+	gpio_direction_output(EXYNOS4212_GPJ1(4), 0);
+	
+	gpio_free(EXYNOS4_GPX2(7));
+	gpio_free(EXYNOS4212_GPJ1(4));
+	
+	printk("Cam0 Reset\n");
+	return 0;
+}
+
+static struct mt9m113_platform_data mt9m113_plat = {
+	.default_width = 1920,
+	.default_height = 1080,
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.freq = 24000000,
+	.is_mipi = 0,
+};
+static struct i2c_board_info mt9m113_i2c_info = {
+	I2C_BOARD_INFO("MT9M113", 0x7a>>1),
+	.platform_data = &mt9m113_plat,
+};
+
+static struct s3c_platform_camera mt9m113 = {
+
+#if defined(CONFIG_MT9M113_CSI_D)
+#define CONFIG_CSI_D
+	.id		= CAMERA_CSI_D,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_MT9M113_CSI_C)
+#define CONFIG_CSI_C
+	.id		= CAMERA_CSI_C,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_MT9M113_ITU_B)
+#define CONFIG_ITU_B
+	.id		= CAMERA_PAR_B,
+	.type		= CAM_TYPE_ITU,
+#else
+#define CONFIG_ITU_A
+	.id		= CAMERA_PAR_A,
+	.type		= CAM_TYPE_ITU,
+#endif
+
+	.clk_name	= "sclk_cam0",
+	.cam_power	= hdkl_odroid_cam0_reset,
+	.i2c_busnum = 5,
+	.fmt		= ITU_601_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_CBYCRY,
+	.info		= &mt9m113_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,
+	.srclk_name	= "xusbxti",
+
+	.clk_rate	= 24000000,
+	.line_length	= 1920,
+	.width		= 640,
+	.height		= 480,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 640,
+		.height	= 480,
+	},
+
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 24,
+
+	/* Polarity */
+	.inv_pclk	= 1,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+	.use_isp	= 0,
+	.initialized	= 0,
+};
+#endif
+
+/* dohofpga3 */
+#if defined(CONFIG_VIDEO_DOHOFPGA) || defined(CONFIG_VIDEO_DOHOFPGA_MODULE)
+#warning DOHOFPGA code enabled
+
+static int doho_odroid_cam0_reset(int dummy)
+{
+	int err;
+	/* Camera A */
+	err = gpio_request(EXYNOS4_GPX2(7), "GPX2"); //reset
+	if (err)
+		printk(KERN_ERR "#### failed to request GPX1_2 ####\n");
+
+	err = gpio_request(EXYNOS4212_GPJ1(4), "GPJ1"); //stnby
+	if (err)
+		printk(KERN_ERR "#### failed to request GPJ1_4 ####\n");
+
+	s3c_gpio_setpull(EXYNOS4_GPX2(7), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(EXYNOS4212_GPJ1(4), S3C_GPIO_PULL_NONE);
+
+	gpio_direction_output(EXYNOS4212_GPJ1(4), 1);
+	gpio_direction_output(EXYNOS4_GPX2(7), 0);
+	msleep(50);
+	gpio_direction_output(EXYNOS4_GPX2(7), 1);
+	msleep(100);
+	gpio_direction_output(EXYNOS4212_GPJ1(4), 0);
+	
+	gpio_free(EXYNOS4_GPX2(7));
+	gpio_free(EXYNOS4212_GPJ1(4));
+	
+	printk("Cam0 Reset\n");
+	return 0;
+}
+
+static struct dohofpga_platform_data dohofpga_plat = {
+	.default_width = 1920,
+	.default_height = 1080,
+	.pixelformat = V4L2_PIX_FMT_UYVY,//V4L2_PIX_FMT_GREY,//
+	.freq = 50000000,//24000000,
+	.is_mipi = 0,
+};
+static struct i2c_board_info dohofpga_i2c_info = {
+	I2C_BOARD_INFO("DOHOFPGA", 0x7a>>1),
+	.platform_data = &dohofpga_plat,
+};
+
+static struct s3c_platform_camera dohofpga = 
+{
+
+#if defined(CONFIG_DOHOFPGA_CSI_D)
+#define CONFIG_CSI_D
+	.id		= CAMERA_CSI_D,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_DOHOFPGA_CSI_C)
+#define CONFIG_CSI_C
+	.id		= CAMERA_CSI_C,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_DOHOFPGA_ITU_B)
+#define CONFIG_ITU_B
+	.id		= CAMERA_PAR_B,
+	.type		= CAM_TYPE_ITU,
+#else
+#define CONFIG_ITU_A
+	.id		= CAMERA_PAR_A,
+	.type		= CAM_TYPE_ITU,
+#endif
+
+	.clk_name	= "sclk_cam0",
+	.cam_power	= doho_odroid_cam0_reset,
+	.i2c_busnum = 5,
+	.fmt		= ITU_601_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_CBYCRY,
+	.info		= &dohofpga_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,//
+	.srclk_name	= "xusbxti",
+
+	.clk_rate	= 50000000,//24000000,
+	.line_length	= 1920,
+	.width		= 640,
+	.height		= 480,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 640,
+		.height	= 480,
+	},
+
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 24,
+
+	/* Polarity */
+	.inv_pclk	= 1,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+	.use_isp	= 0,
+	.initialized	= 0,
+};
+#endif
+
+
 /* hardkernel s5k4ecgx */
 #ifdef CONFIG_VIDEO_S5K4ECGX
 static int s5k4ecgx_power(int enable)
@@ -283,26 +484,44 @@
 /* Interface setting */
 static struct s3c_platform_fimc fimc_plat = {
 #ifdef CONFIG_ITU_A
+#warning default camera is PAR_A
 	.default_cam	= CAMERA_PAR_A,
 #endif
 #ifdef CONFIG_ITU_B
+#warning default camera is PAR_B
 	.default_cam	= CAMERA_PAR_B,
 #endif
 #ifdef CONFIG_CSI_C
+#warning default camera is CSI_C
 	.default_cam	= CAMERA_CSI_C,
 #endif
 #ifdef CONFIG_CSI_D
+#warning default camera is ICSI_D
 	.default_cam	= CAMERA_CSI_D,
 #endif
 #ifdef WRITEBACK_ENABLED
+#warning default camera is CAMERA_WB
 	.default_cam	= CAMERA_WB,
 #endif
 	.camera		= {
 
+#if defined(CONFIG_VIDEO_DOHOFPGA) || defined(CONFIG_VIDEO_DOHOFPGA_MODULE)
+#warning added dohofpga
+		&dohofpga,
+#endif
+
+#if defined(CONFIG_VIDEO_MT9M113) || defined(CONFIG_VIDEO_MT9M113_MODULE)
+#warning added mt9m113
+		&mt9m113,
+#endif
+
 #ifdef CONFIG_VIDEO_S5K4ECGX
+#warning added s5k4ecgx
 		&s5k4ecgx,
 #endif
+
 #ifdef WRITEBACK_ENABLED
+#warning added writeback
 		&writeback,
 #endif
 	},
@@ -311,7 +530,7 @@
 #endif /* CONFIG_VIDEO_FIMC */
 
 /* for mainline fimc interface */
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 #ifdef WRITEBACK_ENABLED
 struct writeback_mbus_platform_data {
 	int id;
@@ -322,7 +541,6 @@
 	I2C_BOARD_INFO("writeback", 0x0),
 };
 #endif
-
 #endif /* CONFIG_VIDEO_SAMSUNG_S5P_FIMC */
 
 #ifdef CONFIG_S3C64XX_DEV_SPI
@@ -1085,18 +1303,21 @@
 	&s5p_device_mixer,
 	&s5p_device_cec,
 #endif
-#if defined(CONFIG_VIDEO_FIMC)
-	&s3c_device_fimc0,
-	&s3c_device_fimc1,
-	&s3c_device_fimc2,
-	&s3c_device_fimc3,
-/* CONFIG_VIDEO_SAMSUNG_S5P_FIMC is the feature for mainline */
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#warning setup s5p_device_fimcX devices
 	&s5p_device_fimc0,
 	&s5p_device_fimc1,
 	&s5p_device_fimc2,
 	&s5p_device_fimc3,
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+#warning setup s3c_device_fimcX devices
+	&s3c_device_fimc0,
+	&s3c_device_fimc1,
+	&s3c_device_fimc2,
+	&s3c_device_fimc3,
 #endif
+
 #if defined(CONFIG_VIDEO_FIMC_MIPI)
 	&s3c_device_csis0,
 	&s3c_device_csis1,
@@ -1223,7 +1444,7 @@
 };
 #endif
 
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 static struct s5p_fimc_isp_info isp_info[] = {
 #if defined(WRITEBACK_ENABLED)
 	{
@@ -1563,17 +1784,23 @@
 	sysmmu_set_owner(&SYSMMU_PLATDEV(mfc_l).dev, &s5p_device_mfc.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(mfc_r).dev, &s5p_device_mfc.dev);
 #endif
-#if defined(CONFIG_VIDEO_FIMC)
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#warning sysmmu_set_owner for s5p_device_fimcX
+    printk(KERN_INFO "exynos_sysmmu_init: sysmmu_set_owner for s5p_device_fimcX\n");
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s5p_device_fimc0.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s5p_device_fimc1.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s5p_device_fimc2.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s5p_device_fimc3.dev);
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+#warning sysmmu_set_owner for s3c_device_fimcX
+    printk(KERN_INFO "exynos_sysmmu_init: sysmmu_set_owner for s3c_device_fimcX\n");
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
 #endif
+
 #ifdef CONFIG_VIDEO_EXYNOS_TV
 	sysmmu_set_owner(&SYSMMU_PLATDEV(tv).dev, &s5p_device_mixer.dev);
 #endif
@@ -1839,7 +2066,12 @@
 #ifdef CONFIG_EXYNOS_THERMAL
 	exynos_tmu_set_platdata(&exynos_tmu_data);
 #endif
-#ifdef CONFIG_VIDEO_FIMC
+
+#warning expect problems here
+
+#if defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+#warning odroid_machine_init - set platformdata for s3c_device_fimcX
+    printk(KERN_INFO "odroid_machine_init: set platformdata for s3c_device_fimcX\n");
 	s3c_fimc0_set_platdata(&fimc_plat);
 	s3c_fimc1_set_platdata(&fimc_plat);
 	s3c_fimc2_set_platdata(&fimc_plat);
@@ -1853,6 +2085,7 @@
 	secmem.parent = &exynos4_device_pd[PD_CAM].dev;
 #endif
 #endif
+
 #ifdef CONFIG_VIDEO_FIMC_MIPI
 	s3c_csis0_set_platdata(NULL);
 	s3c_csis1_set_platdata(NULL);
@@ -1861,9 +2094,11 @@
 	s3c_device_csis1.dev.parent = &exynos4_device_pd[PD_CAM].dev;
 #endif
 #endif
-#endif /* CONFIG_VIDEO_FIMC */
+#endif /* if defined(CONFIG_VIDEO_FIMC) */
 
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#warning odroid_machine_init - dev_set_name for s5p_device_fimcX
+    printk(KERN_INFO "odroid_machine_init: dev_set_name for s5p_device_fimcX\n");
 	smdk4x12_camera_config();
 	smdk4x12_subdev_config();
 
diff -Naur org/arch/arm/mach-exynos/mach-odroid-x.c ths/arch/arm/mach-exynos/mach-odroid-x.c
--- org/arch/arm/mach-exynos/mach-odroid-x.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/arch/arm/mach-exynos/mach-odroid-x.c	2013-07-12 17:59:35.000000000 +0200
@@ -55,12 +55,16 @@
 #include <plat/usbgadget.h>
 #include <plat/s3c64xx-spi.h>
 
-#if defined(CONFIG_VIDEO_FIMC)
+
+#if defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
 #include <plat/fimc.h>
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
-#include <plat/fimc-core.h>
+#endif
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 #include <media/s5p_fimc.h>
+#include <plat/fimc-core.h>
 #endif
+
 #if defined(CONFIG_VIDEO_FIMC_MIPI)
 #include <plat/csis.h>
 #elif defined(CONFIG_VIDEO_S5P_MIPI_CSIS)
@@ -75,10 +79,12 @@
 #if defined(CONFIG_VIDEO_SAMSUNG_S5P_MFC) || defined(CONFIG_VIDEO_MFC5X)
 #include <plat/s5p-mfc.h>
 #endif
-#include <media/s5k4ecgx_platform.h>
 #include <media/exynos_flite.h>
 #include <media/exynos_fimc_is.h>
 #include <video/platform_lcd.h>
+#include <media/s5k4ecgx_platform.h>
+#include <media/dohofpga_platform.h>
+#include "media/mt9m113_platform.h"
 #include <mach/board_rev.h>
 #include <mach/map.h>
 #include <mach/spi-clocks.h>
@@ -103,11 +109,6 @@
 #include <plat/fimg2d.h>
 #include <mach/dev-sysmmu.h>
 
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
-#include <plat/fimc-core.h>
-#include <media/s5p_fimc.h>
-#endif
-
 #ifdef CONFIG_VIDEO_JPEG_V2X
 #include <plat/jpeg.h>
 #endif
@@ -172,7 +173,206 @@
 
 #define WRITEBACK_ENABLED
 
-#ifdef CONFIG_VIDEO_FIMC
+#ifdef CONFIG_VIDEO_FIMC || defined(CONFIG_VIDEO_FIMC_MODULE)
+
+/* hardkernel mt9m113 */
+#if defined(CONFIG_VIDEO_MT9M113) || defined(CONFIG_VIDEO_MT9M113_MODULE)
+#warning MT9M113 code enabled
+static int hdkl_odroid_cam0_reset(int dummy)
+{
+	int err;
+	/* Camera A */
+	err = gpio_request(EXYNOS4_GPX2(7), "GPX2"); //reset
+	if (err)
+		printk(KERN_ERR "#### failed to request GPX1_2 ####\n");
+
+	err = gpio_request(EXYNOS4212_GPJ1(4), "GPJ1"); //stnby
+	if (err)
+		printk(KERN_ERR "#### failed to request GPJ1_4 ####\n");
+
+	s3c_gpio_setpull(EXYNOS4_GPX2(7), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(EXYNOS4212_GPJ1(4), S3C_GPIO_PULL_NONE);
+
+	gpio_direction_output(EXYNOS4212_GPJ1(4), 1);
+	gpio_direction_output(EXYNOS4_GPX2(7), 0);
+	msleep(50);
+	gpio_direction_output(EXYNOS4_GPX2(7), 1);
+	msleep(100);
+	gpio_direction_output(EXYNOS4212_GPJ1(4), 0);
+	
+	gpio_free(EXYNOS4_GPX2(7));
+	gpio_free(EXYNOS4212_GPJ1(4));
+	
+	printk("Cam0 Reset\n");
+	return 0;
+}
+
+static struct mt9m113_platform_data mt9m113_plat = {
+	.default_width = 1920,
+	.default_height = 1080,
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+	.freq = 24000000,
+	.is_mipi = 0,
+};
+static struct i2c_board_info mt9m113_i2c_info = {
+	I2C_BOARD_INFO("MT9M113", 0x7a>>1),
+	.platform_data = &mt9m113_plat,
+};
+
+static struct s3c_platform_camera mt9m113 = {
+
+#if defined(CONFIG_MT9M113_CSI_D)
+#define CONFIG_CSI_D
+	.id		= CAMERA_CSI_D,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_MT9M113_CSI_C)
+#define CONFIG_CSI_C
+	.id		= CAMERA_CSI_C,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_MT9M113_ITU_B)
+#define CONFIG_ITU_B
+	.id		= CAMERA_PAR_B,
+	.type		= CAM_TYPE_ITU,
+#else
+#define CONFIG_ITU_A
+	.id		= CAMERA_PAR_A,
+	.type		= CAM_TYPE_ITU,
+#endif
+
+	.clk_name	= "sclk_cam0",
+	.cam_power	= hdkl_odroid_cam0_reset,
+	.i2c_busnum = 5,
+	.fmt		= ITU_601_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_CBYCRY,
+	.info		= &mt9m113_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,
+	.srclk_name	= "xusbxti",
+
+	.clk_rate	= 24000000,
+	.line_length	= 1920,
+	.width		= 640,
+	.height		= 480,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 640,
+		.height	= 480,
+	},
+
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 24,
+
+	/* Polarity */
+	.inv_pclk	= 1,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+	.use_isp	= 0,
+	.initialized	= 0,
+};
+#endif
+
+/* dohofpga3 */
+#if defined(CONFIG_VIDEO_DOHOFPGA) || defined(CONFIG_VIDEO_DOHOFPGA_MODULE)
+#warning DOHOFPGA code enabled
+
+static int doho_odroid_cam0_reset(int dummy)
+{
+	int err;
+	/* Camera A */
+	err = gpio_request(EXYNOS4_GPX2(7), "GPX2"); //reset
+	if (err)
+		printk(KERN_ERR "#### failed to request GPX1_2 ####\n");
+
+	err = gpio_request(EXYNOS4212_GPJ1(4), "GPJ1"); //stnby
+	if (err)
+		printk(KERN_ERR "#### failed to request GPJ1_4 ####\n");
+
+	s3c_gpio_setpull(EXYNOS4_GPX2(7), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(EXYNOS4212_GPJ1(4), S3C_GPIO_PULL_NONE);
+
+	gpio_direction_output(EXYNOS4212_GPJ1(4), 1);
+	gpio_direction_output(EXYNOS4_GPX2(7), 0);
+	msleep(50);
+	gpio_direction_output(EXYNOS4_GPX2(7), 1);
+	msleep(100);
+	gpio_direction_output(EXYNOS4212_GPJ1(4), 0);
+	
+	gpio_free(EXYNOS4_GPX2(7));
+	gpio_free(EXYNOS4212_GPJ1(4));
+	
+	printk("Cam0 Reset\n");
+	return 0;
+}
+
+static struct dohofpga_platform_data dohofpga_plat = {
+	.default_width = 1920,
+	.default_height = 1080,
+	.pixelformat = V4L2_PIX_FMT_UYVY,//V4L2_PIX_FMT_GREY,//
+	.freq = 50000000,//24000000,
+	.is_mipi = 0,
+};
+static struct i2c_board_info dohofpga_i2c_info = {
+	I2C_BOARD_INFO("DOHOFPGA", 0x7a>>1),
+	.platform_data = &dohofpga_plat,
+};
+
+static struct s3c_platform_camera dohofpga = 
+{
+
+#if defined(CONFIG_DOHOFPGA_CSI_D)
+#define CONFIG_CSI_D
+	.id		= CAMERA_CSI_D,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_DOHOFPGA_CSI_C)
+#define CONFIG_CSI_C
+	.id		= CAMERA_CSI_C,
+	.type		= CAM_TYPE_MIPI,
+#elif defined(CONFIG_DOHOFPGA_ITU_B)
+#define CONFIG_ITU_B
+	.id		= CAMERA_PAR_B,
+	.type		= CAM_TYPE_ITU,
+#else
+#define CONFIG_ITU_A
+	.id		= CAMERA_PAR_A,
+	.type		= CAM_TYPE_ITU,
+#endif
+
+	.clk_name	= "sclk_cam0",
+	.cam_power	= doho_odroid_cam0_reset,
+	.i2c_busnum = 5,
+	.fmt		= ITU_601_YCBCR422_8BIT,
+	.order422	= CAM_ORDER422_8BIT_CBYCRY,
+	.info		= &dohofpga_i2c_info,
+	.pixelformat	= V4L2_PIX_FMT_UYVY,//
+	.srclk_name	= "xusbxti",
+
+	.clk_rate	= 50000000,//24000000,
+	.line_length	= 1920,
+	.width		= 640,
+	.height		= 480,
+	.window		= {
+		.left	= 0,
+		.top	= 0,
+		.width	= 640,
+		.height	= 480,
+	},
+
+	.mipi_lanes	= 2,
+	.mipi_settle	= 12,
+	.mipi_align	= 24,
+
+	/* Polarity */
+	.inv_pclk	= 1,
+	.inv_vsync	= 1,
+	.inv_href	= 0,
+	.inv_hsync	= 0,
+	.use_isp	= 0,
+	.initialized	= 0,
+};
+#endif
+
 /* hardkernel s5k4ecgx */
 #ifdef CONFIG_VIDEO_S5K4ECGX
 static int s5k4ecgx_power(int enable)
@@ -282,26 +482,44 @@
 /* Interface setting */
 static struct s3c_platform_fimc fimc_plat = {
 #ifdef CONFIG_ITU_A
+#warning default camera is PAR_A
 	.default_cam	= CAMERA_PAR_A,
 #endif
 #ifdef CONFIG_ITU_B
+#warning default camera is PAR_B
 	.default_cam	= CAMERA_PAR_B,
 #endif
 #ifdef CONFIG_CSI_C
+#warning default camera is CSI_C
 	.default_cam	= CAMERA_CSI_C,
 #endif
 #ifdef CONFIG_CSI_D
+#warning default camera is ICSI_D
 	.default_cam	= CAMERA_CSI_D,
 #endif
 #ifdef WRITEBACK_ENABLED
+#warning default camera is CAMERA_WB
 	.default_cam	= CAMERA_WB,
 #endif
 	.camera		= {
 
-#ifdef CONFIG_VIDEO_S5K4ECGX
+#ifdef CONFIG_VIDEO_S5K4ECGX || defined(CONFIG_VIDEO_S5K4ECGX_MODULE)
+#warning added s5k4ecgx
 		&s5k4ecgx,
 #endif
+
+#if defined(CONFIG_VIDEO_DOHOFPGA) || defined(CONFIG_VIDEO_DOHOFPGA_MODULE)
+#warning added dohofpga
+		&dohofpga,
+#endif
+
+#if defined(CONFIG_VIDEO_MT9M113) || defined(CONFIG_VIDEO_MT9M113_MODULE)
+#warning added mt9m113
+		&mt9m113,
+#endif
+
 #ifdef WRITEBACK_ENABLED
+#warning added writeback
 		&writeback,
 #endif
 	},
@@ -310,7 +528,7 @@
 #endif /* CONFIG_VIDEO_FIMC */
 
 /* for mainline fimc interface */
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 #ifdef WRITEBACK_ENABLED
 struct writeback_mbus_platform_data {
 	int id;
@@ -321,7 +539,6 @@
 	I2C_BOARD_INFO("writeback", 0x0),
 };
 #endif
-
 #endif /* CONFIG_VIDEO_SAMSUNG_S5P_FIMC */
 
 #ifdef CONFIG_S3C64XX_DEV_SPI
@@ -1068,18 +1285,21 @@
 	&s5p_device_mixer,
 	&s5p_device_cec,
 #endif
-#if defined(CONFIG_VIDEO_FIMC)
-	&s3c_device_fimc0,
-	&s3c_device_fimc1,
-	&s3c_device_fimc2,
-	&s3c_device_fimc3,
-/* CONFIG_VIDEO_SAMSUNG_S5P_FIMC is the feature for mainline */
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#warning setup s5p_device_fimcX devices
 	&s5p_device_fimc0,
 	&s5p_device_fimc1,
 	&s5p_device_fimc2,
 	&s5p_device_fimc3,
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+#warning setup s3c_device_fimcX devices
+	&s3c_device_fimc0,
+	&s3c_device_fimc1,
+	&s3c_device_fimc2,
+	&s3c_device_fimc3,
 #endif
+
 #if defined(CONFIG_VIDEO_FIMC_MIPI)
 	&s3c_device_csis0,
 	&s3c_device_csis1,
@@ -1202,7 +1422,7 @@
 };
 #endif
 
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 static struct s5p_fimc_isp_info isp_info[] = {
 #if defined(WRITEBACK_ENABLED)
 	{
@@ -1542,17 +1762,23 @@
 	sysmmu_set_owner(&SYSMMU_PLATDEV(mfc_l).dev, &s5p_device_mfc.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(mfc_r).dev, &s5p_device_mfc.dev);
 #endif
-#if defined(CONFIG_VIDEO_FIMC)
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#warning sysmmu_set_owner for s5p_device_fimcX
+    printk(KERN_INFO "exynos_sysmmu_init: sysmmu_set_owner for s5p_device_fimcX\n");
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s5p_device_fimc0.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s5p_device_fimc1.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s5p_device_fimc2.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s5p_device_fimc3.dev);
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+#warning sysmmu_set_owner for s3c_device_fimcX
+    printk(KERN_INFO "exynos_sysmmu_init: sysmmu_set_owner for s3c_device_fimcX\n");
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
 #endif
+
 #ifdef CONFIG_VIDEO_EXYNOS_TV
 	sysmmu_set_owner(&SYSMMU_PLATDEV(tv).dev, &s5p_device_mixer.dev);
 #endif
@@ -1815,7 +2041,12 @@
 #ifdef CONFIG_EXYNOS_THERMAL
 	exynos_tmu_set_platdata(&exynos_tmu_data);
 #endif
-#ifdef CONFIG_VIDEO_FIMC
+
+#warning expect problems here
+
+#if defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+#warning odroid_machine_init - set platformdata for s3c_device_fimcX
+    printk(KERN_INFO "odroid_machine_init: set platformdata for s3c_device_fimcX\n");
 	s3c_fimc0_set_platdata(&fimc_plat);
 	s3c_fimc1_set_platdata(&fimc_plat);
 	s3c_fimc2_set_platdata(&fimc_plat);
@@ -1829,6 +2060,7 @@
 	secmem.parent = &exynos4_device_pd[PD_CAM].dev;
 #endif
 #endif
+
 #ifdef CONFIG_VIDEO_FIMC_MIPI
 	s3c_csis0_set_platdata(NULL);
 	s3c_csis1_set_platdata(NULL);
@@ -1837,9 +2069,11 @@
 	s3c_device_csis1.dev.parent = &exynos4_device_pd[PD_CAM].dev;
 #endif
 #endif
-#endif /* CONFIG_VIDEO_FIMC */
+#endif /* if defined(CONFIG_VIDEO_FIMC) */
 
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#warning odroid_machine_init - dev_set_name for s5p_device_fimcX
+    printk(KERN_INFO "odroid_machine_init: dev_set_name for s5p_device_fimcX\n");
 	smdk4x12_camera_config();
 	smdk4x12_subdev_config();
 
diff -Naur org/arch/arm/mach-exynos/mach-smdk4x12.c ths/arch/arm/mach-exynos/mach-smdk4x12.c
--- org/arch/arm/mach-exynos/mach-smdk4x12.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/arch/arm/mach-exynos/mach-smdk4x12.c	2013-07-08 16:43:13.000000000 +0200
@@ -57,12 +57,16 @@
 #include <plat/ehci.h>
 #include <plat/usbgadget.h>
 #include <plat/s3c64xx-spi.h>
-#if defined(CONFIG_VIDEO_FIMC)
+
+#if defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
 #include <plat/fimc.h>
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
-#include <plat/fimc-core.h>
+#endif
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 #include <media/s5p_fimc.h>
+#include <plat/fimc-core.h>
 #endif
+
 #if defined(CONFIG_VIDEO_FIMC_MIPI)
 #include <plat/csis.h>
 #elif defined(CONFIG_VIDEO_S5P_MIPI_CSIS)
@@ -3142,17 +3146,16 @@
 	&s5p_device_mixer,
 	&s5p_device_cec,
 #endif
-#if defined(CONFIG_VIDEO_FIMC)
-	&s3c_device_fimc0,
-	&s3c_device_fimc1,
-	&s3c_device_fimc2,
-	&s3c_device_fimc3,
-/* CONFIG_VIDEO_SAMSUNG_S5P_FIMC is the feature for mainline */
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 	&s5p_device_fimc0,
 	&s5p_device_fimc1,
 	&s5p_device_fimc2,
 	&s5p_device_fimc3,
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+	&s3c_device_fimc0,
+	&s3c_device_fimc1,
+	&s3c_device_fimc2,
+	&s3c_device_fimc3,
 #endif
 #if defined(CONFIG_VIDEO_FIMC_MIPI)
 	&s3c_device_csis0,
@@ -3850,16 +3853,16 @@
 	sysmmu_set_owner(&SYSMMU_PLATDEV(mfc_l).dev, &s5p_device_mfc.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(mfc_r).dev, &s5p_device_mfc.dev);
 #endif
-#if defined(CONFIG_VIDEO_FIMC)
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
-#elif defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC)
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s5p_device_fimc0.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s5p_device_fimc1.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s5p_device_fimc2.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s5p_device_fimc3.dev);
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
 #endif
 #ifdef CONFIG_VIDEO_EXYNOS_TV
 	sysmmu_set_owner(&SYSMMU_PLATDEV(tv).dev, &s5p_device_mixer.dev);
@@ -4107,9 +4110,12 @@
 #ifdef CONFIG_EXYNOS_SETUP_THERMAL
 	s5p_tmu_set_platdata(&exynos_tmu_data);
 #endif
-#ifdef CONFIG_VIDEO_FIMC
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+#warning expect problems here
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
 	s3c_fimc0_set_platdata(&fimc_plat);
-	s3c_fimc1_set_platdata(&fimc_plat);
+	s3c_fimc1_set_platdata(NULL);
 	s3c_fimc2_set_platdata(&fimc_plat);
 	s3c_fimc3_set_platdata(NULL);
 #ifdef CONFIG_EXYNOS_DEV_PD
@@ -4121,6 +4127,7 @@
 	secmem.parent = &exynos4_device_pd[PD_CAM].dev;
 #endif
 #endif
+
 #ifdef CONFIG_VIDEO_FIMC_MIPI
 	s3c_csis0_set_platdata(NULL);
 	s3c_csis1_set_platdata(NULL);
@@ -4140,7 +4147,8 @@
 	|| defined(CONFIG_S5K6A3_CSI_D)
 	smdk4x12_cam1_reset(1);
 #endif
-#endif /* CONFIG_VIDEO_FIMC */
+
+#endif /* if defined(ONFIG_VIDEO_SAMSUNG_S5P_FIMC) */
 
 #ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
 	smdk4x12_camera_config();
diff -Naur org/arch/arm/mach-exynos/mach-smdkv310.c ths/arch/arm/mach-exynos/mach-smdkv310.c
--- org/arch/arm/mach-exynos/mach-smdkv310.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/arch/arm/mach-exynos/mach-smdkv310.c	2013-07-08 16:15:42.000000000 +0200
@@ -47,13 +47,16 @@
 #include <plat/devs.h>
 #include <plat/fb.h>
 #include <plat/fb-s5p.h>
-#ifdef CONFIG_VIDEO_FIMC
+
+#if defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
 #include <plat/fimc.h>
 #endif
-#ifdef CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 #include <media/s5p_fimc.h>
 #include <plat/fimc-core.h>
 #endif
+
 #ifdef CONFIG_VIDEO_FIMC_MIPI
 #include <plat/csis.h>
 #endif
@@ -1873,7 +1876,12 @@
 #ifdef CONFIG_WAKEUP_ASSIST
 	&wakeup_assist_device,
 #endif
-#ifdef CONFIG_VIDEO_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+	&s5p_device_fimc0,
+	&s5p_device_fimc1,
+	&s5p_device_fimc2,
+	&s5p_device_fimc3,
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
 	&s3c_device_fimc0,
 	&s3c_device_fimc1,
 	&s3c_device_fimc2,
@@ -2303,16 +2311,16 @@
 	ASSIGN_SYSMMU_POWERDOMAIN(tv, &exynos4_device_pd[PD_TV].dev);
 	ASSIGN_SYSMMU_POWERDOMAIN(mfc_l, &exynos4_device_pd[PD_MFC].dev);
 	ASSIGN_SYSMMU_POWERDOMAIN(mfc_r, &exynos4_device_pd[PD_MFC].dev);
-#if defined CONFIG_VIDEO_FIMC
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
-	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
-#elif defined CONFIG_VIDEO_SAMSUNG_S5P_FIMC
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s5p_device_fimc0.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s5p_device_fimc1.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s5p_device_fimc2.dev);
 	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s5p_device_fimc3.dev);
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc0).dev, &s3c_device_fimc0.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc1).dev, &s3c_device_fimc1.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc2).dev, &s3c_device_fimc2.dev);
+	sysmmu_set_owner(&SYSMMU_PLATDEV(fimc3).dev, &s3c_device_fimc3.dev);
 #endif
 #ifdef CONFIG_VIDEO_JPEG
 	sysmmu_set_owner(&SYSMMU_PLATDEV(jpeg).dev, &s5p_device_jpeg.dev);
@@ -2456,7 +2464,22 @@
 	s3c24xx_ts1_set_platdata(&s3c_ts_platform);
 #endif
 #endif
-#ifdef CONFIG_VIDEO_FIMC
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
+	s5p_fimc0_set_platdata(&fimc_plat);
+	s5p_fimc1_set_platdata(NULL);
+	s5p_fimc2_set_platdata(&fimc_plat);
+	s5p_fimc3_set_platdata(NULL);
+#ifdef CONFIG_EXYNOS_DEV_PD
+	s5p_device_fimc0.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s5p_device_fimc1.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s5p_device_fimc2.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+	s5p_device_fimc3.dev.parent = &exynos4_device_pd[PD_CAM].dev;
+#ifdef CONFIG_EXYNOS4_CONTENT_PATH_PROTECTION
+	secmem.parent = &exynos4_device_pd[PD_CAM].dev;
+#endif
+#endif
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
 	s3c_fimc0_set_platdata(&fimc_plat);
 	s3c_fimc1_set_platdata(NULL);
 	s3c_fimc2_set_platdata(&fimc_plat);
@@ -2470,6 +2493,8 @@
 	secmem.parent = &exynos4_device_pd[PD_CAM].dev;
 #endif
 #endif
+#endif
+
 #ifdef CONFIG_VIDEO_FIMC_MIPI
 	s3c_csis0_set_platdata(NULL);
 	s3c_csis1_set_platdata(NULL);
diff -Naur org/arch/arm/plat-s5p/dev-fimc-s5p.c ths/arch/arm/plat-s5p/dev-fimc-s5p.c
--- org/arch/arm/plat-s5p/dev-fimc-s5p.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/arch/arm/plat-s5p/dev-fimc-s5p.c	2013-07-17 10:33:18.000000000 +0200
@@ -1,7 +1,7 @@
 /* linux/arch/arm/plat-s5p/dev-fimc-s5p.c
  *
  * Copyright (c) 2011 Samsung Electronics Co., Ltd.
- *		http://www.samsung.com/
+ * http://www.samsung.com/
  *
  * Device definition for FIMC device
  *
@@ -19,206 +19,282 @@
 #include <plat/cpu.h>
 #include <plat/fimc.h>
 
-static struct resource s3c_fimc0_resource[] = {
-	[0] = {
-		.start	= S5P_PA_FIMC0,
-		.end	= S5P_PA_FIMC0 + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_FIMC0,
-		.end	= IRQ_FIMC0,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device s3c_device_fimc0 = {
-	.name		= "s3c-fimc",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(s3c_fimc0_resource),
-	.resource	= s3c_fimc0_resource,
-};
-
-static struct s3c_platform_fimc default_fimc0_data __initdata = {
-	.default_cam	= CAMERA_PAR_A,
-	.hw_ver = 0x51,
+static struct resource s3c_fimc0_resource[] =
+{
+  [0] = 
+  {
+    .start  = S5P_PA_FIMC0,
+    .end    = S5P_PA_FIMC0 + SZ_4K - 1,
+    .flags  = IORESOURCE_MEM,
+  },
+  [1] =
+  {
+    .start  = IRQ_FIMC0,
+    .end    = IRQ_FIMC0,
+    .flags  = IORESOURCE_IRQ,
+  },
 };
 
-void __init s3c_fimc0_set_platdata(struct s3c_platform_fimc *pd)
+struct platform_device s3c_device_fimc0 =
 {
-	struct s3c_platform_fimc *npd;
+  .name           = "s3c-fimc",
+  .id             = 0,
+  .num_resources  = ARRAY_SIZE(s3c_fimc0_resource),
+  .resource       = s3c_fimc0_resource,
+};
 
-	if (!pd)
-		pd = &default_fimc0_data;
+static struct s3c_platform_fimc default_fimc0_data __initdata = 
+{
+  .default_cam  = CAMERA_PAR_A,
+  .hw_ver       = 0x51,
+};
 
-	npd = kmemdup(pd, sizeof(struct s3c_platform_fimc), GFP_KERNEL);
-	if (!npd)
-		printk(KERN_ERR "%s: no memory for platform data\n", __func__);
-	else {
-		if (!npd->cfg_gpio)
-			npd->cfg_gpio = s3c_fimc0_cfg_gpio;
-
-		if (!npd->clk_on)
-			npd->clk_on = s3c_fimc_clk_on;
-
-		if (!npd->clk_off)
-			npd->clk_off = s3c_fimc_clk_off;
-
-		npd->hw_ver = 0x51;
-		npd->use_cam = true;
-		s3c_device_fimc0.dev.platform_data = npd;
-	}
+void __init s3c_fimc0_set_platdata(struct s3c_platform_fimc *pd)
+{
+  struct s3c_platform_fimc *npd;
+  int i,c;
+
+  if (!pd)
+  {
+    printk(KERN_INFO "%s: empty data, using default", __func__);
+    pd = &default_fimc0_data;
+  }
+  else
+  {
+    printk(KERN_INFO "%s: setup from given fimc data", __func__);
+  }
+
+  npd = kmemdup(pd, sizeof(struct s3c_platform_fimc), GFP_KERNEL);
+  if (!npd)
+  {
+    printk(KERN_ERR "%s: no memory for platform data\n", __func__);
+    return ;
+  }
+
+  c=0 ;
+  for ( i=0 ; i<FIMC_CAMENTRIES ; i++ ) if (npd->camera[i] != NULL) c++ ;
+  printk(KERN_INFO "%s: setup with %d camera(s)", __func__);
+
+  if (!npd->cfg_gpio)
+    npd->cfg_gpio = s3c_fimc0_cfg_gpio;
+
+  if (!npd->clk_on)
+    npd->clk_on = s3c_fimc_clk_on;
+
+  if (!npd->clk_off)
+    npd->clk_off = s3c_fimc_clk_off;
+
+  npd->hw_ver = 0x51;
+  npd->use_cam = FIMC0_USECAM;
+  s3c_device_fimc0.dev.platform_data = npd;
 }
 
-static struct resource s3c_fimc1_resource[] = {
-	[0] = {
-		.start	= S5P_PA_FIMC1,
-		.end	= S5P_PA_FIMC1 + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_FIMC1,
-		.end	= IRQ_FIMC1,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device s3c_device_fimc1 = {
-	.name		= "s3c-fimc",
-	.id		= 1,
-	.num_resources	= ARRAY_SIZE(s3c_fimc1_resource),
-	.resource	= s3c_fimc1_resource,
-};
-
-static struct s3c_platform_fimc default_fimc1_data __initdata = {
-	.default_cam	= CAMERA_PAR_A,
-	.hw_ver = 0x51,
+static struct resource s3c_fimc1_resource[] =
+{
+  [0] = 
+  {
+    .start  = S5P_PA_FIMC1,
+    .end    = S5P_PA_FIMC1 + SZ_4K - 1,
+    .flags  = IORESOURCE_MEM,
+  },
+  [1] =
+  {
+    .start  = IRQ_FIMC1,
+    .end    = IRQ_FIMC1,
+    .flags  = IORESOURCE_IRQ,
+  },
 };
 
-void __init s3c_fimc1_set_platdata(struct s3c_platform_fimc *pd)
+struct platform_device s3c_device_fimc1 =
+{
+  .name           = "s3c-fimc",
+  .id             = 1,
+  .num_resources  = ARRAY_SIZE(s3c_fimc1_resource),
+  .resource       = s3c_fimc1_resource,
+};
+
+static struct s3c_platform_fimc default_fimc1_data __initdata = 
 {
-	struct s3c_platform_fimc *npd;
+  .default_cam  = CAMERA_PAR_A,
+  .hw_ver       = 0x51,
+};
 
-	if (!pd)
-		pd = &default_fimc1_data;
+void __init s3c_fimc1_set_platdata(struct s3c_platform_fimc *pd)
+{
+  struct s3c_platform_fimc *npd;
+  int i,c;
 
-	npd = kmemdup(pd, sizeof(struct s3c_platform_fimc), GFP_KERNEL);
-	if (!npd)
-		printk(KERN_ERR "%s: no memory for platform data\n", __func__);
-	else {
-		if (!npd->cfg_gpio)
-			npd->cfg_gpio = s3c_fimc1_cfg_gpio;
-
-		if (!npd->clk_on)
-			npd->clk_on = s3c_fimc_clk_on;
-
-		if (!npd->clk_off)
-			npd->clk_off = s3c_fimc_clk_off;
-
-		npd->hw_ver = 0x51;
-		npd->use_cam = false;
-		s3c_device_fimc1.dev.platform_data = npd;
-	}
+  if (!pd)
+  {
+    printk(KERN_INFO "%s: empty data, using default", __func__);
+    pd = &default_fimc1_data;
+  }
+  else
+  {
+    printk(KERN_INFO "%s: setup from given fimc data", __func__);
+  }
+
+  npd = kmemdup(pd, sizeof(struct s3c_platform_fimc), GFP_KERNEL);
+  if (!npd)
+  {
+    printk(KERN_ERR "%s: no memory for platform data\n", __func__);
+    return ;
+  }
+
+  c=0 ;
+  for ( i=0 ; i<FIMC_CAMENTRIES ; i++ ) if (npd->camera[i] != NULL) c++ ;
+  printk(KERN_INFO "%s: setup with %d camera(s)", __func__);
+
+  if (!npd->cfg_gpio)
+    npd->cfg_gpio = s3c_fimc1_cfg_gpio;
+
+  if (!npd->clk_on)
+    npd->clk_on = s3c_fimc_clk_on;
+
+  if (!npd->clk_off)
+    npd->clk_off = s3c_fimc_clk_off;
+
+  npd->hw_ver = 0x51;
+  npd->use_cam = FIMC1_USECAM;
+  s3c_device_fimc1.dev.platform_data = npd;
 }
 
-static struct resource s3c_fimc2_resource[] = {
-	[0] = {
-		.start	= S5P_PA_FIMC2,
-		.end	= S5P_PA_FIMC2 + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_FIMC2,
-		.end	= IRQ_FIMC2,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device s3c_device_fimc2 = {
-	.name		= "s3c-fimc",
-	.id		= 2,
-	.num_resources	= ARRAY_SIZE(s3c_fimc2_resource),
-	.resource	= s3c_fimc2_resource,
-};
-
-static struct s3c_platform_fimc default_fimc2_data __initdata = {
-	.default_cam	= CAMERA_PAR_A,
-	.hw_ver	= 0x51,
+static struct resource s3c_fimc2_resource[] =
+{
+  [0] = 
+  {
+    .start  = S5P_PA_FIMC2,
+    .end    = S5P_PA_FIMC2 + SZ_4K - 1,
+    .flags  = IORESOURCE_MEM,
+  },
+  [1] =
+  {
+    .start  = IRQ_FIMC2,
+    .end    = IRQ_FIMC2,
+    .flags  = IORESOURCE_IRQ,
+  },
 };
 
-void __init s3c_fimc2_set_platdata(struct s3c_platform_fimc *pd)
+struct platform_device s3c_device_fimc2 =
+{
+  .name           = "s3c-fimc",
+  .id             = 2,
+  .num_resources  = ARRAY_SIZE(s3c_fimc2_resource),
+  .resource       = s3c_fimc2_resource,
+};
+
+static struct s3c_platform_fimc default_fimc2_data __initdata = 
 {
-	struct s3c_platform_fimc *npd;
+  .default_cam  = CAMERA_PAR_A,
+  .hw_ver       = 0x51,
+};
 
-	if (!pd)
-		pd = &default_fimc2_data;
+void __init s3c_fimc2_set_platdata(struct s3c_platform_fimc *pd)
+{
+  struct s3c_platform_fimc *npd;
+  int i,c;
 
-	npd = kmemdup(pd, sizeof(struct s3c_platform_fimc), GFP_KERNEL);
-	if (!npd)
-		printk(KERN_ERR "%s: no memory for platform data\n", __func__);
-	else {
-		if (!npd->cfg_gpio)
-			npd->cfg_gpio = s3c_fimc2_cfg_gpio;
-
-		if (!npd->clk_on)
-			npd->clk_on = s3c_fimc_clk_on;
-
-		if (!npd->clk_off)
-			npd->clk_off = s3c_fimc_clk_off;
-
-		npd->hw_ver = 0x51;
-		npd->use_cam = false;
-		s3c_device_fimc2.dev.platform_data = npd;
-	}
+  if (!pd)
+  {
+    printk(KERN_INFO "%s: empty data, using default", __func__);
+    pd = &default_fimc2_data;
+  }
+  else
+  {
+    printk(KERN_INFO "%s: setup from given fimc data", __func__);
+  }
+
+  npd = kmemdup(pd, sizeof(struct s3c_platform_fimc), GFP_KERNEL);
+  if (!npd)
+  {
+    printk(KERN_ERR "%s: no memory for platform data\n", __func__);
+    return ;
+  }
+
+  c=0 ;
+  for ( i=0 ; i<FIMC_CAMENTRIES ; i++ ) if (npd->camera[i] != NULL) c++ ;
+  printk(KERN_INFO "%s: setup with %d camera(s)", __func__);
+
+  if (!npd->cfg_gpio)
+    npd->cfg_gpio = s3c_fimc2_cfg_gpio;
+
+  if (!npd->clk_on)
+    npd->clk_on = s3c_fimc_clk_on;
+
+  if (!npd->clk_off)
+    npd->clk_off = s3c_fimc_clk_off;
+
+  npd->hw_ver = 0x51;
+  npd->use_cam = FIMC2_USECAM;
+  s3c_device_fimc2.dev.platform_data = npd;
 }
 
-static struct resource s3c_fimc3_resource[] = {
-	[0] = {
-		.start	= S5P_PA_FIMC3,
-		.end	= S5P_PA_FIMC3 + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_FIMC3,
-		.end	= IRQ_FIMC3,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device s3c_device_fimc3 = {
-	.name		= "s3c-fimc",
-	.id		= 3,
-	.num_resources	= ARRAY_SIZE(s3c_fimc3_resource),
-	.resource	= s3c_fimc3_resource,
-};
-
-static struct s3c_platform_fimc default_fimc3_data __initdata = {
-	.default_cam	= CAMERA_PAR_A,
-	.hw_ver	= 0x51,
+static struct resource s3c_fimc3_resource[] =
+{
+  [0] = 
+  {
+    .start  = S5P_PA_FIMC3,
+    .end    = S5P_PA_FIMC3 + SZ_4K - 1,
+    .flags  = IORESOURCE_MEM,
+  },
+  [1] =
+  {
+    .start  = IRQ_FIMC3,
+    .end    = IRQ_FIMC3,
+    .flags  = IORESOURCE_IRQ,
+  },
+};
+
+struct platform_device s3c_device_fimc3 =
+{
+  .name           = "s3c-fimc",
+  .id             = 3,
+  .num_resources  = ARRAY_SIZE(s3c_fimc3_resource),
+  .resource       = s3c_fimc3_resource,
 };
 
-void __init s3c_fimc3_set_platdata(struct s3c_platform_fimc *pd)
+static struct s3c_platform_fimc default_fimc3_data __initdata = 
 {
-	struct s3c_platform_fimc *npd;
+  .default_cam  = CAMERA_PAR_A,
+  .hw_ver       = 0x51,
+};
 
-	if (!pd)
-		pd = &default_fimc3_data;
+void __init s3c_fimc3_set_platdata(struct s3c_platform_fimc *pd)
+{
+  struct s3c_platform_fimc *npd;
+  int i,c;
 
-	npd = kmemdup(pd, sizeof(struct s3c_platform_fimc), GFP_KERNEL);
-	if (!npd)
-		printk(KERN_ERR "%s: no memory for platform data\n", __func__);
-	else {
-		if (!npd->cfg_gpio)
-			npd->cfg_gpio = s3c_fimc3_cfg_gpio;
-
-		if (!npd->clk_on)
-			npd->clk_on = s3c_fimc_clk_on;
-
-		if (!npd->clk_off)
-			npd->clk_off = s3c_fimc_clk_off;
-
-		npd->hw_ver = 0x51;
-		s3c_device_fimc3.dev.platform_data = npd;
-	}
+  if (!pd)
+  {
+    printk(KERN_INFO "%s: empty data, using default", __func__);
+    pd = &default_fimc3_data;
+  }
+  else
+  {
+    printk(KERN_INFO "%s: setup from given fimc data", __func__);
+  }
+
+  npd = kmemdup(pd, sizeof(struct s3c_platform_fimc), GFP_KERNEL);
+  if (!npd)
+  {
+    printk(KERN_ERR "%s: no memory for platform data\n", __func__);
+    return ;
+  }
+
+  c=0 ;
+  for ( i=0 ; i<FIMC_CAMENTRIES ; i++ ) if (npd->camera[i] != NULL) c++ ;
+  printk(KERN_INFO "%s: setup with %d camera(s)", __func__);
+
+  if (!npd->cfg_gpio)
+    npd->cfg_gpio = s3c_fimc3_cfg_gpio;
+
+  if (!npd->clk_on)
+    npd->clk_on = s3c_fimc_clk_on;
+
+  if (!npd->clk_off)
+    npd->clk_off = s3c_fimc_clk_off;
+
+  npd->hw_ver = 0x51;
+  npd->use_cam = FIMC3_USECAM;
+  s3c_device_fimc3.dev.platform_data = npd;
 }
-
diff -Naur org/arch/arm/plat-s5p/include/plat/fimc.h ths/arch/arm/plat-s5p/include/plat/fimc.h
--- org/arch/arm/plat-s5p/include/plat/fimc.h	2013-07-03 11:10:45.000000000 +0200
+++ ths/arch/arm/plat-s5p/include/plat/fimc.h	2013-07-17 13:42:09.000000000 +0200
@@ -18,6 +18,20 @@
 #define FIMC_SRC_MAX_H		4224
 #define FLITE_MAX_NUM		2
 
+#define FIMC0_USECAM      true
+#define FIMC1_USECAM      true
+#define FIMC2_USECAM      true
+#define FIMC3_USECAM      true
+
+#ifdef CONFIG_ARCH_EXYNOS4
+#define FIMC_CAMENTRIES      7
+#else
+#define FIMC_CAMENTRIES      5
+#endif
+
+
+
+
 struct platform_device;
 
 /* For exnternal camera device */
@@ -56,10 +70,14 @@
 	CAMERA_PATTERN	= 6,
 };
 
+#if defined(CONFIG_VIDEO_FIMC)
+#include <media/s5p_fimc.h>
+#else
 enum flite_index {
 	FLITE_IDX_A = 0,
 	FLITE_IDX_B = 1,
 };
+#endif
 
 /* struct s3c_platform_camera: abstraction for input camera */
 struct s3c_platform_camera {
@@ -111,11 +129,7 @@
 /* For camera interface driver */
 struct s3c_platform_fimc {
 	enum fimc_cam_index		default_cam;		/* index of default cam */
-#ifdef CONFIG_ARCH_EXYNOS4
-	struct s3c_platform_camera	*camera[7];		/* FIXME */
-#else
-	struct s3c_platform_camera	*camera[5];		/* FIXME */
-#endif
+	struct s3c_platform_camera	*camera[FIMC_CAMENTRIES]; /* FIXME BETTER */
 	int				hw_ver;
 	bool				use_cam;
 
diff -Naur org/arch/arm/plat-samsung/include/plat/cpu.h ths/arch/arm/plat-samsung/include/plat/cpu.h
--- org/arch/arm/plat-samsung/include/plat/cpu.h	2013-07-05 08:28:14.000000000 +0200
+++ ths/arch/arm/plat-samsung/include/plat/cpu.h	2013-07-09 17:51:08.000000000 +0200
@@ -18,8 +18,16 @@
 #ifndef __SAMSUNG_PLAT_CPU_H
 #define __SAMSUNG_PLAT_CPU_H
 
+#if defined(MODULE)
+
+#define samsung_cpu_id 0
+
+#else 
+
 extern unsigned long samsung_cpu_id;
 
+#endif
+
 #define S3C24XX_CPU_ID		0x32400000
 #define S3C24XX_CPU_MASK	0xFFF00000
 
diff -Naur org/arch/arm/plat-samsung/include/plat/devs.h ths/arch/arm/plat-samsung/include/plat/devs.h
--- org/arch/arm/plat-samsung/include/plat/devs.h	2013-07-05 08:28:14.000000000 +0200
+++ ths/arch/arm/plat-samsung/include/plat/devs.h	2013-07-08 15:14:57.000000000 +0200
@@ -169,17 +169,19 @@
 extern struct platform_device s5pc100_device_spdif;
 
 extern struct platform_device samsung_device_keypad;
-#ifndef CONFIG_VIDEO_FIMC
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) || defined(CONFIG_VIDEO_SAMSUNG_S5P_FIMC_MODULE)
 extern struct platform_device s5p_device_fimc0;
 extern struct platform_device s5p_device_fimc1;
 extern struct platform_device s5p_device_fimc2;
 extern struct platform_device s5p_device_fimc3;
-#else
+#elif defined(CONFIG_VIDEO_FIMC) || defined(CONFIG_VIDEO_FIMC_MODULE)
 extern struct platform_device s3c_device_fimc0;
 extern struct platform_device s3c_device_fimc1;
 extern struct platform_device s3c_device_fimc2;
 extern struct platform_device s3c_device_fimc3;
 #endif
+
 #ifndef CONFIG_VIDEO_FIMC_MIPI
 extern struct platform_device s5p_device_mipi_csis0;
 extern struct platform_device s5p_device_mipi_csis1;
diff -Naur org/drivers/dma/Kconfig ths/drivers/dma/Kconfig
--- org/drivers/dma/Kconfig	2013-07-03 09:28:57.000000000 +0200
+++ ths/drivers/dma/Kconfig	2013-07-09 11:31:28.000000000 +0200
@@ -193,7 +193,7 @@
 config PL330_DMA
 	tristate "DMA API Driver for PL330"
 	select DMA_ENGINE
-	depends on PL330
+	depends on PL330 && ARM_AMBA
 	help
 	  Select if your platform has one or more PL330 DMACs.
 	  You need to provide platform specific settings via
diff -Naur org/drivers/media/video/ar0832.c ths/drivers/media/video/ar0832.c
--- org/drivers/media/video/ar0832.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/drivers/media/video/ar0832.c	2013-07-08 12:25:59.000000000 +0200
@@ -24,8 +24,13 @@
 #include <linux/videodev2.h>
 #include <linux/slab.h>
 
-#ifdef CONFIG_VIDEO_SAMSUNG_V4L2
+#if defined(CONFIG_VIDEO_SAMSUNG_V4L2) || (defined(CONFIG_VIDEO_SAMSUNG_V4L2_MODULE) && defined(MODULE))
 #include <linux/videodev2_samsung.h>
+#include <linux/videodev2_exynos_camera.h>
+#ifndef V4L2_CID_CAMERA_AUTO_FOCUS_RESULT
+#define V4L2_CID_CAMERA_AUTO_FOCUS_RESULT V4L2_CID_CAMERA_AUTO_FOCUS_RESULT_FIRST
+#warning using V4L2_CID_CAMERA_AUTO_FOCUS_RESULT_FIRST to define V4L2_CID_CAMERA_AUTO_FOCUS_RESULT 
+#endif
 #endif
 
 #include <linux/regulator/machine.h>
diff -Naur org/drivers/media/video/ar0832.h ths/drivers/media/video/ar0832.h
--- org/drivers/media/video/ar0832.h	1970-01-01 01:00:00.000000000 +0100
+++ ths/drivers/media/video/ar0832.h	2013-07-05 08:28:14.000000000 +0200
@@ -0,0 +1,756 @@
+/*
+ * Driver for AR0832 (8MP Camera) from Aptina
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __AR0832_H
+#define __AR0832_H
+
+#define CONFIG_CAM_DEBUG	1
+
+#define cam_warn(fmt, ...)	\
+	do { \
+		printk(KERN_WARNING "%s: " fmt, __func__, ##__VA_ARGS__); \
+	} while (0)
+
+#define cam_err(fmt, ...)	\
+	do { \
+		printk(KERN_ERR "%s: " fmt, __func__, ##__VA_ARGS__); \
+	} while (0)
+
+#define cam_info(fmt, ...)	\
+	do { \
+		printk(KERN_INFO "%s: " fmt, __func__, ##__VA_ARGS__); \
+	} while (0)
+
+#ifdef CONFIG_CAM_DEBUG
+#define CAM_DEBUG	(1 << 0)
+#define CAM_TRACE	(1 << 1)
+#define CAM_I2C		(1 << 2)
+
+#define cam_dbg(fmt, ...)	\
+	do { \
+		if (to_state(sd)->dbg_level & CAM_DEBUG) \
+			printk(KERN_DEBUG "%s: " fmt, __func__, ##__VA_ARGS__); \
+	} while (0)
+
+#define cam_trace(fmt, ...)	\
+	do { \
+		if (to_state(sd)->dbg_level & CAM_TRACE) \
+			printk(KERN_DEBUG "%s: " fmt, __func__, ##__VA_ARGS__); \
+	} while (0)
+
+#define cam_i2c_dbg(fmt, ...)	\
+	do { \
+		if (to_state(sd)->dbg_level & CAM_I2C) \
+			printk(KERN_DEBUG "%s: " fmt, __func__, ##__VA_ARGS__); \
+	} while (0)
+#else
+#define cam_dbg(fmt, ...)
+#define cam_trace(fmt, ...)
+#define cam_i2c_dbg(fmt, ...)
+#endif
+
+enum ar0832_prev_frmsize {
+	AR0832_PREVIEW_QCIF,
+	AR0832_PREVIEW_QCIF2,
+	AR0832_PREVIEW_QVGA,
+	AR0832_PREVIEW_VGA,
+	AR0832_PREVIEW_D1,
+	AR0832_PREVIEW_WVGA,
+	AR0832_PREVIEW_720P,
+	AR0832_PREVIEW_1080P,
+	AR0832_PREVIEW_HDR,
+};
+
+enum ar0832_cap_frmsize {
+	AR0832_CAPTURE_VGA,	/* 640 x 480 */
+	AR0832_CAPTURE_WVGA,	/* 800 x 480 */
+	AR0832_CAPTURE_W1MP,	/* 1600 x 960 */
+	AR0832_CAPTURE_2MP,	/* UXGA - 1600 x 1200 */
+	AR0832_CAPTURE_W2MP,	/* 2048 x 1232 */
+	AR0832_CAPTURE_3MP,	/* QXGA - 2048 x 1536 */
+	AR0832_CAPTURE_W4MP,	/* WQXGA - 2560 x 1536 */
+	AR0832_CAPTURE_5MP,	/* 2560 x 1920 */
+	AR0832_CAPTURE_W6MP,	/* 3072 x 1856 */
+	AR0832_CAPTURE_7MP,	/* 3072 x 2304 */
+	AR0832_CAPTURE_W7MP,	/* WQXGA - 2560 x 1536 */
+	AR0832_CAPTURE_8MP,	/* 3264 x 2448 */
+};
+
+struct ar0832_control {
+	u32 id;
+	s32 value;
+	s32 minimum;		/* Note signedness */
+	s32 maximum;
+	s32 step;
+	s32 default_value;
+};
+
+struct ar0832_frmsizeenum {
+	unsigned int index;
+	unsigned int width;
+	unsigned int height;
+	u8 reg_val;		/* a value for category parameter */
+};
+
+struct ar0832_isp {
+	wait_queue_head_t wait;
+	unsigned int irq;	/* irq issued by ISP */
+	unsigned int issued;
+	unsigned int int_factor;
+	unsigned int bad_fw:1;
+};
+
+struct ar0832_jpeg {
+	int quality;
+	unsigned int main_size;	/* Main JPEG file size */
+	unsigned int thumb_size;	/* Thumbnail file size */
+	unsigned int main_offset;
+	unsigned int thumb_offset;
+	unsigned int postview_offset;
+};
+
+struct ar0832_focus {
+	unsigned int mode;
+	unsigned int lock;
+	unsigned int status;
+	unsigned int touch;
+	unsigned int pos_x;
+	unsigned int pos_y;
+};
+
+struct ar0832_exif {
+	char unique_id[7];
+	u32 exptime;		/* us */
+	u16 flash;
+	u16 iso;
+	int tv;			/* shutter speed */
+	int bv;			/* brightness */
+	int ebv;		/* exposure bias */
+};
+
+struct ar0832_state {
+	struct ar0832_platform_data *pdata;
+	struct v4l2_subdev sd;
+
+	struct ar0832_isp isp;
+
+	const struct ar0832_frmsizeenum *preview;
+	const struct ar0832_frmsizeenum *capture;
+
+	enum v4l2_pix_format_mode format_mode;
+	enum v4l2_sensor_mode sensor_mode;
+	enum v4l2_flash_mode flash_mode;
+	int vt_mode;
+	int beauty_mode;
+	int zoom;
+
+	unsigned int fps;
+	struct ar0832_focus focus;
+
+	struct ar0832_jpeg jpeg;
+	struct ar0832_exif exif;
+
+	int check_dataline;
+	char *fw_version;
+
+#ifdef CONFIG_CAM_DEBUG
+	u8 dbg_level;
+#endif
+struct i2c_client *this_client;
+
+};
+
+/* Category */
+#define AR0832_CATEGORY_SYS	0x00
+#define AR0832_CATEGORY_PARM	0x01
+#define AR0832_CATEGORY_MON	0x02
+#define AR0832_CATEGORY_AE	0x03
+#define AR0832_CATEGORY_WB	0x06
+#define AR0832_CATEGORY_EXIF	0x07
+#define AR0832_CATEGORY_FD	0x09
+#define AR0832_CATEGORY_LENS	0x0A
+#define AR0832_CATEGORY_CAPPARM	0x0B
+#define AR0832_CATEGORY_CAPCTRL	0x0C
+#define AR0832_CATEGORY_TEST	0x0D
+#define AR0832_CATEGORY_ADJST	0x0E
+#define AR0832_CATEGORY_FLASH	0x0F    /* F/W update */
+
+/* AR0832_CATEGORY_SYS: 0x00 */
+#define AR0832_SYS_PJT_CODE	0x01
+#define AR0832_SYS_VER_FW		0x02
+#define AR0832_SYS_VER_HW		0x04
+#define AR0832_SYS_VER_PARAM	0x06
+#define AR0832_SYS_VER_AWB	0x08
+#define AR0832_SYS_USER_VER	0x0A
+#define AR0832_SYS_MODE		0x0B
+#define AR0832_SYS_ESD_INT	0x0E
+#define AR0832_SYS_INT_FACTOR	0x10
+#define AR0832_SYS_INT_EN		0x11
+#define AR0832_SYS_ROOT_EN	0x12
+
+/* AR0832_CATEGORY_PARAM: 0x01 */
+#define AR0832_PARM_OUT_SEL	0x00
+#define AR0832_PARM_MON_SIZE	0x01
+#define AR0832_PARM_EFFECT	0x0B
+#define AR0832_PARM_FLEX_FPS	0x31
+#define AR0832_PARM_HDMOVIE	0x32
+#define AR0832_PARM_HDR_MON	0x39
+#define AR0832_PARM_HDR_MON_OFFSET_EV	0x3A
+
+/* AR0832_CATEGORY_MON: 0x02 */
+#define AR0832_MON_ZOOM		0x01
+#define AR0832_MON_MON_REVERSE	0x05
+#define AR0832_MON_MON_MIRROR	0x06
+#define AR0832_MON_SHOT_REVERSE	0x07
+#define AR0832_MON_SHOT_MIRROR	0x08
+#define AR0832_MON_CFIXB		0x09
+#define AR0832_MON_CFIXR		0x0A
+#define AR0832_MON_COLOR_EFFECT	0x0B
+#define AR0832_MON_CHROMA_LVL	0x0F
+#define AR0832_MON_EDGE_LVL	0x11
+#define AR0832_MON_TONE_CTRL	0x25
+
+/* AR0832_CATEGORY_AE: 0x03 */
+#define AR0832_AE_LOCK		0x00
+#define AR0832_AE_MODE		0x01
+#define AR0832_AE_ISOSEL		0x05
+#define AR0832_AE_FLICKER		0x06
+#define AR0832_AE_EP_MODE_MON	0x0A
+#define AR0832_AE_EP_MODE_CAP	0x0B
+#define AR0832_AE_ONESHOT_MAX_EXP	0x36
+#define AR0832_AE_INDEX		0x38
+
+/* AR0832_CATEGORY_WB: 0x06 */
+#define AR0832_AWB_LOCK		0x00
+#define AR0832_WB_AWB_MODE	0x02
+#define AR0832_WB_AWB_MANUAL	0x03
+
+/* AR0832_CATEGORY_EXIF: 0x07 */
+#define AR0832_EXIF_EXPTIME_NUM	0x00
+#define AR0832_EXIF_EXPTIME_DEN	0x04
+#define AR0832_EXIF_TV_NUM	0x08
+#define AR0832_EXIF_TV_DEN	0x0C
+#define AR0832_EXIF_BV_NUM	0x18
+#define AR0832_EXIF_BV_DEN	0x1C
+#define AR0832_EXIF_EBV_NUM	0x20
+#define AR0832_EXIF_EBV_DEN	0x24
+#define AR0832_EXIF_ISO		0x28
+#define AR0832_EXIF_FLASH		0x2A
+
+/* AR0832_CATEGORY_FD: 0x09 */
+#define AR0832_FD_CTL		0x00
+#define AR0832_FD_SIZE		0x01
+#define AR0832_FD_MAX		0x02
+
+/* AR0832_CATEGORY_LENS: 0x0A */
+#define AR0832_LENS_AF_MODE	0x01
+#define AR0832_LENS_AF_START	0x02
+#define AR0832_LENS_AF_STATUS	0x03
+#define AR0832_LENS_AF_UPBYTE_STEP	0x06
+#define AR0832_LENS_AF_LOWBYTE_STEP	0x07
+#define AR0832_LENS_AF_CAL	0x1D
+#define AR0832_LENS_AF_TOUCH_POSX	0x30
+#define AR0832_LENS_AF_TOUCH_POSY	0x32
+
+/* AR0832_CATEGORY_CAPPARM: 0x0B */
+#define AR0832_CAPPARM_YUVOUT_MAIN	0x00
+#define AR0832_CAPPARM_MAIN_IMG_SIZE	0x01
+#define AR0832_CAPPARM_YUVOUT_PREVIEW	0x05
+#define AR0832_CAPPARM_PREVIEW_IMG_SIZE	0x06
+#define AR0832_CAPPARM_YUVOUT_THUMB	0x0A
+#define AR0832_CAPPARM_THUMB_IMG_SIZE	0x0B
+#define AR0832_CAPPARM_JPEG_SIZE_MAX	0x0F
+#define AR0832_CAPPARM_JPEG_RATIO		0x17
+#define AR0832_CAPPARM_MCC_MODE		0x1D
+#define AR0832_CAPPARM_WDR_EN		0x2C
+#define AR0832_CAPPARM_LIGHT_CTRL		0x40
+#define AR0832_CAPPARM_FLASH_CTRL		0x41
+#define AR0832_CAPPARM_JPEG_RATIO_OFS	0x34
+#define AR0832_CAPPARM_THUMB_JPEG_MAX	0x3C
+#define AR0832_CAPPARM_AFB_CAP_EN		0x53
+
+/* AR0832_CATEGORY_CAPCTRL: 0x0C */
+#define AR0832_CAPCTRL_FRM_SEL	0x06
+#define AR0832_CAPCTRL_TRANSFER	0x09
+#define AR0832_CAPCTRL_IMG_SIZE	0x0D
+#define AR0832_CAPCTRL_THUMB_SIZE	0x11
+
+/* AR0832_CATEGORY_ADJST: 0x0E */
+#define AR0832_ADJST_AWB_RG_H	0x3B
+#define AR0832_ADJST_AWB_RG_L	0x3D
+#define AR0832_ADJST_AWB_BG_H	0x3E
+#define AR0832_ADJST_AWB_BG_L	0x3F
+
+/* AR0832_CATEGORY_FLASH: 0x0F */
+#define AR0832_FLASH_ADDR		0x00
+#define AR0832_FLASH_BYTE		0x04
+#define AR0832_FLASH_ERASE	0x06
+#define AR0832_FLASH_WR		0x07
+#define AR0832_FLASH_RAM_CLEAR	0x08
+#define AR0832_FLASH_CAM_START	0x12
+#define AR0832_FLASH_SEL		0x13
+
+/* AR0832_CATEGORY_TEST:	0x0D */
+#define AR0832_TEST_OUTPUT_YCO_TEST_DATA		0x1B
+#define AR0832_TEST_ISP_PROCESS			0x59
+
+/* AR0832 Sensor Mode */
+#define AR0832_SYSINIT_MODE	0x0
+#define AR0832_PARMSET_MODE	0x1
+#define AR0832_MONITOR_MODE	0x2
+#define AR0832_STILLCAP_MODE	0x3
+
+/* Interrupt Factor */
+#define AR0832_INT_SOUND		(1 << 7)
+#define AR0832_INT_LENS_INIT	(1 << 6)
+#define AR0832_INT_FD		(1 << 5)
+#define AR0832_INT_FRAME_SYNC	(1 << 4)
+#define AR0832_INT_CAPTURE	(1 << 3)
+#define AR0832_INT_ZOOM		(1 << 2)
+#define AR0832_INT_AF		(1 << 1)
+#define AR0832_INT_MODE		(1 << 0)
+
+/* ESD Interrupt */
+#define AR0832_INT_ESD		(1 << 0)
+
+/* AR0832 REG by hardkernel*/
+#define AR0832_CATEGORY_MODEL_ID	0x00
+#define AR0832_CATEGORY_REVISION_NUM	0x02
+#define AR0832_CATEGORY_MANUFACTURE_ID	0x03
+#define AR0832_CATEGORY_SMIA_VERSION	0x04
+
+
+
+
+
+/////////////////////////////////////////////////////////////////////////////////
+// History:
+// 
+//
+// V2.0 released on 2011-01-06
+// 		Changes:
+//		Added REG=3064, 0x7400 after the clock configuration.
+//		removed modification to registers 0x3ED8, 0x3EDA, 0x3EDC
+//		Modified value written in 0x316E from 0x869C to 0x869A
+//		
+// V3.0 released on 2011-01-26
+// 		Changes:
+//		Adjusted MIPI timings considering the specific Motorola frequency
+//		Added/changed values to register 0x31B0-0x31BC in  [2-lane MIPI Interface Configuration]
+//
+// V4.0 Release on 2011-03-04
+//		Changes:
+//		Modified recommended registers to minimize row noise(included in V3 Plus).
+//
+/////////////////////////////////////////////////////////////////////////////////
+
+
+
+//[MIPI 2-lane FPGA]
+//SERIAL_REG = 0xCA, 0x00, 0x8016, 8:16   // FPGA disabled
+//SERIAL_REG = 0xCA, 0x00, 0x0016, 8:16   // FPGA into MIPI dual lane mode
+
+
+
+//[Start Streaming]
+static unsigned short ar0832_reg_start_streaming1_3[]={	
+0x301A, 0x200, 1,	//MASK_BAD_Frames
+0x301A, 0x400, 1,	//Restart_bad_frames
+0x301A, 0x8, 1,		//Lock_Register
+};
+static unsigned short ar0832_reg_start_streaming2[]={	
+0x0104, 0x00,		//GROUPED_PARAMETER_HOLD
+};
+static unsigned short ar0832_reg_start_streaming3_3[]={	
+0x301A, 0x4, 1,		//Start_Streaming
+};
+//STATE= Detect Master Clock, 1
+
+
+//[Stop Streaming]
+static unsigned short ar0832_reg_stop_streaming1_3[]={	
+0x301A, 0x4, 0,		//Start_Streaming
+0x301A, 0x8, 0,		//Lock_Register
+};
+static unsigned short ar0832_reg_stop_streaming2[]={	
+0x0104, 0x01,		//GROUPED_PARAMETER_HOLD
+};
+
+
+//[2-lane MIPI Interface Configuration]
+static unsigned short ar0832_init_reg_MIPI_IF_CFG1_3[]={	
+0x3064, 0x0100, 0,	//embedded_data_enable
+};
+static unsigned short ar0832_init_reg_MIPI_IF_CFG2[]={	
+0x31AE, 0x0202,	//2-lane MIPI SERIAL_FORMAT
+0x31B0, 0x0083,
+0x31B2, 0x004D,
+0x31B4, 0x0E77,
+0x31B6, 0x0D20,
+0x31B8, 0x020E,
+0x31BA, 0x0710,
+0x31BC, 0x2A0D,
+0xffff,50, //DELAY=5
+};
+
+static unsigned short ar0832_init_reg_raw10[]={	
+//[RAW10]
+0x0112, 0x0A0A		//CCP_DATA_FORMAT
+};
+
+static unsigned short ar0832_init_reg[]={	
+//[Recommended Settings]
+
+0x3044, 0x0590,
+0x306E, 0xFC80,
+0x30B2, 0xC000,
+0x30D6, 0x0800,
+0x316C, 0xB42F,
+0x316E, 0x869A,
+0x3170, 0x210E,
+0x317A, 0x010E,
+0x31E0, 0x1FB9,
+0x31E6, 0x07FC,
+0x37C0, 0x0000,
+0x37C2, 0x0000,
+0x37C4, 0x0000,
+0x37C6, 0x0000,
+0x3E00, 0x0011,
+0x3E02, 0x8801,
+0x3E04, 0x2801,
+0x3E06, 0x8449,
+0x3E08, 0x6841,
+0x3E0A, 0x400C,
+0x3E0C, 0x1001,
+0x3E0E, 0x2603,
+0x3E10, 0x4B41,
+0x3E12, 0x4B24,
+0x3E14, 0xA3CF,
+0x3E16, 0x8802,
+0x3E18, 0x8401,
+0x3E1A, 0x8601,
+0x3E1C, 0x8401,
+0x3E1E, 0x840A,
+0x3E20, 0xFF00,
+0x3E22, 0x8401,
+0x3E24, 0x00FF,
+0x3E26, 0x0088,
+0x3E28, 0x2E8A,
+0x3E30, 0x0000,
+0x3E32, 0x8801,
+0x3E34, 0x4029,
+0x3E36, 0x00FF,
+0x3E38, 0x8469,
+0x3E3A, 0x00FF,
+0x3E3C, 0x2801,
+0x3E3E, 0x3E2A,
+0x3E40, 0x1C01,
+0x3E42, 0xFF84,
+0x3E44, 0x8401,
+0x3E46, 0x0C01,
+0x3E48, 0x8401,
+0x3E4A, 0x00FF,
+0x3E4C, 0x8402,
+0x3E4E, 0x8984, //0x00FF
+0x3E50, 0x6628,
+0x3E52, 0x8340,
+0x3E54, 0x00FF,
+0x3E56, 0x4A42,
+0x3E58, 0x2703, 
+0x3E5A, 0x6752,
+0x3E5C, 0x3F2A,
+0x3E5E, 0x846A,
+0x3E60, 0x4C01,
+0x3E62, 0x8401,
+0x3E66, 0x3901,
+0x3E90, 0x2C01,
+0x3E98, 0x2B02,
+0x3E92, 0x2A04,
+0x3E94, 0x2509,
+0x3E96, 0x0000,
+0x3E9A, 0x2905,
+0x3E9C, 0x00FF,
+0x3ECC, 0x00EB,
+0x3ED0, 0x1E24,
+0x3ED4, 0xAFC4,
+0x3ED6, 0x909B,
+0x3EE0, 0x2424,
+0x3EE2, 0x9797,
+0x3EE4, 0xC100,
+0x3EE6, 0x0540,
+0x3174, 0x8000,
+};
+
+//STATE= Minimum Gain, 1500	// gain * 1000
+//[Toolbar:eeprom]
+//[2-lane MIPI 3272x2456 15FPS 66,7ms RAW10 Ext=24MHz Vt_pix_clk=192MHz Op_pix_clk=76,8MHz FOV=3264x2448] 
+//Low FPS is limited by Demo2 HW, NOT sensor
+//XMCLK=24000000 
+//LOAD = MIPI 2-lane FPGA
+//LOAD = Stop Streaming
+//LOAD = 2-lane MIPI Interface Configuration
+//LOAD = Recommended Settings
+//LOAD = RAW10
+
+static unsigned short ar0832_init_reg_pll[]={	
+//PLL Configuration (Ext=24MHz, vt_pix_clk=192MHz, op_pix_clk=76.8MHz)
+0x0300, 0x4, //VT_PIX_CLK_DIV=4
+0x0302, 0x1, //VT_SYS_CLK_DIV=1
+0x0304, 0x2, //PRE_PLL_CLK_DIV=2 //Note: 24MHz/2=12MHz
+0x0306, 0x10,//0x10,//0x40 //PLL_MULTIPLIER=64 //Note: Running at 768MHz
+0x0308, 0xa, //OP_PIX_CLK_DIV=10
+0x030A, 0x1, //OP_SYS_CLK_DIV=1
+0xffff,10, //DELAY=1
+0x3064, 0x7400,
+};
+#if 0
+static unsigned short ar0832_init_reg_output_size[]={	
+//Output size (Pixel address must start with EVEN and end with ODD!)
+0x0344, 0x4, //X_ADDR_START 4
+0x0348, 0xCCB, //X_ADDR_END 3275
+0x0346, 0x4 ,//Y_ADDR_START 4
+0x034A, 0x99B, //Y_ADDR_END 2459
+0x034C, 0xCC8, //X_OUTPUT_SIZE 3272
+0x034E, 0x998, //Y_OUTPUT_SIZE 2456
+0x3040, 0x0041
+};
+#else 
+#if 0
+static unsigned short ar0832_init_reg_output_size[]={	
+//Output size (Pixel address must start with EVEN and end with ODD!)
+0x0344, 0x0, //X_ADDR_START 4
+0x0348, 639, //X_ADDR_END 3275
+0x0346, 0x0, //Y_ADDR_START 4
+0x034A, 479, //Y_ADDR_END 2459
+0x034C, 640, //X_OUTPUT_SIZE 3272
+0x034E, 480, //Y_OUTPUT_SIZE 2456
+0x3040, 0x0041
+};
+#else
+static unsigned short ar0832_init_reg_output_size[]={	
+//Output size (Pixel address must start with EVEN and end with ODD!)
+0x0344, 0x0, //X_ADDR_START 4
+0x0348, 1279, //X_ADDR_END 3275
+0x0346, 0x0, //Y_ADDR_START 4
+0x034A, 719, //Y_ADDR_END 2459
+0x034C, 1280, //X_OUTPUT_SIZE 3272
+0x034E, 720, //Y_OUTPUT_SIZE 2456
+0x3040, 0x0041
+};
+
+#endif
+#endif 
+//ETC ..
+
+//"X-Bin2 Y-Bin2" and "X-Bin2Skip2 Y-Bin2Skip2" Optimization
+static unsigned short ar0832_init_reg_etc1_3[]={	
+0x306E, 0x0030, 0x0, //Resample_Binning 3: enable
+};
+static unsigned short ar0832_init_reg_etc2[]={	
+0x306E, 0xFC80,
+0x0400, 0x0000, //SCALE_MODE: 2: ENABLE
+0x0404, 0x10, //SCALE_M = 16
+};
+static unsigned short ar0832_init_reg_etc3_3[]={	
+0x3178, 0x0800, 0, //XSkip2Bin2YSkip4 4x_optimization
+0x3ED0, 0x0080, 0, //XSkip2Bin2YSkip4 4x_optimization
+};
+
+static unsigned short ar0832_init_reg_etc4[]={	
+0x3178, 0x0000,
+0x3ED0, 0x1E24,
+
+//Scale Configuration
+0x0400, 0x0000, //SCALE_MODE: 0:Disable
+0x0404, 0x10, //SCALE_M = 16
+
+//Timing Configuration
+0x0342, 0x133C,//LINE_LENGTH_PCK 4924
+0x0340, 0xA27,//FRAME_LENGTH_LINES 2599
+0x0202, 0xA27, //COARSE_INTEGRATION_TIME 2599
+0x3014, 0x9DC, //FINE_INTEGRATION_TIME 2524
+0x3010, 0x78, //FINE_CORRECTION 120
+};
+
+//LOAD = Start Streaming
+//LOAD=test
+//STATE = Master Clock, 192000000
+#if 1
+#if 0
+static unsigned short ar0832_reg_test[]={	
+//[VGA]
+
+	 0x0104, 0x01  , // GROUPED_PARAMETER_HOLD
+	 0x0382, 0x0007,     // X_ODD_INC
+	 0x0386, 0x0007,     // Y_ODD_INC
+	 0x3040, 0x15C7,     // READ_MODE
+	 0x3040, 0x11C7,     // READ_MODE
+	 0x3040, 0x01C7,     // READ_MODE
+	 0x306E, 0xFCA0,     // DATAPATH_SELECT
+	 0x0344, 0x0008,     // X_ADDR_START
+	 0x0346, 0x0008,     // Y_ADDR_START
+	 0x0348, 0x0CC1,     // X_ADDR_END
+	 0x034A, 0x0991,     // Y_ADDR_END
+	 0x034C, 0x0280,     // X_OUTPUT_SIZE
+	 0x034E, 0x01E0,     // Y_OUTPUT_SIZE
+	 0x0400, 0x0002,     // SCALING_MODE
+	0x0404, 0x0014,     // SCALE_M
+	0x0104, 0x00,   // GROUPED_PARAMETER_HOLD
+
+	0x0342, 0x143C, 	// LINE_LENGTH_PCK
+	0x0202, 0x009B, 	// COARSE_INTEGRATION_TIME
+	0x0202, 0x009B, 	// COARSE_INTEGRATION_TIME
+	0x305A, 0x1443, 	// RED_GAIN
+	0x305A, 0x1443, 	// RED_GAIN
+	0x3056, 0x1060, 	// GREEN1_GAIN
+	0x305C, 0x1060, 	// GREEN2_GAIN
+	0x3056, 0x1060, 	// GREEN1_GAIN
+	0x305C, 0x1060, 	// GREEN2_GAIN
+	0x3058, 0x1453, 	// BLUE_GAIN
+	0x3058, 0x1453, 	// BLUE_GAIN
+};
+
+#else 
+/*
+static unsigned short ar0832_reg_test[]={	
+//[656x492]
+
+	 0x0104, 0x01  , // GROUPED_PARAMETER_HOLD
+	 0x0382, 0x0007,     // X_ODD_INC
+	 0x0386, 0x0007,     // Y_ODD_INC
+	 0x3040, 0x15C7,     // READ_MODE
+	 0x3040, 0x11C7,     // READ_MODE
+	 0x3040, 0x01C7,     // READ_MODE
+	 0x306E, 0xFCA0,     // DATAPATH_SELECT
+	 0x0344, 0x0008,     // X_ADDR_START
+	 0x0346, 0x0008,     // Y_ADDR_START
+	 0x0348, 0x0CC1,     // X_ADDR_END
+	 0x034A, 0x0991,     // Y_ADDR_END
+	 0x034C, 656,     // X_OUTPUT_SIZE
+	 0x034E, 492,     // Y_OUTPUT_SIZE
+	 0x0400, 0x0002,     // SCALING_MODE
+	0x0404, 0x0014,     // SCALE_M
+	0x0104, 0x00,   // GROUPED_PARAMETER_HOLD
+
+	0x0342, 0x143C, 	// LINE_LENGTH_PCK
+	0x0202, 0x009B, 	// COARSE_INTEGRATION_TIME
+	0x0202, 0x009B, 	// COARSE_INTEGRATION_TIME
+	0x305A, 0x1443, 	// RED_GAIN
+	0x305A, 0x1443, 	// RED_GAIN
+	0x3056, 0x1060, 	// GREEN1_GAIN
+	0x305C, 0x1060, 	// GREEN2_GAIN
+	0x3056, 0x1060, 	// GREEN1_GAIN
+	0x305C, 0x1060, 	// GREEN2_GAIN
+	0x3058, 0x1453, 	// BLUE_GAIN
+	0x3058, 0x1453, 	// BLUE_GAIN
+};
+*/
+	static unsigned short ar0832_reg_test[]={	
+	//
+		0x0104, 0x01  , // GROUPED_PARAMETER_HOLD
+		0x0382, 0x0007,	 // X_ODD_INC
+		0x0386, 0x0007,	 // Y_ODD_INC
+		0x3040, 0x15C7,	 // READ_MODE
+		0x3040, 0x11C7,	 // READ_MODE
+		0x3040, 0x01C7,	 // READ_MODE
+		0x306E, 0xFCA0,	 // DATAPATH_SELECT
+		 0x0344, 0x0008,	 // X_ADDR_START
+		 0x0346, 0x0008,	 // Y_ADDR_START
+		 0x0348, 0x0CC1,	 // X_ADDR_END
+		 0x034A, 0x0991,	 // Y_ADDR_END
+		 0x034C, 1280,	  // X_OUTPUT_SIZE
+		 0x034E, 720,	  // Y_OUTPUT_SIZE
+		0x0400, 0x0002,	 // SCALING_MODE
+		0x0404, 0x0014, 	// SCALE_M
+		0x0104, 0x00,	// GROUPED_PARAMETER_HOLD
+	
+		0x0342, 0x143C, 	// LINE_LENGTH_PCK
+		0x0202, 0x009B, 	// COARSE_INTEGRATION_TIME
+		0x0202, 0x009B, 	// COARSE_INTEGRATION_TIME
+		0x305A, 0x1443, 	// RED_GAIN
+		0x305A, 0x1443, 	// RED_GAIN
+		0x3056, 0x1060, 	// GREEN1_GAIN
+		0x305C, 0x1060, 	// GREEN2_GAIN
+		0x3056, 0x1060, 	// GREEN1_GAIN
+		0x305C, 0x1060, 	// GREEN2_GAIN
+		0x3058, 0x1453, 	// BLUE_GAIN
+		0x3058, 0x1453, 	// BLUE_GAIN
+	};
+
+#endif
+
+
+#else 
+static unsigned short ar0832_reg_test[]={	
+//[test]
+0x0104, 0x01, 	// GROUPED_PARAMETER_HOLD
+0x0382, 0x0001, 	// X_ODD_INC
+0x0386, 0x0001, 	// Y_ODD_INC
+0x3040, 0x0041, 	// READ_MODE
+0x3040, 0x0041, 	// READ_MODE
+0x3040, 0x0041, 	// READ_MODE
+0x306E, 0xFC80, 	// DATAPATH_SELECT
+0x0344, 0x0008, 	// X_ADDR_START
+0x0346, 0x0008, 	// Y_ADDR_START
+0x0348, 0x0CC7, 	// X_ADDR_END
+0x034A, 0x0997, 	// Y_ADDR_END
+0x034C, 0x0CC0, 	// X_OUTPUT_SIZE
+0x034E, 0x0990, 	// Y_OUTPUT_SIZE
+0x0400, 0x0000, 	// SCALING_MODE
+0x0404, 0x0010, 	// SCALE_M
+0x0104, 0x00, 	// GROUPED_PARAMETER_HOLD
+0x0342, 0x143C, 	// LINE_LENGTH_PCK
+0x0202, 0x009B, 	// COARSE_INTEGRATION_TIME
+0x0202, 0x009B, 	// COARSE_INTEGRATION_TIME
+0x305A, 0x1443, 	// RED_GAIN
+0x305A, 0x1443, 	// RED_GAIN
+0x3056, 0x1060, 	// GREEN1_GAIN
+0x305C, 0x1060, 	// GREEN2_GAIN
+0x3056, 0x1060, 	// GREEN1_GAIN
+0x305C, 0x1060, 	// GREEN2_GAIN
+0x3058, 0x1453, 	// BLUE_GAIN
+0x3058, 0x1453, 	// BLUE_GAIN
+};
+//----------------------------------------------------------
+#endif
+
+static unsigned short ar0832_init_reg_media_test[]={	
+//[for is media test]
+0x0202, 0x01DA, 	// COARSE_INTEGRATION_TIME
+0x305A, 0x1449, 	// RED_GAIN
+0x3056, 0x1060, 	// GREEN1_GAIN
+0x305C, 0x1060, 	// GREEN2_GAIN
+0x3058, 0x1457 	// BLUE_GAIN
+};
+
+#define AR0832_REG_START_STREAMING1_3	(sizeof(ar0832_reg_start_streaming1_3) / 	sizeof(ar0832_reg_start_streaming1_3[0]))
+#define AR0832_REG_START_STREAMING2		(sizeof(ar0832_reg_start_streaming2) / 	sizeof(ar0832_reg_start_streaming2[0]))
+#define AR0832_REG_START_STREAMING3_3	(sizeof(ar0832_reg_start_streaming3_3) / 	sizeof(ar0832_reg_start_streaming3_3[0]))
+
+#define AR0832_REG_STOP_STREAMING1_3	(sizeof(ar0832_reg_stop_streaming1_3) / 	sizeof(ar0832_reg_stop_streaming1_3[0]))
+#define AR0832_REG_STOP_STREAMING2	(sizeof(ar0832_reg_stop_streaming2) / 	sizeof(ar0832_reg_stop_streaming2[0]))
+
+#define AR0832_INIT_REG_MIPI_IF_CFG1_3	(sizeof(ar0832_init_reg_MIPI_IF_CFG1_3) / 	sizeof(ar0832_init_reg_MIPI_IF_CFG1_3[0]))
+#define AR0832_INIT_REG_MIPI_IF_CFG2	(sizeof(ar0832_init_reg_MIPI_IF_CFG2) / 	sizeof(ar0832_init_reg_MIPI_IF_CFG2[0]))
+
+#define AR0832_INIT_REG_RAW10		(sizeof(ar0832_init_reg_raw10) / 		sizeof(ar0832_init_reg_raw10[0]))
+#define AR0832_INIT_REG_REG			(sizeof(ar0832_init_reg) / 				sizeof(ar0832_init_reg[0]))
+#define AR0832_INIT_REG_PLL			(sizeof(ar0832_init_reg_pll) / 			sizeof(ar0832_init_reg_pll[0]))
+#define AR0832_INIT_REG_OUTPUT_SIZE	(sizeof(ar0832_init_reg_output_size) /	sizeof(ar0832_init_reg_output_size[0]))
+
+#define AR0832_INIT_REG_ETC1_3			(sizeof(ar0832_init_reg_etc1_3) / 			sizeof(ar0832_init_reg_etc1_3[0]))
+#define AR0832_INIT_REG_ETC2			(sizeof(ar0832_init_reg_etc2) / 			sizeof(ar0832_init_reg_etc2[0]))
+#define AR0832_INIT_REG_ETC3_3			(sizeof(ar0832_init_reg_etc3_3) / 			sizeof(ar0832_init_reg_etc3_3[0]))
+#define AR0832_INIT_REG_ETC4			(sizeof(ar0832_init_reg_etc4) / 			sizeof(ar0832_init_reg_etc4[0]))
+
+#define AR0832_INIT_REG_TEST		(sizeof(ar0832_reg_test) / 				sizeof(ar0832_reg_test[0]))
+#define AR0832_INIT_REG_MEDIA_TEST	(sizeof(ar0832_init_reg_media_test) / 	sizeof(ar0832_init_reg_media_test[0]))
+
+
+#endif /* __AR0832_H */
diff -Naur org/drivers/media/video/ar0832_is.c ths/drivers/media/video/ar0832_is.c
--- org/drivers/media/video/ar0832_is.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/drivers/media/video/ar0832_is.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,3171 +0,0 @@
-/*
- * driver for Fusitju AR0832 LS 8MP camera
- *
- * Copyright (c) 2010, Samsung Electronics. All rights reserved
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- */
-
-#include <linux/i2c.h>
-#include <linux/init.h>
-#include <media/v4l2-device.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/vmalloc.h>
-#include <linux/firmware.h>
-#include <linux/videodev2.h>
-#include <linux/slab.h>
-
-#ifdef CONFIG_VIDEO_SAMSUNG_V4L2
-#include <linux/videodev2_samsung.h>
-#endif
-
-#include <linux/regulator/machine.h>
-
-#include <media/ar0832_platform.h>
-#include "ar0832.h"
-
-#define AR0832_DRIVER_NAME	"AR0832_IS"
-#define SDCARD_FW
-#ifdef SDCARD_FW
-#define AR0832_FW_PATH		"/sdcard/RS_M5LS.bin"
-#endif /* SDCARD_FW */
-#define AR0832T_FW_REQUEST_PATH	"ar0832/RS_M5LS_T.bin"	/* Techwin */
-#define AR0832O_FW_REQUEST_PATH	"ar0832/RS_M5LS_O.bin"	/* Optical communication */
-#define AR0832_FW_DUMP_PATH	"/data/RS_M5LS_dump.bin"
-#define AR0832_FW_VER_LEN		22
-#define AR0832_FW_VER_FILE_CUR	0x16FF00
-
-#define AR0832_FLASH_BASE_ADDR	0x10000000
-#define AR0832_INT_RAM_BASE_ADDR	0x68000000
-
-#define AR0832_I2C_RETRY		5
-#define AR0832_I2C_VERIFY		100
-#define AR0832_ISP_TIMEOUT	3000
-#define AR0832_ISP_AFB_TIMEOUT	15000 /* FIXME */
-#define AR0832_ISP_ESD_TIMEOUT	1000
-
-#define AR0832_JPEG_MAXSIZE	0x3A0000
-#define AR0832_THUMB_MAXSIZE	0xFC00
-#define AR0832_POST_MAXSIZE	0xBB800
-
-#define AR0832_DEF_APEX_DEN	100
-
-#define ar0832_readb(sd, g, b, v)		ar0832_read(sd, 1, g, b, v)
-#define ar0832_readw(sd, g, b, v)		ar0832_read(sd, 2, g, b, v)
-#define ar0832_readl(sd, g, b, v)		ar0832_read(sd, 4, g, b, v)
-
-#define ar0832_writeb(sd, g, b, v)	ar0832_write(sd, 1, g, b, v)
-#define ar0832_writew(sd, g, b, v)	ar0832_write(sd, 2, g, b, v)
-#define ar0832_writel(sd, g, b, v)	ar0832_write(sd, 4, g, b, v)
-
-#define CHECK_ERR(x)	if ((x) < 0) { \
-				cam_err("i2c failed, err %d\n", x); \
-				return x; \
-			}
-
-
-/*
-* Because misc devices can not carry a pointer from driver register to
-* open, we keep this global. This limits the driver to a single instance.
-*/
-struct ar0832_state *ar0832_is_data;
-
-static const struct ar0832_frmsizeenum preview_frmsizes[] = {
-	{ AR0832_PREVIEW_QCIF,	176,	144,	0x05 },	/* 176 x 144 */
-	{ AR0832_PREVIEW_QCIF2,	528,	432,	0x2C },	/* 176 x 144 */
-	{ AR0832_PREVIEW_QVGA,	320,	240,	0x09 },
-	{ AR0832_PREVIEW_VGA,	640,	480,	0x17 },
-	{ AR0832_PREVIEW_D1,	720,	480,	0x18 },
-	{ AR0832_PREVIEW_WVGA,	800,	480,	0x1A },
-	{ AR0832_PREVIEW_720P,	1280,	720,	0x21 },
-	{ AR0832_PREVIEW_1080P,	1920,	1080,	0x28 },
-	{ AR0832_PREVIEW_HDR,	3264,	2448,	0x27 },
-};
-
-static const struct ar0832_frmsizeenum capture_frmsizes[] = {
-	{ AR0832_CAPTURE_VGA,	640,	480,	0x09 },
-	{ AR0832_CAPTURE_WVGA,	800,	480,	0x0A },
-	{ AR0832_CAPTURE_W2MP,	2048,	1232,	0x2C },
-	{ AR0832_CAPTURE_3MP,	2048,	1536,	0x1B },
-	{ AR0832_CAPTURE_W7MP,	3264,	1968,	0x2D },
-	{ AR0832_CAPTURE_8MP,	3264,	2448,	0x25 },
-};
-
-static struct ar0832_control ar0832_ctrls[] = {
-	{
-		.id = V4L2_CID_CAMERA_ISO,
-		.minimum = ISO_AUTO,
-		.maximum = ISO_800,
-		.step = 1,
-		.value = ISO_AUTO,
-		.default_value = ISO_AUTO,
-	}, {
-		.id = V4L2_CID_CAMERA_BRIGHTNESS,
-		.minimum = EV_MINUS_4,
-		.maximum = EV_MAX - 1,
-		.step = 1,
-		.value = EV_DEFAULT,
-		.default_value = EV_DEFAULT,
-	}, {
-		.id = V4L2_CID_CAMERA_SATURATION,
-		.minimum = SATURATION_MINUS_2,
-		.maximum = SATURATION_MAX - 1,
-		.step = 1,
-		.value = SATURATION_DEFAULT,
-		.default_value = SATURATION_DEFAULT,
-	}, {
-		.id = V4L2_CID_CAMERA_SHARPNESS,
-		.minimum = SHARPNESS_MINUS_2,
-		.maximum = SHARPNESS_MAX - 1,
-		.step = 1,
-		.value = SHARPNESS_DEFAULT,
-		.default_value = SHARPNESS_DEFAULT,
-	}, {
-		.id = V4L2_CID_CAMERA_ZOOM,
-		.minimum = ZOOM_LEVEL_0,
-		.maximum = ZOOM_LEVEL_MAX - 1,
-		.step = 1,
-		.value = ZOOM_LEVEL_0,
-		.default_value = ZOOM_LEVEL_0,
-	}, {
-		.id = V4L2_CID_CAM_JPEG_QUALITY,
-		.minimum = 1,
-		.maximum = 100,
-		.step = 1,
-		.value = 100,
-		.default_value = 100,
-	},
-};
-
-static inline struct ar0832_state *to_state(struct v4l2_subdev *sd)
-{
-	return container_of(sd, struct ar0832_state, sd);
-}
-
-static int ar0832_read(struct v4l2_subdev *sd,
-	u8 len, u8 category, u8 byte, int *val)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct i2c_msg msg;
-	unsigned char data[5];
-	unsigned char recv_data[len + 1];
-	int i, err = 0;
-
-	if (!client->adapter)
-		return -ENODEV;
-
-	if (len != 0x01 && len != 0x02 && len != 0x04)
-		return -EINVAL;
-
-	msg.addr = client->addr;
-	msg.flags = 0;
-	msg.len = sizeof(data);
-	msg.buf = data;
-
-	/* high byte goes out first */
-	data[0] = msg.len;
-	data[1] = 0x01;			/* Read category parameters */
-	data[2] = category;
-	data[3] = byte;
-	data[4] = len;
-
-	for (i = AR0832_I2C_RETRY; i; i--) {
-		err = i2c_transfer(client->adapter, &msg, 1);
-		if (err == 1)
-			break;
-		msleep(20);
-	}
-
-	if (err != 1) {
-		cam_err("category %#x, byte %#x\n", category, byte);
-		return err;
-	}
-
-	msg.flags = I2C_M_RD;
-	msg.len = sizeof(recv_data);
-	msg.buf = recv_data;
-	for (i = AR0832_I2C_RETRY; i; i--) {
-		err = i2c_transfer(client->adapter, &msg, 1);
-		if (err == 1)
-			break;
-		msleep(20);
-	}
-
-	if (err != 1) {
-		cam_err("category %#x, byte %#x\n", category, byte);
-		return err;
-	}
-
-	if (recv_data[0] != sizeof(recv_data))
-		cam_i2c_dbg("expected length %d, but return length %d\n",
-				 sizeof(recv_data), recv_data[0]);
-
-	if (len == 0x01)
-		*val = recv_data[1];
-	else if (len == 0x02)
-		*val = recv_data[1] << 8 | recv_data[2];
-	else
-		*val = recv_data[1] << 24 | recv_data[2] << 16 |
-				recv_data[3] << 8 | recv_data[4];
-
-	cam_i2c_dbg("category %#02x, byte %#x, value %#x\n", category, byte, *val);
-	return err;
-}
-
-static int ar0832_write(struct v4l2_subdev *sd,
-	u8 len, u8 category, u8 byte, int val)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct i2c_msg msg;
-	unsigned char data[len + 4];
-	int i, err;
-return 0;
-	if (!client->adapter)
-		return -ENODEV;
-
-	if (len != 0x01 && len != 0x02 && len != 0x04)
-		return -EINVAL;
-
-	msg.addr = client->addr;
-	msg.flags = 0;
-	msg.len = sizeof(data);
-	msg.buf = data;
-
-	data[0] = msg.len;
-	data[1] = 0x02;			/* Write category parameters */
-	data[2] = category;
-	data[3] = byte;
-	if (len == 0x01) {
-		data[4] = val & 0xFF;
-	} else if (len == 0x02) {
-		data[4] = (val >> 8) & 0xFF;
-		data[5] = val & 0xFF;
-	} else {
-		data[4] = (val >> 24) & 0xFF;
-		data[5] = (val >> 16) & 0xFF;
-		data[6] = (val >> 8) & 0xFF;
-		data[7] = val & 0xFF;
-	}
-
-	cam_i2c_dbg("category %#x, byte %#x, value %#x\n", category, byte, val);
-
-	for (i = AR0832_I2C_RETRY; i; i--) {
-		err = i2c_transfer(client->adapter, &msg, 1);
-		if (err == 1)
-			break;
-		msleep(20);
-	}
-
-	return err;
-}
-static unsigned short ar0832_i2c_read_reg(struct i2c_client *client, unsigned short reg,int readbyte /*1 or 2*/)
-{
-	int ret;
-	unsigned char i2c_data[10];
-	unsigned char i2c_rdata[10];
-	memset(i2c_rdata,0,10);
-
-	i2c_data[0]= (unsigned char)((reg>>8) & 0xff);
-	i2c_data[1]= (unsigned char)(reg & 0xff);	
-	i2c_master_send(client,i2c_data,2);
-
-	ret = i2c_master_recv(client,i2c_rdata,readbyte);
-
-#if 0
-	int i;
-	for(i=0;i<2;i++)
-	printk("retdata %d => %x \n",i,i2c_rdata[i]);
-
-	if (ret < 0)
-	printk( "%s: err %d\n", __func__, ret);
-#endif
-
-	if (readbyte== 1) 
-		return i2c_rdata[0];
-	return i2c_rdata[0]<<8 | i2c_rdata[1];
-}
-
-static int ar0832_i2c_write(struct v4l2_subdev *sd, unsigned char i2c_data[],
-				unsigned char length)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	unsigned char buf[length], i;
-	struct i2c_msg msg = {client->addr, 0, length, buf};
-
-	for (i = 0; i < length; i++)
-		buf[i] = i2c_data[i];
-
-	return i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
-}
-
-static int ar0832_i2c_write_4byte(struct v4l2_subdev *sd, unsigned char d0,unsigned char d1,unsigned char d2,unsigned char d3)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	unsigned char buf[4], i;
-	struct i2c_msg msg = {client->addr, 0, 4, buf};
-
-	buf[0] = d0;
-	buf[1] = d1;
-	buf[2] = d2;
-	buf[3] = d3;
-
-	return i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
-}
-
-static int ar0832_i2c_write_2short(struct v4l2_subdev *sd, unsigned short d0,unsigned short d1)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	unsigned char buf[4], i;
-	struct i2c_msg msg = {client->addr, 0, 4, buf};
-
-	buf[0] = d0>>8;
-	buf[1] = d0 & 0xff;
-	buf[2] = d1>>8;
-	buf[3] = d1 & 0xff;
-
-	return i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
-}
-
-
-static int ar0832_write_array(struct v4l2_subdev *sd,unsigned  short * reg , int size)
-{	
-	unsigned char _tmp[4];
-	int i,err=0;
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-
-	for (i = 0; i < size ; i=i+2) {
-		if(reg[i] == 0xffff){ //delay
-			mdelay(reg[i+1]);
-		}
-		else {
-//			printk("%x %x. ",reg[i],reg[i+1]);
-//			printk(".");
-
-			_tmp[0] =(unsigned char)( reg[i] >> 8) ;
-			_tmp[1] =(unsigned char)( reg[i] & 0xff);
-
-			_tmp[2] =(unsigned char)( reg[i+1] >> 8) ;
-			_tmp[3] =(unsigned char)( reg[i+1] & 0xff);
-			err = ar0832_i2c_write(sd,_tmp , 4);
-			if (err < 0){
-				v4l_info(client, "%s: register set failed\n", \
-					__func__);
-				v4l_info(client,"err i=%d %02x %02x %02x %02x \n",\
-					i, _tmp[0],_tmp[1],_tmp[2],_tmp[3]); 
-				return -1;
-				
-				}
-		}
-//	if(i%50 == 0) 	printk("\n");
-	}
-//	printk(" %d\n",i);
-	
-	return err;
-}
-
-/* ****************************************
-	data is 3 bytes 
-	{address , bit field, set or clear}
-***************************************** */
-static int ar0832_write_array3(struct v4l2_subdev *sd,unsigned  short * reg , int size)
-{	
-	unsigned char _tmp[4];
-	int i,err=0;
-	int rdata=0;
-	int wdata=0;
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-
-	for (i = 0; i < size ; i=i+3) {
-		
-		rdata = ar0832_i2c_read_reg(client,reg[i],2) & 0xffff;
-		if(reg[i+2] == 1) wdata = rdata | reg[i+1];
-		else wdata = rdata & (~reg[i+1]);
-#if 0	
-		printk("%x %x %x read reg: %x --> write %x \n",reg[i],reg[i+1],reg[i+2],rdata,wdata);
-#endif
-		//address
-		_tmp[0] =(unsigned char)( reg[i] >> 8) ;
-		_tmp[1] =(unsigned char)( reg[i] & 0xff);
-
-		// modified data
-		_tmp[2] =(unsigned char)( wdata >> 8) ;
-		_tmp[3] =(unsigned char)( wdata & 0xff);
-		err = ar0832_i2c_write(sd,_tmp , 4);
-		if (err < 0){
-			v4l_info(client, "%s: register set failed\n", \
-				__func__);
-			v4l_info(client,"err i=%d %02x %02x %02x %02x \n",\
-				i, _tmp[0],_tmp[1],_tmp[2],_tmp[3]); 
-			return -1;
-			
-			}
-		
-//	if(i%50 == 0) 	printk("\n");
-	}
-//	printk(" %d\n",i);
-	
-	return err;
-}
-
-static int ar0832_mem_read(struct v4l2_subdev *sd, u16 len, u32 addr, u8 *val)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct i2c_msg msg;
-	unsigned char data[8];
-	unsigned char recv_data[len + 3];
-	int i, err = 0;
-
-	if (!client->adapter)
-		return -ENODEV;
-
-	if (len <= 0)
-		return -EINVAL;
-
-	msg.addr = client->addr;
-	msg.flags = 0;
-	msg.len = sizeof(data);
-	msg.buf = data;
-
-	/* high byte goes out first */
-	data[0] = 0x00;
-	data[1] = 0x03;
-	data[2] = (addr >> 24) & 0xFF;
-	data[3] = (addr >> 16) & 0xFF;
-	data[4] = (addr >> 8) & 0xFF;
-	data[5] = addr & 0xFF;
-	data[6] = (len >> 8) & 0xFF;
-	data[7] = len & 0xFF;
-
-	for (i = AR0832_I2C_RETRY; i; i--) {
-		err = i2c_transfer(client->adapter, &msg, 1);
-		if (err == 1)
-			break;
-		msleep(20);
-	}
-
-	if (err != 1)
-		return err;
-
-	msg.flags = I2C_M_RD;
-	msg.len = sizeof(recv_data);
-	msg.buf = recv_data;
-	for (i = AR0832_I2C_RETRY; i; i--) {
-		err = i2c_transfer(client->adapter, &msg, 1);
-		if (err == 1)
-			break;
-		msleep(20);
-	}
-
-	if (err != 1)
-		return err;
-
-	if (len != (recv_data[1] << 8 | recv_data[2]))
-		cam_i2c_dbg("expected length %d, but return length %d\n",
-			len, recv_data[1] << 8 | recv_data[2]);
-
-	memcpy(val, recv_data + 3, len);
-
-	cam_i2c_dbg("address %#x, length %d\n", addr, len);
-	return err;
-}
-
-static int ar0832_mem_write(struct v4l2_subdev *sd, u8 cmd, u16 len, u32 addr, u8 *val)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct i2c_msg msg;
-	unsigned char data[len + 8];
-	int i, err = 0;
-
-	if (!client->adapter)
-		return -ENODEV;
-
-	msg.addr = client->addr;
-	msg.flags = 0;
-	msg.len = sizeof(data);
-	msg.buf = data;
-
-	/* high byte goes out first */
-	data[0] = 0x00;
-	data[1] = cmd;
-	data[2] = (addr >> 24) & 0xFF;
-	data[3] = (addr >> 16) & 0xFF;
-	data[4] = (addr >> 8) & 0xFF;
-	data[5] = addr & 0xFF;
-	data[6] = (len >> 8) & 0xFF;
-	data[7] = len & 0xFF;
-	memcpy(data + 2 + sizeof(addr) + sizeof(len), val, len);
-
-	cam_i2c_dbg("address %#x, length %d\n", addr, len);
-
-	for (i = AR0832_I2C_RETRY; i; i--) {
-		err = i2c_transfer(client->adapter, &msg, 1);
-		if (err == 1)
-			break;
-		msleep(20);
-	}
-
-	return err;
-}
-
-static irqreturn_t ar0832_isp_isr(int irq, void *dev_id)
-{
-	struct v4l2_subdev *sd = (struct v4l2_subdev *)dev_id;
-	struct ar0832_state *state = to_state(sd);
-
-	cam_dbg("**************** interrupt ****************\n");
-	state->isp.issued = 1;
-	wake_up_interruptible(&state->isp.wait);
-
-	return IRQ_HANDLED;
-}
-
-static u32 ar0832_wait_interrupt(struct v4l2_subdev *sd,
-	unsigned int timeout)
-{
-	struct ar0832_state *state = to_state(sd);
-	cam_trace("E\n");
-return 0;
-	if (wait_event_interruptible_timeout(state->isp.wait,
-		state->isp.issued == 1,
-		msecs_to_jiffies(timeout)) == 0) {
-		cam_err("timeout\n");
-		return 0;
-	}
-
-	state->isp.issued = 0;
-
-	ar0832_readb(sd, AR0832_CATEGORY_SYS,
-		AR0832_SYS_INT_FACTOR, &state->isp.int_factor);
-
-	cam_trace("X\n");
-	return state->isp.int_factor;
-}
-
-static int ar0832_set_mode(struct v4l2_subdev *sd, u32 mode)
-{
-	int i, err;
-	u32 old_mode, val;
-	cam_trace("E\n");
-
-	err = ar0832_readb(sd, AR0832_CATEGORY_SYS, AR0832_SYS_MODE, &old_mode);
-
-	if (err < 0)
-		return err;
-
-	if (old_mode == mode) {
-		cam_dbg("%#x -> %#x\n", old_mode, mode);
-		return old_mode;
-	}
-
-	cam_dbg("%#x -> %#x\n", old_mode, mode);
-	
-	switch (old_mode) {
-	case AR0832_SYSINIT_MODE:
-		cam_warn("sensor is initializing\n");
-		err = -EBUSY;
-		break;
-
-	case AR0832_PARMSET_MODE:
-		if (mode == AR0832_STILLCAP_MODE) {
-			err = ar0832_writeb(sd, AR0832_CATEGORY_SYS,
-				AR0832_SYS_MODE, AR0832_MONITOR_MODE);
-			if (err < 0)
-				break;
-			for (i = AR0832_I2C_VERIFY; i; i--) {
-				err = ar0832_readb(sd, AR0832_CATEGORY_SYS,
-					AR0832_SYS_MODE, &val);
-				if (val == AR0832_MONITOR_MODE)
-					break;
-				msleep(10);
-			}
-		}
-	case AR0832_MONITOR_MODE:
-	case AR0832_STILLCAP_MODE:
-		err = ar0832_writeb(sd, AR0832_CATEGORY_SYS,
-			AR0832_SYS_MODE, mode);
-		for (i = AR0832_I2C_VERIFY; i; i--) {
-			err = ar0832_readb(sd, AR0832_CATEGORY_SYS,
-				AR0832_SYS_MODE, &val);
-			if (val == AR0832_MONITOR_MODE)
-				break;
-			msleep(10);
-		}
-		break;
-
-	default:
-		cam_warn("current mode is unknown, %d\n", old_mode);
-		err = -EINVAL;
-	}
-
-	if (err < 0)
-		return err;
-
-	for (i = AR0832_I2C_VERIFY; i; i--) {
-		err = ar0832_readb(sd, AR0832_CATEGORY_SYS,
-			AR0832_SYS_MODE, &val);
-		if (val == mode)
-			break;
-		msleep(10);
-	}
-
-	cam_trace("X\n");
-	return old_mode;
-}
-
-/*
- * v4l2_subdev_core_ops
- */
-static int ar0832_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ar0832_ctrls); i++) {
-		if (qc->id == ar0832_ctrls[i].id) {
-			qc->maximum = ar0832_ctrls[i].maximum;
-			qc->minimum = ar0832_ctrls[i].minimum;
-			qc->step = ar0832_ctrls[i].step;
-			qc->default_value = ar0832_ctrls[i].default_value;
-			return 0;
-		}
-	}
-
-	return -EINVAL;
-}
-
-static int ar0832_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct ar0832_state *state = to_state(sd);
-	int err = 0;
-
-	switch (ctrl->id) {
-	case V4L2_CID_CAMERA_AUTO_FOCUS_RESULT:
-		ctrl->value = state->focus.status;
-		break;
-
-	case V4L2_CID_CAM_JPEG_MEMSIZE:
-		ctrl->value = AR0832_JPEG_MAXSIZE +
-			AR0832_THUMB_MAXSIZE + AR0832_POST_MAXSIZE;
-		break;
-
-	case V4L2_CID_CAM_JPEG_MAIN_SIZE:
-		ctrl->value = state->jpeg.main_size;
-		break;
-
-	case V4L2_CID_CAM_JPEG_MAIN_OFFSET:
-		ctrl->value = state->jpeg.main_offset;
-		break;
-
-	case V4L2_CID_CAM_JPEG_THUMB_SIZE:
-		ctrl->value = state->jpeg.thumb_size;
-		break;
-
-	case V4L2_CID_CAM_JPEG_THUMB_OFFSET:
-		ctrl->value = state->jpeg.thumb_offset;
-		break;
-
-	case V4L2_CID_CAM_JPEG_POSTVIEW_OFFSET:
-		ctrl->value = state->jpeg.postview_offset;
-		break;
-
-	case V4L2_CID_CAMERA_EXIF_FLASH:
-		ctrl->value = state->exif.flash;
-		break;
-
-	case V4L2_CID_CAMERA_EXIF_ISO:
-		ctrl->value = state->exif.iso;
-		break;
-
-	case V4L2_CID_CAMERA_EXIF_TV:
-		ctrl->value = state->exif.tv;
-		break;
-
-	case V4L2_CID_CAMERA_EXIF_BV:
-		ctrl->value = state->exif.bv;
-		break;
-
-	case V4L2_CID_CAMERA_EXIF_EBV:
-		ctrl->value = state->exif.ebv;
-		break;
-
-	default:
-		cam_err("no such control id %d\n",
-				ctrl->id - V4L2_CID_PRIVATE_BASE);
-		/*err = -ENOIOCTLCMD*/
-		err = 0;
-		break;
-	}
-
-	if (err < 0 && err != -ENOIOCTLCMD)
-		cam_err("failed, id %d\n", ctrl->id - V4L2_CID_PRIVATE_BASE);
-
-	return err;
-}
-
-#ifdef CONFIG_TARGET_LOCALE_KOR
-static int ar0832_set_antibanding(struct v4l2_subdev *sd, int val)
-{
-	int antibanding = 0x02;	/* Fix 60Hz for domastic */
-	int err = 0;
-
-	cam_dbg("E, value %d\n", val);
-
-	antibanding = val;
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_AE,	AR0832_AE_FLICKER, antibanding);
-	CHECK_ERR(err);
-
-	cam_trace("X\n");
-	return err;
-}
-#endif
-
-static int ar0832_set_af_softlanding(struct v4l2_subdev *sd)
-{
-	struct ar0832_state *state = to_state(sd);
-	u32 status = 0;
-	int i, err = 0;
-
-	cam_trace("E\n");
-
-	if (unlikely(state->isp.bad_fw)) {
-		cam_err("\"Unknown\" state, please update F/W");
-		return -ENOSYS;
-	}
-
-	err = ar0832_set_mode(sd, AR0832_MONITOR_MODE);
-	if (err <= 0) {
-		cam_err("failed to set mode\n");
-		return err;
-	}
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_LENS, AR0832_LENS_AF_MODE, 0x07);
-	CHECK_ERR(err);
-
-	for (i = AR0832_I2C_VERIFY; i; i--) {
-		msleep(10);
-		err = ar0832_readb(sd, AR0832_CATEGORY_LENS,
-			AR0832_LENS_AF_STATUS, &status);
-		CHECK_ERR(err);
-
-		if ((status & 0x01) == 0x00)
-			break;
-	}
-
-	if ((status & 0x01) != 0x00) {
-		cam_err("failed\n");
-		return -ETIMEDOUT;
-	}
-
-	cam_trace("X\n");
-	return err;
-}
-
-static int ar0832_dump_fw(struct v4l2_subdev *sd)
-{
-	struct file *fp;
-	mm_segment_t old_fs;
-	u8 *buf, val;
-	u32 addr, unit, count, intram_unit = 0x1000;
-	int i, j, err;
-
-	old_fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	fp = filp_open(AR0832_FW_DUMP_PATH,
-		O_WRONLY|O_CREAT|O_TRUNC, S_IRUGO|S_IWUGO|S_IXUSR);
-	if (IS_ERR(fp)) {
-		cam_err("failed to open %s, err %ld\n",
-			AR0832_FW_DUMP_PATH, PTR_ERR(fp));
-		err = -ENOENT;
-		goto out0;
-	}
-
-	buf = kmalloc(intram_unit, GFP_KERNEL);
-	if (!buf) {
-		cam_err("failed to allocate memory\n");
-		err = -ENOMEM;
-		goto out0;
-	}
-
-	cam_dbg("start, file path %s\n", AR0832_FW_DUMP_PATH);
-
-	/* set pin */
-	val = 0x7E;
-	err = ar0832_mem_write(sd, 0x04, sizeof(val), 0x50000308, &val);
-	if (err < 0) {
-		cam_err("i2c falied, err %d\n", err);
-		goto out1;
-	}
-
-	addr = AR0832_FLASH_BASE_ADDR;
-	unit = SZ_64K;
-	count = 31;
-	for (i = 0; i < count; i++) {
-		for (j = 0; j < unit; j += intram_unit) {
-			err = ar0832_mem_read(sd,
-				intram_unit, addr + (i * unit) + j, buf);
-			if (err < 0) {
-				cam_err("i2c falied, err %d\n", err);
-				goto out1;
-			}
-			vfs_write(fp, buf, intram_unit, &fp->f_pos);
-		}
-	}
-
-	addr = AR0832_FLASH_BASE_ADDR + SZ_64K * count;
-	unit = SZ_8K;
-	count = 4;
-	for (i = 0; i < count; i++) {
-		for (j = 0; j < unit; j += intram_unit) {
-			err = ar0832_mem_read(sd,
-				intram_unit, addr + (i * unit) + j, buf);
-			if (err < 0) {
-				cam_err("i2c falied, err %d\n", err);
-				goto out1;
-			}
-			vfs_write(fp, buf, intram_unit, &fp->f_pos);
-		}
-	}
-
-	cam_dbg("end\n");
-out1:
-	kfree(buf);
-out0:
-	if (!IS_ERR(fp))
-		filp_close(fp, current->files);
-	set_fs(old_fs);
-
-	return err;
-}
-
-static int ar0832_get_sensor_fw_version(struct v4l2_subdev *sd,
-	char *buf)
-{
-	u8 val;
-	int err;
-
-	/* set pin */
-	val = 0x7E;
-	err = ar0832_mem_write(sd, 0x04, sizeof(val), 0x50000308, &val);
-	CHECK_ERR(err);
-
-	err = ar0832_mem_read(sd, AR0832_FW_VER_LEN,
-		AR0832_FLASH_BASE_ADDR + AR0832_FW_VER_FILE_CUR, buf);
-
-	cam_dbg("%s\n", buf);
-	return 0;
-}
-
-static int ar0832_get_phone_fw_version(struct v4l2_subdev *sd,
-	char *buf)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct device *dev = &client->adapter->dev;
-	u8 sensor_ver[AR0832_FW_VER_LEN] = {0, };
-	const struct firmware *fentry;
-	int err;
-
-#ifdef SDCARD_FW
-	struct file *fp;
-	mm_segment_t old_fs;
-	long nread;
-	int fw_requested = 1;
-
-	old_fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	fp = filp_open(AR0832_FW_PATH, O_RDONLY, 0);
-	if (IS_ERR(fp)) {
-		cam_trace("failed to open %s, err %ld\n", AR0832_FW_PATH, PTR_ERR(fp));
-		goto request_fw;
-	}
-
-	fw_requested = 0;
-	err = vfs_llseek(fp, AR0832_FW_VER_FILE_CUR, SEEK_SET);
-	if (err < 0) {
-		cam_warn("failed to fseek, %d\n", err);
-		goto out;
-	}
-
-	nread = vfs_read(fp, (char __user *)buf, AR0832_FW_VER_LEN, &fp->f_pos);
-	if (nread != AR0832_FW_VER_LEN) {
-		cam_err("failed to read firmware file, %ld Bytes\n", nread);
-		err = -EIO;
-		goto out;
-	}
-
-request_fw:
-	if (fw_requested) {
-		set_fs(old_fs);
-#endif /* SDCARD_FW */
-	ar0832_get_sensor_fw_version(sd, sensor_ver);
-
-	if (sensor_ver[0] == 'T')
-		err = request_firmware(&fentry, AR0832T_FW_REQUEST_PATH, dev);
-	else
-		err = request_firmware(&fentry, AR0832O_FW_REQUEST_PATH, dev);
-
-	if (err != 0) {
-		cam_err("request_firmware falied\n");
-		err = -EINVAL;
-		goto out;
-	}
-
-	memcpy(buf, (u8 *)&fentry->data[AR0832_FW_VER_FILE_CUR], AR0832_FW_VER_LEN);
-#ifdef SDCARD_FW
-	}
-#endif /* SDCARD_FW */
-
-out:
-#ifdef SDCARD_FW
-	if (!fw_requested) {
-		filp_close(fp, current->files);
-		set_fs(old_fs);
-	}
-#endif  /* SDCARD_FW */
-
-	cam_dbg("%s\n", buf);
-	return 0;
-}
-
-static int ar0832_check_fw(struct v4l2_subdev *sd)
-{
-	struct ar0832_state *state = to_state(sd);
-	u8 sensor_ver[AR0832_FW_VER_LEN] = "FAILED Fujitsu AR0832LS";
-	u8 phone_ver[AR0832_FW_VER_LEN] = "FAILED Fujitsu AR0832LS";
-	int af_cal_h = 0, af_cal_l = 0;
-	int rg_cal_h = 0, rg_cal_l = 0;
-	int bg_cal_h = 0, bg_cal_l = 0;
-	int update_count = 0;
-	u32 int_factor;
-	int err;
-
-	cam_trace("E\n");
-
-	/* F/W version */
-	ar0832_get_phone_fw_version(sd, phone_ver);
-
-	if (state->isp.bad_fw)
-		goto out;
-
-	ar0832_get_sensor_fw_version(sd, sensor_ver);
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_FLASH, AR0832_FLASH_CAM_START, 0x01);
-	CHECK_ERR(err);
-
-	int_factor = ar0832_wait_interrupt(sd, AR0832_ISP_TIMEOUT);
-	if (!(int_factor & AR0832_INT_MODE)) {
-		cam_err("firmware was erased?\n");
-		return -ETIMEDOUT;
-	}
-
-	err = ar0832_readb(sd, AR0832_CATEGORY_LENS, AR0832_LENS_AF_CAL, &af_cal_l);
-	CHECK_ERR(err);
-
-	err = ar0832_readb(sd, AR0832_CATEGORY_ADJST, AR0832_ADJST_AWB_RG_H, &rg_cal_h);
-	CHECK_ERR(err);
-	err = ar0832_readb(sd, AR0832_CATEGORY_ADJST, AR0832_ADJST_AWB_RG_L, &rg_cal_l);
-	CHECK_ERR(err);
-
-	err = ar0832_readb(sd, AR0832_CATEGORY_ADJST, AR0832_ADJST_AWB_BG_H, &bg_cal_h);
-	CHECK_ERR(err);
-	err = ar0832_readb(sd, AR0832_CATEGORY_ADJST, AR0832_ADJST_AWB_BG_L, &bg_cal_l);
-	CHECK_ERR(err);
-
-out:
-	if (!state->fw_version) {
-		state->fw_version = kzalloc(50, GFP_KERNEL);
-		if (!state->fw_version) {
-			cam_err("no memory for F/W version\n");
-			return -ENOMEM;
-		}
-	}
-
-	sprintf(state->fw_version, "%s %s %d %x %x %x %x %x %x",
-		sensor_ver, phone_ver, update_count,
-		af_cal_h, af_cal_l, rg_cal_h, rg_cal_l, bg_cal_h, bg_cal_l);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_sensor_mode(struct v4l2_subdev *sd, int val)
-{
-	struct ar0832_state *state = to_state(sd);
-	int err;
-	cam_dbg("E, value %d\n", val);
-
-	err = ar0832_set_mode(sd, AR0832_PARMSET_MODE);
-	CHECK_ERR(err);
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_PARM,
-		AR0832_PARM_HDMOVIE, val == SENSOR_MOVIE ? 0x01 : 0x00);
-	CHECK_ERR(err);
-
-	state->sensor_mode = val;
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_flash(struct v4l2_subdev *sd, int val, int recording)
-{
-	struct ar0832_state *state = to_state(sd);
-	int light, flash;
-	int err;
-	cam_dbg("E, value %d\n", val);
-
-	if (!recording)
-		state->flash_mode = val;
-
-	/* movie flash mode should be set when recording is started */
-	if (state->sensor_mode == SENSOR_MOVIE && !recording)
-		return 0;
-
-retry:
-	switch (val) {
-	case FLASH_MODE_OFF:
-		light = 0x00;
-		flash = (state->sensor_mode == SENSOR_CAMERA) ? 0x00 : -1;
-		break;
-
-	case FLASH_MODE_AUTO:
-		light = (state->sensor_mode == SENSOR_CAMERA) ? 0x02 : 0x04;
-		flash = (state->sensor_mode == SENSOR_CAMERA) ? 0x02 : -1;
-		break;
-
-	case FLASH_MODE_ON:
-		light = (state->sensor_mode == SENSOR_CAMERA) ? 0x01 : 0x03;
-		flash = (state->sensor_mode == SENSOR_CAMERA) ? 0x01 : -1;
-		break;
-
-	case FLASH_MODE_TORCH:
-		light = 0x03;
-		flash = -1;
-		break;
-
-	default:
-		cam_warn("invalid value, %d\n", val);
-		val = FLASH_MODE_OFF;
-		goto retry;
-	}
-
-	if (light >= 0) {
-		err = ar0832_writeb(sd, AR0832_CATEGORY_CAPPARM,
-			AR0832_CAPPARM_LIGHT_CTRL, light);
-		CHECK_ERR(err);
-	}
-
-	if (flash >= 0) {
-		err = ar0832_writeb(sd, AR0832_CATEGORY_CAPPARM,
-			AR0832_CAPPARM_FLASH_CTRL, flash);
-		CHECK_ERR(err);
-	}
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_iso(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct v4l2_queryctrl qc = {0,};
-	int val = ctrl->value, err;
-	u32 iso[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05};
-	cam_dbg("E, value %d\n", val);
-
-	qc.id = ctrl->id;
-	ar0832_queryctrl(sd, &qc);
-
-	if (val < qc.minimum || val > qc.maximum) {
-		cam_warn("invalied value, %d\n", val);
-		val = qc.default_value;
-	}
-
-	val -= qc.minimum;
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_AE, AR0832_AE_ISOSEL, iso[val]);
-	CHECK_ERR(err);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_metering(struct v4l2_subdev *sd, int val)
-{
-	int err;
-	cam_dbg("E, value %d\n", val);
-
-retry:
-	switch (val) {
-	case METERING_CENTER:
-		err = ar0832_writeb(sd, AR0832_CATEGORY_AE, AR0832_AE_MODE, 0x03);
-		CHECK_ERR(err);
-		break;
-	case METERING_SPOT:
-		err = ar0832_writeb(sd, AR0832_CATEGORY_AE, AR0832_AE_MODE, 0x06);
-		CHECK_ERR(err);
-		break;
-	case METERING_MATRIX:
-		err = ar0832_writeb(sd, AR0832_CATEGORY_AE, AR0832_AE_MODE, 0x01);
-		CHECK_ERR(err);
-		break;
-	default:
-		cam_warn("invalid value, %d\n", val);
-		val = METERING_CENTER;
-		goto retry;
-	}
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_exposure(struct v4l2_subdev *sd,
-	struct v4l2_control *ctrl)
-{
-	struct v4l2_queryctrl qc = {0,};
-	int val = ctrl->value, err;
-	u32 exposure[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
-	cam_dbg("E, value %d\n", val);
-
-	qc.id = ctrl->id;
-	ar0832_queryctrl(sd, &qc);
-
-	if (val < qc.minimum || val > qc.maximum) {
-		cam_warn("invalied value, %d\n", val);
-		val = qc.default_value;
-	}
-
-	val -= qc.minimum;
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_AE,
-		AR0832_AE_INDEX, exposure[val]);
-	CHECK_ERR(err);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_whitebalance(struct v4l2_subdev *sd, int val)
-{
-	int err;
-	cam_dbg("E, value %d\n", val);
-
-retry:
-	switch (val) {
-	case WHITE_BALANCE_AUTO:
-		err = ar0832_writeb(sd, AR0832_CATEGORY_WB,
-			AR0832_WB_AWB_MODE, 0x01);
-		CHECK_ERR(err);
-		err = ar0832_writeb(sd, AR0832_CATEGORY_WB,
-			AR0832_WB_AWB_MANUAL, 0x01);
-		CHECK_ERR(err);
-		break;
-
-	case WHITE_BALANCE_SUNNY:
-		err = ar0832_writeb(sd, AR0832_CATEGORY_WB,
-			AR0832_WB_AWB_MODE, 0x02);
-		CHECK_ERR(err);
-		err = ar0832_writeb(sd, AR0832_CATEGORY_WB,
-			AR0832_WB_AWB_MANUAL, 0x04);
-		CHECK_ERR(err);
-		break;
-
-	case WHITE_BALANCE_CLOUDY:
-		err = ar0832_writeb(sd, AR0832_CATEGORY_WB,
-			AR0832_WB_AWB_MODE, 0x02);
-		CHECK_ERR(err);
-		err = ar0832_writeb(sd, AR0832_CATEGORY_WB,
-			AR0832_WB_AWB_MANUAL, 0x05);
-		CHECK_ERR(err);
-		break;
-
-	case WHITE_BALANCE_TUNGSTEN:
-		err = ar0832_writeb(sd, AR0832_CATEGORY_WB,
-			AR0832_WB_AWB_MODE, 0x02);
-		CHECK_ERR(err);
-		err = ar0832_writeb(sd, AR0832_CATEGORY_WB,
-			AR0832_WB_AWB_MANUAL, 0x01);
-		CHECK_ERR(err);
-		break;
-
-	case WHITE_BALANCE_FLUORESCENT:
-		err = ar0832_writeb(sd, AR0832_CATEGORY_WB,
-			AR0832_WB_AWB_MODE, 0x02);
-		CHECK_ERR(err);
-		err = ar0832_writeb(sd, AR0832_CATEGORY_WB,
-			AR0832_WB_AWB_MANUAL, 0x02);
-		CHECK_ERR(err);
-		break;
-
-	default:
-		cam_warn("invalid value, %d\n", val);
-		val = WHITE_BALANCE_AUTO;
-		goto retry;
-	}
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_sharpness(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct v4l2_queryctrl qc = {0,};
-	int val = ctrl->value, err;
-	u32 sharpness[] = {0x03, 0x04, 0x05, 0x06, 0x07};
-	cam_dbg("E, value %d\n", val);
-
-	qc.id = ctrl->id;
-	ar0832_queryctrl(sd, &qc);
-
-	if (val < qc.minimum || val > qc.maximum) {
-		cam_warn("invalied value, %d\n", val);
-		val = qc.default_value;
-	}
-
-	val -= qc.minimum;
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_MON,
-		AR0832_MON_EDGE_LVL, sharpness[val]);
-	CHECK_ERR(err);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_saturation(struct v4l2_subdev *sd,
-	struct v4l2_control *ctrl)
-{
-	struct v4l2_queryctrl qc = {0,};
-	int val = ctrl->value, err;
-	u32 saturation[] = {0x01, 0x02, 0x03, 0x04, 0x05};
-	cam_dbg("E, value %d\n", val);
-
-	qc.id = ctrl->id;
-	ar0832_queryctrl(sd, &qc);
-
-	if (val < qc.minimum || val > qc.maximum) {
-		cam_warn("invalied value, %d\n", val);
-		val = qc.default_value;
-	}
-
-	val -= qc.minimum;
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_MON,
-		AR0832_MON_CHROMA_LVL, saturation[val]);
-	CHECK_ERR(err);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_scene_mode(struct v4l2_subdev *sd, int val)
-{
-	struct v4l2_control ctrl;
-	int evp, iso, brightness, whitebalance, sharpness, saturation;
-	int err;
-	cam_dbg("E, value %d\n", val);
-
-	iso = ISO_AUTO;
-	brightness = EV_DEFAULT;
-	whitebalance = WHITE_BALANCE_AUTO;
-	sharpness = SHARPNESS_DEFAULT;
-	saturation = CONTRAST_DEFAULT;
-
-retry:
-	switch (val) {
-	case SCENE_MODE_NONE:
-		evp = 0x00;
-		break;
-
-	case SCENE_MODE_PORTRAIT:
-		evp = 0x01;
-		sharpness = SHARPNESS_MINUS_1;
-		break;
-
-	case SCENE_MODE_LANDSCAPE:
-		evp = 0x02;
-		sharpness = SHARPNESS_PLUS_1;
-		saturation = SATURATION_PLUS_1;
-		break;
-
-	case SCENE_MODE_SPORTS:
-		evp = 0x03;
-		break;
-
-	case SCENE_MODE_PARTY_INDOOR:
-		evp = 0x04;
-		/*iso = ISO_200; sensor will set internally */
-		saturation = SATURATION_PLUS_1;
-		break;
-
-	case SCENE_MODE_BEACH_SNOW:
-		evp = 0x05;
-		/*iso = ISO_50; sensor will set internally */
-		brightness = EV_PLUS_2;
-		saturation = SATURATION_PLUS_1;
-		break;
-
-	case SCENE_MODE_SUNSET:
-		evp = 0x06;
-		whitebalance = WHITE_BALANCE_SUNNY;
-		break;
-
-	case SCENE_MODE_DUSK_DAWN:
-		evp = 0x07;
-		whitebalance = WHITE_BALANCE_FLUORESCENT;
-		break;
-
-	case SCENE_MODE_FALL_COLOR:
-		evp = 0x08;
-		saturation = SATURATION_PLUS_2;
-		break;
-
-	case SCENE_MODE_NIGHTSHOT:
-		evp = 0x09;
-		break;
-
-	case SCENE_MODE_BACK_LIGHT:
-		evp = 0x0A;
-		break;
-
-	case SCENE_MODE_FIREWORKS:
-		evp = 0x0B;
-		/*iso = ISO_50; sensor will set internally */
-		break;
-
-	case SCENE_MODE_TEXT:
-		evp = 0x0C;
-		sharpness = SHARPNESS_PLUS_2;
-		break;
-
-	case SCENE_MODE_CANDLE_LIGHT:
-		evp = 0x0D;
-		whitebalance = WHITE_BALANCE_SUNNY;
-		break;
-
-	default:
-		cam_warn("invalid value, %d\n", val);
-		val = SCENE_MODE_NONE;
-		goto retry;
-	}
-
-	/* EV-P */
-	err = ar0832_writeb(sd, AR0832_CATEGORY_AE, AR0832_AE_EP_MODE_MON, evp);
-	CHECK_ERR(err);
-	err = ar0832_writeb(sd, AR0832_CATEGORY_AE, AR0832_AE_EP_MODE_CAP, evp);
-	CHECK_ERR(err);
-
-	/* ISO */
-	ctrl.id = V4L2_CID_CAMERA_ISO;
-	ctrl.value = iso;
-	ar0832_set_iso(sd, &ctrl);
-
-	/* EV Bias */
-	ctrl.id = V4L2_CID_CAMERA_BRIGHTNESS;
-	ctrl.value = brightness;
-	ar0832_set_exposure(sd, &ctrl);
-
-	/* AWB */
-	ar0832_set_whitebalance(sd, whitebalance);
-
-	/* Chroma Saturation */
-	ctrl.id = V4L2_CID_CAMERA_SATURATION;
-	ctrl.value = saturation;
-	ar0832_set_saturation(sd, &ctrl);
-
-	/* Sharpness */
-	ctrl.id = V4L2_CID_CAMERA_SHARPNESS;
-	ctrl.value = sharpness;
-	ar0832_set_sharpness(sd, &ctrl);
-
-	/* Emotional Color */
-	err = ar0832_writeb(sd, AR0832_CATEGORY_CAPPARM,
-		AR0832_CAPPARM_MCC_MODE, val == SCENE_MODE_NONE ? 0x01 : 0x00);
-	CHECK_ERR(err);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_effect_color(struct v4l2_subdev *sd, int val)
-{
-	u32 int_factor;
-	int on, old_mode, cb, cr;
-	int err;
-
-	err = ar0832_readb(sd, AR0832_CATEGORY_PARM, AR0832_PARM_EFFECT, &on);
-	CHECK_ERR(err);
-	if (on)	{
-		old_mode = ar0832_set_mode(sd, AR0832_PARMSET_MODE);
-		CHECK_ERR(old_mode);
-
-		err = ar0832_writeb(sd, AR0832_CATEGORY_PARM, AR0832_PARM_EFFECT, 0);
-		CHECK_ERR(err);
-
-		if (old_mode == AR0832_MONITOR_MODE) {
-			err = ar0832_set_mode(sd, old_mode);
-			CHECK_ERR(err);
-
-			int_factor = ar0832_wait_interrupt(sd, AR0832_ISP_TIMEOUT);
-			if (!(int_factor & AR0832_INT_MODE)) {
-				cam_err("AR0832_INT_MODE isn't issued, %#x\n",
-					int_factor);
-				return -ETIMEDOUT;
-			}
-			CHECK_ERR(err);
-		}
-	}
-
-	switch (val) {
-	case IMAGE_EFFECT_NONE:
-		break;
-
-	case IMAGE_EFFECT_SEPIA:
-		cb = 0xD8;
-		cr = 0x18;
-		break;
-
-	case IMAGE_EFFECT_BNW:
-		cb = 0x00;
-		cr = 0x00;
-		break;
-	}
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_MON,
-		AR0832_MON_COLOR_EFFECT, val == IMAGE_EFFECT_NONE ? 0x00 : 0x01);
-		CHECK_ERR(err);
-
-	if (val != IMAGE_EFFECT_NONE) {
-		err = ar0832_writeb(sd, AR0832_CATEGORY_MON, AR0832_MON_CFIXB, cb);
-		CHECK_ERR(err);
-		err = ar0832_writeb(sd, AR0832_CATEGORY_MON, AR0832_MON_CFIXR, cr);
-		CHECK_ERR(err);
-	}
-
-	return 0;
-}
-
-static int ar0832_set_effect_gamma(struct v4l2_subdev *sd, s32 val)
-{
-	u32 int_factor;
-	int on, effect, old_mode;
-	int err;
-
-	err = ar0832_readb(sd, AR0832_CATEGORY_MON, AR0832_MON_COLOR_EFFECT, &on);
-	CHECK_ERR(err);
-	if (on) {
-		err = ar0832_writeb(sd, AR0832_CATEGORY_MON,
-			AR0832_MON_COLOR_EFFECT, 0);
-		CHECK_ERR(err);
-	}
-
-	switch (val) {
-	case IMAGE_EFFECT_NEGATIVE:
-		effect = 0x01;
-		break;
-
-	case IMAGE_EFFECT_AQUA:
-		effect = 0x08;
-		break;
-	}
-
-	old_mode = ar0832_set_mode(sd, AR0832_PARMSET_MODE);
-	CHECK_ERR(old_mode);
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_PARM, AR0832_PARM_EFFECT, effect);
-	CHECK_ERR(err);
-
-	if (old_mode == AR0832_MONITOR_MODE) {
-		err = ar0832_set_mode(sd, old_mode);
-		CHECK_ERR(err);
-
-		int_factor = ar0832_wait_interrupt(sd, AR0832_ISP_TIMEOUT);
-		if (!(int_factor & AR0832_INT_MODE)) {
-			cam_err("AR0832_INT_MODE isn't issued, %#x\n",
-				int_factor);
-			return -ETIMEDOUT;
-		}
-		CHECK_ERR(err);
-	}
-
-	return err;
-}
-
-static int ar0832_set_effect(struct v4l2_subdev *sd, int val)
-{
-	int err;
-	cam_dbg("E, value %d\n", val);
-
-retry:
-	switch (val) {
-	case IMAGE_EFFECT_NONE:
-	case IMAGE_EFFECT_BNW:
-	case IMAGE_EFFECT_SEPIA:
-		err = ar0832_set_effect_color(sd, val);
-		CHECK_ERR(err);
-		break;
-
-	case IMAGE_EFFECT_AQUA:
-	case IMAGE_EFFECT_NEGATIVE:
-		err = ar0832_set_effect_gamma(sd, val);
-		CHECK_ERR(err);
-		break;
-
-	default:
-		cam_warn("invalid value, %d\n", val);
-		val = IMAGE_EFFECT_NONE;
-		goto retry;
-	}
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_wdr(struct v4l2_subdev *sd, int val)
-{
-	int contrast, wdr, err;
-
-	cam_dbg("%s\n", val ? "on" : "off");
-
-	contrast = (val == 1 ? 0x09 : 0x05);
-	wdr = (val == 1 ? 0x01 : 0x00);
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_MON,
-			AR0832_MON_TONE_CTRL, contrast);
-		CHECK_ERR(err);
-	err = ar0832_writeb(sd, AR0832_CATEGORY_CAPPARM,
-			AR0832_CAPPARM_WDR_EN, wdr);
-		CHECK_ERR(err);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_antishake(struct v4l2_subdev *sd, int val)
-{
-	int ahs, err;
-
-	cam_dbg("%s\n", val ? "on" : "off");
-
-	ahs = (val == 1 ? 0x0E : 0x00);
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_AE, AR0832_AE_EP_MODE_MON, ahs);
-		CHECK_ERR(err);
-	err = ar0832_writeb(sd, AR0832_CATEGORY_AE, AR0832_AE_EP_MODE_CAP, ahs);
-		CHECK_ERR(err);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_face_beauty(struct v4l2_subdev *sd, int val)
-{
-	struct ar0832_state *state = to_state(sd);
-	int err;
-
-	cam_dbg("%s\n", val ? "on" : "off");
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_CAPPARM,
-		AR0832_CAPPARM_AFB_CAP_EN, val ? 0x01 : 0x00);
-	CHECK_ERR(err);
-
-	state->beauty_mode = val;
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_lock(struct v4l2_subdev *sd, int val)
-{
-	struct ar0832_state *state = to_state(sd);
-
-	cam_trace("%s\n", val ? "on" : "off");
-
-	ar0832_writeb(sd, AR0832_CATEGORY_AE, AR0832_AE_LOCK, val);
-	ar0832_writeb(sd, AR0832_CATEGORY_WB, AR0832_AWB_LOCK, val);
-	state->focus.lock = val;
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_af(struct v4l2_subdev *sd, int val)
-{
-	struct ar0832_state *state = to_state(sd);
-	int i, status, err;
-
-	cam_info("%s, mode %#x\n", val ? "start" : "stop", state->focus.mode);
-
-	state->focus.status = 0;
-
-	if (state->focus.mode != FOCUS_MODE_CONTINOUS) {
-		err = ar0832_writeb(sd, AR0832_CATEGORY_LENS,
-			AR0832_LENS_AF_START, val);
-		CHECK_ERR(err);
-
-		if (!(state->focus.touch &&
-			state->focus.mode == FOCUS_MODE_TOUCH)) {
-			if (val && state->focus.lock) {
-				ar0832_set_lock(sd, 0);
-				msleep(100);
-			}
-			ar0832_set_lock(sd, val);
-		}
-
-		/* check AF status for 6 sec */
-		for (i = 600; i && err; i--) {
-			msleep(10);
-			err = ar0832_readb(sd, AR0832_CATEGORY_LENS,
-				AR0832_LENS_AF_STATUS, &status);
-			CHECK_ERR(err);
-
-			if (!(status & 0x01))
-				err = 0;
-		}
-
-		state->focus.status = status;
-	} else {
-		err = ar0832_writeb(sd, AR0832_CATEGORY_LENS,
-			AR0832_LENS_AF_START, val ? 0x02 : 0x00);
-		CHECK_ERR(err);
-
-		err = -EBUSY;
-		for (i = AR0832_I2C_VERIFY; i && err; i--) {
-			msleep(10);
-			err = ar0832_readb(sd, AR0832_CATEGORY_LENS,
-				AR0832_LENS_AF_STATUS, &status);
-			CHECK_ERR(err);
-
-			if ((val && status == 0x05) || (!val && status != 0x05))
-				err = 0;
-		}
-	}
-
-	cam_dbg("X\n");
-	return err;
-}
-
-static int ar0832_set_af_mode(struct v4l2_subdev *sd, int val)
-{
-	struct ar0832_state *state = to_state(sd);
-	struct regulator *movie = regulator_get(NULL, "led_movie");
-	u32 cancel, mode, status = 0;
-	int i, err;
-
-	cancel = val & FOCUS_MODE_DEFAULT;
-	val &= 0xFF;
-
-retry:
-	switch (val) {
-	case FOCUS_MODE_AUTO:
-		mode = 0x00;
-		break;
-
-	case FOCUS_MODE_MACRO:
-		mode = 0x01;
-		break;
-
-	case FOCUS_MODE_CONTINOUS:
-		mode = 0x02;
-		cancel = 0;
-		break;
-
-	case FOCUS_MODE_FACEDETECT:
-		mode = 0x03;
-		break;
-
-	case FOCUS_MODE_TOUCH:
-		mode = 0x04;
-		cancel = 0;
-		break;
-
-	case FOCUS_MODE_INFINITY:
-		mode = 0x06;
-		cancel = 0;
-		break;
-
-	default:
-		cam_warn("invalid value, %d", val);
-		val = FOCUS_MODE_AUTO;
-		goto retry;
-	}
-
-	if (cancel) {
-		ar0832_set_af(sd, 0);
-		ar0832_set_lock(sd, 0);
-	} else {
-		if (state->focus.mode == val)
-			return 0;
-	}
-
-	cam_dbg("E, value %d\n", val);
-
-	if (val == FOCUS_MODE_FACEDETECT) {
-		/* enable face detection */
-		err = ar0832_writeb(sd, AR0832_CATEGORY_FD, AR0832_FD_CTL, 0x11);
-		CHECK_ERR(err);
-		msleep(10);
-	} else if (state->focus.mode == FOCUS_MODE_FACEDETECT) {
-		/* disable face detection */
-		err = ar0832_writeb(sd, AR0832_CATEGORY_FD, AR0832_FD_CTL, 0x00);
-		CHECK_ERR(err);
-	}
-
-	if (val == FOCUS_MODE_MACRO)
-		regulator_set_current_limit(movie, 15000, 17000);
-	else if (state->focus.mode == FOCUS_MODE_MACRO)
-		regulator_set_current_limit(movie, 90000, 110000);
-
-	state->focus.mode = val;
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_LENS, AR0832_LENS_AF_MODE, mode);
-	CHECK_ERR(err);
-
-	for (i = AR0832_I2C_VERIFY; i; i--) {
-		msleep(10);
-		err = ar0832_readb(sd, AR0832_CATEGORY_LENS,
-			AR0832_LENS_AF_STATUS, &status);
-		CHECK_ERR(err);
-
-		if (!(status & 0x01))
-			break;
-	}
-
-	if ((status & 0x01) != 0x00) {
-		cam_err("failed\n");
-		return -ETIMEDOUT;
-	}
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_touch_auto_focus(struct v4l2_subdev *sd, int val)
-{
-	struct ar0832_state *state = to_state(sd);
-	int err;
-	cam_info("%s\n", val ? "start" : "stop");
-
-	state->focus.touch = val;
-
-	if (val) {
-		err = ar0832_set_af_mode(sd, FOCUS_MODE_TOUCH);
-		if (err < 0) {
-			cam_err("ar0832_set_af_mode failed\n");
-			return err;
-		}
-		err = ar0832_writew(sd, AR0832_CATEGORY_LENS,
-				AR0832_LENS_AF_TOUCH_POSX, state->focus.pos_x);
-		CHECK_ERR(err);
-		err = ar0832_writew(sd, AR0832_CATEGORY_LENS,
-				AR0832_LENS_AF_TOUCH_POSY, state->focus.pos_y);
-		CHECK_ERR(err);
-	}
-
-	cam_trace("X\n");
-	return err;
-}
-
-static int ar0832_set_zoom(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct ar0832_state *state = to_state(sd);
-	struct v4l2_queryctrl qc = {0,};
-	int val = ctrl->value, err;
-	int zoom[] = { 1, 2, 3, 5, 6, 7, 9, 10, 11, 13, 14, 15, 17, 18, 19,
-		20, 21, 22, 24, 25, 26, 28, 29, 30, 31, 32, 34, 35, 36, 38, 39};
-	cam_dbg("E, value %d\n", val);
-
-	qc.id = ctrl->id;
-	ar0832_queryctrl(sd, &qc);
-
-	if (val < qc.minimum || val > qc.maximum) {
-		cam_warn("invalied value, %d\n", val);
-		val = qc.default_value;
-	}
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_MON, AR0832_MON_ZOOM, zoom[val]);
-	CHECK_ERR(err);
-
-	state->zoom = val;
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_set_jpeg_quality(struct v4l2_subdev *sd,
-	struct v4l2_control *ctrl)
-{
-	struct v4l2_queryctrl qc = {0,};
-	int val = ctrl->value, ratio, err;
-	cam_dbg("E, value %d\n", val);
-
-	qc.id = ctrl->id;
-	ar0832_queryctrl(sd, &qc);
-
-	if (val < qc.minimum || val > qc.maximum) {
-		cam_warn("invalied value, %d\n", val);
-		val = qc.default_value;
-	}
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_CAPPARM,
-		AR0832_CAPPARM_JPEG_RATIO, 0x62);
-	CHECK_ERR(err);
-
-	if (val <= 65)		/* Normal */
-		ratio = 0x0A;
-	else if (val <= 75)	/* Fine */
-		ratio = 0x05;
-	else			/* Superfine */
-		ratio = 0x00;
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_CAPPARM,
-		AR0832_CAPPARM_JPEG_RATIO_OFS, ratio);
-	CHECK_ERR(err);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_get_exif(struct v4l2_subdev *sd)
-{
-	struct ar0832_state *state = to_state(sd);
-	/* standard values */
-	u16 iso_std_values[] = { 10, 12, 16, 20, 25, 32, 40, 50, 64, 80,
-		100, 125, 160, 200, 250, 320, 400, 500, 640, 800,
-		1000, 1250, 1600, 2000, 2500, 3200, 4000, 5000, 6400, 8000};
-	/* quantization table */
-	u16 iso_qtable[] = { 11, 14, 17, 22, 28, 35, 44, 56, 71, 89,
-		112, 141, 178, 224, 282, 356, 449, 565, 712, 890,
-		1122, 1414, 1782, 2245, 2828, 3564, 4490, 5657, 7127, 8909};
-	int num, den, i, err;
-
-	/* exposure time */
-	err = ar0832_readl(sd, AR0832_CATEGORY_EXIF,
-		AR0832_EXIF_EXPTIME_NUM, &num);
-	CHECK_ERR(err);
-	err = ar0832_readl(sd, AR0832_CATEGORY_EXIF,
-		AR0832_EXIF_EXPTIME_DEN, &den);
-	CHECK_ERR(err);
-	state->exif.exptime = (u32)num*1000/den;
-
-	/* flash */
-	err = ar0832_readw(sd, AR0832_CATEGORY_EXIF, AR0832_EXIF_FLASH, &num);
-	CHECK_ERR(err);
-	state->exif.flash = (u16)num;
-
-	/* iso */
-	err = ar0832_readw(sd, AR0832_CATEGORY_EXIF, AR0832_EXIF_ISO, &num);
-	CHECK_ERR(err);
-	for (i = 0; i < ARRAY_SIZE(iso_qtable); i++) {
-		if (num <= iso_qtable[i]) {
-			state->exif.iso = iso_std_values[i];
-			break;
-		}
-	}
-
-	/* shutter speed */
-	err = ar0832_readl(sd, AR0832_CATEGORY_EXIF, AR0832_EXIF_TV_NUM, &num);
-	CHECK_ERR(err);
-	err = ar0832_readl(sd, AR0832_CATEGORY_EXIF, AR0832_EXIF_TV_DEN, &den);
-	CHECK_ERR(err);
-	state->exif.tv = num*AR0832_DEF_APEX_DEN/den;
-
-	/* brightness */
-	err = ar0832_readl(sd, AR0832_CATEGORY_EXIF, AR0832_EXIF_BV_NUM, &num);
-	CHECK_ERR(err);
-	err = ar0832_readl(sd, AR0832_CATEGORY_EXIF, AR0832_EXIF_BV_DEN, &den);
-	CHECK_ERR(err);
-	state->exif.bv = num*AR0832_DEF_APEX_DEN/den;
-
-	/* exposure */
-	err = ar0832_readl(sd, AR0832_CATEGORY_EXIF, AR0832_EXIF_EBV_NUM, &num);
-	CHECK_ERR(err);
-	err = ar0832_readl(sd, AR0832_CATEGORY_EXIF, AR0832_EXIF_EBV_DEN, &den);
-	CHECK_ERR(err);
-	state->exif.ebv = num*AR0832_DEF_APEX_DEN/den;
-
-	return err;
-}
-
-static int ar0832_start_capture(struct v4l2_subdev *sd, int val)
-{
-	struct ar0832_state *state = to_state(sd);
-	int err, int_factor;
-	cam_trace("E\n");
-
-	if (!(state->isp.int_factor & AR0832_INT_CAPTURE)) {
-		int_factor = ar0832_wait_interrupt(sd,
-			state->beauty_mode ? AR0832_ISP_AFB_TIMEOUT : AR0832_ISP_TIMEOUT);
-		if (!(int_factor & AR0832_INT_CAPTURE)) {
-			cam_warn("AR0832_INT_CAPTURE isn't issued, %#x\n", int_factor);
-			return -ETIMEDOUT;
-		}
-	}
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_CAPCTRL, AR0832_CAPCTRL_FRM_SEL, 0x01);
-	CHECK_ERR(err);
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_CAPCTRL,
-		AR0832_CAPCTRL_TRANSFER, 0x01);
-	int_factor = ar0832_wait_interrupt(sd, AR0832_ISP_TIMEOUT);
-	if (!(int_factor & AR0832_INT_CAPTURE)) {
-		cam_warn("AR0832_INT_CAPTURE isn't issued on transfer, %#x\n", int_factor);
-		return -ETIMEDOUT;
-	}
-
-	err = ar0832_readl(sd, AR0832_CATEGORY_CAPCTRL, AR0832_CAPCTRL_IMG_SIZE,
-				&state->jpeg.main_size);
-	CHECK_ERR(err);
-	err = ar0832_readl(sd, AR0832_CATEGORY_CAPCTRL, AR0832_CAPCTRL_THUMB_SIZE,
-				&state->jpeg.thumb_size);
-	CHECK_ERR(err);
-
-	state->jpeg.main_offset = 0;
-	state->jpeg.thumb_offset = AR0832_JPEG_MAXSIZE;
-	state->jpeg.postview_offset = AR0832_JPEG_MAXSIZE + AR0832_THUMB_MAXSIZE;
-
-	ar0832_get_exif(sd);
-
-	cam_trace("X\n");
-	return err;
-}
-
-static int ar0832_set_hdr(struct v4l2_subdev *sd, int val)
-{
-	u32 int_factor;
-	int err;
-	cam_trace("E\n");
-
-	switch (val) {
-	case 0:
-		err = ar0832_set_mode(sd, AR0832_MONITOR_MODE);
-		CHECK_ERR(err);
-		int_factor = ar0832_wait_interrupt(sd, AR0832_ISP_TIMEOUT);
-		if (!(int_factor & AR0832_INT_MODE)) {
-			cam_err("AR0832_INT_MODE isn't issued, %#x\n",
-				int_factor);
-			return -ETIMEDOUT;
-		}
-		break;
-	case 1:
-	case 2:
-		err = ar0832_writeb(sd, AR0832_CATEGORY_SYS,
-			AR0832_SYS_ROOT_EN, 0x01);
-		int_factor = ar0832_wait_interrupt(sd, AR0832_ISP_TIMEOUT);
-		break;
-	default:
-		cam_err("invalid HDR count\n");
-	}
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_check_dataline(struct v4l2_subdev *sd, int val)
-{
-	int err = 0;
-
-	cam_dbg("E, value %d\n", val);
-
-	err = ar0832_writeb(sd, AR0832_CATEGORY_TEST,
-		AR0832_TEST_OUTPUT_YCO_TEST_DATA, val ? 0x01 : 0x00);
-	CHECK_ERR(err);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_check_esd(struct v4l2_subdev *sd)
-{
-	s32 val = 0;
-	int err = 0;
-
-	/* check ISP */
-	err = ar0832_readb(sd, AR0832_CATEGORY_TEST, AR0832_TEST_ISP_PROCESS, &val);
-	CHECK_ERR(err);
-	cam_dbg("progress %#x\n", val);
-
-	if (val != 0x80) {
-		goto esd_occur;
-	} else {
-		ar0832_wait_interrupt(sd, AR0832_ISP_ESD_TIMEOUT);
-
-		err = ar0832_readb(sd, AR0832_CATEGORY_SYS, AR0832_SYS_ESD_INT, &val);
-		CHECK_ERR(err);
-
-		if (val & AR0832_INT_ESD)
-			goto esd_occur;
-	}
-
-	cam_warn("ESD is not detected\n");
-	return 0;
-
-esd_occur:
-	cam_warn("ESD shock is detected\n");
-	return -EIO;
-}
-
-static int ar0832_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct ar0832_state *state = to_state(sd);
-	int err = 0;
-
-	printk(KERN_INFO "id %d, value %d\n",
-		ctrl->id - V4L2_CID_PRIVATE_BASE, ctrl->value);
-
-	if (unlikely(state->isp.bad_fw && ctrl->id != V4L2_CID_CAM_UPDATE_FW)) {
-		cam_err("\"Unknown\" state, please update F/W");
-		return -ENOSYS;
-	}
-
-	switch (ctrl->id) {
-	case V4L2_CID_CAM_UPDATE_FW:
-		if (ctrl->value == FW_MODE_DUMP)
-			err = ar0832_dump_fw(sd);
-		else
-			err = ar0832_check_fw(sd);
-		break;
-
-	case V4L2_CID_CAMERA_SENSOR_MODE:
-		err = ar0832_set_sensor_mode(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_FLASH_MODE:
-		err = ar0832_set_flash(sd, ctrl->value, 0);
-		break;
-
-	case V4L2_CID_CAMERA_ISO:
-		err = ar0832_set_iso(sd, ctrl);
-		break;
-
-	case V4L2_CID_CAMERA_METERING:
-		if (state->sensor_mode == SENSOR_CAMERA)
-			err = ar0832_set_metering(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_BRIGHTNESS:
-		err = ar0832_set_exposure(sd, ctrl);
-		break;
-
-	case V4L2_CID_CAMERA_WHITE_BALANCE:
-		err = ar0832_set_whitebalance(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_SCENE_MODE:
-		err = ar0832_set_scene_mode(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_EFFECT:
-		err = ar0832_set_effect(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_WDR:
-		err = ar0832_set_wdr(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_ANTI_SHAKE:
-		err = ar0832_set_antishake(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_BEAUTY_SHOT:
-		err = ar0832_set_face_beauty(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_FOCUS_MODE:
-		err = ar0832_set_af_mode(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_SET_AUTO_FOCUS:
-		err = ar0832_set_af(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_OBJECT_POSITION_X:
-		state->focus.pos_x = ctrl->value;
-		break;
-
-	case V4L2_CID_CAMERA_OBJECT_POSITION_Y:
-		state->focus.pos_y = ctrl->value;
-		break;
-
-	case V4L2_CID_CAMERA_TOUCH_AF_START_STOP:
-		err = ar0832_set_touch_auto_focus(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_ZOOM:
-		err = ar0832_set_zoom(sd, ctrl);
-		break;
-
-	case V4L2_CID_CAM_JPEG_QUALITY:
-		err = ar0832_set_jpeg_quality(sd, ctrl);
-		break;
-
-	case V4L2_CID_CAMERA_CAPTURE:
-		err = ar0832_start_capture(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_HDR:
-		err = ar0832_set_hdr(sd, ctrl->value);
-		break;
-
-	case V4L2_CID_CAMERA_VT_MODE:
-		state->vt_mode = ctrl->value;
-		break;
-
-	case V4L2_CID_CAMERA_CHECK_DATALINE:
-		state->check_dataline = ctrl->value;
-		break;
-
-	case V4L2_CID_CAMERA_CHECK_ESD:
-		err = ar0832_check_esd(sd);
-		break;
-
-	default:
-		cam_err("no such control id %d, value %d\n",
-				ctrl->id - V4L2_CID_PRIVATE_BASE, ctrl->value);
-		/*err = -ENOIOCTLCMD;*/
-		err = 0;
-		break;
-	}
-
-	if (err < 0 && err != -ENOIOCTLCMD)
-		cam_err("failed, id %d, value %d\n",
-				ctrl->id - V4L2_CID_PRIVATE_BASE, ctrl->value);
-	return err;
-}
-
-static int ar0832_g_ext_ctrl(struct v4l2_subdev *sd, struct v4l2_ext_control *ctrl)
-{
-	struct ar0832_state *state = to_state(sd);
-	int err = 0;
-
-	switch (ctrl->id) {
-	case V4L2_CID_CAM_SENSOR_FW_VER:
-		strcpy(ctrl->string, state->exif.unique_id);
-		break;
-
-	default:
-		cam_err("no such control id %d\n", ctrl->id - V4L2_CID_CAMERA_CLASS_BASE);
-		/*err = -ENOIOCTLCMD*/
-		err = 0;
-		break;
-	}
-
-	if (err < 0 && err != -ENOIOCTLCMD)
-		cam_err("failed, id %d\n", ctrl->id - V4L2_CID_CAMERA_CLASS_BASE);
-
-	return err;
-}
-
-static int ar0832_g_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls)
-{
-	struct v4l2_ext_control *ctrl = ctrls->controls;
-	int i, err = 0;
-
-	for (i = 0; i < ctrls->count; i++, ctrl++) {
-		err = ar0832_g_ext_ctrl(sd, ctrl);
-		if (err) {
-			ctrls->error_idx = i;
-			break;
-		}
-	}
-	return err;
-}
-
-static int ar0832_check_manufacturer_id(struct v4l2_subdev *sd)
-{
-	int i, err;
-	u8 id;
-	u32 addr[] = {0x1000AAAA, 0x10005554, 0x1000AAAA};
-	u8 val[3][2] = {
-		[0] = {0x00, 0xAA},
-		[1] = {0x00, 0x55},
-		[2] = {0x00, 0x90},
-	};
-	u8 reset[] = {0x00, 0xF0};
-
-	/* set manufacturer's ID read-mode */
-	for (i = 0; i < 3; i++) {
-		err = ar0832_mem_write(sd, 0x06, 2, addr[i], val[i]);
-		CHECK_ERR(err);
-	}
-
-	/* read manufacturer's ID */
-	err = ar0832_mem_read(sd, sizeof(id), 0x10000001, &id);
-	CHECK_ERR(err);
-
-	/* reset manufacturer's ID read-mode */
-	err = ar0832_mem_write(sd, 0x06, sizeof(reset), 0x10000000, reset);
-	CHECK_ERR(err);
-
-	cam_dbg("%#x\n", id);
-
-	return id;
-}
-
-static int ar0832_program_fw(struct v4l2_subdev *sd,
-	u8 *buf, u32 addr, u32 unit, u32 count, u8 id)
-{
-	u32 val;
-	u32 intram_unit = SZ_4K;
-	int i, j, retries, err = 0;
-	int erase = 0x01;
-	if (unit == SZ_64K && id != 0x01)
-		erase = 0x04;
-
-	for (i = 0; i < unit*count; i += unit) {
-		/* Set Flash ROM memory address */
-		err = ar0832_writel(sd, AR0832_CATEGORY_FLASH,
-			AR0832_FLASH_ADDR, addr + i);
-		CHECK_ERR(err);
-
-		/* Erase FLASH ROM entire memory */
-		err = ar0832_writeb(sd, AR0832_CATEGORY_FLASH,
-			AR0832_FLASH_ERASE, erase);
-		CHECK_ERR(err);
-		/* Response while sector-erase is operating */
-		retries = 0;
-		do {
-			mdelay(50);
-			err = ar0832_readb(sd, AR0832_CATEGORY_FLASH,
-				AR0832_FLASH_ERASE, &val);
-			CHECK_ERR(err);
-		} while (val == erase && retries++ < AR0832_I2C_VERIFY);
-
-		if (val != 0) {
-			cam_err("failed to erase sector\n");
-			return -1;
-		}
-
-		/* Set FLASH ROM programming size */
-		err = ar0832_writew(sd, AR0832_CATEGORY_FLASH, AR0832_FLASH_BYTE,
-			unit == SZ_64K ? 0 : unit);
-		CHECK_ERR(err);
-
-		/* Clear M-5MoLS internal RAM */
-		err = ar0832_writeb(sd, AR0832_CATEGORY_FLASH,
-			AR0832_FLASH_RAM_CLEAR, 0x01);
-		CHECK_ERR(err);
-
-		/* Set Flash ROM programming address */
-		err = ar0832_writel(sd, AR0832_CATEGORY_FLASH,
-			AR0832_FLASH_ADDR, addr + i);
-		CHECK_ERR(err);
-
-		/* Send programmed firmware */
-		for (j = 0; j < unit; j += intram_unit) {
-			err = ar0832_mem_write(sd, 0x04, intram_unit,
-				AR0832_INT_RAM_BASE_ADDR + j, buf + i + j);
-			CHECK_ERR(err);
-			mdelay(10);
-		}
-
-		/* Start Programming */
-		err = ar0832_writeb(sd, AR0832_CATEGORY_FLASH, AR0832_FLASH_WR, 0x01);
-		CHECK_ERR(err);
-
-		/* Confirm programming has been completed */
-		retries = 0;
-		do {
-			mdelay(50);
-			err = ar0832_readb(sd, AR0832_CATEGORY_FLASH,
-				AR0832_FLASH_WR, &val);
-			CHECK_ERR(err);
-		} while (val && retries++ < AR0832_I2C_VERIFY);
-
-		if (val != 0) {
-			cam_err("failed to program\n");
-			return -1;
-		}
-	}
-
-	return 0;
-}
-
-static int ar0832_load_fw(struct v4l2_subdev *sd)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct device *dev = &client->adapter->dev;
-	const struct firmware *fentry;
-	u8 sensor_ver[AR0832_FW_VER_LEN] = {0, };
-	u8 *buf = NULL, val, id;
-	int offset, err;
-
-#ifdef SDCARD_FW
-	struct file *fp;
-	mm_segment_t old_fs;
-	long fsize, nread;
-	int fw_requested = 1;
-
-	old_fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	fp = filp_open(AR0832_FW_PATH, O_RDONLY, 0);
-	if (IS_ERR(fp)) {
-		cam_trace("failed to open %s, err %ld\n",
-			AR0832_FW_PATH, PTR_ERR(fp));
-		goto request_fw;
-	}
-
-	fw_requested = 0;
-	fsize = fp->f_path.dentry->d_inode->i_size;
-
-	cam_dbg("start, file path %s, size %ld Bytes\n", AR0832_FW_PATH, fsize);
-
-	buf = vmalloc(fsize);
-	if (!buf) {
-		cam_err("failed to allocate memory\n");
-		err = -ENOMEM;
-		goto out;
-	}
-
-	nread = vfs_read(fp, (char __user *)buf, fsize, &fp->f_pos);
-	if (nread != fsize) {
-		cam_err("failed to read firmware file, %ld Bytes\n", nread);
-		err = -EIO;
-		goto out;
-	}
-
-request_fw:
-	if (fw_requested) {
-		set_fs(old_fs);
-#endif /* SDCARD_FW */
-	ar0832_get_sensor_fw_version(sd, sensor_ver);
-
-	if (sensor_ver[0] == 'T')
-		err = request_firmware(&fentry, AR0832T_FW_REQUEST_PATH, dev);
-	else
-		err = request_firmware(&fentry, AR0832O_FW_REQUEST_PATH, dev);
-
-	if (err != 0) {
-		cam_err("request_firmware falied\n");
-			err = -EINVAL;
-			goto out;
-	}
-
-	cam_dbg("start, size %d Bytes\n", fentry->size);
-	buf = (u8 *)fentry->data;
-
-#ifdef SDCARD_FW
-	}
-#endif /* SDCARD_FW */
-
-	/* set pin */
-	val = 0x7E;
-	err = ar0832_mem_write(sd, 0x04, sizeof(val), 0x50000308, &val);
-	if (err < 0) {
-		cam_err("i2c falied, err %d\n", err);
-		goto out;
-	}
-
-	id = ar0832_check_manufacturer_id(sd);
-	if (id < 0) {
-		cam_err("i2c falied, err %d\n", id);
-		goto out;
-	}
-
-	/* select flash memory */
-	err = ar0832_writeb(sd, AR0832_CATEGORY_FLASH,
-		AR0832_FLASH_SEL, id == 0x01 ? 0x00 : 0x01);
-	if (err < 0) {
-		cam_err("i2c falied, err %d\n", err);
-		goto out;
-	}
-
-	/* program FLSH ROM */
-	err = ar0832_program_fw(sd, buf, AR0832_FLASH_BASE_ADDR, SZ_64K, 31, id);
-	if (err < 0)
-		goto out;
-
-	offset = SZ_64K * 31;
-	if (id == 0x01) {
-		err = ar0832_program_fw(sd,
-			buf + offset, AR0832_FLASH_BASE_ADDR + offset, SZ_8K, 4, id);
-	} else {
-		err = ar0832_program_fw(sd,
-			buf + offset, AR0832_FLASH_BASE_ADDR + offset, SZ_4K, 8, id);
-	}
-
-	cam_dbg("end\n");
-
-out:
-#ifdef SDCARD_FW
-	if (!fw_requested) {
-		vfree(buf);
-		filp_close(fp, current->files);
-		set_fs(old_fs);
-	}
-#endif  /* SDCARD_FW */
-	return err;
-}
-
-/*
- * v4l2_subdev_video_ops
- */
-static const struct ar0832_frmsizeenum *ar0832_get_frmsize
-	(const struct ar0832_frmsizeenum *frmsizes, int num_entries, int index)
-{
-	int i;
-
-	for (i = 0; i < num_entries; i++) {
-		if (frmsizes[i].index == index)
-			return &frmsizes[i];
-	}
-
-	return NULL;
-}
-
-static int ar0832_set_frmsize(struct v4l2_subdev *sd)
-{
-	struct ar0832_state *state = to_state(sd);
-	struct v4l2_control ctrl;
-	int err;
-	u32 old_mode;
-	cam_trace("E\n");
-
-	if (state->format_mode != V4L2_PIX_FMT_MODE_CAPTURE) {
-		err = ar0832_set_mode(sd, AR0832_PARMSET_MODE);
-		err = ar0832_readb(sd, AR0832_CATEGORY_SYS, AR0832_SYS_MODE, &old_mode);
-
-		CHECK_ERR(err);
-
-		err = ar0832_writeb(sd, AR0832_CATEGORY_PARM,
-			AR0832_PARM_MON_SIZE, state->preview->reg_val);
-		CHECK_ERR(err);
-
-		if (state->zoom) {
-			/* Zoom position returns to 1 when the monitor size is changed. */
-			ctrl.id = V4L2_CID_CAMERA_ZOOM;
-			ctrl.value = state->zoom;
-			ar0832_set_zoom(sd, &ctrl);
-		}
-
-		cam_info("preview frame size %dx%d\n",
-			state->preview->width, state->preview->height);
-	} else {
-		err = ar0832_writeb(sd, AR0832_CATEGORY_CAPPARM,
-			AR0832_CAPPARM_MAIN_IMG_SIZE, state->capture->reg_val);
-		CHECK_ERR(err);
-		cam_info("capture frame size %dx%d\n",
-			state->capture->width, state->capture->height);
-	}
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *ffmt)
-{
-	struct ar0832_state *state = to_state(sd);
-	const struct ar0832_frmsizeenum **frmsize;
-	
-	u32 width = ffmt->width;
-	u32 height = ffmt->height;
-	u32 tmp_width;
-	u32 old_index;
-	int i, num_entries;
-	cam_trace("E\n");
-
-	if (unlikely(state->isp.bad_fw)) {
-		cam_err("\"Unknown\" state, please update F/W");
-		return -ENOSYS;
-	}
-	if (ffmt->width < ffmt->height) {
-		tmp_width = ffmt->height;
-		height = ffmt->width;
-		width = tmp_width;
-	}
-
-	if (ffmt->colorspace == V4L2_COLORSPACE_JPEG) {
-		state->format_mode = V4L2_PIX_FMT_MODE_CAPTURE;
-		frmsize = &state->capture;
-	} else {
-		state->format_mode = V4L2_PIX_FMT_MODE_PREVIEW;
-		frmsize = &state->preview;
-	}
-	
-	old_index = *frmsize ? (*frmsize)->index : -1;
-	*frmsize = NULL;
-
-	if (state->format_mode != V4L2_PIX_FMT_MODE_CAPTURE) {
-		num_entries = ARRAY_SIZE(preview_frmsizes);
-		for (i = 0; i < num_entries; i++) {
-			if (width == preview_frmsizes[i].width &&
-				height == preview_frmsizes[i].height) {
-				*frmsize = &preview_frmsizes[i];
-				break;
-			}
-		}
-	} else {
-		num_entries = ARRAY_SIZE(capture_frmsizes);
-		for (i = 0; i < num_entries; i++) {
-			if (width == capture_frmsizes[i].width &&
-				height == capture_frmsizes[i].height) {
-				*frmsize = &capture_frmsizes[i];
-				break;
-			}
-		}
-	}
-
-	if (*frmsize == NULL) {
-		cam_warn("invalid frame size %dx%d\n", width, height);
-		*frmsize = state->format_mode != V4L2_PIX_FMT_MODE_CAPTURE ?
-			ar0832_get_frmsize(preview_frmsizes, num_entries,
-				AR0832_PREVIEW_VGA) :
-			ar0832_get_frmsize(capture_frmsizes, num_entries,
-				AR0832_CAPTURE_3MP);
-	}
-
-	cam_dbg("%dx%d\n", (*frmsize)->width, (*frmsize)->height);
-	ar0832_set_frmsize(sd);
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
-{
-	struct ar0832_state *state = to_state(sd);
-
-	a->parm.capture.timeperframe.numerator = 1;
-	a->parm.capture.timeperframe.denominator = state->fps;
-
-	return 0;
-}
-
-static int ar0832_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
-{
-	struct ar0832_state *state = to_state(sd);
-	int err;
-
-	u32 fps = a->parm.capture.timeperframe.denominator /
-					a->parm.capture.timeperframe.numerator;
-
-	if (unlikely(state->isp.bad_fw)) {
-		cam_err("\"Unknown\" state, please update F/W");
-		return -ENOSYS;
-	}
-
-	if (fps != state->fps) {
-		if (fps <= 0 || fps > 30) {
-			cam_err("invalid frame rate %d\n", fps);
-			fps = 30;
-		}
-		state->fps = fps;
-	}
-
-	err = ar0832_set_mode(sd, AR0832_PARMSET_MODE);
-	CHECK_ERR(err);
-
-	cam_dbg("fixed fps %d\n", state->fps);
-	err = ar0832_writeb(sd, AR0832_CATEGORY_PARM,
-		AR0832_PARM_FLEX_FPS, state->fps != 30 ? state->fps : 0);
-	CHECK_ERR(err);
-
-	return 0;
-}
-
-static int ar0832_enum_framesizes(struct v4l2_subdev *sd,
-	struct v4l2_frmsizeenum *fsize)
-{
-	struct ar0832_state *state = to_state(sd);
-	u32 err, old_mode;
-	err = ar0832_readb(sd, AR0832_CATEGORY_SYS, AR0832_SYS_MODE, &old_mode);
-
-	/*
-	* The camera interface should read this value, this is the resolution
-	* at which the sensor would provide framedata to the camera i/f
-	* In case of image capture,
-	* this returns the default camera resolution (VGA)
-	*/
-	if (state->format_mode != V4L2_PIX_FMT_MODE_CAPTURE) {
-		if (state->preview == NULL || state->preview->index < 0)
-			return -EINVAL;
-
-		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-		fsize->discrete.width = state->preview->width;
-		fsize->discrete.height = state->preview->height;
-//		fsize->discrete.width = 3272;
-//		fsize->discrete.height =2456;
-	} else {
-		if (state->capture == NULL || state->capture->index < 0)
-			return -EINVAL;
-
-		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-		fsize->discrete.width = state->capture->width;
-		fsize->discrete.height = state->capture->height;
-	}
-
-	return 0;
-}
-
-static int ar0832_s_stream_preview(struct v4l2_subdev *sd, int enable)
-{
-	struct ar0832_state *state = to_state(sd);
-	u32 old_mode, int_factor;
-	int err;
-
-	err = ar0832_readb(sd, AR0832_CATEGORY_SYS, AR0832_SYS_MODE, &old_mode);
-
-	if (enable) {
-		ar0832_set_lock(sd, 0);
-
-		if (state->vt_mode) {
-			printk("vt mode\n");
-			err = ar0832_writeb(sd, AR0832_CATEGORY_AE,
-				AR0832_AE_EP_MODE_MON, 0x11);
-			CHECK_ERR(err);
-		}
-
-		old_mode = ar0832_set_mode(sd, AR0832_MONITOR_MODE);
-		if (old_mode <= 0) {
-			cam_err("failed to set mode\n");
-			return old_mode;
-		}
-
-		if (old_mode != AR0832_MONITOR_MODE) {
-			int_factor = ar0832_wait_interrupt(sd, AR0832_ISP_TIMEOUT);
-			if (!(int_factor & AR0832_INT_MODE)) {
-				cam_err("AR0832_INT_MODE isn't issued, %#x\n",
-					int_factor);
-				return -ETIMEDOUT;
-			}
-		}
-
-		if (state->check_dataline) {
-			err = ar0832_check_dataline(sd, state->check_dataline);
-			CHECK_ERR(err);
-		}
-	} else {
-		err = ar0832_readb(sd, AR0832_CATEGORY_SYS, AR0832_SYS_MODE, &old_mode);
-	}
-
-	return 0;
-}
-
-static int ar0832_s_stream_capture(struct v4l2_subdev *sd, int enable)
-{
-	u32 int_factor;
-	int err;
-
-	if (enable) {
-		err = ar0832_set_mode(sd, AR0832_STILLCAP_MODE);
-		if (err <= 0) {
-			cam_err("failed to set mode\n");
-			return err;
-		}
-
-		int_factor = ar0832_wait_interrupt(sd, AR0832_ISP_TIMEOUT);
-		if (!(int_factor & AR0832_INT_SOUND)) {
-			cam_err("AR0832_INT_SOUND isn't issued, %#x\n",
-				int_factor);
-			return -ETIMEDOUT;
-		}
-	} else {
-	}
-	return 0;
-}
-
-static int ar0832_s_stream_hdr(struct v4l2_subdev *sd, int enable)
-{
-	int err;
-
-	err = ar0832_set_mode(sd, AR0832_PARMSET_MODE);
-	CHECK_ERR(err);
-
-	if (enable) {
-		err = ar0832_writeb(sd, AR0832_CATEGORY_TEST, 0x50, 0x02);
-		CHECK_ERR(err);
-
-		err = ar0832_writeb(sd, AR0832_CATEGORY_TEST, 0x51, 0x80);
-		CHECK_ERR(err);
-
-		err = ar0832_writeb(sd, AR0832_CATEGORY_PARM,
-			AR0832_PARM_HDR_MON, 0x01);
-		CHECK_ERR(err);
-
-		err = ar0832_writeb(sd, AR0832_CATEGORY_PARM,
-			AR0832_PARM_HDR_MON_OFFSET_EV, 0x64);
-		CHECK_ERR(err);
-	} else {
-		err = ar0832_writeb(sd, AR0832_CATEGORY_PARM,
-			AR0832_PARM_HDR_MON, 0x00);
-		CHECK_ERR(err);
-	}
-	return 0;
-}
-
-static int ar0832_s_stream(struct v4l2_subdev *sd, int enable)
-{
-	struct ar0832_state *state = to_state(sd);
-	int err;
-
-	cam_trace("E\n");
-
-	if (unlikely(state->isp.bad_fw)) {
-		cam_err("\"Unknown\" state, please update F/W");
-		return -ENOSYS;
-	}
-
-	switch (enable) {
-	case STREAM_MODE_CAM_ON:
-	case STREAM_MODE_CAM_OFF:
-		switch (state->format_mode) {
-		case V4L2_PIX_FMT_MODE_CAPTURE:
-			cam_info("capture %s",
-				enable == STREAM_MODE_CAM_ON ? "on" : "off");
-			err = ar0832_s_stream_capture(sd, enable == STREAM_MODE_CAM_ON);
-			break;
-		case V4L2_PIX_FMT_MODE_HDR:
-			err = ar0832_s_stream_hdr(sd, enable == STREAM_MODE_CAM_ON);
-			break;
-		default:
-			cam_info("preview %s",
-				enable == STREAM_MODE_CAM_ON ? "on" : "off");
-			//err = ar0832_s_stream_preview(sd, enable == STREAM_MODE_CAM_ON);
-
-			if(enable){
-				//preview start
-				mdelay(500);
-				
-				err=ar0832_write_array3(sd,ar0832_reg_start_streaming1_3,AR0832_REG_START_STREAMING1_3);
-					if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-				err=ar0832_write_array(sd,ar0832_reg_start_streaming2,AR0832_REG_START_STREAMING2);
-					if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-				err=ar0832_write_array3(sd,ar0832_reg_start_streaming3_3,AR0832_REG_START_STREAMING3_3);
-					if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-				
-				//test		
-				err=ar0832_write_array(sd,ar0832_reg_test,AR0832_INIT_REG_TEST);
-						if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-				}
-			else {
-				//preview stop
-				err=ar0832_write_array3(sd,ar0832_reg_stop_streaming1_3,AR0832_REG_STOP_STREAMING1_3);
-					if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-				err=ar0832_write_array(sd,ar0832_reg_stop_streaming2,AR0832_REG_STOP_STREAMING2);
-					if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-				}
-			cam_info("\n");
-			break;
-		}
-		break;
-
-	case STREAM_MODE_MOVIE_ON:
-		if (state->flash_mode != FLASH_MODE_OFF)
-			err = ar0832_set_flash(sd, state->flash_mode, 1);
-
-		if (state->preview->index == AR0832_PREVIEW_720P ||
-				state->preview->index == AR0832_PREVIEW_1080P)
-			err = ar0832_set_af(sd, 1);
-		break;
-
-	case STREAM_MODE_MOVIE_OFF:
-		if (state->preview->index == AR0832_PREVIEW_720P ||
-				state->preview->index == AR0832_PREVIEW_1080P)
-			err = ar0832_set_af(sd, 0);
-
-		ar0832_set_flash(sd, FLASH_MODE_OFF, 1);
-		break;
-
-	default:
-		cam_err("invalid stream option, %d\n", enable);
-		break;
-	}
-
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_check_version(struct v4l2_subdev *sd)
-{
-	struct ar0832_state *state = to_state(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int i, val,err;
-
-	cam_info("*************************************\n");
-#if 0
-	for (i = 0; i < 0xff; i++) {
-		client->addr=i;
-			cam_info("client->addr %x \n",client->addr);
-			err=ar0832_i2c_write_2short(sd,0x1406,0x00);
-			if(err<0) cam_info("error \n");	
-		}
-
-	err=ar0832_i2c_write_2short(sd,0x1406,0x00);
-		if(err<0) cam_info("error \n"); 
-		else  cam_info("address check passed \n"); 
-#endif
-
-	val=ar0832_i2c_read_reg(client,AR0832_CATEGORY_MODEL_ID,2);
-	cam_info("model_id : %d\n",val);
-	val=ar0832_i2c_read_reg(client,AR0832_CATEGORY_REVISION_NUM,1);
-	cam_info("revision_number :%d\n",val);
-	val=ar0832_i2c_read_reg(client,AR0832_CATEGORY_MANUFACTURE_ID,1);
-	cam_info("manufacturer_id : %d\n",val);
-	val=ar0832_i2c_read_reg(client,AR0832_CATEGORY_SMIA_VERSION,1);
-	cam_info("smia_version : %d\n",val);
-
-//	state->exif.unique_id[i] = (char)val;
-//	state->exif.unique_id[i] = '\0';
-
-	cam_info("*************************************\n");
-
-	return val;
-}
-  int ar0832_init_param_extern()
-{
-	printk("%s ... \n",__func__);
-	struct v4l2_subdev *sd;
-	sd= &ar0832_is_data->sd;
-	int err;
-	printk("E\n");
-
-	err=ar0832_write_array3(sd,ar0832_init_reg_MIPI_IF_CFG1_3,AR0832_INIT_REG_MIPI_IF_CFG1_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array(sd,ar0832_init_reg_MIPI_IF_CFG2,AR0832_INIT_REG_MIPI_IF_CFG2);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array3(sd,ar0832_reg_stop_streaming1_3,AR0832_REG_STOP_STREAMING1_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array(sd,ar0832_reg_stop_streaming2,AR0832_REG_STOP_STREAMING2);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array(sd,ar0832_init_reg,AR0832_INIT_REG_REG);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array(sd,ar0832_init_reg_raw10,AR0832_INIT_REG_RAW10);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array(sd,ar0832_init_reg_pll,AR0832_INIT_REG_PLL);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-	
-	err=ar0832_write_array(sd,ar0832_init_reg_output_size,AR0832_INIT_REG_OUTPUT_SIZE);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array3(sd,ar0832_init_reg_etc1_3,AR0832_INIT_REG_ETC1_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }		
-
-	err=ar0832_write_array(sd,ar0832_init_reg_etc2,AR0832_INIT_REG_ETC2);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array3(sd,ar0832_init_reg_etc3_3,AR0832_INIT_REG_ETC3_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }		
-		
-	err=ar0832_write_array(sd,ar0832_init_reg_etc4,AR0832_INIT_REG_ETC4);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-#if 0
-	//start
-	err=ar0832_write_array3(sd,ar0832_reg_start_streaming1_3,AR0832_REG_START_STREAMING1_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-	err=ar0832_write_array(sd,ar0832_reg_start_streaming2,AR0832_REG_START_STREAMING2);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-	err=ar0832_write_array3(sd,ar0832_reg_start_streaming3_3,AR0832_REG_START_STREAMING3_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	//test		
-	err=ar0832_write_array(sd,ar0832_reg_test,AR0832_INIT_REG_TEST);
-			if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-#endif
-	printk("X\n");
-	return 0;
-}
-  int ar0832_stream_param_extern()
-  {
-	  printk("%s ... \n",__func__);
-	  struct v4l2_subdev *sd;
-	  sd= &ar0832_is_data->sd;
-	  int err;
-	  printk("E\n");
-  
-	 
-#if 1
-	  //start
-	  err=ar0832_write_array3(sd,ar0832_reg_start_streaming1_3,AR0832_REG_START_STREAMING1_3);
-		  if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-	  err=ar0832_write_array(sd,ar0832_reg_start_streaming2,AR0832_REG_START_STREAMING2);
-		  if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-	  err=ar0832_write_array3(sd,ar0832_reg_start_streaming3_3,AR0832_REG_START_STREAMING3_3);
-		  if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-  mdelay(100);
-	  //test	  
-	 // err=ar0832_write_array(sd,ar0832_reg_test,AR0832_INIT_REG_TEST);
-		//	  if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-#endif
-	  printk("X\n");
-	  return 0;
-  }
-
- int ar0832_init_param(struct v4l2_subdev *sd)
-{
-	int err;
-	cam_trace("E\n");
-	
-	err=ar0832_write_array3(sd,ar0832_init_reg_MIPI_IF_CFG1_3,AR0832_INIT_REG_MIPI_IF_CFG1_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array(sd,ar0832_init_reg_MIPI_IF_CFG2,AR0832_INIT_REG_MIPI_IF_CFG2);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array3(sd,ar0832_reg_stop_streaming1_3,AR0832_REG_STOP_STREAMING1_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array(sd,ar0832_reg_stop_streaming2,AR0832_REG_STOP_STREAMING2);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array(sd,ar0832_init_reg,AR0832_INIT_REG_REG);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array(sd,ar0832_init_reg_raw10,AR0832_INIT_REG_RAW10);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array(sd,ar0832_init_reg_pll,AR0832_INIT_REG_PLL);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-	
-	err=ar0832_write_array(sd,ar0832_init_reg_output_size,AR0832_INIT_REG_OUTPUT_SIZE);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array3(sd,ar0832_init_reg_etc1_3,AR0832_INIT_REG_ETC1_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }		
-
-	err=ar0832_write_array(sd,ar0832_init_reg_etc2,AR0832_INIT_REG_ETC2);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	err=ar0832_write_array3(sd,ar0832_init_reg_etc3_3,AR0832_INIT_REG_ETC3_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }		
-		
-	err=ar0832_write_array(sd,ar0832_init_reg_etc4,AR0832_INIT_REG_ETC4);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-#if 1
-	//start
-	err=ar0832_write_array3(sd,ar0832_reg_start_streaming1_3,AR0832_REG_START_STREAMING1_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-	err=ar0832_write_array(sd,ar0832_reg_start_streaming2,AR0832_REG_START_STREAMING2);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-	err=ar0832_write_array3(sd,ar0832_reg_start_streaming3_3,AR0832_REG_START_STREAMING3_3);
-		if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-
-	//test		
-	err=ar0832_write_array(sd,ar0832_reg_test,AR0832_INIT_REG_TEST);
-			if(err <0) {cam_err("%s init error %d \n",__func__,err); return -1; }
-#endif
-	cam_trace("X\n");
-	return 0;
-}
-
-static int ar0832_init(struct v4l2_subdev *sd, u32 val)
-{
-	struct ar0832_state *state = to_state(sd);
-	u32 int_factor;
-	int err;
-	cam_trace("%s \n",__func__);
-	printk("%s\n", __func__);
-
-	/* Default state values */
-	state->isp.bad_fw = 0;
-
-	state->preview = NULL;
-	state->capture = NULL;
-
-	state->format_mode = V4L2_PIX_FMT_MODE_PREVIEW;
-	state->sensor_mode = SENSOR_CAMERA;
-	state->flash_mode = FLASH_MODE_OFF;
-	state->beauty_mode = 0;
-
-	state->fps = 0;			/* auto */
-
-	memset(&state->focus, 0, sizeof(state->focus));
-#if 0 //firmware no needed //rapheal
-	/* start camera program(parallel FLASH ROM) */
-	err = ar0832_writeb(sd, AR0832_CATEGORY_FLASH,
-		AR0832_FLASH_CAM_START, 0x01);
-	CHECK_ERR(err);
-
-	int_factor = ar0832_wait_interrupt(sd, AR0832_ISP_TIMEOUT);
-	if (!(int_factor & AR0832_INT_MODE)) {
-		cam_err("firmware was erased?\n");
-		state->isp.bad_fw = 1;
-		return -ENOSYS;
-	}
-#endif
-
-	/* check up F/W version */
-	err = ar0832_check_version(sd);
-	CHECK_ERR(err);
-
-	ar0832_init_param(sd);
-
-	return 0;
-}
-
-static const struct v4l2_subdev_core_ops ar0832_core_ops = {
-	.init = ar0832_init,		/* initializing API */
-	//.load_fw = ar0832_load_fw,
-	.queryctrl = ar0832_queryctrl,
-	.g_ctrl = ar0832_g_ctrl,
-	.s_ctrl = ar0832_s_ctrl,
-	.g_ext_ctrls = ar0832_g_ext_ctrls,
-};
-
-static const struct v4l2_subdev_video_ops ar0832_video_ops = {
-	.s_mbus_fmt = ar0832_s_fmt,
-	.g_parm = ar0832_g_parm,
-	.s_parm = ar0832_s_parm,
-	.enum_framesizes = ar0832_enum_framesizes,
-	.s_stream = ar0832_s_stream,
-};
-
-static const struct v4l2_subdev_ops ar0832_ops = {
-	.core = &ar0832_core_ops,
-	.video = &ar0832_video_ops,
-};
-
-static ssize_t ar0832_camera_type_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	char type[] = "APTINA_AR0832_NONE";
-
-	return sprintf(buf, "%s\n", type);
-}
-
-static ssize_t ar0832_camera_fw_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct ar0832_state *state = to_state(sd);
-
-	return sprintf(buf, "%s\n", state->fw_version);
-}
-
-static DEVICE_ATTR(camera_type, S_IRUGO, ar0832_camera_type_show, NULL);
-static DEVICE_ATTR(camera_fw, S_IRUGO, ar0832_camera_fw_show, NULL);
-
-/*
- * ar0832_probe
- * Fetching platform data is being done with s_config subdev call.
- * In probe routine, we just register subdev device
- */
-static int __devinit ar0832_probe(struct i2c_client *client,
-			 const struct i2c_device_id *id)
-{
-	struct ar0832_state *state;
-	struct v4l2_subdev *sd;
-
-	const struct ar0832_platform_data *pdata =
-		client->dev.platform_data;
-	int err = 0;
-
-	state = kzalloc(sizeof(struct ar0832_state), GFP_KERNEL);
-	if (state == NULL)
-		return -ENOMEM;
-
-	sd = &state->sd;
-	strcpy(sd->name, AR0832_DRIVER_NAME);
-	
-	/* Registering subdev */
-	v4l2_i2c_subdev_init(sd, client, &ar0832_ops);
-
-	state->this_client = client;
-	ar0832_is_data = state;
-
-#ifdef CAM_DEBUG
-	state->dbg_level = CAM_DEBUG| CAM_TRACE | CAM_I2C;
-#endif
-
-#if 0 //rapheal
-	if (device_create_file(&client->dev, &dev_attr_camera_type) < 0) {
-		cam_warn("failed to create device file, %s\n",
-			dev_attr_camera_type.attr.name);
-	}
-
-	if (device_create_file(&client->dev, &dev_attr_camera_fw) < 0) {
-		cam_warn("failed to create device file, %s\n",
-			dev_attr_camera_fw.attr.name);
-	}
-
-	/* wait queue initialize */
-	init_waitqueue_head(&state->isp.wait);
-
-	if (pdata->config_isp_irq)
-		pdata->config_isp_irq();
-
-	err = request_irq(pdata->irq,
-		ar0832_isp_isr, IRQF_TRIGGER_RISING, "ar0832 isp", sd);
-	if (err) {
-		cam_err("failed to request irq\n");
-		return err;
-	}
-	state->isp.irq = pdata->irq;
-	state->isp.issued = 0;
-#endif
-	printk("%s\n", __func__);
-
-	return 0;
-}
-
-static int __devexit ar0832_remove(struct i2c_client *client)
-{
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct ar0832_state *state = to_state(sd);
-
-	if (ar0832_set_af_softlanding(sd) < 0)
-		cam_err("failed to set soft landing\n");
-
-	device_remove_file(&client->dev, &dev_attr_camera_type);
-	device_remove_file(&client->dev, &dev_attr_camera_fw);
-
-	if (state->isp.irq > 0)
-		free_irq(state->isp.irq, sd);
-
-	v4l2_device_unregister_subdev(sd);
-
-	kfree(state->fw_version);
-	kfree(state);
-
-	return 0;
-}
-
-static const struct i2c_device_id ar0832_id[] = {
-	{ AR0832_DRIVER_NAME, 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, ar0832_id);
-
-static struct i2c_driver ar0832_i2c_driver = {
-	.driver = {
-		.name	= AR0832_DRIVER_NAME,
-	},
-	.probe		= ar0832_probe,
-	.remove		= __devexit_p(ar0832_remove),
-	.id_table	= ar0832_id,
-};
-
-static int __init ar0832_mod_init(void)
-{
-	printk("%s\n", __func__);
-
-	return i2c_add_driver(&ar0832_i2c_driver);
-}
-
-static void __exit ar0832_mod_exit(void)
-{
-	i2c_del_driver(&ar0832_i2c_driver);
-}
-module_init(ar0832_mod_init);
-module_exit(ar0832_mod_exit);
-
-
-MODULE_AUTHOR("Dongyol Yun <ydongyol@hardkenel.com>");
-MODULE_DESCRIPTION("driver for Aptina AR0832 8MP camera");
-MODULE_LICENSE("GPL");
diff -Naur org/drivers/media/video/dohofpga.c ths/drivers/media/video/dohofpga.c
--- org/drivers/media/video/dohofpga.c	1970-01-01 01:00:00.000000000 +0100
+++ ths/drivers/media/video/dohofpga.c	2013-07-15 16:12:31.000000000 +0200
@@ -0,0 +1,615 @@
+/* linux/drivers/media/video/dohofpga.c
+ *
+ * Copyright (c) 2013 intsitute for visual computing, ETH Zuerich
+ * http://ivc.ethz.ch/
+ * based on mt9m113.c
+ * Copyright (c) 2010 Samsung Electronics Co., Ltd.
+ * http://www.samsung.com/
+ *
+ * Driver for dominik honeggers fpga camara interface 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#define __DOHOFPGA_C__
+
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/dohofpga_platform.h>
+
+#ifdef CONFIG_VIDEO_SAMSUNG_V4L2
+#include <linux/videodev2_samsung.h>
+#endif
+
+#include "dohofpga.h"
+
+/* Default resolution & pixelformat. plz ref dohofpga_platform.h */
+#define DEFAULT_RES    WVGA  /* Index of resoultion */
+#define DEFAUT_FPS_INDEX  DOHOFPGA_15FPS
+#define DEFAULT_FMT    V4L2_PIX_FMT_UYVY//  /* YUV422 */
+
+#define DOHOFPGA_JPEG_MAXSIZE  0x3A0000
+#define DOHOFPGA_THUMB_MAXSIZE  0xFC00
+#define DOHOFPGA_POST_MAXSIZE  0xBB800
+
+// code
+
+static inline struct dohofpga_state *to_state(struct v4l2_subdev *sd)
+{
+  return container_of(sd, struct dohofpga_state, sd);
+}
+
+/*
+ * DOHOFPGA register structure : 2bytes address, 2bytes value
+ * retry on write failure up-to 5 times
+ */
+
+static inline int dohofpga_write(struct v4l2_subdev *sd, u16 addr, u16 val)
+{
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct i2c_msg msg[1];
+  unsigned char reg[4];
+  int err   = 0;
+  int retry = 1;
+
+  if (!client->adapter) return -ENODEV;
+
+  while(retry)
+  {
+    retry--;
+    msg->addr = client->addr;
+    msg->flags = 0;
+    msg->len = 4;
+    msg->buf = reg;
+
+    reg[0] = addr >> 8;
+    reg[1] = addr & 0xff;
+    reg[2] = val >> 8;
+    reg[3] = val & 0xff;
+
+    err = i2c_transfer(client->adapter, msg, 1);
+    if (err >= 0 ) return err ;
+    dev_err(&client->dev, "%s: address: 0x%02x%02x, " \
+            "value: 0x%02x%02x error..\n", __func__, \
+            reg[0], reg[1], reg[2], reg[3]);
+  }
+  return err;
+}
+
+static int dohofpga_i2c_write(struct v4l2_subdev *sd, unsigned char i2c_data[],
+        unsigned char length)
+{
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  unsigned char buf[length], i;
+  struct i2c_msg msg = {client->addr, 0, length, buf};
+
+  for (i = 0; i < length; i++) buf[i] = i2c_data[i];
+
+  return i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
+}
+
+const char * const *dohofpga_ctrl_get_menu(u32 id)
+{
+  switch (id) 
+  {
+    case V4L2_CID_WHITE_BALANCE_PRESET:
+      return dohofpga_querymenu_wb_preset;
+    case V4L2_CID_COLORFX:
+      return dohofpga_querymenu_effect_mode;
+    case V4L2_CID_EXPOSURE:
+      return dohofpga_querymenu_ev_bias_mode;
+    default:
+      return v4l2_ctrl_get_menu(id);
+  }
+}
+
+static inline struct v4l2_queryctrl const *dohofpga_find_qctrl(int id)
+{
+  int i;
+  for (i = 0; i < ARRAY_SIZE(dohofpga_controls); i++)
+    if (dohofpga_controls[i].id == id)
+      return &dohofpga_controls[i];
+  return NULL;
+}
+
+static int dohofpga_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+  int i;
+  for (i = 0; i < ARRAY_SIZE(dohofpga_controls); i++) 
+  {
+    if (dohofpga_controls[i].id == qc->id) 
+    {
+      memcpy(qc, &dohofpga_controls[i], \
+             sizeof(struct v4l2_queryctrl));
+      return 0;
+    }
+  }
+  return -EINVAL;
+}
+
+
+static int dohofpga_querymenu(struct v4l2_subdev *sd, struct v4l2_querymenu *qm)
+{
+  struct v4l2_queryctrl qctrl;
+  qctrl.id = qm->id;
+  dohofpga_queryctrl(sd, &qctrl);
+  return v4l2_ctrl_query_menu(qm, &qctrl, dohofpga_ctrl_get_menu(qm->id));
+}
+
+/*
+ * Clock configuration
+ * Configure expected MCLK from host and return EINVAL if not supported clock
+ * frequency is expected
+ *  freq : in Hz
+ *  flag : not supported for now
+ */
+static int dohofpga_s_crystal_freq(struct v4l2_subdev *sd, u32  freq, u32 flags)
+{
+  int err = -EINVAL;
+  return err;
+}
+
+static int dohofpga_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)
+{
+  struct dohofpga_state *state = to_state(sd);
+  int err = 0;
+  *fmt = state->fmt;
+  return err;
+}
+
+static int dohofpga_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)
+{
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct dohofpga_state *state = to_state(sd);
+  int err = 0;
+
+  dev_dbg(&client->dev, "requested res(%d, %d)\n",
+          fmt->width, fmt->height);
+
+  printk( "requested res(%d, %d)\n",fmt->width, fmt->height);
+  if((fmt->width == 640) && (fmt->height == 480))
+  {
+    err = __dohofpga_init_2byte(sd, \
+      (unsigned short *) set_resol_640x480, DOHOFPGA_set_resol);
+    err = __dohofpga_init_2byte(sd, \
+      (unsigned short *) Refresh, DOHOFPGA_Refresh);
+    printk( "set resolution %dx%d done.\n",fmt->width,fmt->height);
+    state->fmt = *fmt;
+  }
+  else if((fmt->width == 1280) && (fmt->height == 720))
+  {
+    err = __dohofpga_init_2byte(sd, \
+      (unsigned short *) set_resol_1280x720, DOHOFPGA_set_resol);
+    err = __dohofpga_init_2byte(sd, \
+      (unsigned short *) Refresh, DOHOFPGA_Refresh);
+    printk( "set resolution %dx%d done.\n",fmt->width,fmt->height);
+    state->fmt = *fmt;
+  }
+
+  /*
+  if (!state->fmt.width ||
+    !state->fmt.height ||
+    !state->fmt.code)
+    state->fmt = *fmt;
+  else
+    *fmt = state->fmt;
+  */
+  return err;
+}
+
+static int dohofpga_enum_framesizes(struct v4l2_subdev *sd,
+          struct v4l2_frmsizeenum *fsize)
+{
+  int err = 0;
+  return err;
+}
+
+static int dohofpga_enum_frameintervals(struct v4l2_subdev *sd,
+          struct v4l2_frmivalenum *fival)
+{
+  int err = 0;
+  return err;
+}
+
+static int dohofpga_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+  int err = 0;
+  return err;
+}
+
+static int dohofpga_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+  int err = 0;
+  return err;
+}
+
+static int dohofpga_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct dohofpga_state *state = to_state(sd);
+  struct dohofpga_userset userset = state->userset;
+  int err = -EINVAL;
+
+  switch (ctrl->id) 
+  {
+    case V4L2_CID_CAM_JPEG_MEMSIZE:
+      ctrl->value = DOHOFPGA_JPEG_MAXSIZE +
+        DOHOFPGA_THUMB_MAXSIZE + DOHOFPGA_POST_MAXSIZE;
+      err = 0;
+      break;
+    case V4L2_CID_EXPOSURE:
+      ctrl->value = userset.exposure_bias;
+      err = 0;
+      break;
+    case V4L2_CID_AUTO_WHITE_BALANCE:
+      ctrl->value = userset.auto_wb;
+      err = 0;
+      break;
+    case V4L2_CID_WHITE_BALANCE_PRESET:
+      ctrl->value = userset.manual_wb;
+      err = 0;
+      break;
+    case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+      ctrl->value = userset.wb_temp;
+      err = 0;
+      break;
+    case V4L2_CID_COLORFX:
+      ctrl->value = userset.effect;
+      err = 0;
+      break;
+    case V4L2_CID_CONTRAST:
+      ctrl->value = userset.contrast;
+      err = 0;
+      break;
+    case V4L2_CID_SATURATION:
+      ctrl->value = userset.saturation;
+      err = 0;
+      break;
+    case V4L2_CID_SHARPNESS:
+      ctrl->value = userset.saturation;
+      err = 0;
+      break;
+    default:
+      dev_err(&client->dev, "%s: no such ctrl\n", __func__);
+      break;
+  }
+
+  return err;
+}
+
+
+static int dohofpga_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+#ifdef DOHOFPGA_COMPLETE
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct dohofpga_state *state = to_state(sd);
+  struct dohofpga_userset userset = state->userset;
+  int err = -EINVAL;
+
+  switch (ctrl->id) 
+  {
+    case V4L2_CID_EXPOSURE:
+      dev_dbg(&client->dev, "%s: V4L2_CID_EXPOSURE\n", \
+        __func__);
+      err = dohofpga_write_regs(sd, dohofpga_regs_ev_bias[ctrl->value]);
+      break;
+    case V4L2_CID_AUTO_WHITE_BALANCE:
+      dev_dbg(&client->dev, "%s: V4L2_CID_AUTO_WHITE_BALANCE\n", \
+        __func__);
+      err = dohofpga_write_regs(sd, \
+        dohofpga_regs_awb_enable[ctrl->value]);
+      break;
+    case V4L2_CID_WHITE_BALANCE_PRESET:
+      dev_dbg(&client->dev, "%s: V4L2_CID_WHITE_BALANCE_PRESET\n", \
+        __func__);
+      err = dohofpga_write_regs(sd, \
+        dohofpga_regs_wb_preset[ctrl->value]);
+      break;
+    case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+      dev_dbg(&client->dev, \
+        "%s: V4L2_CID_WHITE_BALANCE_TEMPERATURE\n", __func__);
+      err = dohofpga_write_regs(sd, \
+        dohofpga_regs_wb_temperature[ctrl->value]);
+      break;
+    case V4L2_CID_COLORFX:
+      dev_dbg(&client->dev, "%s: V4L2_CID_COLORFX\n", __func__);
+      err = dohofpga_write_regs(sd, \
+        dohofpga_regs_color_effect[ctrl->value]);
+      break;
+    case V4L2_CID_CONTRAST:
+      dev_dbg(&client->dev, "%s: V4L2_CID_CONTRAST\n", __func__);
+      err = dohofpga_write_regs(sd, \
+        dohofpga_regs_contrast_bias[ctrl->value]);
+      break;
+    case V4L2_CID_SATURATION:
+      dev_dbg(&client->dev, "%s: V4L2_CID_SATURATION\n", __func__);
+      err = dohofpga_write_regs(sd, \
+        dohofpga_regs_saturation_bias[ctrl->value]);
+      break;
+    case V4L2_CID_SHARPNESS:
+      dev_dbg(&client->dev, "%s: V4L2_CID_SHARPNESS\n", __func__);
+      err = dohofpga_write_regs(sd, \
+        dohofpga_regs_sharpness_bias[ctrl->value]);
+      break;
+    default:
+      dev_err(&client->dev, "%s: no such control\n", __func__);
+      break;
+  }
+  if (err < 0)
+    goto out;
+  else
+    return 0;
+
+  out:
+    dev_dbg(&client->dev, "%s: vidioc_s_ctrl failed\n", __func__);
+    return err;
+  #else
+    return 0;
+  #endif
+}
+
+
+static int __dohofpga_init_2byte(struct v4l2_subdev *sd, 
+                                 unsigned short reg[], int total)
+{
+#ifdef __DOHOFPGA_REGWRITE__
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  int err = -EINVAL, i;
+  unsigned short *item;
+
+  for (i = 0; i < total ; i+=2) 
+  {
+    item = (unsigned short *) &reg[i];
+    if (item[0] == REG_DELAY) 
+    {
+      mdelay(item[1]);
+      err = 0;
+    } 
+    else 
+    {
+      err = dohofpga_write(sd, item[0], item[1]);
+    }
+
+    if (err < 0)
+    {
+      v4l_info(client, "%s: register set failed\n",__func__);
+      printk("%s: register set failed\n", __func__);
+    }
+  }
+  return err;
+#else
+  return 0;
+#endif
+}
+
+static int dohofpga_init(struct v4l2_subdev *sd, u32 val)
+{
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  int err = -EINVAL;
+
+  v4l_info(client, "%s: camera initialization start\n", __func__);
+
+  err = __dohofpga_init_2byte(sd, \
+        (unsigned short *) dohofpga_init0, DOHOFPGA_INIT0);
+
+  if (err < 0) 
+  {
+    v4l_info(client, "%s: camera initialization failed\n",__func__);
+    //return -EIO;  /* FIXME */
+  }
+  return 0;
+}
+
+static int dohofpga_s_power(struct v4l2_subdev *sd, int on)
+{
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct dohofpga_state *state = to_state(sd);
+  struct dohofpga_mbus_platform_data *pdata = state->pdata;
+  int ret;
+
+  printk("dohofpga_s_power()\n") ;
+  /* bug report */
+  BUG_ON(!pdata);
+  if(pdata->set_clock) 
+  {
+    ret = pdata->set_clock(&client->dev, on);
+    if(ret)
+      return -EIO;
+  }
+
+  /* setting power */
+  if(pdata->set_power) 
+  {
+    ret = pdata->set_power(on);
+    if (ret)
+      return -EIO;
+    if(on)
+      return dohofpga_init(sd, 0);
+  }
+  return 0;
+}
+
+static int dohofpga_sleep(struct v4l2_subdev *sd)
+{
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  int err = -EINVAL, i;
+
+  v4l_info(client, "%s: sleep mode\n", __func__);
+
+  for (i = 0; i < DOHOFPGA_SLEEP_REGS; i++) 
+  {
+    if (dohofpga_sleep_reg[i][0] == REG_DELAY) 
+    {
+      mdelay(dohofpga_sleep_reg[i][1]);
+      err = 0;
+    } else 
+    {
+      err = dohofpga_write(sd, dohofpga_sleep_reg[i][0], \
+                           dohofpga_sleep_reg[i][1]);
+    }
+    if (err < 0)
+      v4l_info(client, "%s: register set failed\n", __func__);
+  }
+
+  if (err < 0) 
+  {
+    v4l_err(client, "%s: sleep failed\n", __func__);
+    return -EIO;
+  }
+  return 0;
+}
+
+static int dohofpga_wakeup(struct v4l2_subdev *sd)
+{
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  int err = -EINVAL, i;
+
+  v4l_info(client, "%s: wakeup mode\n", __func__);
+
+  for (i = 0; i < DOHOFPGA_WAKEUP_REGS; i++) 
+  {
+    if (dohofpga_wakeup_reg[i][0] == REG_DELAY) 
+    {
+      mdelay(dohofpga_wakeup_reg[i][1]);
+      err = 0;
+    } else 
+    {
+      err = dohofpga_write(sd, dohofpga_wakeup_reg[i][0], \
+                           dohofpga_wakeup_reg[i][1]);
+    }
+    if (err < 0)
+      v4l_info(client, "%s: register set failed\n", __func__);
+  }
+
+  if (err < 0) 
+  {
+    v4l_err(client, "%s: wake up failed\n", __func__);
+    return -EIO;
+  }
+  return 0;
+}
+
+
+static int dohofpga_s_stream(struct v4l2_subdev *sd, int enable)
+{
+  struct dohofpga_state *state = to_state(sd);
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+  int err=0;
+  printk("%s %d \n",__func__,enable);
+
+  switch (enable) 
+  {
+    case STREAM_MODE_CAM_ON:
+      printk("%s STREAM_MODE_CAM_ON\n",__func__);
+      err = __dohofpga_init_2byte(sd, \
+           (unsigned short *) Viewfinder_ON, DOHOFPGA_Viewfinder_ON);
+      if (err < 0) 
+      {
+        v4l_info(client, "%s: camera i2c setting failed\n", __func__);
+        //return -EIO;  /* FIXME */
+      }
+      break;
+    case STREAM_MODE_CAM_OFF:
+      printk("%s STREAM_MODE_CAM_OFF\n",__func__);
+      err = __dohofpga_init_2byte(sd, \
+            (unsigned short *) Viewfinder_OFF, DOHOFPGA_Viewfinder_OFF);
+      if (err < 0) 
+      {
+        v4l_info(client, "%s: camera i2c setting failed\n", __func__);
+        //return -EIO;  /* FIXME */
+      }
+      break;
+  }
+
+  return err;
+  //return enable ? dohofpga_wakeup(sd) : dohofpga_sleep(sd);
+}
+
+/*
+ * dohofpga_probe
+ * Fetching platform data is being done with s_config subdev call.
+ * In probe routine, we just register subdev device
+ */
+
+static int dohofpga_probe(struct i2c_client *client,
+       const struct i2c_device_id *id)
+{
+  struct dohofpga_state *state;
+  struct v4l2_subdev *sd;
+  struct dohofpga_mbus_platform_data *pdata = client->dev.platform_data;
+
+  printk("dohofpga_probe() - started \n");
+
+  if (!pdata)
+  {
+    dev_err( &client->dev, "null platform data");
+    return -EIO;
+  }
+
+  state = kzalloc(sizeof(struct dohofpga_state), GFP_KERNEL);
+  if (state == NULL) return -ENOMEM;
+
+  sd = &state->sd;
+  strcpy(sd->name, DOHOFPGA_DRIVER_NAME);
+  state->pdata = client->dev.platform_data;
+
+  /* set default data from sensor specific value */
+  state->fmt.width = pdata->fmt.width;
+  state->fmt.height = pdata->fmt.height;
+  state->fmt.code = pdata->fmt.code;
+
+  /* Registering subdev */
+  v4l2_i2c_subdev_init(sd, client, &dohofpga_ops);
+
+  /* needed for acquiring subdevice by this module name */
+  snprintf(sd->name, sizeof(sd->name), DOHOFPGA_DRIVER_NAME);
+
+  dev_info(&client->dev, "id: %d, fmt.code: %d, res: res: %d x %d",
+      pdata->id, pdata->fmt.code,
+      pdata->fmt.width, pdata->fmt.height);
+  dev_info(&client->dev, "dohofpga has been probed\n");
+
+  printk("dohofpga_probe() - finished \n") ;
+  return 0;
+}
+
+static int dohofpga_remove(struct i2c_client *client)
+{
+  struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+  printk("dohofpga_remove()\n") ;
+  v4l2_device_unregister_subdev(sd);
+  kfree(to_state(sd));
+  return 0;
+}
+
+static int __init dohofpga_mod_init(void)
+{
+  int err=i2c_add_driver(&dohofpga_i2c_driver);
+  printk("dohofpga_mod_init() - i2c_add_driver() returned %d\n", err) ;
+  return err;
+}
+
+static void __exit dohofpga_mod_exit(void)
+{
+  i2c_del_driver(&dohofpga_i2c_driver);
+  printk("dohofpga_mod_exit() - i2c_del_driver() called\n") ;
+  return ;
+}
+
+module_init(dohofpga_mod_init);
+
+module_exit(dohofpga_mod_exit);
+
+MODULE_DESCRIPTION("DOHOFPGA - ivc/doho fpga camera interface driver");
+MODULE_AUTHOR("dominik.honegger <dominik.honegger@inf.ethz.ch>");
+MODULE_LICENSE("GPL");
+
diff -Naur org/drivers/media/video/dohofpga.h ths/drivers/media/video/dohofpga.h
--- org/drivers/media/video/dohofpga.h	1970-01-01 01:00:00.000000000 +0100
+++ ths/drivers/media/video/dohofpga.h	2013-07-12 13:41:19.000000000 +0200
@@ -0,0 +1,2611 @@
+/* linux/drivers/media/video/dohofpga.h
+ *
+ * Copyright (c) 2013 intsitute for visual computing, ETH Zuerich
+ * http://ivc.ethz.ch/
+ * based on mt9m113
+ * Copyright (c) 2010 Samsung Electronics Co., Ltd.
+ * http://www.samsung.com/
+ *
+ * Driver for dominik honeggers fpga camara interface 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#define DOHOFPGA_COMPLETE
+#undef DOHOFPGA_COMPLETE
+#ifndef __DOHOFPGA_H__
+#define __DOHOFPGA_H__
+
+#define DOHOFPGA_DRIVER_NAME  "DOHOFPGA"
+//define __DOHOFPGA_REGWRITE__
+
+struct dohofpga_reg 
+{
+  unsigned short addr;
+  unsigned short val;
+};
+
+struct dohofpga_regset_type 
+{
+  unsigned char *regset;
+  int len;
+};
+
+/*
+ * Macro
+ */
+#define REGSET_LENGTH(x)  (sizeof(x)/sizeof(dohofpga_reg))
+
+/*
+ * Host S/W Register interface (0x70000000-0x70002000)
+ */
+/* Initialization section */
+#define DOHOFPGA_Speed_368Mbps    0
+#define DOHOFPGA_Speed_464Mbps    1
+#define DOHOFPGA_Speed_552Mbps    2
+#define DOHOFPGA_Speed_648Mbps    3
+#define DOHOFPGA_Speed_736Mbps    4
+#define DOHOFPGA_Speed_832Mbps    5
+#define DOHOFPGA_Speed_920Mbps    6
+
+#define DOHOFPGA4Khz_0Mhz    0x0000
+#define DOHOFPGA4Khz_46Mhz    0x2CEC
+#define DOHOFPGA4Khz_58Mhz    0x38A4
+#define DOHOFPGA4Khz_69Mhz    0x4362
+#define DOHOFPGA4Khz_81Mhz    0x4F1A
+#define DOHOFPGA4Khz_91Mhz    0x58DE
+#define DOHOFPGA4Khz_92Mhz    0x59D8
+#define DOHOFPGA4Khz_93Mhz    0x5AD2
+#define DOHOFPGA4Khz_104Mhz    0x6590
+#define DOHOFPGA4Khz_115Mhz    0x704E
+
+#define DOHOFPGAFrTime_30fps    0x014D  /*  33.3ms -> 30 fps */
+#define DOHOFPGAFrTime_15fps    0x029A  /*  66.6ms -> 15 fps */
+#define DOHOFPGAFrTime_7P5fps    0x0535  /*  133.3ms -> 7.5 fps */
+#define DOHOFPGAFrTime_1P5fps    0x1964  /*  650.0ms -> 1.5 fps */
+/*=====================================*/
+/*========Register map for DOHOFPGA EVT1(Don't modify)===========*/
+#define DOHOFPGA_REG_TC_IPRM_InClockLSBs        0x0238
+#define DOHOFPGA_REG_TC_IPRM_InClockMSBs        0x023A
+#define DOHOFPGA_REG_TC_IPRM_UseNPviClocks      0x0252
+#define DOHOFPGA_REG_TC_IPRM_UseNMipiClocks      0x0254
+#define DOHOFPGA_REG_TC_IPRM_NumberOfMipiLanes      0x0256
+#define DOHOFPGA_REG_TC_IPRM_OpClk4KHz_0        0x025A
+#define DOHOFPGA_REG_TC_IPRM_MinOutRate4KHz_0      0x025C
+#define DOHOFPGA_REG_TC_IPRM_MaxOutRate4KHz_0      0x025E
+#define DOHOFPGA_REG_TC_IPRM_InitParamsUpdated      0x026E
+#define DOHOFPGA_REG_TC_GP_EnablePreview        0x0280
+#define DOHOFPGA_REG_TC_GP_EnablePreviewChanged      0x0282
+#define DOHOFPGA_REG_TC_GP_NewConfigSync        0x0290
+#define DOHOFPGA_REG_TC_GP_ActivePrevConfig      0x02A4
+#define DOHOFPGA_REG_TC_GP_PrevConfigChanged      0x02A6
+#define DOHOFPGA_REG_TC_GP_PrevOpenAfterChange      0x02A8
+#define DOHOFPGA_REG_0TC_PCFG_usWidth        0x02E2
+#define DOHOFPGA_REG_0TC_PCFG_usHeight        0x02E4
+#define DOHOFPGA_REG_0TC_PCFG_Format        0x02E6
+#define DOHOFPGA_REG_0TC_PCFG_usMaxOut4KHzRate      0x02E8
+#define DOHOFPGA_REG_0TC_PCFG_usMinOut4KHzRate      0x02EA
+#define DOHOFPGA_REG_0TC_PCFG_PVIMask        0x02F0
+#define DOHOFPGA_REG_0TC_PCFG_uClockInd        0x02F8
+#define DOHOFPGA_REG_0TC_PCFG_FrRateQualityType      0x02FC
+#define DOHOFPGA_REG_0TC_PCFG_usFrTimeType      0x02FA
+#define DOHOFPGA_REG_0TC_PCFG_usMaxFrTimeMsecMult10    0x02FE
+#define DOHOFPGA_REG_0TC_PCFG_usMinFrTimeMsecMult10    0x0300
+
+#define DOHOFPGA_PCLK_MIN  DOHOFPGA4Khz_115Mhz
+#define DOHOFPGA_PCLK_MAX  DOHOFPGA4Khz_115Mhz
+
+#define DOHOFPGA_FrTime_MAX  DOHOFPGAFrTime_30fps
+/*
+ * User defined commands
+ */
+/* S/W defined features for tune */
+#define REG_DELAY  0xFFFF  /* in ms */
+#define REG_CMD    0xFFFF  /* Followed by command */
+
+/* Following order should not be changed */
+enum image_size_dohofpga 
+{
+  /* This SoC supports upto SXGA (1280*1024) */
+#if 0
+  QQVGA, /* 160*120*/
+  QCIF, /* 176*144 */
+  QVGA, /* 320*240 */
+  CIF, /* 352*288 */
+#endif
+  VGA, /* 640*480 */
+#if 0
+  SVGA, /* 800*600 */
+  HD720P, /* 1280*720 */
+  SXGA, /* 1280*1024 */
+#endif
+};
+
+/*
+ * Following values describe controls of camera
+ * in user aspect and must be match with index of dohofpga_regset[]
+ * These values indicates each controls and should be used
+ * to control each control
+ */
+enum dohofpga_control 
+{
+  DOHOFPGA_INIT,
+  DOHOFPGA_EV,
+  DOHOFPGA_AWB,
+  DOHOFPGA_MWB,
+  DOHOFPGA_EFFECT,
+  DOHOFPGA_CONTRAST,
+  DOHOFPGA_SATURATION,
+  DOHOFPGA_SHARPNESS,
+};
+
+#define DOHOFPGA_REGSET(x)  {  \
+  .regset = x,      \
+  .len = sizeof(x)/sizeof(dohofpga_reg),}
+
+/*
+ * User tuned register setting values
+ */
+unsigned short dohofpga_init0[]={
+//mclk : 24MHz
+
+//pclk : 60MHz
+
+//preview : 640 x 480 (30fps)
+
+//capture : 1280 x 960
+
+//
+
+//[1. CA?a AAUA]
+
+//      
+
+ 0x001c, 0x0001,//
+
+ 0x001c, 0x0000,//
+
+ 0xffff, 0x000a, // //DELAY=10
+
+
+
+ 0x0014,0x304A,//
+
+  
+
+// 0xffff, 0x012c,//
+
+ 0x0016, 0x40ff,//
+
+ 0x0018, 0x0028,//
+
+
+
+ 0x0014, 0x2147,//
+
+ 0x0014, 0x2143,//
+
+ 0x0014, 0x2145,//
+
+ 0x0010, 0x0114,//
+
+ 0x0012, 0x1FF1,//
+
+ 0x0014, 0x2545,//
+
+ 0x0014, 0x2547,//
+
+ 0x0014, 0x3447,//
+
+ 0xffff, 0x000a,////DELAY= 3   
+
+ 0x0014, 0x3047,//
+
+ 0x0014, 0x3046,//
+
+
+
+ 0x0014, 0x3047,//
+
+ 0x0014, 0x3046,//
+
+ 0x001E, 0x0772,// // new 2010 0705
+
+ 0x332E, 0x0200,// // new 2010 0705
+
+  
+
+ 0x098C, 0x2703,// output a
+
+ 0x0990, 0x0280,////640 w
+
+ 0x098C, 0x2705,// output a
+
+ 0x0990, 0x01E0,//// 480 w
+
+ 0x098C, 0x2707,//  output B
+
+  //NvOdmImagerI2c16Write16(&pContext->I2c, 0x0990, 0x0500//
+
+ 0x0990, 0x0500, //400
+
+ 0x098C, 0x2709,// output C
+
+  //NvOdmImagerI2c16Write16(&pContext->I2c, 0x0990, 0x03C0//
+
+ 0x0990, 0x03c0,  //300//
+
+ 0x098C, 0x270D,//
+
+ 0x0990, 0x0000,//
+
+ 0x098C, 0x270F,//
+
+ 0x0990, 0x0000,//
+
+ 0x098C, 0x2711,//
+
+ 0x0990, 0x03CD,//
+
+ 0x098C, 0x2713,//
+
+ 0x0990, 0x050D,//
+
+ 0x098C, 0x2715,//
+
+ 0x0990, 0x2111,//
+
+ 0x098C, 0x2717,//
+
+  //NvOdmImagerI2c16Write16(&pContext->I2c, 0x0990, 0x046C//
+
+ 0x0990, 0x046C,//  // sungmin.woo 20100720 Mirrored images for preview
+
+ 0x098C, 0x2719,//
+
+ 0x0990, 0x00AC,//
+
+ 0x098C, 0x271B,//
+
+ 0x0990, 0x01F1,//
+
+ 0x098C, 0x271D,//
+
+ 0x0990, 0x013F,//
+
+ 0x098C, 0x271F,//
+
+ 0x0990, 0x0255,//
+
+ 0x098C, 0x2721,//
+
+ 0x0990, 0x0722,//
+
+ 0x098C, 0x2723,//
+
+ 0x0990, 0x0004,//
+
+ 0x098C, 0x2725,//
+
+ 0x0990, 0x0004,//
+
+ 0x098C, 0x2727,//
+
+  //NvOdmImagerI2c16Write16(&pContext->I2c, 0x0990, 0x040B//
+
+ 0x0990, 0x03CB,//  // from aptina choi's fix
+
+ 0x098C, 0x2729,//
+
+ 0x0990, 0x050B,//
+
+ 0x098C, 0x272B,//
+
+ 0x0990, 0x2111,//
+
+ 0x098C, 0x272D,//
+
+  //NvOdmImagerI2c16Write16(&pContext->I2c, 0x0990, 0x0024//
+
+ 0x0990, 0x0025,//  // sungmin.woo 20100720 Mirrored images for capture
+
+ 0x098C, 0x272F,//
+
+ 0x0990, 0x004C,//
+
+ 0x098C, 0x2731,//
+
+ 0x0990, 0x00F9,//
+
+ 0x098C, 0x2733,//
+
+ 0x0990, 0x00A7,//
+
+ 0x098C, 0x2735,//
+
+ 0x0990, 0x048B,//
+
+ 0x098C, 0x2737,//
+
+ 0x0990, 0x0722,//
+
+ 0x098C, 0x2739,// crop x0 a
+
+ 0x0990, 0x0000,//
+
+ 0x098C, 0x273B,// crop x1 a
+
+ 0x0990, 0x027F,//
+
+ 0x098C, 0x273D,// crop y0 a
+
+ 0x0990, 0x0000,//
+
+ 0x098C, 0x273F,//crop y1 a
+
+ 0x0990, 0x01DF,//
+
+ 0x098C, 0x2747,//crop x0 b
+
+ 0x0990, 0x0000,//
+
+ 0x098C, 0x2749,//crop x1 b
+
+ 0x0990, 0x04FF,//
+
+ 0x098C, 0x274B,//crop y0 b
+
+ 0x0990, 0x0000,//
+
+ 0x098C, 0x274D,//crop y1 b
+
+  //NvOdmImagerI2c16Write16(&pContext->I2c, 0x0990, 0x03FF//
+
+ 0x0990, 0x03BF,//  // from aptina choi's fix
+
+ 0x098C, 0x222D,//
+
+ 0x0990, 0x0089,//
+
+ 0x098C, 0xA404,//
+
+ 0x0990, 0x0010,//
+
+ 0x098C, 0xA408,//
+
+ 0x0990, 0x0021,//
+
+ 0x098C, 0xA409,//
+
+ 0x0990, 0x0023,//
+
+ 0x098C, 0xA40A,//
+
+ 0x0990, 0x0028,//
+
+ 0x098C, 0xA40B,//
+
+ 0x0990, 0x002A,//
+
+ 0x098C, 0x2411,//
+
+ 0x0990, 0x0089,//
+
+ 0x098C, 0x2413,//
+
+ 0x0990, 0x00A4,//
+
+ 0x098C, 0x2415,//
+
+ 0x0990, 0x0089,//
+
+ 0x098C, 0x2417,//
+
+ 0x0990, 0x00A4,//
+
+ 0x098C, 0xA40D,//
+
+ 0x0990, 0x0002,//
+
+ 0x098C, 0xA40E,//
+
+ 0x0990, 0x0003,//
+
+ 0x098C, 0xA410,//
+
+ 0x0990, 0x000A,//
+
+  //[High Power Preview Mode]
+
+ 0x098C, 0x275f,//
+
+ 0x0990, 0x0596,//
+
+ 0x098C, 0x2761,//
+
+ 0x0990, 0x0094,//
+
+  //[pevuew 0 seq]
+
+ 0x098C, 0xa117,//
+
+ 0x0990, 0x0002,//
+
+ 0x098C, 0xa118,//
+
+ 0x0990, 0x0001,//
+
+ 0x098C, 0xa119,//
+
+ 0x0990, 0x0001,//
+
+ 0x098C, 0xa11a,//
+
+ 0x0990, 0x0001,//
+
+  //[pevuew 1 seq]
+
+ 0x098C, 0xa11d,//
+
+ 0x0990, 0x0002,//
+
+ 0x098C, 0xa11e,//
+
+ 0x0990, 0x0001,//
+
+ 0x098C, 0xa11f,//
+
+ 0x0990, 0x0001,//
+
+ 0x098C, 0xa120,//
+
+ 0x0990, 0x0001,//
+
+  //[Lens Correction 95%]
+
+ 0x364E, 0x0730,//
+
+ 0x3650, 0x1E4E,//
+
+ 0x3652, 0x14F1,//
+
+ 0x3654, 0x32CF,//
+
+ 0x3656, 0x734F,//
+
+ 0x3658, 0x0330,//
+
+ 0x365A, 0xF1AD,//
+
+ 0x365C, 0x2731,//
+
+ 0x365E, 0x550E,//
+
+ 0x3660, 0x6F8F,//
+
+ 0x3662, 0x0250,//
+
+ 0x3664, 0x01AE,//
+
+ 0x3666, 0x7FD0,//
+
+ 0x3668, 0x03EF,//
+
+ 0x366A, 0x442F,//
+
+ 0x366C, 0x0250,//
+
+ 0x366E, 0x82EE,//
+
+ 0x3670, 0x0591,//
+
+ 0x3672, 0x128E,//
+
+ 0x3674, 0x540F,//
+
+ 0x3676, 0x650D,//
+
+ 0x3678, 0x714C,//
+
+ 0x367A, 0x272E,//
+
+ 0x367C, 0x09CA,//
+
+ 0x367E, 0xD12E,//
+
+ 0x3680, 0x652D,//
+
+ 0x3682, 0x9C0D,//
+
+ 0x3684, 0x172F,//
+
+ 0x3686, 0xB64D,//
+
+ 0x3688, 0xB3EF,//
+
+ 0x368A, 0x1F6D,//
+
+ 0x368C, 0xAA2D,//
+
+ 0x368E, 0x68CA,//
+
+ 0x3690, 0x300D,//
+
+ 0x3692, 0x826E,//
+
+ 0x3694, 0x13CD,//
+
+ 0x3696, 0x37AB,//
+
+ 0x3698, 0x2B2D,//
+
+ 0x369A, 0xB52A,//
+
+ 0x369C, 0x874F,//
+
+ 0x369E, 0x5390,//
+
+ 0x36A0, 0x0370,//
+
+ 0x36A2, 0x3812,//
+
+ 0x36A4, 0xFAB0,//
+
+ 0x36A6, 0xBE13,//
+
+ 0x36A8, 0x7F90,//
+
+ 0x36AA, 0xA5AC,//
+
+ 0x36AC, 0x0393,//
+
+ 0x36AE, 0x1DAD,//
+
+ 0x36B0, 0xF693,//
+
+ 0x36B2, 0x3C90,//
+
+ 0x36B4, 0x5CCF,//
+
+ 0x36B6, 0x3E72,//
+
+ 0x36B8, 0x8F70,//
+
+ 0x36BA, 0xABB3,//
+
+ 0x36BC, 0x5390,//
+
+ 0x36BE, 0x06AE,//
+
+ 0x36C0, 0x23F2,//
+
+ 0x36C2, 0x9FB0,//
+
+ 0x36C4, 0x93F3,//
+
+ 0x36C6, 0xA0AA,//
+
+ 0x36C8, 0x43CD,//
+
+ 0x36CA, 0x4E0A,//
+
+ 0x36CC, 0xE750,//
+
+ 0x36CE, 0xDAF1,//
+
+ 0x36D0, 0x50EB,//
+
+ 0x36D2, 0x88CB,//
+
+ 0x36D4, 0xAE0C,//
+
+ 0x36D6, 0x256E,//
+
+ 0x36D8, 0xA36F,//
+
+ 0x36DA, 0xC06E,//
+
+ 0x36DC, 0x844D,//
+
+ 0x36DE, 0x8CED,//
+
+ 0x36E0, 0x9110,//
+
+ 0x36E2, 0xADD1,//
+
+ 0x36E4, 0xEA2D,//
+
+ 0x36E6, 0x1BAE,//
+
+ 0x36E8, 0xD86E,//
+
+ 0x36EA, 0xBF0D,//
+
+ 0x36EC, 0xED30,//
+
+ 0x36EE, 0x224F,//
+
+ 0x36F0, 0xCC10,//
+
+ 0x36F2, 0xAAB2,//
+
+ 0x36F4, 0x510E,//
+
+ 0x36F6, 0xDC54,//
+
+ 0x36F8, 0x29B0,//
+
+ 0x36FA, 0xE5ED,//
+
+ 0x36FC, 0x90F3,//
+
+ 0x36FE, 0xA811,//
+
+ 0x3700, 0xE814,//
+
+ 0x3702, 0x3810,//
+
+ 0x3704, 0xFE2F,//
+
+ 0x3706, 0xA1B2,//
+
+ 0x3708, 0x328D,//
+
+ 0x370A, 0xBC34,//
+
+ 0x370C, 0x2D4F,//
+
+ 0x370E, 0xEA70,//
+
+ 0x3710, 0xBCF1,//
+
+ 0x3712, 0x7BD1,//
+
+ 0x3714, 0xED54,//
+
+ 0x3644, 0x0280,//
+
+ 0x3642, 0x01C0,//
+
+ 0x3210, 0x01A8,//
+
+//
+
+//  NvOdmImagerI2cRead16(&pContext->I2c, 0x3210, &RegVAEC//
+
+//  RegVAEC |= (1<<3//
+
+//  
+
+// 0x3210,RegVAEC//
+
+  
+
+ 0x098C, 0x2306,//
+
+ 0x0990, 0x00A4,//
+
+ 0x098C, 0x2308,//
+
+ 0x0990, 0x00D4,//
+
+ 0x098C, 0x230A,//
+
+ 0x0990, 0xFFBD,//
+
+ 0x098C, 0x230C,//
+
+ 0x0990, 0xFF68,//
+
+ 0x098C, 0x230E,//
+
+ 0x0990, 0x0284,//
+
+ 0x098C, 0x2310,//
+
+ 0x0990, 0xFF70,//
+
+ 0x098C, 0x2312,//
+
+ 0x0990, 0xFFE5,//
+
+ 0x098C, 0x2314,//
+
+ 0x0990, 0xFF1B,//
+
+ 0x098C, 0x2316,//
+
+ 0x0990, 0x0259,//
+
+ 0x098C, 0x2318,// 
+
+ 0x0990, 0x002B,//              
+
+ 0x098C, 0x231A,//
+
+ 0x0990, 0x0042,//      
+
+ 0x098C, 0x231C,//
+
+ 0x0990, 0x002D,//             
+
+ 0x098C, 0x231E,//
+
+ 0x0990, 0xFF32,//          
+
+ 0x098C, 0x2320,//
+
+ 0x0990, 0x0045,//   
+
+ 0x098C, 0x2322,//
+
+ 0x0990, 0x0034,//
+
+ 0x098C, 0x2324,//
+
+ 0x0990, 0xFF52,//            
+
+ 0x098C, 0x2326,//
+
+ 0x0990, 0x002A,//   
+
+ 0x098C, 0x2328,//
+
+ 0x0990, 0xFFF8,//
+
+ 0x098C, 0x232A,//
+
+ 0x0990, 0x0052,//   
+
+ 0x098C, 0x232C,//
+
+ 0x0990, 0xFF61,//  
+
+ 0x098C, 0x232E,//
+
+ 0x0990, 0x0008,//
+
+ 0x098C, 0x2330,//
+
+ 0x0990, 0xFFE7,// 
+
+ 0x098C, 0xA348,//
+
+ 0x0990, 0x0008,//
+
+ 0x098C, 0xA349,//
+
+ 0x0990, 0x0002,//
+
+ 0x098C, 0xA34A,//
+
+ 0x0990, 0x0059,//
+
+ 0x098C, 0xA34B,//
+
+ 0x0990, 0x00A6,//
+
+ 0x098C, 0xA34C,//
+
+ 0x0990, 0x0059,//
+
+ 0x098C, 0xA34D,//
+
+ 0x0990, 0x00a6,//
+
+ 0x098C, 0xA351,//
+
+ 0x0990, 0x0000,//
+
+ 0x098C, 0xA352,//
+
+ 0x0990, 0x007F,//
+
+ 0x098C, 0xA354,//
+
+ 0x0990, 0x0043,//
+
+ 0x098C, 0xA355,//
+
+ 0x0990, 0x0002,//
+
+ 0x098C, 0xA35D,//
+
+ 0x0990, 0x0078,//
+
+ 0x098C, 0xA35E,//
+
+ 0x0990, 0x0086,//
+
+ 0x098C, 0xA35F,//
+
+ 0x0990, 0x007E,//
+
+ 0x098C, 0xA360,//
+
+ 0x0990, 0x0082,//
+
+ 0x098C, 0xA365,//
+
+ 0x0990, 0x0010,//
+
+  //[true gray] 
+
+ 0x098C, 0xA363,//
+
+ 0x0990, 0x00C7,//
+
+ 0x098C, 0xA364,//
+
+ 0x0990, 0x00F0,//
+
+  //[K FACTOR]
+
+ 0x098C, 0xA366,//
+
+ 0x0990, 0x007D,//
+
+ 0x098C, 0xA367,//
+
+ 0x0990, 0x0080,//
+
+ 0x098C, 0xA368,//
+
+ 0x0990, 0x0080,//
+
+ 0x098C, 0xA369,//
+
+ 0x0990, 0x0080,//
+
+ 0x098C, 0xA36A,//
+
+ 0x0990, 0x0077,//
+
+ 0x098C, 0xA36B,//
+
+ 0x0990, 0x0078,//
+
+  //lowlight bluish
+
+ 0x35A2, 0x00A4,//
+
+ 0x3240, 0xC802,//
+
+  //[AFD]
+
+  ////Auto flicker detection
+
+ 0x098C, 0xA11E,//
+
+ 0x0990, 0x0001,//
+
+ 0x098C, 0xA404,//
+
+ 0x0990, 0x0000,//
+
+  //[virtgain]
+
+ 0x098C, 0xA20C,//
+
+ 0x0990, 0x000C,//
+
+ 0x098C, 0x2212,//
+
+ 0x0990, 0x01A0,//
+
+ 0x098C, 0xA20D,//
+
+ 0x0990, 0x0017,//
+
+ 0x098C, 0xA20E,//
+
+ 0x0990, 0x0080,//
+
+ 0x098C, 0xA216,//
+
+ 0x0990, 0x0060,//
+
+ 0x098C, 0xA11D,//
+
+ 0x0990, 0x0002,//
+
+
+
+                                         
+
+                                         
+
+  //[no gain up3]                        
+
+ 0x098C, 0xAB2C,//
+
+ 0x0990, 0x0006,//
+
+ 0x098C, 0xAB2D,//
+
+ 0x0990, 0x000e,//
+
+ 0x098C, 0xAB2E,//
+
+ 0x0990, 0x0006,//
+
+ 0x098C, 0xAB2F,//
+
+ 0x0990, 0x0006,//
+
+ 0x098C, 0xAB30,//
+
+ 0x0990, 0x001e,//
+
+ 0x098C, 0xAB31,//
+
+ 0x0990, 0x000e,//
+
+ 0x098C, 0xAB32,//
+
+ 0x0990, 0x001e,//
+
+ 0x098C, 0xAB33,//
+
+ 0x0990, 0x001e,//
+
+ 0x098C, 0xAB34,//
+
+ 0x0990, 0x0008,//
+
+ 0x098C, 0xAB35,//
+
+ 0x0990, 0x0080,//
+
+  //[AE setting]           
+
+ 0x098C, 0xA207,//  
+
+ 0x0990, 0x0004,//
+
+ 0x098C, 0xA24F,//  
+
+ 0x0990, 0x0036,//
+
+ 0x098C, 0x2257,//  
+
+ 0x0990, 0x2710,//
+
+ 0x098C, 0x2250,//  
+
+ 0x0990, 0x1B58,//
+
+ 0x098C, 0x2252,//  
+
+ 0x0990, 0x32C8,//
+
+//[black gamma contrast]
+
+ 0x098C, 0x2B1B,//   // MCU_ADDRESS [HG_BRIGHTNESSMETRIC]
+
+ 0x0990, 0x0643,//   // MCU_DATA_0
+
+ 0x098C, 0xAB37,//   // MCU_ADDRESS [HG_GAMMA_MORPH_CTRL]
+
+ 0x0990, 0x0003,//   // MCU_DATA_0
+
+ 0x098C, 0x2B38,//   // MCU_ADDRESS [HG_GAMMASTARTMORPH]
+
+ 0x0990, 0x2800,//          // MCU_DATA_0
+
+ 0x098C, 0x2B3A,//   // MCU_ADDRESS [HG_GAMMASTOPMORPH]
+
+ 0x0990, 0x46fe,//   // MCU_DATA_0
+
+//black 06
+
+ 0x098C, 0xAB3C,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_0]
+
+ 0x0990, 0x0000,//   // MCU_DATA_0
+
+ 0x098C, 0xAB3D,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_1]
+
+ 0x0990, 0x0008,//   // MCU_DATA_0
+
+ 0x098C, 0xAB3E,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_2]
+
+ 0x0990, 0x0019,//   // MCU_DATA_0
+
+ 0x098C, 0xAB3F,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_3]
+
+ 0x0990, 0x0035,//   // MCU_DATA_0
+
+ 0x098C, 0xAB40,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_4]
+
+ 0x0990, 0x0056,//   // MCU_DATA_0
+
+ 0x098C, 0xAB41,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_5]
+
+ 0x0990, 0x006F,//   // MCU_DATA_0
+
+ 0x098C, 0xAB42,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_6]
+
+ 0x0990, 0x0085,//   // MCU_DATA_0
+
+ 0x098C, 0xAB43,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_7]
+
+ 0x0990, 0x0098,//   // MCU_DATA_0
+
+ 0x098C, 0xAB44,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_8]
+
+ 0x0990, 0x00A7,//   // MCU_DATA_0
+
+ 0x098C, 0xAB45,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_9]
+
+ 0x0990, 0x00B4,//   // MCU_DATA_0
+
+ 0x098C, 0xAB46,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_10]
+
+ 0x0990, 0x00C0,//   // MCU_DATA_0
+
+ 0x098C, 0xAB47,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_11]
+
+ 0x0990, 0x00CA,//   // MCU_DATA_0
+
+ 0x098C, 0xAB48,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_12]
+
+ 0x0990, 0x00D4,//   // MCU_DATA_0
+
+ 0x098C, 0xAB49,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_13]
+
+ 0x0990, 0x00DC,//   // MCU_DATA_0
+
+ 0x098C, 0xAB4A,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_14]
+
+ 0x0990, 0x00E4,//   // MCU_DATA_0
+
+ 0x098C, 0xAB4B,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_15]
+
+ 0x0990, 0x00EC,//   // MCU_DATA_0
+
+ 0x098C, 0xAB4C,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_16]
+
+ 0x0990, 0x00F3,//   // MCU_DATA_0
+
+ 0x098C, 0xAB4D,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_17]
+
+ 0x0990, 0x00F9,//   // MCU_DATA_0
+
+ 0x098C, 0xAB4E,//   // MCU_ADDRESS [HG_GAMMA_TABLE_A_18]
+
+ 0x0990, 0x00FF,//   // MCU_DATA_0
+
+//Black 05 contrast 1.35
+
+ 0x098C, 0xAB4F,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_0]
+
+ 0x0990, 0x0000,//   // MCU_DATA_0
+
+ 0x098C, 0xAB50,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_1]
+
+ 0x0990, 0x0006,//   // MCU_DATA_0
+
+ 0x098C, 0xAB51,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_2]
+
+ 0x0990, 0x0012,//   // MCU_DATA_0
+
+ 0x098C, 0xAB52,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_3]
+
+ 0x0990, 0x002F,//   // MCU_DATA_0
+
+ 0x098C, 0xAB53,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_4]
+
+ 0x0990, 0x0053,//   // MCU_DATA_0
+
+ 0x098C, 0xAB54,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_5]
+
+ 0x0990, 0x006D,//   // MCU_DATA_0
+
+ 0x098C, 0xAB55,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_6]
+
+ 0x0990, 0x0083,//   // MCU_DATA_0
+
+ 0x098C, 0xAB56,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_7]
+
+ 0x0990, 0x0096,//   // MCU_DATA_0
+
+ 0x098C, 0xAB57,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_8]
+
+ 0x0990, 0x00A6,//   // MCU_DATA_0
+
+ 0x098C, 0xAB58,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_9]
+
+ 0x0990, 0x00B3,//   // MCU_DATA_0
+
+ 0x098C, 0xAB59,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_10]
+
+ 0x0990, 0x00BF,//   // MCU_DATA_0
+
+ 0x098C, 0xAB5A,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_11]
+
+ 0x0990, 0x00CA,//   // MCU_DATA_0
+
+ 0x098C, 0xAB5B,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_12]
+
+ 0x0990, 0x00D3,//   // MCU_DATA_0
+
+ 0x098C, 0xAB5C,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_13]
+
+ 0x0990, 0x00DC,//   // MCU_DATA_0
+
+ 0x098C, 0xAB5D,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_14]
+
+ 0x0990, 0x00E4,//   // MCU_DATA_0
+
+ 0x098C, 0xAB5E,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_15]
+
+ 0x0990, 0x00EB,//   // MCU_DATA_0
+
+ 0x098C, 0xAB5F,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_16]
+
+ 0x0990, 0x00F2,//   // MCU_DATA_0
+
+ 0x098C, 0xAB60,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_17]
+
+ 0x0990, 0x00F9,//   // MCU_DATA_0
+
+ 0x098C, 0xAB61,//   // MCU_ADDRESS [HG_GAMMA_TABLE_B_18]
+
+ 0x0990, 0x00FF,//   // MCU_DATA_0
+
+//[LL-mode-modified]
+
+ 0x098C, 0xAB04,//   // MCU_ADDRESS [HG_MAX_DLEVEL]
+
+ 0x0990, 0x0040,//   // MCU_DATA_0
+
+ 0x098C, 0xAB06,//   // MCU_ADDRESS [HG_PERCENT]
+
+ 0x0990, 0x0005,//    // 3, //0x000A   // MCU_DATA_0
+
+ 0x098C, 0xAB08,//   // MCU_ADDRESS [HG_DLEVEL]
+
+ 0x0990, 0x0010,//   // MCU_DATA_0
+
+ 0x098C, 0xAB20,//   // MCU_ADDRESS [HG_LL_SAT1]
+
+ 0x0990, 0x0050,//   //63,   // MCU_DATA_0
+
+ 0x098C, 0xAB21,//   // MCU_ADDRESS [RESERVED_HG_21]
+
+ 0x0990, 0x001d,//   // MCU_DATA_0
+
+ 0x098C, 0xAB22,//   // MCU_ADDRESS [RESERVED_HG_22]
+
+ 0x0990, 0x0007,//   // MCU_DATA_0
+
+ 0x098C, 0xAB23,//   // MCU_ADDRESS [RESERVED_HG_23]
+
+ 0x0990, 0x0004,// //0x000A   // MCU_DATA_0
+
+ 0x098C, 0xAB24,//   // MCU_ADDRESS [HG_LL_SAT2]
+
+ 0x0990, 0x0000,//   // MCU_DATA_0
+
+ 0x098C, 0xAB25,//   // MCU_ADDRESS [RESERVED_HG_25]
+
+ 0x0990, 0x00a0,//     //0x0014   // MCU_DATA_0
+
+ 0x098C, 0xAB26,//   // MCU_ADDRESS [RESERVED_HG_26]
+
+ 0x0990, 0x0005,//   // MCU_DATA_0
+
+ 0x098C, 0xAB27,//   // MCU_ADDRESS [RESERVED_HG_27]
+
+ 0x0990, 0x0010,//   // MCU_DATA_0
+
+ 0x098C, 0x2B28,//   // MCU_ADDRESS [HG_LL_BRIGHTNESSSTART]
+
+ 0x0990, 0x157c,// //0x0a00 //0x157c  //0x0A00   // MCU_DATA_0
+
+ 0x098C, 0x2B2A,//   // MCU_ADDRESS [HG_LL_BRIGHTNESSSTOP]
+
+ 0x0990, 0x37ef,//     //0x7000   // MCU_DATA_0
+
+
+  //enter refresh mode
+
+ 0x098C,0xA103 ,//
+
+ 0x0990,0x0006 ,//
+
+//POLL_FIELD=SEQ_CMD, !=0, DELAY=10, TIMEOUT=50//delay=50
+
+//DELAY=300
+0xffff,300,
+
+
+//DELAY=300
+
+//  for(k = 0; k < DOHOFPGA_WAIT_TIMES; k ++)
+
+//  {
+//    NvOdmImagerI2c16Write16(&pContext->I2c,0x098C,0xA103//
+
+//    NvOdmImagerI2cRead16(&pContext->I2c,0x0990, &RegVAEC//
+
+//    if(RegVAEC == 0x0000)  break;
+
+//    //NvOdmOsWaitUS(10000//
+
+//  }
+
+ 0x098C,0xA103 ,//
+
+ 0x0990,0x0005 ,//
+
+//POLL_FIELD=SEQ_CMD, !=0, DELAY=10, TIMEOUT=50//delay=50
+
+//  for(k = 0; k < DOHOFPGA_WAIT_TIMES; k ++)
+
+//  {
+
+//   0x098C,0xA103//
+
+//    NvOdmImagerI2cRead16(&pContext->I2c, 0x0990, &RegVAEC//
+
+//    if(RegVAEC == 0x0000)  break;
+
+//    //NvOdmOsWaitUS(10000//
+
+//  }
+
+//
+
+//#ifdef Debug_message_on  
+
+//    LOGD("SensorInit End!\n"//
+
+//#endif
+
+//};
+
+
+
+//[2. ?a AuE?A(A?AA)]
+
+ 0x098C, 0xA115,   // MCU_ADDRESS [SEQ_CAP_MODE]
+
+ 0x0990, 0x0002,   // MCU_DATA_0
+
+ 0x098C, 0xA103,   // MCU_ADDRESS [SEQ_CMD]
+
+ 0x0990, 0x0002,   // MCU_DATA_0
+
+//  for(k = 0; k < DOHOFPGA_WAIT_TIMES; k ++)
+
+//  {
+
+ 0x098C,0xA103,//
+
+//    NvOdmImagerI2cRead16(&pContext->I2c, 0x0990, &RegVAEC//
+
+//    if(RegVAEC == 0x0000)  break;
+
+//  }
+
+
+
+//[capture_command]//return the preview after 3 full resolution.
+
+ 0x098C, 0xA115,   // MCU_ADDRESS [SEQ_CAP_MODE]
+
+ 0x0990, 0x0000,   // MCU_DATA_0
+
+ 0x098C, 0xA116,   // MCU_ADDRESS [SEQ_CAP_NUMFRAMES]
+
+ 0x0990, 0x0003,   // MCU_DATA_0
+
+ 0x098C, 0xA103,   // MCU_ADDRESS [SEQ_CMD]
+
+ 0x0990, 0x0002,   // MCU_DATA_0
+};
+
+
+
+unsigned short Viewfinder_ON[]={
+//[Viewfinder ON]
+
+ 0x098C, 0xA115,   // MCU_ADDRESS [SEQ_CAP_MODE]
+
+ 0x0990, 0x0000,   // MCU_DATA_0
+
+ 0x098C, 0xA103,   // MCU_ADDRESS [SEQ_CMD]
+
+ 0x0990, 0x0001,   // MCU_DATA_0
+};
+
+unsigned short Viewfinder_OFF[]={
+
+//[Viewfinder OFF]
+
+ 0x098C, 0xA115,   // MCU_ADDRESS [SEQ_CAP_MODE]
+
+ 0x0990, 0x0002,   // MCU_DATA_0
+
+ 0x098C, 0xA103,   // MCU_ADDRESS [SEQ_CMD]
+
+ 0x0990, 0x0002,   // MCU_DATA_0
+};
+
+unsigned short Refresh[]={
+
+  //enter refresh mode
+
+ 0x098C,0xA103 ,//
+
+ 0x0990,0x0006 ,//
+
+//POLL_FIELD=SEQ_CMD, !=0, DELAY=10, TIMEOUT=50//delay=50
+
+//DELAY=300
+0xffff,300,
+
+
+//DELAY=300
+
+//  for(k = 0; k < DOHOFPGA_WAIT_TIMES; k ++)
+
+//  {
+//    NvOdmImagerI2c16Write16(&pContext->I2c,0x098C,0xA103//
+
+//    NvOdmImagerI2cRead16(&pContext->I2c,0x0990, &RegVAEC//
+
+//    if(RegVAEC == 0x0000)  break;
+
+//    //NvOdmOsWaitUS(10000//
+
+//  }
+
+ 0x098C,0xA103 ,//
+
+ 0x0990,0x0005 ,//
+
+};
+//crop size   
+
+unsigned short set_resol_640x480[]={
+  
+ 0x098C, 0x2703,// output a
+ 0x0990, 0x0280,////640 w
+ 0x098C, 0x2705,// output a
+ 0x0990, 0x01E0,//// 480 w
+
+ 0x098C, 0x2739,// crop x0 a
+ 0x0990, 0x0000,//
+ 0x098C, 0x273B,// crop x1 a
+ 0x0990, 0x027F,//
+ 0x098C, 0x273D,// crop y0 a
+ 0x0990, 0x0000,//
+ 0x098C, 0x273F,//crop y1 a
+ 0x0990, 0x01DF,//
+};
+
+unsigned short set_resol_1280x720[]={
+  
+ 0x098C, 0x2703,// output a
+ 0x0990, 1280,//
+ 0x098C, 0x2705,// output a
+ 0x0990, 720,//
+
+ 0x098C, 0x2739,// crop x0 a
+ 0x0990, 0x0000,//
+ 0x098C, 0x273B,// crop x1 a
+ 0x0990, 1280-1,
+ 0x098C, 0x273D,// crop y0 a
+ 0x0990, 0x0000,//
+ 0x098C, 0x273F,//crop y1 a
+ 0x0990, 720-1,
+};
+
+
+
+#define DOHOFPGA_INIT0  \
+  (sizeof(dohofpga_init0) / sizeof(dohofpga_init0[0]))
+#define DOHOFPGA_Viewfinder_ON  \
+  (sizeof(Viewfinder_ON) / sizeof(Viewfinder_ON[0]))
+#define DOHOFPGA_Viewfinder_OFF  \
+  (sizeof(Viewfinder_OFF) / sizeof(Viewfinder_OFF[0]))
+
+#define DOHOFPGA_Refresh  \
+  (sizeof(Refresh) / sizeof(Refresh[0]))
+  
+#define DOHOFPGA_set_resol  \
+  (sizeof(set_resol_640x480) / sizeof(set_resol_640x480[0]))
+
+unsigned char dohofpga_init_reg1[][4] = {
+  {0xFC, 0xFC, 0xD0, 0x00},
+
+  /* === Analog/APS setting === */
+  /* WRITE  D000F262  0000
+   * tgr_auto_exp (shutter off=0b shutter on=1b) */
+  {0x00, 0x28, 0xD0, 0x00},
+
+  /* 002A  F468 */
+  /* 0F12  0006   For avg mode */
+  {0x00, 0x2A, 0xF4, 0x04},
+  {0x0F, 0x12, 0x00, 0x2A},/* ADC SAT(450mV):  by Ana 090609 */
+  {0x00, 0x2A, 0xF4, 0x6E},
+  {0x0F, 0x12, 0x00, 0x02},/* CDS TEST [0]SR/SS EN: by Ana 090126 */
+  /*  [1]S1 H, [2]LDB H, [3]clp H */
+  /*  [4]S34 P X, [5]S24 N X */
+  {0x00, 0x2A, 0xF4, 0x5A},
+  {0x0F, 0x12, 0x00, 0x02},/*  LD LDB EN :  by Ana 090126 */
+  {0x00, 0x2A, 0xF4, 0x0E},
+  {0x0F, 0x12, 0x00, 0x04},/*  RMP REG 1.8V:  by Ana 090126 */
+  {0x00, 0x2A, 0xF4, 0x0C},
+  {0x0F, 0x12, 0x00, 0x20}, /*  rmp_option(RMP_INIT_DAC):
+          *  by Ana 090126 */
+  {0x00, 0x2A, 0xF4, 0x20},
+  {0x0F, 0x12, 0x00, 0x76}, /* For SHBN 76 0075
+    * COMP(CDS) bias [7:4] comp2, [3:0] comp1: by Ana 090126 */
+
+  {0x0F, 0x12, 0x00, 0x05}, /*  pix current bias */
+
+  {0x00, 0x2A, 0xF4, 0x26},
+  {0x0F, 0x12, 0x00, 0xD4}, /*  CLP level */
+  {0x00, 0x2A, 0xF4, 0x60},
+  {0x0F, 0x12, 0x00, 0x01}, /*  CLP on:  by Ana 090126 */
+
+  {0x00, 0x2A, 0xE3, 0x04},
+  {0x0F, 0x12, 0x00, 0x81}, /*  ADC OFFSET 128:  by Ana 090126 */
+  {0x00, 0x2A, 0xE3, 0x08},
+  {0x0F, 0x12, 0x00, 0x81}, /*  ADC DEFAULT 128:  by Ana 090209 */
+
+  /*  ADLC */
+  {0x00, 0x2A, 0xE5, 0x06},
+  {0x0F, 0x12, 0x00, 0x93}, /*  ADLC [7]FL,[6:5]FM,: by Ana 090126 */
+  /*  [4]F,[3:2]LM,[1]L,[0]CH */
+  {0x00, 0x2A, 0xE4, 0x02},
+  {0x0F, 0x12, 0x04, 0x0C}, /*  ADLC BPR EN[10], th 12: by Ana 090126 */
+  /* WRITE D000E510 3804  adlc_frame_filter_co_reg[B][A] */
+
+  {0x00, 0x2A, 0xF4, 0x2A},
+  {0x0F, 0x12, 0x00, 0x80}, /*  ALL TX mode enable(ref_option[7]):
+      *  by Ana 090130 */
+
+  {0x00, 0x2A, 0xF4, 0x08},
+  {0x0F, 0x12, 0x00, 0x0E}, /* aig_sig_mx:  by Ana 090209 */
+  {0x0F, 0x12, 0x00, 0x07}, /* aig_rst_mx:  by Ana 090209 */
+  {0x00, 0x2A, 0xF4, 0x00},
+  {0x0F, 0x12, 0x00, 0x07}, /* 0007 aig_off_rst1: for 92MHZ HS (full) */
+        /* 0006  aig_off_rst1:
+         * for 92MHz LS(full & avg)/ 46MHz LS(full) */
+        /*  0005 aig_off_rst1: for 46MHz LS(avg) */
+        /*  0004 aig_off_rst1: for 46MHz HS (full) */
+
+  /*  Doubler   */
+  {0x00, 0x2A, 0xF4, 0x3C},
+  {0x0F, 0x12, 0x00, 0x01}, /*  aig_pd_inrush_ctrl: by Ana 090126 */
+  {0x00, 0x2A, 0xF4, 0x40},
+  {0x0F, 0x12, 0x00, 0x44}, /* aig_rosc_tune_ncp[7:4],
+        * aig_rosc_tune_cp[3:0]: by Ana 090126 */
+  {0x00, 0x2A, 0xF4, 0x44},
+  {0x0F, 0x12, 0x00, 0x08}, /*  aig_reg_tune_pix */
+  {0x00, 0x2A, 0xF4, 0x48},
+  {0x0F, 0x12, 0x00, 0x08}, /*  aig_reg_tune_ntg */
+
+  {0x00, 0x2A, 0xF4, 0x5C},
+  {0x0F, 0x12, 0x00, 0x01}, /*  aig_dshut_en */
+
+  /* Multiple Sampling */
+  {0x00, 0x2A, 0xF4, 0x06},
+  {0x0F, 0x12, 0x00, 0x01}, /*  MS[2:0], No Multiple Sampling @92MHz,
+        * :  by Ana 090130 */
+  /*  1b' 2 times multiple sampling(0001h) for 46MHz or LS@92MHz */
+  {0x00, 0x2A, 0xF4, 0x10},
+  {0x0F, 0x12, 0x00, 0x00}, /*  MSOFF_EN=0 : no Multiple sampling
+        * if gain < 2 :  by Ana 090609 */
+  /* === APS Timing === */
+  {0x00, 0x28, 0xD0, 0x00},
+  {0x00, 0x2A, 0xF4, 0x72},
+  {0x0F, 0x12, 0x00, 0x5C}, /* For 92MHz LS & HS aig_dstx_width(1us@92MHz)
+        * :  by Ana 090216  */
+        /* 002E  aig_dstx_width(1us@46MHz)
+         * :  by Ana 090216 */
+
+  /* For 46MHz 7.5fps */
+  /* 002A  F476 */
+  /* 0F12  0045  aig_stx_width(1.5us@46MHz):  by Ana 090216 */
+
+  {0x00, 0x28, 0xD0, 0x00},
+  {0x00, 0x2A, 0xF4, 0x70},
+  {0x0F, 0x12, 0x00, 0x04},
+
+  /* == CDS Timing == */
+  /*  Rom retreive address was changed from 0x70003880 to 0x7000 3C00. */
+  /* 2009.03.16 */
+
+  {0x00, 0x28, 0x70, 0x00},
+  /* value       register    decription.   */
+  /* 700017CC    senHal_ContPtrs_senModesDataArr[0]
+    * nomal speed, normal */
+
+  /* 700017D0    senHal_ContPtrs_senModesDataArr[1]
+    * nomal speed, avg mode */
+  /* 700017D4    senHal_ContPtrs_senModesDataArr[2]
+    * nomal speed, weighted mode */
+  /* 700017D8    senHal_ContPtrs_senHighSpeedModesDataArr[0]
+    * high speed, normal        */
+  /* 700017DC    senHal_ContPtrs_senHighSpeedModesDataArr[1]
+     * high speed, avg mode    */
+  /* 700017E0    senHal_ContPtrs_senHighSpeedModesDataArr[2]
+    * high speed, weighted mode   */
+
+  /* HS_Normal         */
+  {0x00, 0x2A, 0x17, 0xD8}, /*  High speed Normal/Dig-subsampling */
+  {0x0F, 0x12, 0x3C, 0x00}, /*  senHal_ContPtrs_senModesDataArr */
+  {0x0F, 0x12, 0x70, 0x00}, /*  senHal_ContPtrs_senModesDataArr */
+
+  /* 1.15fps@92MHz,HS,Normal 2.15fps@92MHz,LS,Normal  */
+  /* 3.15fps@92MHz,HS,avg    4.15fps@92MHz,LS,avg    */
+
+  /* 1. */
+  {0x00, 0x2A, 0x3C, 0x00},  /* 1.    2.    3.    4.   */
+  {0x0F, 0x12, 0x00, 0x03},  /* 0003  0003  0003  0003 */
+  {0x0F, 0x12, 0x05, 0xBA},  /* 05BA  098A  081E  0B92 */
+  {0x0F, 0x12, 0x00, 0x01},  /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x05, 0xBC},  /* 05BC  098C  0414  05CE */
+  {0x0F, 0x12, 0x00, 0x01},  /* 0001  0001  040F  05C9 */
+  {0x0F, 0x12, 0x05, 0xBC},  /* 05BC  098C  0820  0B94 */
+  {0x0F, 0x12, 0x00, 0x14},  /* 0014  0014  0014  0014 */
+  {0x0F, 0x12, 0x05, 0xBC},  /* 05BC  098C  040F  05C9 */
+  {0x0F, 0x12, 0x00, 0x14},  /* 0014  0014  0422  05DC */
+  {0x0F, 0x12, 0x05, 0xBC},  /* 05BC  098C  0820  0B94 */
+  {0x0F, 0x12, 0x01, 0xAE},  /* 01AE  0286  0146  01B6 */
+  {0x0F, 0x12, 0x02, 0x38},  /* 0238  0310  01D0  0240 */
+  {0x0F, 0x12, 0x01, 0xAE},  /* 01AE  0286  0554  077E */
+  {0x0F, 0x12, 0x02, 0x38},  /* 0238  0310  05DE  0808 */
+  {0x0F, 0x12, 0x02, 0x38},    /* 0238  0310  01D0  0240 */
+  {0x0F, 0x12, 0x05, 0xBA},    /* 05BA  098A  0410  05CA */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  05DE  0808 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  081E  0B92 */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x01, 0xAC},    /* 01AC  0284  0144  01B4 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0414  05CE */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0552  077C */
+  {0x0F, 0x12, 0x01, 0xAC},    /* 01AC  0284  0144  01B4 */
+  {0x0F, 0x12, 0x02, 0x40},    /* 0240  0318  01D8  0248 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0552  077C */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  05E6  0810 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x00, 0x8C},    /* 008C  008C  008C  008C */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  040F  05C9 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  049A  0654 */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x00, 0x9E},    /* 009E  009E  009E  009E */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  040F  05C9 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  04AC  0666 */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x01, 0xAC},    /* 01AC  0284  0144  01B4 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  040F  05C9 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0552  077C */
+  {0x0F, 0x12, 0x00, 0xA6},    /* 00A6  00A6  00A6  00A6 */
+  {0x0F, 0x12, 0x05, 0xBA},    /* 05BA  098A  0410  05CA */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  04B4  066E */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  081E  0B92 */
+  {0x0F, 0x12, 0x02, 0x92},    /* 0292  036A  022A  029A */
+  {0x0F, 0x12, 0x05, 0xBA},    /* 05BA  098A  0410  05CA */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0638  0862 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  081E  0B92 */
+  {0x0F, 0x12, 0x00, 0xD8},    /* 00D8  00D8  00D8  00D8 */
+  {0x0F, 0x12, 0x01, 0xA8},    /* 01A8  0278  0140  01A8 */
+  {0x0F, 0x12, 0x02, 0xC4},    /* 02C4  039C  0292  02CC */
+  {0x0F, 0x12, 0x05, 0xB4},    /* 05B4  097C  040A  05BC */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  04E6  06A0 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  054E  0770 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  06A0  0894 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0818  0B84 */
+  {0x0F, 0x12, 0x01, 0xAA},    /* 01AA  0282  0142  01B2 */
+  {0x0F, 0x12, 0x01, 0xD6},    /* 01D6  02AE  016E  01DE */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  040C  05C6 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0438  05F2 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0550  077A */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  057C  07A6 */
+  {0x0F, 0x12, 0x01, 0xBB},    /* 01BB  0293  014D  01BD */
+  {0x0F, 0x12, 0x01, 0xEF},    /* 01EF  02C7  0182  01F2 */
+  {0x0F, 0x12, 0x01, 0xF9},    /* 01F9  02D1  018C  01FC */
+  {0x0F, 0x12, 0x02, 0x03},    /* 0203  02DB  0196  0206 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0417  05D1 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  044C  0606 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0456  0610 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0460  061A */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  055B  0785 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0590  07BA */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  059A  07C4 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  05A4  07CE */
+  {0x0F, 0x12, 0x01, 0xCC},    /* 01CC  02A4  0158  01C8 */
+  {0x0F, 0x12, 0x01, 0xEF},    /* 01EF  02C7  0182  01F2 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0422  05DC */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  044C  0606 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0566  0790 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0590  07BA */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x00, 0x0D},    /* 000D  000D  000D  000D */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x00, 0x0D},    /* 000D  000D  000D  000D */
+  {0x0F, 0x12, 0x01, 0xAE},    /* 01AE  0286  0146  01B6 */
+  {0x0F, 0x12, 0x01, 0xB6},    /* 01B6  028E  014E  01BE */
+  {0x0F, 0x12, 0x05, 0xBA},    /* 05BA  098A  0410  05CA */
+  {0x0F, 0x12, 0x05, 0xC6},    /* 05C6  0996  0418  05D2 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0554  077E */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  055C  0786 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  081E  0B92 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  082A  0B9E */
+  {0x0F, 0x12, 0x00, 0xD4},    /* 00D4  00D4  00D4  00D4 */
+  {0x0F, 0x12, 0x01, 0xAC},    /* 01AC  0284  0144  01B4 */
+  {0x0F, 0x12, 0x02, 0xC0},    /* 02C0  0398  028E  02C8 */
+  {0x0F, 0x12, 0x05, 0xB8},    /* 05B8  0988  040E  05C8 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  04E2  069C */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0552  077C */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  069C  0890 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  081C  0B90 */
+  {0x0F, 0x12, 0x01, 0xAE},    /* 01AE  0286  0146  01B6 */
+  {0x0F, 0x12, 0x05, 0xC9},    /* 05C9  0A7C  0410  05CA */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0554  077E */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0830  0BA4 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+
+  /* HS_avg */
+  {0x00, 0x2A, 0x17, 0xDC}, /*  High speed Normal/Dig-subsampling */
+  {0x0F, 0x12, 0x3C, 0xE0}, /*  senHal_ContPtrs_senModesDataArr */
+  {0x0F, 0x12, 0x70, 0x00}, /*  senHal_ContPtrs_senModesDataArr */
+
+  /* 1.15fps@92MHz,HS,Normal 2.15fps@92MHz,LS,Normal  */
+  /* 3.15fps@92MHz,HS,avg    4.15fps@92MHz,LS,avg    */
+
+  /* 1. */
+  {0x00, 0x2A, 0x3C, 0xE0}, /* 1.    2.    3.    4.   */
+  {0x0F, 0x12, 0x00, 0x03}, /* 0003  0003  0003  0003 */
+  {0x0F, 0x12, 0x08, 0x1E},    /* 05BA  098A  081E  0B92 */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x04, 0x14},    /* 05BC  098C  0414  05CE */
+  {0x0F, 0x12, 0x04, 0x0F},    /* 0001  0001  040F  05C9 */
+  {0x0F, 0x12, 0x08, 0x20},    /* 05BC  098C  0820  0B94 */
+  {0x0F, 0x12, 0x00, 0x14},    /* 0014  0014  0014  0014 */
+  {0x0F, 0x12, 0x04, 0x0F},    /* 05BC  098C  040F  05C9 */
+  {0x0F, 0x12, 0x04, 0x22},    /* 0014  0014  0422  05DC */
+  {0x0F, 0x12, 0x08, 0x20},    /* 05BC  098C  0820  0B94 */
+  {0x0F, 0x12, 0x01, 0x46},    /* 01AE  0286  0146  01B6 */
+  {0x0F, 0x12, 0x01, 0xD0},    /* 0238  0310  01D0  0240 */
+  {0x0F, 0x12, 0x05, 0x54},    /* 01AE  0286  0554  077E */
+  {0x0F, 0x12, 0x05, 0xDE},    /* 0238  0310  05DE  0808 */
+  {0x0F, 0x12, 0x01, 0xD0},    /* 0238  0310  01D0  0240 */
+  {0x0F, 0x12, 0x04, 0x10},    /* 05BA  098A  0410  05CA */
+  {0x0F, 0x12, 0x05, 0xDE},    /* 0000  0000  05DE  0808 */
+  {0x0F, 0x12, 0x08, 0x1E},    /* 0000  0000  081E  0B92 */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x01, 0x44},    /* 01AC  0284  0144  01B4 */
+  {0x0F, 0x12, 0x04, 0x14},    /* 0000  0000  0414  05CE */
+  {0x0F, 0x12, 0x05, 0x52},    /* 0000  0000  0552  077C */
+  {0x0F, 0x12, 0x01, 0x44},    /* 01AC  0284  0144  01B4 */
+  {0x0F, 0x12, 0x01, 0xD8},    /* 0240  0318  01D8  0248 */
+  {0x0F, 0x12, 0x05, 0x52},    /* 0000  0000  0552  077C */
+  {0x0F, 0x12, 0x05, 0xE6},    /* 0000  0000  05E6  0810 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x00, 0x8C},    /* 008C  008C  008C  008C */
+  {0x0F, 0x12, 0x04, 0x0F},    /* 0000  0000  040F  05C9 */
+  {0x0F, 0x12, 0x04, 0x9A},    /* 0000  0000  049A  0654 */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x00, 0x9E},    /* 009E  009E  009E  009E */
+  {0x0F, 0x12, 0x04, 0x0F},    /* 0000  0000  040F  05C9 */
+  {0x0F, 0x12, 0x04, 0xAC},    /* 0000  0000  04AC  0666 */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x01, 0x44},    /* 01AC  0284  0144  01B4 */
+  {0x0F, 0x12, 0x04, 0x0F},    /* 0000  0000  040F  05C9 */
+  {0x0F, 0x12, 0x05, 0x52},    /* 0000  0000  0552  077C */
+  {0x0F, 0x12, 0x00, 0xA6},    /* 00A6  00A6  00A6  00A6 */
+  {0x0F, 0x12, 0x04, 0x10},    /* 05BA  098A  0410  05CA */
+  {0x0F, 0x12, 0x04, 0xB4},    /* 0000  0000  04B4  066E */
+  {0x0F, 0x12, 0x08, 0x1E},    /* 0000  0000  081E  0B92 */
+  {0x0F, 0x12, 0x02, 0x2A},    /* 0292  036A  022A  029A */
+  {0x0F, 0x12, 0x04, 0x10},    /* 05BA  098A  0410  05CA */
+  {0x0F, 0x12, 0x06, 0x38},    /* 0000  0000  0638  0862 */
+  {0x0F, 0x12, 0x08, 0x1E},    /* 0000  0000  081E  0B92 */
+  {0x0F, 0x12, 0x00, 0xD8},    /* 00D8  00D8  00D8  00D8 */
+  {0x0F, 0x12, 0x01, 0x40},    /* 01A8  0278  0140  01A8 */
+  {0x0F, 0x12, 0x02, 0x92},    /* 02C4  039C  0292  02CC */
+  {0x0F, 0x12, 0x04, 0x0A},    /* 05B4  097C  040A  05BC */
+  {0x0F, 0x12, 0x04, 0xE6},    /* 0000  0000  04E6  06A0 */
+  {0x0F, 0x12, 0x05, 0x4E},    /* 0000  0000  054E  0770 */
+  {0x0F, 0x12, 0x06, 0xA0},    /* 0000  0000  06A0  0894 */
+  {0x0F, 0x12, 0x08, 0x18},    /* 0000  0000  0818  0B84 */
+  {0x0F, 0x12, 0x01, 0x42},    /* 01AA  0282  0142  01B2 */
+  {0x0F, 0x12, 0x01, 0x6E},    /* 01D6  02AE  016E  01DE */
+  {0x0F, 0x12, 0x04, 0x0C},    /* 0000  0000  040C  05C6 */
+  {0x0F, 0x12, 0x04, 0x38},    /* 0000  0000  0438  05F2 */
+  {0x0F, 0x12, 0x05, 0x50},    /* 0000  0000  0550  077A */
+  {0x0F, 0x12, 0x05, 0x7C},    /* 0000  0000  057C  07A6 */
+  {0x0F, 0x12, 0x01, 0x4D},    /* 01BB  0293  014D  01BD */
+  {0x0F, 0x12, 0x01, 0x82},    /* 01EF  02C7  0182  01F2 */
+  {0x0F, 0x12, 0x01, 0x8C},    /* 01F9  02D1  018C  01FC */
+  {0x0F, 0x12, 0x01, 0x96},    /* 0203  02DB  0196  0206 */
+  {0x0F, 0x12, 0x04, 0x17},    /* 0000  0000  0417  05D1 */
+  {0x0F, 0x12, 0x04, 0x4C},    /* 0000  0000  044C  0606 */
+  {0x0F, 0x12, 0x04, 0x56},    /* 0000  0000  0456  0610 */
+  {0x0F, 0x12, 0x04, 0x60},    /* 0000  0000  0460  061A */
+  {0x0F, 0x12, 0x05, 0x5B},    /* 0000  0000  055B  0785 */
+  {0x0F, 0x12, 0x05, 0x90},    /* 0000  0000  0590  07BA */
+  {0x0F, 0x12, 0x05, 0x9A},    /* 0000  0000  059A  07C4 */
+  {0x0F, 0x12, 0x05, 0xA4},    /* 0000  0000  05A4  07CE */
+  {0x0F, 0x12, 0x01, 0x58},    /* 01CC  02A4  0158  01C8 */
+  {0x0F, 0x12, 0x01, 0x82},    /* 01EF  02C7  0182  01F2 */
+  {0x0F, 0x12, 0x04, 0x22},    /* 0000  0000  0422  05DC */
+  {0x0F, 0x12, 0x04, 0x4C},    /* 0000  0000  044C  0606 */
+  {0x0F, 0x12, 0x05, 0x66},    /* 0000  0000  0566  0790 */
+  {0x0F, 0x12, 0x05, 0x90},    /* 0000  0000  0590  07BA */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x00, 0x0D},    /* 000D  000D  000D  000D */
+  {0x0F, 0x12, 0x00, 0x01},    /* 0001  0001  0001  0001 */
+  {0x0F, 0x12, 0x00, 0x0D},    /* 000D  000D  000D  000D */
+  {0x0F, 0x12, 0x01, 0x46},    /* 01AE  0286  0146  01B6 */
+  {0x0F, 0x12, 0x01, 0x4E},    /* 01B6  028E  014E  01BE */
+  {0x0F, 0x12, 0x04, 0x10},    /* 05BA  098A  0410  05CA */
+  {0x0F, 0x12, 0x04, 0x18},    /* 05C6  0996  0418  05D2 */
+  {0x0F, 0x12, 0x05, 0x54},    /* 0000  0000  0554  077E */
+  {0x0F, 0x12, 0x05, 0x5C},    /* 0000  0000  055C  0786 */
+  {0x0F, 0x12, 0x08, 0x1E},    /* 0000  0000  081E  0B92 */
+  {0x0F, 0x12, 0x08, 0x2A},    /* 0000  0000  082A  0B9E */
+  {0x0F, 0x12, 0x00, 0xD4},    /* 00D4  00D4  00D4  00D4 */
+  {0x0F, 0x12, 0x01, 0x44},    /* 01AC  0284  0144  01B4 */
+  {0x0F, 0x12, 0x02, 0x8E},    /* 02C0  0398  028E  02C8 */
+  {0x0F, 0x12, 0x04, 0x0E},    /* 05B8  0988  040E  05C8 */
+  {0x0F, 0x12, 0x04, 0xE2},    /* 0000  0000  04E2  069C */
+  {0x0F, 0x12, 0x05, 0x52},    /* 0000  0000  0552  077C */
+  {0x0F, 0x12, 0x06, 0x9C},    /* 0000  0000  069C  0890 */
+  {0x0F, 0x12, 0x08, 0x1C},    /* 0000  0000  081C  0B90 */
+  {0x0F, 0x12, 0x01, 0x46},    /* 01AE  0286  0146  01B6 */
+  {0x0F, 0x12, 0x04, 0x10},    /* 05C9  0A7C  0410  05CA */
+  {0x0F, 0x12, 0x05, 0x54},    /* 0000  0000  0554  077E */
+  {0x0F, 0x12, 0x08, 0x30},    /* 0000  0000  0830  0BA4 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+  {0x0F, 0x12, 0x00, 0x00},    /* 0000  0000  0000  0000 */
+
+  {REG_DELAY & 0xff, 100, 0, 0}, /*  p100 */
+
+  /* Current(00:2mA,01:4mA,10:6mA,11:8mA) */
+  {0x00, 0x28, 0xD0, 0x00},
+  {0x00, 0x2A, 0x10, 0x82},
+  {0x0F, 0x12, 0x01, 0x55}, /* FFFF  D0_D4_cs12 [11:0] */
+  {0x0F, 0x12, 0x01, 0x55}, /* FFFF  D0_D4_cs12 [11:0] */
+  {0x00, 0x2A, 0x10, 0x88},
+  {0x0F, 0x12, 0x05, 0x55}, /* 05CF  0555 Sda_cd10  Scl_cd10
+    PCLK_cd10  Reserved  Vsync_cd10  Hsync_cd10 */
+
+  {REG_DELAY & 0xff , 100, 0, 0}, /*  p100 */
+
+  /*  End Analog script */
+
+  /*  */
+  /*  Start Tuning param for EVT1 */
+  /*  */
+
+  /* / AF Setting Start */
+  /*  AF Interface Settings */
+  {0x00, 0x28, 0x70, 0x00},
+  {0x00, 0x2A, 0x02, 0x3E},
+  {0x0F, 0x12, 0x00, 0x03}, /*  AFModeType - 0:NONE, 2:VCM_PWM,
+        * 3:VCM_I2C */
+  {0x00, 0x2A, 0x02, 0x3C},
+  {0x0F, 0x12, 0x00, 0x00}, /*  No Led Gpio */
+  {0x00, 0x2A, 0x02, 0x40},
+  {0x0F, 0x12, 0x00, 0x00}, /*  No PWM */
+  {0x00, 0x2A, 0x02, 0x42},
+  {0x0F, 0x12, 0x00, 0x00},
+  {0x00, 0x2A, 0x02, 0x44},
+  {0x0F, 0x12, 0x00, 0x31}, /*  No GPIO Port,
+        31   Use GPIO3 for Enable Port */
+  {0x00, 0x2A, 0x02, 0x46},
+  {0x0F, 0x12, 0x00, 0x00},
+  {0x00, 0x2A, 0x02, 0x4C},
+  {0x0F, 0x12, 0x20, 0x0C}, /*  Use GPIO1 for SCL, GPIO2 for SDA */
+  {0x00, 0x2A, 0x02, 0x4E},
+  {0x0F, 0x12, 0x03, 0x20}, /* 0C0 0190  0320   MI2C Speed : 400KHz */
+
+  /*  AF Window Settings */
+  {0x00, 0x2A, 0x02, 0xC6},
+  {0x0F, 0x12, 0x01, 0x00},
+  {0x00, 0x2A, 0x02, 0xC8},
+  {0x0F, 0x12, 0x00, 0xE3},
+  {0x00, 0x2A, 0x02, 0xCA},
+  {0x0F, 0x12, 0x02, 0x00},
+  {0x00, 0x2A, 0x02, 0xCC},
+  {0x0F, 0x12, 0x02, 0x38},
+  {0x00, 0x2A, 0x02, 0xCE},
+  {0x0F, 0x12, 0x01, 0x8C},
+  {0x00, 0x2A, 0x02, 0xD0},
+  {0x0F, 0x12, 0x01, 0x66},
+  {0x00, 0x2A, 0x02, 0xD2},
+  {0x0F, 0x12, 0x00, 0xE6},
+  {0x00, 0x2A, 0x02, 0xD4},
+  {0x0F, 0x12, 0x01, 0x32},
+  {0x00, 0x2A, 0x02, 0xD6},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  /*  AF Setot Settings */
+  {0x00, 0x2A, 0x06, 0xBE},
+  {0x0F, 0x12, 0x00, 0xFF},
+
+  /*  AF Scene Settings */
+  {0x00, 0x2A, 0x15, 0xDA},
+  {0x0F, 0x12, 0x00, 0x03},
+
+  /*  AF Fine Search Settings */
+  {0x00, 0x2A, 0x15, 0x50},
+  {0x0F, 0x12, 0x10, 0x02},
+  {0x00, 0x2A, 0x15, 0x5A},
+  {0x0F, 0x12, 0x00, 0x04},
+  {0x00, 0x2A, 0x14, 0xE8},
+  {0x0F, 0x12, 0x03, 0x02},
+
+
+  /*  AF Lens Position Table Settings */
+  {0x00, 0x2A, 0x14, 0xF0},
+  {0x0F, 0x12, 0x00, 0x11}, /*  18 Steps   */
+  {0x0f, 0x12, 0x00, 0x36}, /*  af_pos_usTable */
+  {0x0F, 0x12, 0x00, 0x3D},
+  {0x0F, 0x12, 0x00, 0x44},
+  {0x0F, 0x12, 0x00, 0x4B},
+  {0x0F, 0x12, 0x00, 0x52},
+  {0x0F, 0x12, 0x00, 0x59},
+  {0x0F, 0x12, 0x00, 0x60},
+  {0x0F, 0x12, 0x00, 0x67},
+  {0x0F, 0x12, 0x00, 0x6E},
+  {0x0F, 0x12, 0x00, 0x75},
+  {0x0F, 0x12, 0x00, 0x7C},
+  {0x0F, 0x12, 0x00, 0x83},
+  {0x0F, 0x12, 0x00, 0x8A},
+  {0x0F, 0x12, 0x00, 0x91},
+  {0x0F, 0x12, 0x00, 0x98},
+  {0x0F, 0x12, 0x00, 0x9F},
+  {0x0F, 0x12, 0x00, 0xA6},
+  {0x0F, 0x12, 0x00, 0xAD},
+
+  /*  AF Macro Position Setting */
+  {0x00, 0x2A, 0x14, 0xE2},
+  {0x0F, 0x12, 0x11, 0x04},
+
+  /* / AF Setting End */
+
+  /* /Jpeg/ */
+  {0x00, 0x2A, 0x16, 0x90},
+  {0x0F, 0x12, 0x01, 0x8E}, /* jpeg_BrcMaxQuality */
+  {0x00, 0x2A, 0x16, 0xD6},
+  {0x0F, 0x12, 0x00, 0x01}, /* jpeg_MinQtblValue */
+  {0x00, 0x2A, 0x04, 0xC0},
+  {0x0F, 0x12, 0x00, 0x5D}, /* 005F 005D
+        * 4EA_REG_TC_BRC_usCaptureQuality(4~99_dec) */
+
+};
+
+unsigned short dohofpga_init_reg2[][2] = {
+  /* clk Settings */
+  {0x002A, DOHOFPGA_REG_TC_IPRM_InClockLSBs}, /* input=24MHz */
+  {0x0F12, 0xBB80}, /*  input=48MHz : source clk is mpll */
+  {0x002A, DOHOFPGA_REG_TC_IPRM_InClockMSBs},
+  {0x0F12, 0x0000},
+  {0x002A, DOHOFPGA_REG_TC_IPRM_UseNPviClocks}, /* 0 PVI configurations */
+  {0x0F12, 0x0000},
+  {0x002A, DOHOFPGA_REG_TC_IPRM_UseNMipiClocks}, /* 1 MIPI configurations */
+  {0x0F12, 0x0001},
+  {0x002A, DOHOFPGA_REG_TC_IPRM_NumberOfMipiLanes}, /*  Num of lane MIPI  */
+  {0x0F12, 2},
+  {0x002A, DOHOFPGA_REG_TC_IPRM_OpClk4KHz_0}, /*  1st system CLK 92MHz
+            * for parallel */
+  {0x0F12, DOHOFPGA4Khz_92Mhz}, /*  2CEC */
+  {0x002A, DOHOFPGA_REG_TC_IPRM_MinOutRate4KHz_0},  /* Pclk : 92Mhz */
+  {0x0F12, DOHOFPGA_PCLK_MIN},
+  {0x002A, DOHOFPGA_REG_TC_IPRM_MaxOutRate4KHz_0},
+  {0x0F12, DOHOFPGA_PCLK_MAX},
+  {0x002A, DOHOFPGA_REG_TC_IPRM_InitParamsUpdated},
+  {0x0F12, 0x0001},
+  {REG_DELAY, 100}, /*  p100 */
+};
+
+unsigned char dohofpga_init_reg3[][4] = {
+  /* AE Setting */
+  {0x00, 0x2A, 0x13, 0xC8},
+  {0x0F, 0x12, 0x00, 0x30}, /* 3C  002D 003C 003A 0030 003A 0038 003C 0035
+        TVAR_ae_BrAve    AE target   */
+  {0x00, 0x2A, 0x13, 0xCE},
+  {0x0F, 0x12, 0x00, 0x0F}, /* 0011  ae_StatMode */
+  {0x00, 0x2A, 0x05, 0x90},
+  {0x0F, 0x12, 0x35, 0x20}, /* lt_uMaxExp1 (x4 8000/ 80ms) */
+  {0x0F, 0x12, 0x00, 0x00},
+  {0x00, 0x2A, 0x05, 0x94},
+  {0x0F, 0x12, 0xC3, 0x50},
+  {0x0F, 0x12, 0x00, 0x00}, /* lt_uMaxExp2 (x4 25000/ 250ms) */
+  {0x00, 0x2A, 0x05, 0x98},
+  {0x0F, 0x12, 0x35, 0x20},
+  {0x0F, 0x12, 0x00, 0x00}, /* lt_uCapMaxExp1 (x4 8000/ 80ms) */
+  {0x00, 0x2A, 0x05, 0x9C},
+  {0x0F, 0x12, 0xC3, 0x50}, /* C350  86A0   */
+  {0x0F, 0x12, 0x00, 0x00}, /* lt_uCapMaxExp2 (x4 25000/ 250ms) */
+  {0x00, 0x2A, 0x05, 0xA0},
+  {0x0F, 0x12, 0x04, 0x70}, /* (1/12) 0350 (1/8) 0200 lt_uMaxAnGain1 */
+  {0x00, 0x2A, 0x05, 0xA2},
+  {0x0F, 0x12, 0x10, 0x00}, /* lt_uMaxAnGain2 */
+  {0x00, 0x2A, 0x05, 0xA4},
+  {0x0F, 0x12, 0x01, 0x00},
+  {0x00, 0x2A, 0x05, 0xA6},
+  {0x0F, 0x12, 0x10, 0x00}, /* lt_uMaxTotGain (Limit Gain) */
+
+  {0x00, 0x2A, 0x05, 0x74},
+  {0x0F, 0x12, 0x01, 0x11}, /* lt_uLimitHigh */
+  {0x00, 0x2A, 0x05, 0x76},
+  {0x0F, 0x12, 0x00, 0xEF}, /* lt_uLimitLow */
+};
+
+unsigned short dohofpga_init_reg4[][2] = {
+  /* / */
+  /* PREVIEW CONFIGURATION 0 (FullHD, YUV, 20fps) */
+  {0x002A, DOHOFPGA_REG_0TC_PCFG_usWidth},
+  {0x0F12, 1920},  /* 1920 */
+  {0x0F12, 1080}, /* 1080 */
+  {0x002A, 0x02E6},
+};
+
+unsigned char dohofpga_init_reg5[][4] = {
+  {0x0F, 0x12, 0x00, 0x05}, /* YUV */
+  {0x00, 0x2A, 0x02, 0xF8}, /* PLL config */
+  {0x0F, 0x12, 0x00, 0x00},
+  {0x00, 0x2A, 0x02, 0xE8}, /* PCLK max */
+};
+
+unsigned char dohofpga_init_jpeg[][4] = {
+  {0x0F, 0x12, 0x00, 0x09},  /* YUV */
+  {0x00, 0x2A, 0x02, 0xF8},  /* PLL config */
+  {0x0F, 0x12, 0x00, 0x00},
+  {0x00, 0x2A, 0x02, 0xE8},  /* PCLK max */
+};
+
+unsigned short dohofpga_init_reg6[][2] = {
+  {0x0F12, DOHOFPGA_PCLK_MAX},
+};
+
+unsigned char dohofpga_init_reg7[][4] = {
+  {0x00, 0x2A, 0x02, 0xEA}, /* PCLK min */
+};
+
+unsigned short dohofpga_init_reg8[][2] = {
+  {0x0F12, DOHOFPGA_PCLK_MIN},
+};
+
+unsigned char dohofpga_init_reg9[][4] = {
+  {0x00, 0x2A, 0x02, 0xF0}, /*  KJ_090802 : Non-continuous clock */
+  {0x0F, 0x12, 0x00, 0x12}, /*  [4]UY0VY1  0002 */
+  {0x00, 0x2A, 0x02, 0xFC}, /*  1b: FR (bin) 2b: Quality (no-bin) */
+  {0x0F, 0x12, 0x00, 0x00},
+  {0x00, 0x2A, 0x02, 0xFA},
+  {0x0F, 0x12, 0x00, 0x02},
+  {0x00, 0x2A, 0x02, 0xFE}, /* max frame time  */
+  {0x0F, 0x12, 0x05, 0x35},/*  7.5fps */
+  {0x00, 0x2A, 0x03, 0x00},
+  {0x0F, 0x12, 0x00, 0x00},
+
+  {REG_DELAY & 0xff, 100, 0, 0}, /*  p100 */
+
+  /* 002A  17A0 */
+  /* 0F12  0000 [0]:dig [1]:avg */
+  /* 002A  17A2 1/2 sub-sampling */
+  /* 0F12  0002 */
+  {0x00, 0x2A, 0x05, 0x40}, /*  use high speed analog */
+  {0x0F, 0x12, 0x00, 0x01},
+  {0x00, 0x2A, 0x05, 0x3A},
+  {0x0F, 0x12, 0x00, 0x01},
+  /* 002A  17B2 17B2 */
+  /* 0F12  0549 */
+  /* 002A  17B6 17B6 */
+  /* 0F12  0549 */
+  /* 002A  17BA 17BA */
+  /* 0F12  005B */
+
+  /* For C100 -  jpeg output data  type control
+   * 0028   D000 002A  B032  0F12   002A */
+  /*  JPEG data type (RAW8 type) */
+
+  {0x00, 0x28, 0x70, 0x00},
+
+  /* Capture Configuratio 0 (2592x1944,  MJPEG, 15fps) */
+  {0x00, 0x2A, 0x03, 0xD6},
+  {0x0F, 0x12, 0x0A, 0x20}, /* 2592 */
+  {0x00, 0x2A, 0x03, 0xD8},
+  {0x0F, 0x12, 0x07, 0x98}, /* 1944 */
+  {0x00, 0x2A, 0x03, 0xDA},
+  {0x0F, 0x12, 0x00, 0x09}, /* YUV */
+  {0x00, 0x2A, 0x03, 0xEC}, /* PLL config */
+  {0x0F, 0x12, 0x00, 0x00},
+  {0x00, 0x2A, 0x03, 0xDC}, /* PCLK max */
+  {0x0F, 0x12, 0x5A, 0xD2},
+  {0x00, 0x2A, 0x03, 0xDE}, /* PCLK min */
+  {0x0F, 0x12, 0x58, 0xDE},
+  {0x00, 0x2A, 0x03, 0xE4},
+  {0x0F, 0x12, 0x00, 0x42},
+  {0x00, 0x2A, 0x03, 0xF0}, /*  1b: FR (bin) 2b: Quality (no-bin) */
+  {0x0F, 0x12, 0x00, 0x02},
+  {0x00, 0x2A, 0x03, 0xEE},
+  {0x0F, 0x12, 0x00, 0x02},
+  {0x00, 0x2A, 0x03, 0xF2}, /* max frame time : 15fps 029a */
+  {0x0F, 0x12, 0x05, 0x35}, /*  7.5 fps */
+  {0x00, 0x2A, 0x03, 0xF4},
+  {0x0F, 0x12, 0x00, 0x00},
+
+  /*  */
+  /* PREVIEW */
+  {0x00, 0x2A, 0x02, 0xA4},
+  {0x0F, 0x12, 0x00, 0x00},
+
+  {0x00, 0x2A, 0x02, 0xA8},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  {0x00, 0x2A, 0x02, 0x90},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  {0x00, 0x2A, 0x02, 0xA6},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  {0x00, 0x2A, 0x02, 0x80},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  {0x00, 0x2A, 0x02, 0x82},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  /*  */
+
+  {0x00, 0x2A, 0x02, 0x92},
+  {0x0F, 0x12, 0x07, 0x80}, /* input width  */
+  {0x0F, 0x12, 0x04, 0x38}, /* input height */
+  {0x0F, 0x12, 0x01, 0x50}, /* input w-offset */
+  {0x0F, 0x12, 0x01, 0xB0}, /* input h-offset */
+
+  {0x00, 0x2A, 0x04, 0xDA},
+  {0x0F, 0x12, 0x07, 0x80}, /* crop width  */
+  {0x0F, 0x12, 0x04, 0x38}, /* crop height */
+  /* 0F12  0150  w-offset */
+  /* 0F12  01B0  h-offset */
+
+  {0x00, 0x2A, 0x02, 0xA2}, /* 4EA_REG_TC_GP_InputsChangeRequest */
+  {0x0F, 0x12, 0x00, 0x01},
+  {0x00, 0x2A, 0x02, 0x90}, /* 4EA_REG_TC_GP_NewConfigSync */
+  {0x0F, 0x12, 0x00, 0x01},
+
+  {REG_DELAY & 0xff , 200, 0, 0}, /*  p200 */
+};
+
+unsigned short dohofpga_init_reg10[][2] = {
+  {0x002A, DOHOFPGA_REG_0TC_PCFG_usMaxFrTimeMsecMult10},/* max frame time */
+  {0x0F12, DOHOFPGA_FrTime_MAX}, /* 30fps */
+};
+
+unsigned char dohofpga_init_reg11[][4] = {
+  /*  */
+  /* PREVIEW */
+  {0x00, 0x2A, 0x02, 0xA4},
+  {0x0F, 0x12, 0x00, 0x00},
+
+  {0x00, 0x2A, 0x02, 0xA8},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  {0x00, 0x2A, 0x02, 0x90},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  {0x00, 0x2A, 0x02, 0xA6},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  {0x00, 0x2A, 0x02, 0x80},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  {0x00, 0x2A, 0x02, 0x82},
+  {0x0F, 0x12, 0x00, 0x01},
+
+  /*  */
+
+  /*  AF CMD */
+  {0x00, 0x2A, 0x02, 0xBE}, /* #4EA_REG_TC_AF   */
+  {0x0F, 0x12, 0x00, 0x03}, /* 4EA_REG_TC_AF_AfCmd */
+
+  {REG_DELAY & 0xff , 200, 0, 0}, /*  p300 */
+
+  {0x00, 0x2A, 0x02, 0xBE}, /* #4EA_REG_TC_AF   */
+  {0x0F, 0x12, 0x00, 0x05}, /* 5:single AF, 6:continus AF */
+};
+
+#define DOHOFPGA_INIT_REGS1  \
+  (sizeof(dohofpga_init_reg1) / sizeof(dohofpga_init_reg1[0]))
+#define DOHOFPGA_INIT_REGS2  \
+  (sizeof(dohofpga_init_reg2) / sizeof(dohofpga_init_reg2[0]))
+#define DOHOFPGA_INIT_REGS3  \
+  (sizeof(dohofpga_init_reg3) / sizeof(dohofpga_init_reg3[0]))
+#define DOHOFPGA_INIT_REGS4  \
+  (sizeof(dohofpga_init_reg4) / sizeof(dohofpga_init_reg4[0]))
+#define DOHOFPGA_INIT_JPEG  \
+  (sizeof(dohofpga_init_jpeg) / sizeof(dohofpga_init_jpeg[0]))
+#define DOHOFPGA_INIT_REGS5\
+  (sizeof(dohofpga_init_reg5) / sizeof(dohofpga_init_reg5[0]))
+#define DOHOFPGA_INIT_REGS6  \
+  (sizeof(dohofpga_init_reg6) / sizeof(dohofpga_init_reg6[0]))
+#define DOHOFPGA_INIT_REGS7  \
+  (sizeof(dohofpga_init_reg7) / sizeof(dohofpga_init_reg7[0]))
+#define DOHOFPGA_INIT_REGS8  \
+  (sizeof(dohofpga_init_reg8) / sizeof(dohofpga_init_reg8[0]))
+#define DOHOFPGA_INIT_REGS9  \
+  (sizeof(dohofpga_init_reg9) / sizeof(dohofpga_init_reg9[0]))
+#define DOHOFPGA_INIT_REGS10  \
+  (sizeof(dohofpga_init_reg10) / sizeof(dohofpga_init_reg10[0]))
+#define DOHOFPGA_INIT_REGS11  \
+  (sizeof(dohofpga_init_reg11) / sizeof(dohofpga_init_reg11[0]))
+
+unsigned short dohofpga_sleep_reg[][2] = {
+  {0x002A, DOHOFPGA_REG_TC_GP_EnablePreview},
+  {0x0F12, 0x0000},
+  {0x002A, DOHOFPGA_REG_TC_GP_EnablePreviewChanged},
+  {0x0F12, 0x0001},
+  {REG_DELAY, 100},
+};
+
+#define DOHOFPGA_SLEEP_REGS  \
+  (sizeof(dohofpga_sleep_reg) / sizeof(dohofpga_sleep_reg[0]))
+
+unsigned short dohofpga_wakeup_reg[][2] = {
+  {0x002A, 0x02F0},
+  {0x0F12, 0x0052},
+  {0x002A, DOHOFPGA_REG_TC_GP_PrevConfigChanged},
+  {0x0F12, 0x0001},
+};
+
+#define DOHOFPGA_WAKEUP_REGS  \
+  (sizeof(dohofpga_wakeup_reg) / sizeof(dohofpga_wakeup_reg[0]))
+
+/* Preview configuration preset #1 */
+/* Preview configuration preset #2 */
+/* Preview configuration preset #3 */
+/* Preview configuration preset #4 */
+
+/* Capture configuration preset #0 */
+/* Capture configuration preset #1 */
+/* Capture configuration preset #2 */
+/* Capture configuration preset #3 */
+/* Capture configuration preset #4 */
+
+/*
+ * EV bias
+ */
+
+static const struct dohofpga_reg dohofpga_ev_m6[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_m5[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_m4[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_m3[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_m2[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_m1[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_default[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_p1[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_p2[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_p3[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_p4[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_p5[] = {
+};
+
+static const struct dohofpga_reg dohofpga_ev_p6[] = {
+};
+
+#ifdef DOHOFPGA_COMPLETE
+/* Order of this array should be following the querymenu data */
+static const unsigned char *dohofpga_regs_ev_bias[] = {
+  (unsigned char *)dohofpga_ev_m6, (unsigned char *)dohofpga_ev_m5,
+  (unsigned char *)dohofpga_ev_m4, (unsigned char *)dohofpga_ev_m3,
+  (unsigned char *)dohofpga_ev_m2, (unsigned char *)dohofpga_ev_m1,
+  (unsigned char *)dohofpga_ev_default, (unsigned char *)dohofpga_ev_p1,
+  (unsigned char *)dohofpga_ev_p2, (unsigned char *)dohofpga_ev_p3,
+  (unsigned char *)dohofpga_ev_p4, (unsigned char *)dohofpga_ev_p5,
+  (unsigned char *)dohofpga_ev_p6,
+};
+
+/*
+ * Auto White Balance configure
+ */
+static const struct dohofpga_reg dohofpga_awb_off[] = {
+};
+
+static const struct dohofpga_reg dohofpga_awb_on[] = {
+};
+
+static const unsigned char *dohofpga_regs_awb_enable[] = {
+  (unsigned char *)dohofpga_awb_off,
+  (unsigned char *)dohofpga_awb_on,
+};
+
+/*
+ * Manual White Balance (presets)
+ */
+static const struct dohofpga_reg dohofpga_wb_tungsten[] = {
+
+};
+
+static const struct dohofpga_reg dohofpga_wb_fluorescent[] = {
+
+};
+
+static const struct dohofpga_reg dohofpga_wb_sunny[] = {
+
+};
+
+static const struct dohofpga_reg dohofpga_wb_cloudy[] = {
+
+};
+
+/* Order of this array should be following the querymenu data */
+static const unsigned char *dohofpga_regs_wb_preset[] = {
+  (unsigned char *)dohofpga_wb_tungsten,
+  (unsigned char *)dohofpga_wb_fluorescent,
+  (unsigned char *)dohofpga_wb_sunny,
+  (unsigned char *)dohofpga_wb_cloudy,
+};
+
+/*
+ * Color Effect (COLORFX)
+ */
+static const struct dohofpga_reg dohofpga_color_sepia[] = {
+};
+
+static const struct dohofpga_reg dohofpga_color_aqua[] = {
+};
+
+static const struct dohofpga_reg dohofpga_color_monochrome[] = {
+};
+
+static const struct dohofpga_reg dohofpga_color_negative[] = {
+};
+
+static const struct dohofpga_reg dohofpga_color_sketch[] = {
+};
+
+/* Order of this array should be following the querymenu data */
+static const unsigned char *dohofpga_regs_color_effect[] = {
+  (unsigned char *)dohofpga_color_sepia,
+  (unsigned char *)dohofpga_color_aqua,
+  (unsigned char *)dohofpga_color_monochrome,
+  (unsigned char *)dohofpga_color_negative,
+  (unsigned char *)dohofpga_color_sketch,
+};
+
+/*
+ * Contrast bias
+ */
+static const struct dohofpga_reg dohofpga_contrast_m2[] = {
+};
+
+static const struct dohofpga_reg dohofpga_contrast_m1[] = {
+};
+
+static const struct dohofpga_reg dohofpga_contrast_default[] = {
+};
+
+static const struct dohofpga_reg dohofpga_contrast_p1[] = {
+};
+
+static const struct dohofpga_reg dohofpga_contrast_p2[] = {
+};
+
+static const unsigned char *dohofpga_regs_contrast_bias[] = {
+  (unsigned char *)dohofpga_contrast_m2,
+  (unsigned char *)dohofpga_contrast_m1,
+  (unsigned char *)dohofpga_contrast_default,
+  (unsigned char *)dohofpga_contrast_p1,
+  (unsigned char *)dohofpga_contrast_p2,
+};
+
+/*
+ * Saturation bias
+ */
+static const struct dohofpga_reg dohofpga_saturation_m2[] = {
+};
+
+static const struct dohofpga_reg dohofpga_saturation_m1[] = {
+};
+
+static const struct dohofpga_reg dohofpga_saturation_default[] = {
+};
+
+static const struct dohofpga_reg dohofpga_saturation_p1[] = {
+};
+
+static const struct dohofpga_reg dohofpga_saturation_p2[] = {
+};
+
+static const unsigned char *dohofpga_regs_saturation_bias[] = {
+  (unsigned char *)dohofpga_saturation_m2,
+  (unsigned char *)dohofpga_saturation_m1,
+  (unsigned char *)dohofpga_saturation_default,
+  (unsigned char *)dohofpga_saturation_p1,
+  (unsigned char *)dohofpga_saturation_p2,
+};
+
+/*
+ * Sharpness bias
+ */
+static const struct dohofpga_reg dohofpga_sharpness_m2[] = {
+};
+
+static const struct dohofpga_reg dohofpga_sharpness_m1[] = {
+};
+
+static const struct dohofpga_reg dohofpga_sharpness_default[] = {
+};
+
+static const struct dohofpga_reg dohofpga_sharpness_p1[] = {
+};
+
+static const struct dohofpga_reg dohofpga_sharpness_p2[] = {
+};
+
+static const unsigned char *dohofpga_regs_sharpness_bias[] = {
+  (unsigned char *)dohofpga_sharpness_m2,
+  (unsigned char *)dohofpga_sharpness_m1,
+  (unsigned char *)dohofpga_sharpness_default,
+  (unsigned char *)dohofpga_sharpness_p1,
+  (unsigned char *)dohofpga_sharpness_p2,
+};
+#endif /* DOHOFPGA _COMPLETE */
+
+#ifdef __DOHOFPGA_C__
+
+static inline struct dohofpga_state *to_state(struct v4l2_subdev *) ;
+static inline int dohofpga_write(struct v4l2_subdev *, u16 , u16 ) ;
+static int dohofpga_i2c_write(struct v4l2_subdev *, unsigned char[], unsigned char);
+const  char * const *dohofpga_ctrl_get_menu( u32 ) ;
+static inline struct v4l2_queryctrl const *dohofpga_find_qctrl(int ) ;
+static int dohofpga_queryctrl(struct v4l2_subdev *, struct v4l2_queryctrl *) ;
+static int dohofpga_querymenu(struct v4l2_subdev *, struct v4l2_querymenu *) ;
+static int dohofpga_s_crystal_freq(struct v4l2_subdev *, u32  , u32 ) ;
+static int dohofpga_g_fmt(struct v4l2_subdev *, struct v4l2_mbus_framefmt *) ;
+static int dohofpga_s_fmt(struct v4l2_subdev *, struct v4l2_mbus_framefmt *) ;
+static int dohofpga_enum_framesizes(struct v4l2_subdev *,struct v4l2_frmsizeenum *) ;
+static int dohofpga_enum_frameintervals(struct v4l2_subdev *,struct v4l2_frmivalenum *);
+static int dohofpga_g_parm(struct v4l2_subdev *, struct v4l2_streamparm *);
+static int dohofpga_s_parm(struct v4l2_subdev *, struct v4l2_streamparm *);
+static int dohofpga_g_ctrl(struct v4l2_subdev *, struct v4l2_control *);
+static int dohofpga_s_ctrl(struct v4l2_subdev *, struct v4l2_control *);
+static int __dohofpga_init_2byte(struct v4l2_subdev *, unsigned short[], int );
+static int dohofpga_init(struct v4l2_subdev *, u32);
+static int dohofpga_s_power(struct v4l2_subdev *, int );
+static int dohofpga_sleep(struct v4l2_subdev *);
+static int dohofpga_wakeup(struct v4l2_subdev *);
+static int dohofpga_s_stream(struct v4l2_subdev *, int);
+static int dohofpga_probe(struct i2c_client *, const struct i2c_device_id *);
+static int dohofpga_remove(struct i2c_client *);
+
+/*
+ * Specification
+ * Parallel : ITU-R. 656/601 YUV422, RGB565, RGB888 (Up to VGA), RAW10
+ * Serial : MIPI CSI2 (single lane) YUV422, RGB565, RGB888 (Up to VGA), RAW10
+ * Resolution : 1280 (H) x 1024 (V)
+ * Image control : Brightness, Contrast, Saturation, Sharpness, Glamour
+ * Effect : Mono, Negative, Sepia, Aqua, Sketch
+ * FPS : 15fps @full resolution, 30fps @VGA, 24fps @720p
+ * Max. pixel clock frequency : 48MHz(upto)
+ * Internal PLL (6MHz to 27MHz input frequency)
+ */
+
+/* Camera functional setting values configured by user concept */
+struct dohofpga_userset 
+{
+  signed int exposure_bias;  /* V4L2_CID_EXPOSURE */
+  unsigned int ae_lock;
+  unsigned int awb_lock;
+  unsigned int auto_wb;  /* V4L2_CID_AUTO_WHITE_BALANCE */
+  unsigned int manual_wb;  /* V4L2_CID_WHITE_BALANCE_PRESET */
+  unsigned int wb_temp;  /* V4L2_CID_WHITE_BALANCE_TEMPERATURE */
+  unsigned int effect;  /* Color FX (AKA Color tone) */
+  unsigned int contrast;  /* V4L2_CID_CONTRAST */
+  unsigned int saturation;  /* V4L2_CID_SATURATION */
+  unsigned int sharpness;    /* V4L2_CID_SHARPNESS */
+  unsigned int glamour;
+};
+
+struct dohofpga_state 
+{
+  struct dohofpga_mbus_platform_data *pdata;
+  struct v4l2_subdev sd;
+  struct v4l2_mbus_framefmt   fmt;
+  struct v4l2_fract     timeperframe;
+  struct dohofpga_userset     userset;
+  int         freq;  /* MCLK in KHz */
+  int         is_mipi;
+  int         isize;
+  int         ver;
+  int         fps;
+  int         fmt_index;
+  unsigned short       devid_mask;
+};
+
+static const char *dohofpga_querymenu_wb_preset[] = 
+{
+  "WB Tungsten", "WB Fluorescent", "WB sunny", "WB cloudy", NULL
+};
+
+static const char *dohofpga_querymenu_effect_mode[] = 
+{
+  "Effect Sepia", "Effect Aqua", "Effect Monochrome",
+  "Effect Negative", "Effect Sketch", NULL
+};
+
+static const char *dohofpga_querymenu_ev_bias_mode[] = 
+{
+  "-3EV",  "-2,1/2EV", "-2EV", "-1,1/2EV",
+  "-1EV", "-1/2EV", "0", "1/2EV",
+  "1EV", "1,1/2EV", "2EV", "2,1/2EV",
+  "3EV", NULL
+};
+
+static struct v4l2_queryctrl dohofpga_controls[] = 
+{
+  {
+    /*
+     * For now, we just support in preset type
+     * to be close to generic WB system,
+     * we define color temp range for each preset
+     */
+    .id = V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .name = "White balance in kelvin",
+    .minimum = 0,
+    .maximum = 10000,
+    .step = 1,
+    .default_value = 0,  /* FIXME */
+  },
+  {
+    .id = V4L2_CID_WHITE_BALANCE_PRESET,
+    .type = V4L2_CTRL_TYPE_MENU,
+    .name = "White balance preset",
+    .minimum = 0,
+    .maximum = ARRAY_SIZE(dohofpga_querymenu_wb_preset) - 2,
+    .step = 1,
+    .default_value = 0,
+  },
+  {
+    .id = V4L2_CID_AUTO_WHITE_BALANCE,
+    .type = V4L2_CTRL_TYPE_BOOLEAN,
+    .name = "Auto white balance",
+    .minimum = 0,
+    .maximum = 1,
+    .step = 1,
+    .default_value = 0,
+  },
+  {
+    .id = V4L2_CID_EXPOSURE,
+    .type = V4L2_CTRL_TYPE_MENU,
+    .name = "Exposure bias",
+    .minimum = 0,
+    .maximum = ARRAY_SIZE(dohofpga_querymenu_ev_bias_mode) - 2,
+    .step = 1,
+    .default_value = (ARRAY_SIZE(dohofpga_querymenu_ev_bias_mode) \
+        - 2) / 2,  /* 0 EV */
+  },
+  {
+    .id = V4L2_CID_COLORFX,
+    .type = V4L2_CTRL_TYPE_MENU,
+    .name = "Image Effect",
+    .minimum = 0,
+    .maximum = ARRAY_SIZE(dohofpga_querymenu_effect_mode) - 2,
+    .step = 1,
+    .default_value = 0,
+  },
+  {
+    .id = V4L2_CID_CONTRAST,
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .name = "Contrast",
+    .minimum = 0,
+    .maximum = 4,
+    .step = 1,
+    .default_value = 2,
+  },
+  {
+    .id = V4L2_CID_SATURATION,
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .name = "Saturation",
+    .minimum = 0,
+    .maximum = 4,
+    .step = 1,
+    .default_value = 2,
+  },
+  {
+    .id = V4L2_CID_SHARPNESS,
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .name = "Sharpness",
+    .minimum = 0,
+    .maximum = 4,
+    .step = 1,
+    .default_value = 2,
+  },
+};
+
+static const struct v4l2_subdev_core_ops dohofpga_core_ops =
+{
+  .init = dohofpga_init,  /* initializing API */
+  .s_power = dohofpga_s_power,
+  .queryctrl = dohofpga_queryctrl,
+  .querymenu = dohofpga_querymenu,
+  .g_ctrl = dohofpga_g_ctrl,
+  .s_ctrl = dohofpga_s_ctrl,
+};
+
+static const struct v4l2_subdev_video_ops dohofpga_video_ops = 
+{
+  .s_crystal_freq = dohofpga_s_crystal_freq,
+  .g_mbus_fmt = dohofpga_g_fmt,
+  .s_mbus_fmt = dohofpga_s_fmt,
+  .enum_framesizes = dohofpga_enum_framesizes,
+  .enum_frameintervals = dohofpga_enum_frameintervals,
+  .g_parm = dohofpga_g_parm,
+  .s_parm = dohofpga_s_parm,
+  .s_stream = dohofpga_s_stream,
+};
+
+static const struct v4l2_subdev_ops dohofpga_ops = 
+{
+  .core = &dohofpga_core_ops,
+  .video = &dohofpga_video_ops,
+};
+
+static const struct i2c_device_id dohofpga_id[] = 
+{
+  { DOHOFPGA_DRIVER_NAME, 0 },
+  { },
+};
+
+MODULE_DEVICE_TABLE(i2c, dohofpga_id);
+
+static struct i2c_driver dohofpga_i2c_driver = 
+{
+  .driver = 
+  {
+    .name  = DOHOFPGA_DRIVER_NAME,
+  },
+  .probe    = dohofpga_probe,
+  .remove    = dohofpga_remove,
+  .id_table  = dohofpga_id,
+};
+
+
+#endif
+
+#endif
diff -Naur org/drivers/media/video/exynos/fimc-is/fimc-is-v4l2.c ths/drivers/media/video/exynos/fimc-is/fimc-is-v4l2.c
--- org/drivers/media/video/exynos/fimc-is/fimc-is-v4l2.c	2013-07-08 07:55:58.000000000 +0200
+++ ths/drivers/media/video/exynos/fimc-is/fimc-is-v4l2.c	2013-07-08 12:25:36.000000000 +0200
@@ -41,6 +41,15 @@
 #include <linux/dma-mapping.h>
 #include <linux/vmalloc.h>
 
+#if defined(CONFIG_VIDEO_SAMSUNG_V4L2) || (defined(CONFIG_VIDEO_SAMSUNG_V4L2_MODULE) && defined(MODULE))
+#include <linux/videodev2_samsung.h>
+#include <linux/videodev2_exynos_camera.h>
+#ifndef V4L2_CID_CAMERA_AUTO_FOCUS_RESULT
+#define V4L2_CID_CAMERA_AUTO_FOCUS_RESULT V4L2_CID_CAMERA_AUTO_FOCUS_RESULT_FIRST
+#warning using V4L2_CID_CAMERA_AUTO_FOCUS_RESULT_FIRST to define V4L2_CID_CAMERA_AUTO_FOCUS_RESULT 
+#endif
+#endif
+
 #include "fimc-is-core.h"
 #include "fimc-is-regs.h"
 #include "fimc-is-param.h"
diff -Naur org/drivers/media/video/exynos/fimc-lite/fimc-lite-core.h ths/drivers/media/video/exynos/fimc-lite/fimc-lite-core.h
--- org/drivers/media/video/exynos/fimc-lite/fimc-lite-core.h	2013-07-08 08:09:18.000000000 +0200
+++ ths/drivers/media/video/exynos/fimc-lite/fimc-lite-core.h	2013-07-08 08:08:08.000000000 +0200
@@ -288,7 +288,7 @@
 	ctrl->cur.val = ctrl->val = value;
 }
 
-inline struct flite_fmt const *find_flite_format(struct v4l2_mbus_framefmt *mf);
+struct flite_fmt const *find_flite_format(struct v4l2_mbus_framefmt *mf);
 
 /*
  * Add buf to the capture active buffers queue.
diff -Naur org/drivers/media/video/Kconfig ths/drivers/media/video/Kconfig
--- org/drivers/media/video/Kconfig	2013-07-05 08:28:14.000000000 +0200
+++ ths/drivers/media/video/Kconfig	2013-07-11 12:49:33.000000000 +0200
@@ -511,65 +511,124 @@
 endchoice
 
 # hardkernel added
+
 config VIDEO_S5K5AAFA
-	tristate "S5K5AAFA  supporting camera driver"
-	depends on I2C && VIDEO_V4L2
-	---help---
-	  This driver supports s5k5aafa SoC camera module with
+  tristate "S5K5AAFA  supporting camera driver"
+  depends on I2C && VIDEO_V4L2
+  help
+    This driver supports s5k5aafa SoC camera module with 
+    do not select, source missing !
 
 config VIDEO_S5K5CAGX
-	tristate "S5K5CAGX  supporting camera driver"
-	depends on I2C && VIDEO_V4L2
-	---help---
-	  This driver supports s5k5cagx SoC camera module with
+  tristate "S5K5CAGX  supporting camera driver"
+  depends on I2C && VIDEO_V4L2
+  help
+    This driver supports s5k5cagx SoC camera module with
+    do not select, source missing !
 
 config VIDEO_S5K4ECGX
-	tristate "S5K4ECGX supporting camera driver"
-	depends on VIDEO_V4L2 && (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS) 
-	select VIDEO_S5K4ECGX_ODROIDQ
-	---help---
-	  This driver supports S5K4ECGX sensor.
+  tristate "S5K4ECGX supporting camera driver"
+  depends on VIDEO_V4L2 && (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS) 
+  select VIDEO_S5K4ECGX_ODROIDQ
+  help
+    This driver supports S5K4ECGX sensor.
+
 choice
-depends on VIDEO_S5K4ECGX
-prompt "MIPI Camera port for S5K4ECGX"
-default S5K4ECGX_CSI_D
+  depends on VIDEO_S5K4ECGX
+  prompt "MIPI Camera port for S5K4ECGX"
+  default S5K4ECGX_CSI_D
+
 config S5K4ECGX_CSI_C
-	bool "CSI Camera A port"
-	depends on (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS)
-	help
-	  This enables support for CSI A port
+  bool "CSI Camera A port"
+  depends on (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS)
+  help
+    This enables support for CSI A port
 config SS5K4ECGX_CSI_D
-	bool "CSI Camera B port"
-	depends on (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS)
-	help
-	  This enalbes support for CSI B port
+  bool "CSI Camera B port"
+  depends on (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS)
+  help
+    This enalbes support for CSI B port
 endchoice
 
 config VIDEO_S5K4ECGX_ODROIDQ
-	tristate "S5K4ECGX supporting camera driver for odroid-q"
-	depends on VIDEO_S5K4ECGX
-	help
-	  This driver supports S5K4ECGX SoC camera module
+  tristate "S5K4ECGX supporting camera driver for odroid-q"
+  depends on VIDEO_S5K4ECGX
+  help
+    This driver supports S5K4ECGX SoC camera module
 
 config VIDEO_MT9M113
-        tristate "mt9m113 support"
-        depends on I2C
-        help
-          This driver supports MT9M113cameras from Micron/Aptina
+  tristate "mt9m113 support"
+  depends on I2C
+  help
+    This driver supports MT9M113cameras from Micron/Aptina
+choice
+  depends on VIDEO_MT9M113
+  prompt "Select ITU/MIPI Camera port for MT9M113"
+  default MT9M113_ITU_A
+  config MT9M113_ITU_A
+    bool "ITU Camera A port"
+    depends on I2C
+    help
+      This enables support for ITU A port
+  config MT9M113_ITU_B
+    bool "ITU Camera B port"
+    depends on I2C
+    help
+      This enables support for ITU B port
+  config MT9M113_CSI_C
+    bool "CSI Camera A port"
+    depends on (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS)
+    help
+      This enables support for CSI A port
+  config MT9M113_CSI_D
+    bool "CSI Camera B port"
+    depends on (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS)
+    help
+      This enalbes support for CSI B port
+endchoice
 
-#
+config VIDEO_DOHOFPGA
+  tristate "dohofpga support"
+  depends on I2C
+  help
+    This driver supports Dominik Honeggers FPGA camera interface
+choice
+  depends on VIDEO_DOHOFPGA
+  prompt "Select ITU/MIPI Camera port for DOHOFPGA"
+  default DOHOFPGA_ITU_A
+  config DOHOFPGA_ITU_A
+    bool "ITU Camera A port"
+    depends on I2C
+    help
+      This enables support for ITU A port
+  config DOHOFPGA_ITU_B
+    bool "ITU Camera B port"
+    depends on I2C
+    help
+      This enables support for ITU B port
+  config DOHOFPGA_CSI_C
+    bool "CSI Camera A port"
+    depends on (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS)
+    help
+      This enables support for CSI A port
+  config DOHOFPGA_CSI_D
+    bool "CSI Camera B port"
+    depends on (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS)
+    help
+      This enables support for CSI B port
+endchoice
 
 config VIDEO_M5MO
-        tristate "M5MO supporting camera driver"
-	depends on I2C && VIDEO_V4L2 && VIDEO_FIMC_MIPI
-        ---help---
-          This driver supports M5MO SoC camera module
+  tristate "M5MO supporting camera driver"
+  depends on I2C && VIDEO_V4L2 && VIDEO_FIMC_MIPI
+  help
+    This driver supports M5MO SoC camera module
 
 config VIDEO_AR0832
-        tristate "AR0832 supporting camera driver"
-        depends on I2C && VIDEO_V4L2 && VIDEO_FIMC_MIPI
-        ---help---
-          This driver supports AR0832 SoC camera module
+  tristate "AR0832 supporting camera driver"
+  depends on I2C && VIDEO_V4L2 && VIDEO_FIMC_MIPI
+  help
+    This driver supports AR0832 SoC camera module
 
 
 config VIDEO_S5K4BA
@@ -603,7 +662,7 @@
 			VIDEO_EXYNOS_MIPI_CSIS)
 	help
 	  This enables support for ITU B port
-config CSI_Cs5k4ecgx_regs-odroidq.h
+config CSI_C
 	bool "CSI Camera A port"
 	depends on (VIDEO_FIMC_MIPI || VIDEO_S5P_MIPI_CSIS ||\
 			VIDEO_EXYNOS_MIPI_CSIS)
diff -Naur org/drivers/media/video/m5mo.c ths/drivers/media/video/m5mo.c
--- org/drivers/media/video/m5mo.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/drivers/media/video/m5mo.c	2013-07-08 12:26:12.000000000 +0200
@@ -22,9 +22,15 @@
 #include <linux/vmalloc.h>
 #include <linux/firmware.h>
 #include <linux/videodev2.h>
+#include <linux/slab.h>
 
-#ifdef CONFIG_VIDEO_SAMSUNG_V4L2
+#if defined(CONFIG_VIDEO_SAMSUNG_V4L2) || (defined(CONFIG_VIDEO_SAMSUNG_V4L2_MODULE) && defined(MODULE))
 #include <linux/videodev2_samsung.h>
+#include <linux/videodev2_exynos_camera.h>
+#ifndef V4L2_CID_CAMERA_AUTO_FOCUS_RESULT
+#define V4L2_CID_CAMERA_AUTO_FOCUS_RESULT V4L2_CID_CAMERA_AUTO_FOCUS_RESULT_FIRST
+#warning using V4L2_CID_CAMERA_AUTO_FOCUS_RESULT_FIRST to define V4L2_CID_CAMERA_AUTO_FOCUS_RESULT 
+#endif
 #endif
 
 #include <linux/regulator/machine.h>
diff -Naur org/drivers/media/video/Makefile ths/drivers/media/video/Makefile
--- org/drivers/media/video/Makefile	2013-07-05 08:28:14.000000000 +0200
+++ ths/drivers/media/video/Makefile	2013-07-10 18:11:43.000000000 +0200
@@ -89,6 +89,7 @@
 obj-$(CONFIG_SOC_CAMERA_MT9M001)	+= mt9m001.o
 obj-$(CONFIG_SOC_CAMERA_MT9M111)	+= mt9m111.o
 obj-$(CONFIG_VIDEO_MT9M113)	+= mt9m113.o
+obj-$(CONFIG_VIDEO_DOHOFPGA)	+= dohofpga.o
 obj-$(CONFIG_SOC_CAMERA_MT9T031)	+= mt9t031.o
 obj-$(CONFIG_SOC_CAMERA_MT9T112)	+= mt9t112.o
 obj-$(CONFIG_SOC_CAMERA_MT9V022)	+= mt9v022.o
@@ -100,9 +101,10 @@
 obj-$(CONFIG_SOC_CAMERA_RJ54N1)		+= rj54n1cb0c.o
 obj-$(CONFIG_SOC_CAMERA_TW9910)		+= tw9910.o
 
+obj-$(CONFIG_VIDEO_S5K5AAFA)		+= s5k5aafa.o
 obj-$(CONFIG_VIDEO_S5K5CAGX)		+= s5k5cagx.o
 obj-$(CONFIG_VIDEO_S5K4ECGX)		+= s5k4ecgx.o
-obj-$(CONFIG_VIDEO_S5K5AAFA)		+= s5k5aafa.o
+
 
 # And now the v4l2 drivers:
 
diff -Naur org/drivers/media/video/s5k4ecgx.c ths/drivers/media/video/s5k4ecgx.c
--- org/drivers/media/video/s5k4ecgx.c	2013-07-05 08:28:14.000000000 +0200
+++ ths/drivers/media/video/s5k4ecgx.c	2013-07-08 10:05:05.000000000 +0200
@@ -12,12 +12,9 @@
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  * for more details.
  */
+
+#define __S5K4ECGX_C__
 #include "s5k4ecgx.h"
-#include <linux/delay.h>
-#if defined(CONFIG_EXYNOS4_CPUFREQ)
-#include <linux/cpufreq.h>
-#include <mach/cpufreq.h>
-#endif
 
 static int s5k4ecgx_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
 static int s5k4ecgx_init(struct v4l2_subdev *sd, u32 val);
diff -Naur org/drivers/media/video/s5k4ecgx.h ths/drivers/media/video/s5k4ecgx.h
--- org/drivers/media/video/s5k4ecgx.h	2013-07-05 08:28:14.000000000 +0200
+++ ths/drivers/media/video/s5k4ecgx.h	2013-07-08 11:54:29.000000000 +0200
@@ -14,6 +14,9 @@
 
 #ifndef __S5K4ECGX_H__
 #define __S5K4ECGX_H__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/i2c.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
@@ -26,6 +29,47 @@
 #include <linux/videodev2_samsung.h>
 #include <linux/workqueue.h>
 
+#include <linux/delay.h>
+#ifdef CONFIG_EXYNOS4_CPUFREQ
+#include <linux/cpufreq.h>
+#include <mach/cpufreq.h>
+#endif
+
+#include "s5k4ecgx.h"
+#if defined(CONFIG_VIDEO_S5K4ECGX_ODROIDQ) || (defined(CONFIG_VIDEO_S5K4ECGX_ODROIDQ_MODULE) && defined(MODULE))
+#include "s5k4ecgx_regs_odroid.h"
+#else
+#include "s5k4ecgx_regs.h"
+#endif 
+
+/* The Path of Setfile */
+#ifdef CONFIG_LOAD_FILE
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+struct test {
+	u8 data;
+	struct test *nextBuf;
+};
+static struct test *testBuf;
+static s32 large_file;
+
+#define TEST_INIT	\
+{			\
+	.data = 0;	\
+	.nextBuf = NULL;	\
+}
+
+#if defined(CONFIG_VIDEO_S5K4ECGX_ODROIDQ)
+#define TUNING_FILE_PATH "/mnt/sdcard/s5k4ecgx_regs_odroid.h"
+#else
+#define TUNING_FILE_PATH NULL
+#endif
+#endif /* CONFIG_LOAD_FILE*/
+
 #define S5K4ECGX_DRIVER_NAME	"S5K4ECGX"
 
 #define S5K4ECGX_DELAY		0xFFFF0000
@@ -554,38 +598,4 @@
 #define SCND_WINSIZE_X			230
 #define SCND_WINSIZE_Y			306
 
-/* The Path of Setfile */
-#ifdef CONFIG_LOAD_FILE
-#include <linux/vmalloc.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/uaccess.h>
-
-struct test {
-	u8 data;
-	struct test *nextBuf;
-};
-static struct test *testBuf;
-static s32 large_file;
-
-#define TEST_INIT	\
-{			\
-	.data = 0;	\
-	.nextBuf = NULL;	\
-}
-
-#if defined(CONFIG_VIDEO_S5K4ECGX_ODROIDQ)
-#define TUNING_FILE_PATH "/mnt/sdcard/s5k4ecgx_regs_odroid.h"
-#else
-#define TUNING_FILE_PATH NULL
-#endif
-#endif /* CONFIG_LOAD_FILE*/
-
-#if defined(CONFIG_VIDEO_S5K4ECGX_ODROIDQ)
-#include "s5k4ecgx_regs_odroid.h"
-#else
-#include "s5k4ecgx_reg.h"
-#endif /* CONFIG_VIDEO_S5K4ECGX_P4W*/
-
 #endif /* __S5K4ECGX_H__ */
diff -Naur org/drivers/media/video/s5k4ecgx_regs.h ths/drivers/media/video/s5k4ecgx_regs.h
--- org/drivers/media/video/s5k4ecgx_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ ths/drivers/media/video/s5k4ecgx_regs.h	2013-07-05 08:28:14.000000000 +0200
@@ -0,0 +1,5362 @@
+/* drivers/media/video/s5k4ecgx_regs_1_1.h
+ *
+ * Driver for s5k4ecgx (5MP Camera) from SEC(LSI), firmware EVT1.1
+ *
+ * Copyright (C) 2010, SAMSUNG ELECTRONICS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __S5K4ECGX_REGS_ODROID_H__
+#define __S5K4ECGX_REGS_ODROID_H__
+
+static const u32 s5k4ecgx_init_arm[] =
+{
+	0xFCFCD000,
+	0x00100001,	//S/W Reset
+	0x10300000,	//contint_host_int
+	0x00140001,	//sw_load_complete - Release CORE (Arm) from reset state 
+};
+
+static const u32 s5k4ecgx_init_reg[] =
+{
+	/* Drive current setting */
+	0x0028D000, // 0xD0001082
+	0x002A1082,
+	0x0F120000, //cregs_d0_d4_cd10 //D4[9:8], D3[7:6], D2[5:4], D1[3:2], D0[1:0]
+	0x002A0084,
+	0x0F120000,	//cregs_d5_d9_cd10 //D9[9:8], D8[7:6], D7[5:4], D6[3:2], D5[1:0]
+	0x002A0088,
+	0x0F120000,	//cregs_clks_output_cd10 //SDA[11:10], SCL[9:8], PCLK[7:6], VSYNC[3:2], HSYNC[1:0]
+
+	0x0028D000, // 0xD000007A
+	0x002A007A,
+	0x0F120000,
+
+	/* ISP FE(ADLC) */
+  	0x002AE406,	//[7]f_ladlc_en [6:5]f max [4]fadlc_en [3:2]L max [1]ladlc_en [0]adlc_ch_sel
+	0x0F120092,
+	0x002AE410,
+ 	0x0F123804,	//[15:8]fadlc_filter_co_b, [7:0]fadlc_filter_co_a       
+	0x002AE41A,
+	0x0F120010,
+	0x002AE420,
+	0x0F120003,	//adlc_fadlc_filter_refresh     
+	0x0F120060,			//adlc_filter_level_diff_threshold
+	0x002AE42E,
+	0x0F120004,	//dithered l-ADLC(4bit)
+	0x002AF400,
+	0x0F125A3C,	//[15:8]stx_width, [7:0]dstx_width 
+	0x0F120023,	//[14]binning_test [13]gain_mode [11:12]row_id [10]cfpn_test [9]pd_pix [8]teg_en, [7]adc_res, [6]smp_en, [5]ldb_en, [4]ld_en, [3]clp_en [2]srx_en, [1]dshut_en, [0]dcds_en 
+	0x0F128080,	//CDS option 
+	0x0F1203AF,	//[11:6]rst_mx, [5:0]sig_mx
+	0x0F12000A,	//Avg mode
+	0x0F12AA54,	//x1~x1.49:No MS, x1.5~x3.99:MS2, x4~x16:MS4
+	0x0F120040,	//RMP option [6]1: RES gain
+	0x0F12464E,	//[14]msoff_en, [13:8]off_rst, [7:0]adc_sat
+	0x0F120240,	//bist_sig_width_e
+	0x0F120240,	//bist_sig_width_o
+	0x0F120040,	//[9]dbs_bist_en, [8:0]bist_rst_width
+	0x0F121000,	//[15]aac_en, [14]GCLK_DIV2_EN, [13:10]dl_cont [9:8]dbs_mode, [7:0]dbs_option
+	0x0F1255FF,	//bias [15:12]pix, [11:8]pix_bst [7:4]comp2, [3:0]comp1         
+	0x0F12D000,	//[15:8]clp_lvl, [7:0]ref_option, [5]pix_bst_en
+	0x0F120010,	//[7:0]monit
+	0x0F120202,	//[15:8]dbr_tune_tgsl, [7:0]dbr_tune_pix
+	0x0F120401,	//[15:8]dbr_tune_ntg, [7:0]dbr_tune_rg                             
+	0x0F120022,	//[15:8]reg_option, [7:4]rosc_tune_ncp, [3:0]rosc_tune_c
+	0x0F120088,	//PD [8]inrush_ctrl, [7]fblv, [6]reg_ntg, [5]reg_tgsl, [4]reg_rg, [3]reg_pix, [2]ncp_rosc, [1]cp_rosc, [0]cp
+	0x0F12009F,	//[9]capa_ctrl_en, [8:7]fb_lv, [6:5]dbr_clk_sel, [4:0]cp_capa  
+	0x0F120000,	//[15:0]blst_en_cintr 
+	0x0F121800,	//[11]blst_en, [10]rfpn_test, [9]sl_off, [8]tx_off, [7:0]rdv_option
+	0x0F120000,	//[15:1]analog_dummy, [0]pd_reg_test 
+	0x0F122428,	//[13:11]srx_gap1, [10:8]srx_gap0, [7:0]stx_gap
+	0x0F120000,	//[0]atx_option       
+	0x0F1203EE,	//aig_avg_half
+	0x0F120000,	//[0]hvs_test_reg     
+	0x0F120000,	//[0]dbus_bist_auto   
+	0x0F120000,	//[7:0]dbr_option           
+	0x002AF552,
+	0x0F120708,	//[7:0]lat_st, [15:8]lat_width  
+	0x0F12080C,	//[7:0]hold_st, [15:8]hold_width
+
+	/* 07. Analog Setting 2 */
+	/* For subsampling Size */
+	0x00287000, 
+	0x002A18BC, 
+	0x0F120004, 
+	0x0F1205B6, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120001, 
+	0x0F1205BA, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120007, 
+	0x0F1205BA, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F1201F4, 
+	0x0F12024E, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F1201F4, 
+	0x0F1205B6, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F1201F4, 
+	0x0F1205BA, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F1201F4, 
+	0x0F12024F, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120075, 
+	0x0F1200CF, 
+	0x0F120000, 
+	0x0F120000,
+	0x0F120075, 
+	0x0F1200D6, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120004, 
+	0x0F1201F4, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F1200F0, 
+	0x0F1201F4, 
+	0x0F12029E, 
+	0x0F1205B2, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F1201F8, 
+	0x0F120228, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120208, 
+	0x0F120238, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120218, 
+	0x0F120238, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120001, 
+	0x0F120009, 
+	0x0F1200DE, 
+	0x0F1205C0, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F1200DF, 
+	0x0F1200E4, 
+	0x0F1201F8, 
+	0x0F1201FD, 
+	0x0F1205B6, 
+	0x0F1205BB, 
+	0x0F120000, 
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F1201F8,
+	0x0F120000,
+	0x0F120000,
+	0x0F120077,
+	0x0F12007E,
+	0x0F12024F,
+	0x0F12025E,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	/* For Capture  */
+	0x0F120004,
+	0x0F1209D1,
+	0x0F120000,
+	0x0F120000,
+	0x0F120001, 
+	0x0F1209D5, 
+	0x0F120000, 
+	0x0F120000,
+	0x0F120008,
+	0x0F1209D5,
+	0x0F120000,
+	0x0F120000,
+	0x0F1202AA,
+	0x0F120326,
+	0x0F120000,
+	0x0F120000,
+	0x0F1202AA,
+	0x0F1209D1,
+	0x0F120000,
+	0x0F120000,
+	0x0F1202AA,
+	0x0F1209D5,
+	0x0F120000,
+	0x0F120000,
+	0x0F1202AA,
+	0x0F120327,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120008,
+	0x0F120084, 
+	0x0F120000, 
+	0x0F120000,
+	0x0F120008,
+	0x0F12008D,
+	0x0F120000,
+	0x0F120000,
+	0x0F120008,
+	0x0F1202AA,
+	0x0F120000,
+	0x0F120000,
+	0x0F1200AA,
+	0x0F1202AA,
+	0x0F1203AD,
+	0x0F1209CD,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F1202AE,
+	0x0F1202DE,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F1202BE,
+	0x0F1202EE,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F1202CE,
+	0x0F1202EE,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120001,
+	0x0F120009,
+	0x0F120095,
+	0x0F1209DB,
+	0x0F120000,
+	0x0F120000,
+	0x0F120096,
+	0x0F12009B,
+	0x0F1202AE,
+	0x0F1202B3,
+	0x0F1209D1,
+	0x0F1209D6,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F1202AE, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120009, 
+	0x0F120010, 
+	0x0F120327, 
+	0x0F120336, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x0F120000, 
+	0x002A1AF8, 
+	0x0F125A3C,	//senHal_TuneStr_AngTuneData1_2_D000F400 register at subsampling
+	0x002A1896, 
+	0x0F120002,	//senHal_SamplingType   0002 03EE: PLA setting          
+	0x0F120000,	//senHal_SamplingMode 0 : 2 PLA / 1 : 4PLA              
+	0x0F120003,	//senHal_PLAOption      [0] VPLA enable  [1] HPLA enable
+	0x002A189E,  
+	0x0F120FB0,	//senHal_ExpMinPixels
+	0x002A18AC,  
+	0x0F120060,	//senHal_uAddColsBin  
+	0x0F120060,	//senHal_uAddColsNoBin
+	0x0F1205C0,	//senHal_uMinColsBin  
+	0x0F1205C0,	//senHal_uMinColsNoBin
+	0x002A1AEA,  
+	0x0F128080,	//senHal_SubF404Tune 
+	0x0F120080,	//senHal_FullF404Tune
+	0x002A1AE0,  
+	0x0F120000,	//senHal_bSenAAC     
+	0x002A1A72,  
+	0x0F120000,	//senHal_bSRX   SRX off
+	0x002A18A2,  
+	0x0F120004,	//senHal_NExpLinesCheckFine extend Forbidden area line       
+	0x002A1A6A,  
+	0x0F12009A,	//senHal_usForbiddenRightOfs extend right Forbidden area line
+	0x002A385E,  
+	0x0F12024C,	//Mon_Sen_uExpPixelsOfs                                      
+	0x002A0EE6,  
+	0x0F120000,	//setot_bUseDigitalHbin
+	0x002A1B2A,  
+	0x0F120300,	//70001B2A //senHal_TuneStr2_usAngTuneGainTh    
+	0x0F1200D6,	//70001B2C //senHal_TuneStr2_AngTuneF4CA_0_ 
+	0x0F12008D,	//70001B2E //senHal_TuneStr2_AngTuneF4CA_1_ 
+	0x0F1200CF,	//70001B30 //senHal_TuneStr2_AngTuneF4C2_0_ 
+	0x0F120084,	//70001B32 //senHal_TuneStr2_AngTuneF4C2_1_
+	
+	/* OTP Setting */
+	0x00287000, 
+	0x002A0722,
+	0x0F120100,	//skl_OTP_usWaitTime This register should be positioned in fornt of D0001000 
+	0x002A0726,
+	0x0F120001,	//skl_bUseOTPfunc This is OTP on/off function 
+	0x002A08D6,
+	0x0F120001,	//ash_bUseOTPData       
+	0x002A146E, 
+	0x0F120000,	//awbb_otp_disable      
+	0x002A08DC, 
+	0x0F120000,	//ash_bUseGasAlphaOTP             
+	0x0028D000,
+	0x002A1000,
+	0x0F120001,
+
+	/* TnP Setting */
+	/* Start of Patch Data */
+	0x00287000,
+	0x002A3AF8,
+	0x0F12B570,	// 70003AF8              
+	0x0F124B39,	// 70003AFA              
+	0x0F124939,	// 70003AFC              
+	0x0F12483A,	// 70003AFE              
+	0x0F122200,	// 70003B00              
+	0x0F12C008,	// 70003B02              
+	0x0F126001,	// 70003B04              
+	0x0F124939,	// 70003B06              
+	0x0F124839,	// 70003B08              
+	0x0F122401,	// 70003B0A              
+	0x0F12F000,	// 70003B0C              
+	0x0F12FBEC,	// 70003B0E              
+	0x0F124938,	// 70003B10              
+	0x0F124839,	// 70003B12              
+	0x0F122502,	// 70003B14              
+	0x0F120022,	// 70003B16              
+	0x0F12F000,	// 70003B18              
+	0x0F12FBE6,	// 70003B1A              
+	0x0F124837,	// 70003B1C              
+	0x0F120261,	// 70003B1E              
+	0x0F128001,	// 70003B20              
+	0x0F122100,	// 70003B22              
+	0x0F128041,	// 70003B24              
+	0x0F124936,	// 70003B26              
+	0x0F124836,	// 70003B28              
+	0x0F126041,	// 70003B2A              
+	0x0F124936,	// 70003B2C              
+	0x0F124837,	// 70003B2E              
+	0x0F122403,	// 70003B30              
+	0x0F12002A,	// 70003B32              
+	0x0F12F000,	// 70003B34              
+	0x0F12FBD8,	// 70003B36              
+	0x0F124832,	// 70003B38              
+	0x0F124935,	// 70003B3A              
+	0x0F1230C0,	// 70003B3C              
+	0x0F1263C1,	// 70003B3E              
+	0x0F124930,	// 70003B40              
+	0x0F124834,	// 70003B42              
+	0x0F123980,	// 70003B44              
+	0x0F126408,	// 70003B46              
+	0x0F124833,	// 70003B48              
+	0x0F124934,	// 70003B4A              
+	0x0F126388,	// 70003B4C              
+	0x0F124934,	// 70003B4E              
+	0x0F124834,	// 70003B50              
+	0x0F120022,	// 70003B52              
+	0x0F122504,	// 70003B54              
+	0x0F12F000,	// 70003B56              
+	0x0F12FBC7,	// 70003B58              
+	0x0F124933,	// 70003B5A              
+	0x0F124833,	// 70003B5C              
+	0x0F122405,	// 70003B5E              
+	0x0F12002A,	// 70003B60              
+	0x0F12F000,	// 70003B62              
+	0x0F12F881,	// 70003B64              
+	0x0F12491F,	// 70003B66              
+	0x0F124830,	// 70003B68              
+	0x0F120022,	// 70003B6A              
+	0x0F122506,	// 70003B6C              
+	0x0F1239B6,	// 70003B6E              
+	0x0F121D80,	// 70003B70              
+	0x0F12F000,	// 70003B72              
+	0x0F12F879,	// 70003B74              
+	0x0F12482D,	// 70003B76              
+	0x0F12492D,	// 70003B78              
+	0x0F122407,	// 70003B7A              
+	0x0F12002A,	// 70003B7C              
+	0x0F12300C,	// 70003B7E              
+	0x0F12F000,	// 70003B80              
+	0x0F12F872,	// 70003B82              
+	0x0F124829,	// 70003B84              
+	0x0F12492B,	// 70003B86              
+	0x0F120022,	// 70003B88              
+	0x0F122508,	// 70003B8A              
+	0x0F123010,	// 70003B8C              
+	0x0F12F000,	// 70003B8E              
+	0x0F12F86B,	// 70003B90              
+	0x0F124929,	// 70003B92              
+	0x0F124829,	// 70003B94              
+	0x0F122409,	// 70003B96              
+	0x0F12002A,	// 70003B98              
+	0x0F12F000,	// 70003B9A              
+	0x0F12FBA5,	// 70003B9C              
+	0x0F124928,	// 70003B9E              
+	0x0F124828,	// 70003BA0              
+	0x0F120022,	// 70003BA2              
+	0x0F12250A,	// 70003BA4              
+	0x0F12F000,	// 70003BA6              
+	0x0F12FB9F,	// 70003BA8              
+	0x0F124927,	// 70003BAA              
+	0x0F124827,	// 70003BAC              
+	0x0F12240B,	// 70003BAE              
+	0x0F12002A,	// 70003BB0              
+	0x0F12F000,	// 70003BB2              
+	0x0F12FB99,	// 70003BB4              
+	0x0F124926,	// 70003BB6              
+	0x0F124826,	// 70003BB8              
+	0x0F120022,	// 70003BBA              
+	0x0F12250C,	// 70003BBC              
+	0x0F12F000,	// 70003BBE              
+	0x0F12FB93,	// 70003BC0              
+	0x0F124925,	// 70003BC2              
+	0x0F124825,	// 70003BC4              
+	0x0F12240D,	// 70003BC6              
+	0x0F12002A,	// 70003BC8              
+	0x0F12F000,	// 70003BCA              
+	0x0F12FB8D,	// 70003BCC              
+	0x0F124924,	// 70003BCE              
+	0x0F124824,	// 70003BD0              
+	0x0F120022,	// 70003BD2              
+	0x0F12F000,	// 70003BD4              
+	0x0F12FB88,	// 70003BD6              
+	0x0F12BC70,	// 70003BD8              
+	0x0F12BC08,	// 70003BDA              
+	0x0F124718,	// 70003BDC              
+	0x0F120000,	// 70003BDE              
+	0x0F12017B,	// 70003BE0              
+	0x0F124EC2,	// 70003BE2              
+	0x0F12037F,	// 70003BE4              
+	0x0F120000,	// 70003BE6              
+	0x0F121F90,	// 70003BE8              
+	0x0F127000,	// 70003BEA              
+	0x0F123C81,	// 70003BEC              
+	0x0F127000,	// 70003BEE              
+	0x0F12E38B,	// 70003BF0              
+	0x0F120000,	// 70003BF2              
+	0x0F123CB9,	// 70003BF4              
+	0x0F127000,	// 70003BF6              
+	0x0F12C3B1,	// 70003BF8              
+	0x0F120000,	// 70003BFA              
+	0x0F124780,	// 70003BFC              
+	0x0F127000,	// 70003BFE              
+	0x0F123D17,	// 70003C00              
+	0x0F127000,	// 70003C02              
+	0x0F120080,	// 70003C04              
+	0x0F127000,	// 70003C06              
+	0x0F123D53,	// 70003C08              
+	0x0F127000,	// 70003C0A              
+	0x0F12B49D,	// 70003C0C              
+	0x0F120000,	// 70003C0E              
+	0x0F123DFF,	// 70003C10              
+	0x0F127000,	// 70003C12              
+	0x0F123DB3,	// 70003C14              
+	0x0F127000,	// 70003C16              
+	0x0F12FFFF,	// 70003C18              
+	0x0F1200FF,	// 70003C1A              
+	0x0F1217E0,	// 70003C1C              
+	0x0F127000,	// 70003C1E              
+	0x0F123F7B,	// 70003C20              
+	0x0F127000,	// 70003C22              
+	0x0F12053D,	// 70003C24              
+	0x0F120000,	// 70003C26              
+	0x0F120000,	// 70003C28              
+	0x0F120A89,	// 70003C2A              
+	0x0F126CD2,	// 70003C2C              
+	0x0F120000,	// 70003C2E              
+	0x0F120000,	// 70003C30              
+	0x0F120A9A,	// 70003C32              
+	0x0F120000,	// 70003C34              
+	0x0F1202D2,	// 70003C36              
+	0x0F123FC9,	// 70003C38              
+	0x0F127000,	// 70003C3A              
+	0x0F129E65,	// 70003C3C              
+	0x0F120000,	// 70003C3E              
+	0x0F12403D,	// 70003C40              
+	0x0F127000,	// 70003C42              
+	0x0F127C49,	// 70003C44              
+	0x0F120000,	// 70003C46              
+	0x0F1240B1,	// 70003C48              
+	0x0F127000,	// 70003C4A              
+	0x0F127C63,	// 70003C4C              
+	0x0F120000,	// 70003C4E              
+	0x0F1240CD,	// 70003C50              
+	0x0F127000,	// 70003C52              
+	0x0F128F01,	// 70003C54              
+	0x0F120000,	// 70003C56              
+	0x0F12416F,	// 70003C58              
+	0x0F127000,	// 70003C5A              
+	0x0F127F3F,	// 70003C5C              
+	0x0F120000,	// 70003C5E              
+	0x0F1241FD,	// 70003C60              
+	0x0F127000,	// 70003C62              
+	0x0F1298C5,	// 70003C64              
+	0x0F120000,	// 70003C66              
+	0x0F12B570,	// 70003C68              
+	0x0F12000C,	// 70003C6A              
+	0x0F120015,	// 70003C6C              
+	0x0F120029,	// 70003C6E              
+	0x0F12F000,	// 70003C70              
+	0x0F12FB42,	// 70003C72              
+	0x0F1249F8,	// 70003C74              
+	0x0F1200A8,	// 70003C76              
+	0x0F12500C,	// 70003C78              
+	0x0F12BC70,	// 70003C7A              
+	0x0F12BC08,	// 70003C7C              
+	0x0F124718,	// 70003C7E              
+	0x0F126808,	// 70003C80              
+	0x0F120400,	// 70003C82              
+	0x0F120C00,	// 70003C84              
+	0x0F126849,	// 70003C86              
+	0x0F120409,	// 70003C88              
+	0x0F120C09,	// 70003C8A              
+	0x0F124AF3,	// 70003C8C              
+	0x0F128992,	// 70003C8E              
+	0x0F122A00,	// 70003C90              
+	0x0F12D00D,	// 70003C92              
+	0x0F122300,	// 70003C94              
+	0x0F121A89,	// 70003C96              
+	0x0F12D400,	// 70003C98              
+	0x0F12000B,	// 70003C9A              
+	0x0F120419,	// 70003C9C              
+	0x0F120C09,	// 70003C9E              
+	0x0F1223FF,	// 70003CA0              
+	0x0F1233C1,	// 70003CA2              
+	0x0F121810,	// 70003CA4              
+	0x0F124298,	// 70003CA6              
+	0x0F12D800,	// 70003CA8              
+	0x0F120003,	// 70003CAA              
+	0x0F120418,	// 70003CAC              
+	0x0F120C00,	// 70003CAE              
+	0x0F124AEB,	// 70003CB0              
+	0x0F128150,	// 70003CB2              
+	0x0F128191,	// 70003CB4              
+	0x0F124770,	// 70003CB6              
+	0x0F12B5F3,	// 70003CB8              
+	0x0F120004,	// 70003CBA              
+	0x0F12B081,	// 70003CBC              
+	0x0F129802,	// 70003CBE              
+	0x0F126800,	// 70003CC0              
+	0x0F120600,	// 70003CC2              
+	0x0F120E00,	// 70003CC4              
+	0x0F122201,	// 70003CC6              
+	0x0F120015,	// 70003CC8              
+	0x0F120021,	// 70003CCA              
+	0x0F123910,	// 70003CCC              
+	0x0F12408A,	// 70003CCE              
+	0x0F1240A5,	// 70003CD0              
+	0x0F124FE4,	// 70003CD2              
+	0x0F120016,	// 70003CD4              
+	0x0F122C10,	// 70003CD6              
+	0x0F12DA03,	// 70003CD8              
+	0x0F128839,	// 70003CDA              
+	0x0F1243A9,	// 70003CDC              
+	0x0F128039,	// 70003CDE              
+	0x0F12E002,	// 70003CE0              
+	0x0F128879,	// 70003CE2              
+	0x0F1243B1,	// 70003CE4              
+	0x0F128079,	// 70003CE6              
+	0x0F12F000,	// 70003CE8              
+	0x0F12FB0E,	// 70003CEA              
+	0x0F122C10,	// 70003CEC              
+	0x0F12DA03,	// 70003CEE              
+	0x0F128839,	// 70003CF0              
+	0x0F124329,	// 70003CF2              
+	0x0F128039,	// 70003CF4              
+	0x0F12E002,	// 70003CF6              
+	0x0F128879,	// 70003CF8              
+	0x0F124331,	// 70003CFA              
+	0x0F128079,	// 70003CFC              
+	0x0F1249DA,	// 70003CFE              
+	0x0F128809,	// 70003D00              
+	0x0F122900,	// 70003D02              
+	0x0F12D102,	// 70003D04              
+	0x0F12F000,	// 70003D06              
+	0x0F12FB07,	// 70003D08              
+	0x0F122000,	// 70003D0A              
+	0x0F129902,	// 70003D0C              
+	0x0F126008,	// 70003D0E              
+	0x0F12BCFE,	// 70003D10              
+	0x0F12BC08,	// 70003D12              
+	0x0F124718,	// 70003D14              
+	0x0F12B538,	// 70003D16              
+	0x0F129C04,	// 70003D18              
+	0x0F120015,	// 70003D1A              
+	0x0F12002A,	// 70003D1C              
+	0x0F129400,	// 70003D1E              
+	0x0F12F000,	// 70003D20              
+	0x0F12FB02,	// 70003D22              
+	0x0F124AD1,	// 70003D24              
+	0x0F128811,	// 70003D26              
+	0x0F122900,	// 70003D28              
+	0x0F12D00F,	// 70003D2A              
+	0x0F128820,	// 70003D2C              
+	0x0F124281,	// 70003D2E              
+	0x0F12D20C,	// 70003D30              
+	0x0F128861,	// 70003D32              
+	0x0F128853,	// 70003D34              
+	0x0F124299,	// 70003D36              
+	0x0F12D200,	// 70003D38              
+	0x0F121E40,	// 70003D3A              
+	0x0F120400,	// 70003D3C              
+	0x0F120C00,	// 70003D3E              
+	0x0F128020,	// 70003D40              
+	0x0F128851,	// 70003D42              
+	0x0F128061,	// 70003D44              
+	0x0F124368,	// 70003D46              
+	0x0F121840,	// 70003D48              
+	0x0F126060,	// 70003D4A              
+	0x0F12BC38,	// 70003D4C              
+	0x0F12BC08,	// 70003D4E              
+	0x0F124718,	// 70003D50              
+	0x0F12B5F8,	// 70003D52              
+	0x0F120004,	// 70003D54              
+	0x0F126808,	// 70003D56              
+	0x0F120400,	// 70003D58              
+	0x0F120C00,	// 70003D5A              
+	0x0F122201,	// 70003D5C              
+	0x0F120015,	// 70003D5E              
+	0x0F120021,	// 70003D60              
+	0x0F123910,	// 70003D62              
+	0x0F12408A,	// 70003D64              
+	0x0F1240A5,	// 70003D66              
+	0x0F124FBE,	// 70003D68              
+	0x0F120016,	// 70003D6A              
+	0x0F122C10,	// 70003D6C              
+	0x0F12DA03,	// 70003D6E              
+	0x0F128839,	// 70003D70              
+	0x0F1243A9,	// 70003D72              
+	0x0F128039,	// 70003D74              
+	0x0F12E002,	// 70003D76              
+	0x0F128879,	// 70003D78              
+	0x0F1243B1,	// 70003D7A              
+	0x0F128079,	// 70003D7C              
+	0x0F12F000,	// 70003D7E              
+	0x0F12FADB,	// 70003D80              
+	0x0F122C10,	// 70003D82              
+	0x0F12DA03,	// 70003D84              
+	0x0F128838,	// 70003D86              
+	0x0F124328,	// 70003D88              
+	0x0F128038,	// 70003D8A              
+	0x0F12E002,	// 70003D8C              
+	0x0F128878,	// 70003D8E              
+	0x0F124330,	// 70003D90              
+	0x0F128078,	// 70003D92              
+	0x0F1248B6,	// 70003D94              
+	0x0F128800,	// 70003D96              
+	0x0F120400,	// 70003D98              
+	0x0F12D507,	// 70003D9A              
+	0x0F124BB5,	// 70003D9C              
+	0x0F127819,	// 70003D9E              
+	0x0F124AB5,	// 70003DA0              
+	0x0F127810,	// 70003DA2              
+	0x0F127018,	// 70003DA4              
+	0x0F127011,	// 70003DA6              
+	0x0F1249B4,	// 70003DA8              
+	0x0F128188,	// 70003DAA              
+	0x0F12BCF8,	// 70003DAC              
+	0x0F12BC08,	// 70003DAE              
+	0x0F124718,	// 70003DB0              
+	0x0F12B538,	// 70003DB2              
+	0x0F1248B2,	// 70003DB4              
+	0x0F124669,	// 70003DB6              
+	0x0F12F000,	// 70003DB8              
+	0x0F12FAC6,	// 70003DBA              
+	0x0F1248B1,	// 70003DBC              
+	0x0F1249B0,	// 70003DBE              
+	0x0F1269C2,	// 70003DC0              
+	0x0F122400,	// 70003DC2              
+	0x0F1231A8,	// 70003DC4              
+	0x0F122A00,	// 70003DC6              
+	0x0F12D008,	// 70003DC8              
+	0x0F1261C4,	// 70003DCA              
+	0x0F12684A,	// 70003DCC              
+	0x0F126242,	// 70003DCE              
+	0x0F126282,	// 70003DD0              
+	0x0F12466B,	// 70003DD2              
+	0x0F12881A,	// 70003DD4              
+	0x0F126302,	// 70003DD6              
+	0x0F12885A,	// 70003DD8              
+	0x0F126342,	// 70003DDA              
+	0x0F126A02,	// 70003DDC              
+	0x0F122A00,	// 70003DDE              
+	0x0F12D00A,	// 70003DE0              
+	0x0F126204,	// 70003DE2              
+	0x0F126849,	// 70003DE4              
+	0x0F126281,	// 70003DE6              
+	0x0F12466B,	// 70003DE8              
+	0x0F128819,	// 70003DEA              
+	0x0F126301,	// 70003DEC              
+	0x0F128859,	// 70003DEE              
+	0x0F126341,	// 70003DF0              
+	0x0F1249A5,	// 70003DF2              
+	0x0F1288C9,	// 70003DF4              
+	0x0F1263C1,	// 70003DF6              
+	0x0F12F000,	// 70003DF8              
+	0x0F12FAAE,	// 70003DFA              
+	0x0F12E7A6,	// 70003DFC              
+	0x0F12B5F0,	// 70003DFE              
+	0x0F12B08B,	// 70003E00              
+	0x0F1220FF,	// 70003E02              
+	0x0F121C40,	// 70003E04              
+	0x0F1249A1,	// 70003E06              
+	0x0F1289CC,	// 70003E08              
+	0x0F124E9E,	// 70003E0A              
+	0x0F126AB1,	// 70003E0C              
+	0x0F124284,	// 70003E0E              
+	0x0F12D101,	// 70003E10              
+	0x0F12489F,	// 70003E12              
+	0x0F126081,	// 70003E14              
+	0x0F126A70,	// 70003E16              
+	0x0F120200,	// 70003E18              
+	0x0F12F000,	// 70003E1A              
+	0x0F12FAA5,	// 70003E1C              
+	0x0F120400,	// 70003E1E              
+	0x0F120C00,	// 70003E20              
+	0x0F124A96,	// 70003E22              
+	0x0F128A11,	// 70003E24              
+	0x0F129109,	// 70003E26              
+	0x0F122101,	// 70003E28              
+	0x0F120349,	// 70003E2A              
+	0x0F124288,	// 70003E2C              
+	0x0F12D200,	// 70003E2E              
+	0x0F120001,	// 70003E30              
+	0x0F124A92,	// 70003E32              
+	0x0F128211,	// 70003E34              
+	0x0F124D97,	// 70003E36              
+	0x0F128829,	// 70003E38              
+	0x0F129108,	// 70003E3A              
+	0x0F124A8B,	// 70003E3C              
+	0x0F122303,	// 70003E3E              
+	0x0F123222,	// 70003E40              
+	0x0F121F91,	// 70003E42              
+	0x0F12F000,	// 70003E44              
+	0x0F12FA96,	// 70003E46              
+	0x0F128028,	// 70003E48              
+	0x0F12488E,	// 70003E4A              
+	0x0F124987,	// 70003E4C              
+	0x0F126BC2,	// 70003E4E              
+	0x0F126AC0,	// 70003E50              
+	0x0F124282,	// 70003E52              
+	0x0F12D201,	// 70003E54              
+	0x0F128CC8,	// 70003E56              
+	0x0F128028,	// 70003E58              
+	0x0F1288E8,	// 70003E5A              
+	0x0F129007,	// 70003E5C              
+	0x0F122240,	// 70003E5E              
+	0x0F124310,	// 70003E60              
+	0x0F1280E8,	// 70003E62              
+	0x0F122000,	// 70003E64              
+	0x0F120041,	// 70003E66              
+	0x0F12194B,	// 70003E68              
+	0x0F12001E,	// 70003E6A              
+	0x0F123680,	// 70003E6C              
+	0x0F128BB2,	// 70003E6E              
+	0x0F12AF04,	// 70003E70              
+	0x0F12527A,	// 70003E72              
+	0x0F124A7D,	// 70003E74              
+	0x0F12188A,	// 70003E76              
+	0x0F128897,	// 70003E78              
+	0x0F1283B7,	// 70003E7A              
+	0x0F1233A0,	// 70003E7C              
+	0x0F12891F,	// 70003E7E              
+	0x0F12AE01,	// 70003E80              
+	0x0F125277,	// 70003E82              
+	0x0F128A11,	// 70003E84              
+	0x0F128119,	// 70003E86              
+	0x0F121C40,	// 70003E88              
+	0x0F120400,	// 70003E8A              
+	0x0F120C00,	// 70003E8C              
+	0x0F122806,	// 70003E8E              
+	0x0F12D3E9,	// 70003E90              
+	0x0F12F000,	// 70003E92              
+	0x0F12FA77,	// 70003E94              
+	0x0F12F000,	// 70003E96              
+	0x0F12FA7D,	// 70003E98              
+	0x0F124F79,	// 70003E9A              
+	0x0F1237A8,	// 70003E9C              
+	0x0F122800,	// 70003E9E              
+	0x0F12D10A,	// 70003EA0              
+	0x0F121FE0,	// 70003EA2              
+	0x0F1238FD,	// 70003EA4              
+	0x0F12D001,	// 70003EA6              
+	0x0F121CC0,	// 70003EA8              
+	0x0F12D105,	// 70003EAA              
+	0x0F124874,	// 70003EAC              
+	0x0F128829,	// 70003EAE              
+	0x0F123818,	// 70003EB0              
+	0x0F126840,	// 70003EB2              
+	0x0F124348,	// 70003EB4              
+	0x0F126078,	// 70003EB6              
+	0x0F124972,	// 70003EB8              
+	0x0F126878,	// 70003EBA              
+	0x0F126B89,	// 70003EBC              
+	0x0F124288,	// 70003EBE              
+	0x0F12D300,	// 70003EC0              
+	0x0F120008,	// 70003EC2              
+	0x0F126078,	// 70003EC4              
+	0x0F122000,	// 70003EC6              
+	0x0F120041,	// 70003EC8              
+	0x0F12AA04,	// 70003ECA              
+	0x0F125A53,	// 70003ECC              
+	0x0F12194A,	// 70003ECE              
+	0x0F12269C,	// 70003ED0              
+	0x0F1252B3,	// 70003ED2              
+	0x0F12AB01,	// 70003ED4              
+	0x0F125A59,	// 70003ED6              
+	0x0F1232A0,	// 70003ED8              
+	0x0F128111,	// 70003EDA              
+	0x0F121C40,	// 70003EDC              
+	0x0F120400,	// 70003EDE              
+	0x0F120C00,	// 70003EE0              
+	0x0F122806,	// 70003EE2              
+	0x0F12D3F0,	// 70003EE4              
+	0x0F124965,	// 70003EE6              
+	0x0F129809,	// 70003EE8              
+	0x0F128208,	// 70003EEA              
+	0x0F129808,	// 70003EEC              
+	0x0F128028,	// 70003EEE              
+	0x0F129807,	// 70003EF0              
+	0x0F1280E8,	// 70003EF2              
+	0x0F121FE0,	// 70003EF4              
+	0x0F1238FD,	// 70003EF6              
+	0x0F12D13B,	// 70003EF8              
+	0x0F124D64,	// 70003EFA              
+	0x0F1289E8,	// 70003EFC              
+	0x0F121FC1,	// 70003EFE              
+	0x0F1239FF,	// 70003F00              
+	0x0F12D136,	// 70003F02              
+	0x0F124C5F,	// 70003F04              
+	0x0F128AE0,	// 70003F06              
+	0x0F12F000,	// 70003F08              
+	0x0F12FA4C,	// 70003F0A              
+	0x0F120006,	// 70003F0C              
+	0x0F128B20,	// 70003F0E              
+	0x0F12F000,	// 70003F10              
+	0x0F12FA50,	// 70003F12              
+	0x0F129000,	// 70003F14              
+	0x0F126AA1,	// 70003F16              
+	0x0F126878,	// 70003F18              
+	0x0F121809,	// 70003F1A              
+	0x0F120200,	// 70003F1C              
+	0x0F12F000,	// 70003F1E              
+	0x0F12FA23,	// 70003F20              
+	0x0F120400,	// 70003F22              
+	0x0F120C00,	// 70003F24              
+	0x0F120022,	// 70003F26              
+	0x0F123246,	// 70003F28              
+	0x0F120011,	// 70003F2A              
+	0x0F12310A,	// 70003F2C              
+	0x0F122305,	// 70003F2E              
+	0x0F12F000,	// 70003F30              
+	0x0F12FA20,	// 70003F32              
+	0x0F1266E8,	// 70003F34              
+	0x0F126B23,	// 70003F36              
+	0x0F120002,	// 70003F38              
+	0x0F120031,	// 70003F3A              
+	0x0F120018,	// 70003F3C              
+	0x0F12F000,	// 70003F3E              
+	0x0F12FA41,	// 70003F40              
+	0x0F12466B,	// 70003F42              
+	0x0F128518,	// 70003F44              
+	0x0F126EEA,	// 70003F46              
+	0x0F126B60,	// 70003F48              
+	0x0F129900,	// 70003F4A              
+	0x0F12F000,	// 70003F4C              
+	0x0F12FA3A,	// 70003F4E              
+	0x0F12466B,	// 70003F50              
+	0x0F128558,	// 70003F52              
+	0x0F120029,	// 70003F54              
+	0x0F12980A,	// 70003F56              
+	0x0F123170,	// 70003F58              
+	0x0F12F000,	// 70003F5A              
+	0x0F12FA3B,	// 70003F5C              
+	0x0F120028,	// 70003F5E              
+	0x0F123060,	// 70003F60              
+	0x0F128A02,	// 70003F62              
+	0x0F124946,	// 70003F64              
+	0x0F123128,	// 70003F66              
+	0x0F12808A,	// 70003F68              
+	0x0F128A42,	// 70003F6A              
+	0x0F1280CA,	// 70003F6C              
+	0x0F128A80,	// 70003F6E              
+	0x0F128108,	// 70003F70              
+	0x0F12B00B,	// 70003F72              
+	0x0F12BCF0,	// 70003F74              
+	0x0F12BC08,	// 70003F76              
+	0x0F124718,	// 70003F78              
+	0x0F12B570,	// 70003F7A              
+	0x0F122400,	// 70003F7C              
+	0x0F124D46,	// 70003F7E              
+	0x0F124846,	// 70003F80              
+	0x0F128881,	// 70003F82              
+	0x0F124846,	// 70003F84              
+	0x0F128041,	// 70003F86              
+	0x0F122101,	// 70003F88              
+	0x0F128001,	// 70003F8A              
+	0x0F12F000,	// 70003F8C              
+	0x0F12FA2A,	// 70003F8E              
+	0x0F124842,	// 70003F90              
+	0x0F123820,	// 70003F92              
+	0x0F128BC0,	// 70003F94              
+	0x0F12F000,	// 70003F96              
+	0x0F12FA2D,	// 70003F98              
+	0x0F124B42,	// 70003F9A              
+	0x0F12220D,	// 70003F9C              
+	0x0F120712,	// 70003F9E              
+	0x0F1218A8,	// 70003FA0              
+	0x0F128806,	// 70003FA2              
+	0x0F1200E1,	// 70003FA4              
+	0x0F1218C9,	// 70003FA6              
+	0x0F1281CE,	// 70003FA8              
+	0x0F128846,	// 70003FAA              
+	0x0F12818E,	// 70003FAC              
+	0x0F128886,	// 70003FAE              
+	0x0F12824E,	// 70003FB0              
+	0x0F1288C0,	// 70003FB2              
+	0x0F128208,	// 70003FB4              
+	0x0F123508,	// 70003FB6              
+	0x0F12042D,	// 70003FB8              
+	0x0F120C2D,	// 70003FBA              
+	0x0F121C64,	// 70003FBC              
+	0x0F120424,	// 70003FBE              
+	0x0F120C24,	// 70003FC0              
+	0x0F122C07,	// 70003FC2              
+	0x0F12D3EC,	// 70003FC4              
+	0x0F12E658,	// 70003FC6              
+	0x0F12B510,	// 70003FC8              
+	0x0F124834,	// 70003FCA              
+	0x0F124C34,	// 70003FCC              
+	0x0F1288C0,	// 70003FCE              
+	0x0F128060,	// 70003FD0              
+	0x0F122001,	// 70003FD2              
+	0x0F128020,	// 70003FD4              
+	0x0F124831,	// 70003FD6              
+	0x0F123820,	// 70003FD8              
+	0x0F128BC0,	// 70003FDA              
+	0x0F12F000,	// 70003FDC              
+	0x0F12FA0A,	// 70003FDE              
+	0x0F1288E0,	// 70003FE0              
+	0x0F124A31,	// 70003FE2              
+	0x0F122800,	// 70003FE4              
+	0x0F12D003,	// 70003FE6              
+	0x0F124930,	// 70003FE8              
+	0x0F128849,	// 70003FEA              
+	0x0F122900,	// 70003FEC              
+	0x0F12D009,	// 70003FEE              
+	0x0F122001,	// 70003FF0              
+	0x0F1203C0,	// 70003FF2              
+	0x0F128050,	// 70003FF4              
+	0x0F1280D0,	// 70003FF6              
+	0x0F122000,	// 70003FF8              
+	0x0F128090,	// 70003FFA              
+	0x0F128110,	// 70003FFC              
+	0x0F12BC10,	// 70003FFE              
+	0x0F12BC08,	// 70004000              
+	0x0F124718,	// 70004002              
+	0x0F128050,	// 70004004              
+	0x0F128920,	// 70004006              
+	0x0F1280D0,	// 70004008              
+	0x0F128960,	// 7000400A              
+	0x0F120400,	// 7000400C              
+	0x0F121400,	// 7000400E              
+	0x0F128090,	// 70004010              
+	0x0F1289A1,	// 70004012              
+	0x0F120409,	// 70004014              
+	0x0F121409,	// 70004016              
+	0x0F128111,	// 70004018              
+	0x0F1289E3,	// 7000401A              
+	0x0F128A24,	// 7000401C              
+	0x0F122B00,	// 7000401E              
+	0x0F12D104,	// 70004020              
+	0x0F1217C3,	// 70004022              
+	0x0F120F5B,	// 70004024              
+	0x0F121818,	// 70004026              
+	0x0F1210C0,	// 70004028              
+	0x0F128090,	// 7000402A              
+	0x0F122C00,	// 7000402C              
+	0x0F12D1E6,	// 7000402E              
+	0x0F1217C8,	// 70004030              
+	0x0F120F40,	// 70004032              
+	0x0F121840,	// 70004034              
+	0x0F1210C0,	// 70004036              
+	0x0F128110,	// 70004038              
+	0x0F12E7E0,	// 7000403A              
+	0x0F12B510,	// 7000403C              
+	0x0F12000C,	// 7000403E              
+	0x0F124919,	// 70004040              
+	0x0F122204,	// 70004042              
+	0x0F126820,	// 70004044              
+	0x0F125E8A,	// 70004046              
+	0x0F120140,	// 70004048              
+	0x0F121A80,	// 7000404A              
+	0x0F120280,	// 7000404C              
+	0x0F128849,	// 7000404E              
+	0x0F12F000,	// 70004050              
+	0x0F12F9D8,	// 70004052              
+	0x0F126020,	// 70004054              
+	0x0F12E7D2,	// 70004056              
+	0x0F1238D4,	// 70004058              
+	0x0F127000,	// 7000405A              
+	0x0F1217D0,	// 7000405C              
+	0x0F127000,	// 7000405E              
+	0x0F125000,	// 70004060              
+	0x0F12D000,	// 70004062              
+	0x0F121100,	// 70004064              
+	0x0F12D000,	// 70004066              
+	0x0F12171A,	// 70004068              
+	0x0F127000,	// 7000406A              
+	0x0F124780,	// 7000406C              
+	0x0F127000,	// 7000406E              
+	0x0F122FCA,	// 70004070              
+	0x0F127000,	// 70004072              
+	0x0F122FC5,	// 70004074              
+	0x0F127000,	// 70004076              
+	0x0F122FC6,	// 70004078              
+	0x0F127000,	// 7000407A              
+	0x0F122ED8,	// 7000407C              
+	0x0F127000,	// 7000407E              
+	0x0F122BD0,	// 70004080              
+	0x0F127000,	// 70004082              
+	0x0F1217E0,	// 70004084              
+	0x0F127000,	// 70004086              
+	0x0F122DE8,	// 70004088              
+	0x0F127000,	// 7000408A              
+	0x0F1237E0,	// 7000408C              
+	0x0F127000,	// 7000408E              
+	0x0F12210C,	// 70004090              
+	0x0F127000,	// 70004092              
+	0x0F121484,	// 70004094              
+	0x0F127000,	// 70004096              
+	0x0F12A006,	// 70004098              
+	0x0F120000,	// 7000409A              
+	0x0F120724,	// 7000409C              
+	0x0F127000,	// 7000409E              
+	0x0F12A000,	// 700040A0              
+	0x0F12D000,	// 700040A2              
+	0x0F122270,	// 700040A4              
+	0x0F127000,	// 700040A6              
+	0x0F122558,	// 700040A8              
+	0x0F127000,	// 700040AA              
+	0x0F12146C,	// 700040AC              
+	0x0F127000,	// 700040AE              
+	0x0F12B510,	// 700040B0              
+	0x0F12000C,	// 700040B2              
+	0x0F124983,	// 700040B4              
+	0x0F122208,	// 700040B6              
+	0x0F126820,	// 700040B8              
+	0x0F125E8A,	// 700040BA              
+	0x0F120140,	// 700040BC              
+	0x0F121A80,	// 700040BE              
+	0x0F120280,	// 700040C0              
+	0x0F1288C9,	// 700040C2              
+	0x0F12F000,	// 700040C4              
+	0x0F12F99E,	// 700040C6              
+	0x0F126020,	// 700040C8              
+	0x0F12E798,	// 700040CA              
+	0x0F12B5FE,	// 700040CC              
+	0x0F12000C,	// 700040CE              
+	0x0F126825,	// 700040D0              
+	0x0F126866,	// 700040D2              
+	0x0F1268A0,	// 700040D4              
+	0x0F129001,	// 700040D6              
+	0x0F1268E7,	// 700040D8              
+	0x0F121BA8,	// 700040DA              
+	0x0F1242B5,	// 700040DC              
+	0x0F12DA00,	// 700040DE              
+	0x0F121B70,	// 700040E0              
+	0x0F129000,	// 700040E2              
+	0x0F124977,	// 700040E4              
+	0x0F124878,	// 700040E6              
+	0x0F12884A,	// 700040E8              
+	0x0F128843,	// 700040EA              
+	0x0F12435A,	// 700040EC              
+	0x0F122304,	// 700040EE              
+	0x0F125ECB,	// 700040F0              
+	0x0F120A92,	// 700040F2              
+	0x0F1218D2,	// 700040F4              
+	0x0F1202D2,	// 700040F6              
+	0x0F120C12,	// 700040F8              
+	0x0F1288CB,	// 700040FA              
+	0x0F128880,	// 700040FC              
+	0x0F124343,	// 700040FE              
+	0x0F120A98,	// 70004100              
+	0x0F122308,	// 70004102              
+	0x0F125ECB,	// 70004104              
+	0x0F1218C0,	// 70004106              
+	0x0F1202C0,	// 70004108              
+	0x0F120C00,	// 7000410A              
+	0x0F120411,	// 7000410C              
+	0x0F120400,	// 7000410E              
+	0x0F121409,	// 70004110              
+	0x0F121400,	// 70004112              
+	0x0F121A08,	// 70004114              
+	0x0F12496C,	// 70004116              
+	0x0F1239E0,	// 70004118              
+	0x0F126148,	// 7000411A              
+	0x0F129801,	// 7000411C              
+	0x0F123040,	// 7000411E              
+	0x0F127880,	// 70004120              
+	0x0F122800,	// 70004122              
+	0x0F12D103,	// 70004124              
+	0x0F129801,	// 70004126              
+	0x0F120029,	// 70004128              
+	0x0F12F000,	// 7000412A              
+	0x0F12F971,	// 7000412C              
+	0x0F128839,	// 7000412E              
+	0x0F129800,	// 70004130              
+	0x0F124281,	// 70004132              
+	0x0F12D814,	// 70004134              
+	0x0F128879,	// 70004136              
+	0x0F129800,	// 70004138              
+	0x0F124281,	// 7000413A              
+	0x0F12D20C,	// 7000413C              
+	0x0F129801,	// 7000413E              
+	0x0F120029,	// 70004140              
+	0x0F12F000,	// 70004142              
+	0x0F12F96D,	// 70004144              
+	0x0F129801,	// 70004146              
+	0x0F120029,	// 70004148              
+	0x0F12F000,	// 7000414A              
+	0x0F12F969,	// 7000414C              
+	0x0F129801,	// 7000414E              
+	0x0F120029,	// 70004150              
+	0x0F12F000,	// 70004152              
+	0x0F12F965,	// 70004154              
+	0x0F12E003,	// 70004156              
+	0x0F129801,	// 70004158              
+	0x0F120029,	// 7000415A              
+	0x0F12F000,	// 7000415C              
+	0x0F12F960,	// 7000415E              
+	0x0F129801,	// 70004160              
+	0x0F120032,	// 70004162              
+	0x0F120039,	// 70004164              
+	0x0F12F000,	// 70004166              
+	0x0F12F963,	// 70004168              
+	0x0F126020,	// 7000416A              
+	0x0F12E5D0,	// 7000416C              
+	0x0F12B57C,	// 7000416E              
+	0x0F124856,	// 70004170              
+	0x0F12A901,	// 70004172              
+	0x0F120004,	// 70004174              
+	0x0F12F000,	// 70004176              
+	0x0F12F8E7,	// 70004178              
+	0x0F12466B,	// 7000417A              
+	0x0F1288D9,	// 7000417C              
+	0x0F128898,	// 7000417E              
+	0x0F124B51,	// 70004180              
+	0x0F123346,	// 70004182              
+	0x0F121E9A,	// 70004184              
+	0x0F12F000,	// 70004186              
+	0x0F12F95B,	// 70004188              
+	0x0F124850,	// 7000418A              
+	0x0F12494E,	// 7000418C              
+	0x0F123812,	// 7000418E              
+	0x0F123140,	// 70004190              
+	0x0F128A42,	// 70004192              
+	0x0F12888B,	// 70004194              
+	0x0F1218D2,	// 70004196              
+	0x0F128242,	// 70004198              
+	0x0F128AC2,	// 7000419A              
+	0x0F1288C9,	// 7000419C              
+	0x0F121851,	// 7000419E              
+	0x0F1282C1,	// 700041A0              
+	0x0F120020,	// 700041A2              
+	0x0F124669,	// 700041A4              
+	0x0F12F000,	// 700041A6              
+	0x0F12F8CF,	// 700041A8              
+	0x0F124849,	// 700041AA              
+	0x0F12214D,	// 700041AC              
+	0x0F128301,	// 700041AE              
+	0x0F122196,	// 700041B0              
+	0x0F128381,	// 700041B2              
+	0x0F12211D,	// 700041B4              
+	0x0F123020,	// 700041B6              
+	0x0F128001,	// 700041B8              
+	0x0F12F000,	// 700041BA              
+	0x0F12F949,	// 700041BC              
+	0x0F12F000,	// 700041BE              
+	0x0F12F94F,	// 700041C0              
+	0x0F124844,	// 700041C2              
+	0x0F124C44,	// 700041C4              
+	0x0F126E00,	// 700041C6              
+	0x0F1260E0,	// 700041C8              
+	0x0F12466B,	// 700041CA              
+	0x0F128818,	// 700041CC              
+	0x0F128859,	// 700041CE              
+	0x0F120025,	// 700041D0              
+	0x0F121A40,	// 700041D2              
+	0x0F123540,	// 700041D4              
+	0x0F1261A8,	// 700041D6              
+	0x0F12483B,	// 700041D8              
+	0x0F129900,	// 700041DA              
+	0x0F123060,	// 700041DC              
+	0x0F12F000,	// 700041DE              
+	0x0F12F947,	// 700041E0              
+	0x0F12466B,	// 700041E2              
+	0x0F128819,	// 700041E4              
+	0x0F121DE0,	// 700041E6              
+	0x0F1230F9,	// 700041E8              
+	0x0F128741,	// 700041EA              
+	0x0F128859,	// 700041EC              
+	0x0F128781,	// 700041EE              
+	0x0F122000,	// 700041F0              
+	0x0F1271A0,	// 700041F2              
+	0x0F1274A8,	// 700041F4              
+	0x0F12BC7C,	// 700041F6              
+	0x0F12BC08,	// 700041F8              
+	0x0F124718,	// 700041FA              
+	0x0F12B5F8,	// 700041FC              
+	0x0F120005,	// 700041FE              
+	0x0F126808,	// 70004200              
+	0x0F120400,	// 70004202              
+	0x0F120C00,	// 70004204              
+	0x0F12684A,	// 70004206              
+	0x0F120412,	// 70004208              
+	0x0F120C12,	// 7000420A              
+	0x0F12688E,	// 7000420C              
+	0x0F1268CC,	// 7000420E              
+	0x0F12492C,	// 70004210              
+	0x0F12884B,	// 70004212              
+	0x0F124343,	// 70004214              
+	0x0F120A98,	// 70004216              
+	0x0F122304,	// 70004218              
+	0x0F125ECB,	// 7000421A              
+	0x0F1218C0,	// 7000421C              
+	0x0F1202C0,	// 7000421E              
+	0x0F120C00,	// 70004220              
+	0x0F1288CB,	// 70004222              
+	0x0F124353,	// 70004224              
+	0x0F120A9A,	// 70004226              
+	0x0F122308,	// 70004228              
+	0x0F125ECB,	// 7000422A              
+	0x0F1218D1,	// 7000422C              
+	0x0F1202C9,	// 7000422E              
+	0x0F120C09,	// 70004230              
+	0x0F122701,	// 70004232              
+	0x0F12003A,	// 70004234              
+	0x0F1240AA,	// 70004236              
+	0x0F129200,	// 70004238              
+	0x0F12002A,	// 7000423A              
+	0x0F123A10,	// 7000423C              
+	0x0F124097,	// 7000423E              
+	0x0F122D10,	// 70004240              
+	0x0F12DA06,	// 70004242              
+	0x0F124A25,	// 70004244              
+	0x0F129B00,	// 70004246              
+	0x0F128812,	// 70004248              
+	0x0F12439A,	// 7000424A              
+	0x0F124B23,	// 7000424C              
+	0x0F12801A,	// 7000424E              
+	0x0F12E003,	// 70004250              
+	0x0F124B22,	// 70004252              
+	0x0F12885A,	// 70004254              
+	0x0F1243BA,	// 70004256              
+	0x0F12805A,	// 70004258              
+	0x0F120023,	// 7000425A              
+	0x0F120032,	// 7000425C              
+	0x0F12F000,	// 7000425E              
+	0x0F12F8EF,	// 70004260              
+	0x0F122D10,	// 70004262              
+	0x0F12DA05,	// 70004264              
+	0x0F12491D,	// 70004266              
+	0x0F129A00,	// 70004268              
+	0x0F128808,	// 7000426A              
+	0x0F124310,	// 7000426C              
+	0x0F128008,	// 7000426E              
+	0x0F12E003,	// 70004270              
+	0x0F12481A,	// 70004272              
+	0x0F128841,	// 70004274              
+	0x0F124339,	// 70004276              
+	0x0F128041,	// 70004278              
+	0x0F124D17,	// 7000427A              
+	0x0F122000,	// 7000427C              
+	0x0F123580,	// 7000427E              
+	0x0F1288AA,	// 70004280              
+	0x0F125E30,	// 70004282              
+	0x0F122100,	// 70004284              
+	0x0F12F000,	// 70004286              
+	0x0F12F8FB,	// 70004288              
+	0x0F128030,	// 7000428A              
+	0x0F122000,	// 7000428C              
+	0x0F1288AA,	// 7000428E              
+	0x0F125E20,	// 70004290              
+	0x0F122100,	// 70004292              
+	0x0F12F000,	// 70004294              
+	0x0F12F8F4,	// 70004296              
+	0x0F128020,	// 70004298              
+	0x0F12E587,	// 7000429A              
+	0x0F12B510,	// 7000429C              
+	0x0F12F000,	// 7000429E              
+	0x0F12F8F7,	// 700042A0              
+	0x0F124A0F,	// 700042A2              
+	0x0F128D50,	// 700042A4              
+	0x0F122800,	// 700042A6              
+	0x0F12D007,	// 700042A8              
+	0x0F12490A,	// 700042AA              
+	0x0F1231C0,	// 700042AC              
+	0x0F12684B,	// 700042AE              
+	0x0F12490C,	// 700042B0              
+	0x0F124283,	// 700042B2              
+	0x0F12D202,	// 700042B4              
+	0x0F128D90,	// 700042B6              
+	0x0F1281C8,	// 700042B8              
+	0x0F12E6A0,	// 700042BA              
+	0x0F128DD0,	// 700042BC              
+	0x0F1281C8,	// 700042BE              
+	0x0F12E69D,	// 700042C0              
+	0x0F120000,	// 700042C2              
+	0x0F122558,	// 700042C4              
+	0x0F127000,	// 700042C6              
+	0x0F122AB8,	// 700042C8              
+	0x0F127000,	// 700042CA              
+	0x0F12145E,	// 700042CC              
+	0x0F127000,	// 700042CE              
+	0x0F122698,	// 700042D0              
+	0x0F127000,	// 700042D2              
+	0x0F122BB8,	// 700042D4              
+	0x0F127000,	// 700042D6              
+	0x0F122998,	// 700042D8              
+	0x0F127000,	// 700042DA              
+	0x0F121100,	// 700042DC              
+	0x0F12D000,	// 700042DE              
+	0x0F124780,	// 700042E0              
+	0x0F127000,	// 700042E2              
+	0x0F12E200,	// 700042E4              
+	0x0F12D000,	// 700042E6              
+	0x0F124778,	// 700042E8              
+	0x0F1246C0,	// 700042EA              
+	0x0F12C000,	// 700042EC              
+	0x0F12E59F,	// 700042EE              
+	0x0F12FF1C,	// 700042F0              
+	0x0F12E12F,	// 700042F2              
+	0x0F121789,	// 700042F4              
+	0x0F120001,	// 700042F6              
+	0x0F124778,	// 700042F8              
+	0x0F1246C0,	// 700042FA              
+	0x0F12C000,	// 700042FC              
+	0x0F12E59F,	// 700042FE              
+	0x0F12FF1C,	// 70004300              
+	0x0F12E12F,	// 70004302              
+	0x0F1216F1,	// 70004304              
+	0x0F120001,	// 70004306              
+	0x0F124778,	// 70004308              
+	0x0F1246C0,	// 7000430A              
+	0x0F12C000,	// 7000430C              
+	0x0F12E59F,	// 7000430E              
+	0x0F12FF1C,	// 70004310              
+	0x0F12E12F,	// 70004312              
+	0x0F12C3B1,	// 70004314              
+	0x0F120000,	// 70004316              
+	0x0F124778,	// 70004318              
+	0x0F1246C0,	// 7000431A              
+	0x0F12C000,	// 7000431C              
+	0x0F12E59F,	// 7000431E              
+	0x0F12FF1C,	// 70004320              
+	0x0F12E12F,	// 70004322              
+	0x0F12C36D,	// 70004324              
+	0x0F120000,	// 70004326              
+	0x0F124778,	// 70004328              
+	0x0F1246C0,	// 7000432A              
+	0x0F12C000,	// 7000432C              
+	0x0F12E59F,	// 7000432E              
+	0x0F12FF1C,	// 70004330              
+	0x0F12E12F,	// 70004332              
+	0x0F12F6D7,	// 70004334              
+	0x0F120000,	// 70004336              
+	0x0F124778,	// 70004338              
+	0x0F1246C0,	// 7000433A              
+	0x0F12C000,	// 7000433C              
+	0x0F12E59F,	// 7000433E              
+	0x0F12FF1C,	// 70004340              
+	0x0F12E12F,	// 70004342              
+	0x0F12B49D,	// 70004344              
+	0x0F120000,	// 70004346              
+	0x0F124778,	// 70004348              
+	0x0F1246C0,	// 7000434A              
+	0x0F12C000,	// 7000434C              
+	0x0F12E59F,	// 7000434E              
+	0x0F12FF1C,	// 70004350              
+	0x0F12E12F,	// 70004352              
+	0x0F127EDF,	// 70004354              
+	0x0F120000,	// 70004356              
+	0x0F124778,	// 70004358              
+	0x0F1246C0,	// 7000435A              
+	0x0F12C000,	// 7000435C              
+	0x0F12E59F,	// 7000435E              
+	0x0F12FF1C,	// 70004360              
+	0x0F12E12F,	// 70004362              
+	0x0F12448D,	// 70004364              
+	0x0F120000,	// 70004366              
+	0x0F124778,	// 70004368              
+	0x0F1246C0,	// 7000436A              
+	0x0F12F004,	// 7000436C              
+	0x0F12E51F,	// 7000436E              
+	0x0F1229EC,	// 70004370              
+	0x0F120001,	// 70004372              
+	0x0F124778,	// 70004374              
+	0x0F1246C0,	// 70004376              
+	0x0F12C000,	// 70004378              
+	0x0F12E59F,	// 7000437A              
+	0x0F12FF1C,	// 7000437C              
+	0x0F12E12F,	// 7000437E              
+	0x0F122EF1,	// 70004380              
+	0x0F120000,	// 70004382              
+	0x0F124778,	// 70004384              
+	0x0F1246C0,	// 70004386              
+	0x0F12C000,	// 70004388              
+	0x0F12E59F,	// 7000438A              
+	0x0F12FF1C,	// 7000438C              
+	0x0F12E12F,	// 7000438E              
+	0x0F12EE03,	// 70004390              
+	0x0F120000,	// 70004392              
+	0x0F124778,	// 70004394              
+	0x0F1246C0,	// 70004396              
+	0x0F12C000,	// 70004398              
+	0x0F12E59F,	// 7000439A              
+	0x0F12FF1C,	// 7000439C              
+	0x0F12E12F,	// 7000439E              
+	0x0F12A58B,	// 700043A0              
+	0x0F120000,	// 700043A2              
+	0x0F124778,	// 700043A4              
+	0x0F1246C0,	// 700043A6              
+	0x0F12C000,	// 700043A8              
+	0x0F12E59F,	// 700043AA              
+	0x0F12FF1C,	// 700043AC              
+	0x0F12E12F,	// 700043AE              
+	0x0F127C49,	// 700043B0              
+	0x0F120000,	// 700043B2              
+	0x0F124778,	// 700043B4              
+	0x0F1246C0,	// 700043B6              
+	0x0F12C000,	// 700043B8              
+	0x0F12E59F,	// 700043BA              
+	0x0F12FF1C,	// 700043BC              
+	0x0F12E12F,	// 700043BE              
+	0x0F127C63,	// 700043C0              
+	0x0F120000,	// 700043C2              
+	0x0F124778,	// 700043C4              
+	0x0F1246C0,	// 700043C6              
+	0x0F12C000,	// 700043C8              
+	0x0F12E59F,	// 700043CA              
+	0x0F12FF1C,	// 700043CC              
+	0x0F12E12F,	// 700043CE              
+	0x0F122DB7,	// 700043D0              
+	0x0F120000,	// 700043D2              
+	0x0F124778,	// 700043D4              
+	0x0F1246C0,	// 700043D6              
+	0x0F12C000,	// 700043D8              
+	0x0F12E59F,	// 700043DA              
+	0x0F12FF1C,	// 700043DC              
+	0x0F12E12F,	// 700043DE              
+	0x0F12EB3D,	// 700043E0              
+	0x0F120000,	// 700043E2              
+	0x0F124778,	// 700043E4              
+	0x0F1246C0,	// 700043E6              
+	0x0F12C000,	// 700043E8              
+	0x0F12E59F,	// 700043EA              
+	0x0F12FF1C,	// 700043EC              
+	0x0F12E12F,	// 700043EE              
+	0x0F12F061,	// 700043F0              
+	0x0F120000,	// 700043F2              
+	0x0F124778,	// 700043F4              
+	0x0F1246C0,	// 700043F6              
+	0x0F12C000,	// 700043F8              
+	0x0F12E59F,	// 700043FA              
+	0x0F12FF1C,	// 700043FC              
+	0x0F12E12F,	// 700043FE              
+	0x0F12F0EF,	// 70004400              
+	0x0F120000,	// 70004402              
+	0x0F124778,	// 70004404              
+	0x0F1246C0,	// 70004406              
+	0x0F12F004,	// 70004408              
+	0x0F12E51F,	// 7000440A              
+	0x0F122824,	// 7000440C              
+	0x0F120001,	// 7000440E              
+	0x0F124778,	// 70004410              
+	0x0F1246C0,	// 70004412              
+	0x0F12C000,	// 70004414              
+	0x0F12E59F,	// 70004416              
+	0x0F12FF1C,	// 70004418              
+	0x0F12E12F,	// 7000441A              
+	0x0F128EDD,	// 7000441C              
+	0x0F120000,	// 7000441E              
+	0x0F124778,	// 70004420              
+	0x0F1246C0,	// 70004422              
+	0x0F12C000,	// 70004424              
+	0x0F12E59F,	// 70004426              
+	0x0F12FF1C,	// 70004428              
+	0x0F12E12F,	// 7000442A              
+	0x0F128DCB,	// 7000442C              
+	0x0F120000,	// 7000442E              
+	0x0F124778,	// 70004430              
+	0x0F1246C0,	// 70004432              
+	0x0F12C000,	// 70004434              
+	0x0F12E59F,	// 70004436              
+	0x0F12FF1C,	// 70004438              
+	0x0F12E12F,	// 7000443A              
+	0x0F128E17,	// 7000443C              
+	0x0F120000,	// 7000443E              
+	0x0F124778,	// 70004440              
+	0x0F1246C0,	// 70004442              
+	0x0F12C000,	// 70004444              
+	0x0F12E59F,	// 70004446              
+	0x0F12FF1C,	// 70004448              
+	0x0F12E12F,	// 7000444A              
+	0x0F1298C5,	// 7000444C              
+	0x0F120000,	// 7000444E              
+	0x0F124778,	// 70004450              
+	0x0F1246C0,	// 70004452              
+	0x0F12C000,	// 70004454              
+	0x0F12E59F,	// 70004456              
+	0x0F12FF1C,	// 70004458              
+	0x0F12E12F,	// 7000445A              
+	0x0F127C7D,	// 7000445C              
+	0x0F120000,	// 7000445E              
+	0x0F124778,	// 70004460              
+	0x0F1246C0,	// 70004462              
+	0x0F12C000,	// 70004464              
+	0x0F12E59F,	// 70004466              
+	0x0F12FF1C,	// 70004468              
+	0x0F12E12F,	// 7000446A              
+	0x0F127E31,	// 7000446C              
+	0x0F120000,	// 7000446E              
+	0x0F124778,	// 70004470              
+	0x0F1246C0,	// 70004472              
+	0x0F12C000,	// 70004474              
+	0x0F12E59F,	// 70004476              
+	0x0F12FF1C,	// 70004478              
+	0x0F12E12F,	// 7000447A              
+	0x0F127EAB,	// 7000447C              
+	0x0F120000,	// 7000447E              
+	0x0F124778,	// 70004480              
+	0x0F1246C0,	// 70004482              
+	0x0F12C000,	// 70004484              
+	0x0F12E59F,	// 70004486              
+	0x0F12FF1C,	// 70004488              
+	0x0F12E12F,	// 7000448A              
+	0x0F127501,	// 7000448C              
+	0x0F120000,	// 7000448E              
+	0x0F124778,	// 70004490              
+	0x0F1246C0,	// 70004492              
+	0x0F12C000,	// 70004494              
+	0x0F12E59F,	// 70004496              
+	0x0F12FF1C,	// 70004498              
+	0x0F12E12F,	// 7000449A              
+	0x0F12F63F,	// 7000449C              
+	0x0F120000,	// 7000449E      
+// End of Patch Data(Last : 7000449Eh)
+// Total Size 2472 (0x09A8)           
+// Addr : 3AF8 , Size : 2470(9A6h)  
+
+	0x0028D000,
+	0x002A1000,
+	0x0F120001,
+  
+	/* 08.AF Setting */
+	0x00287000,  
+	0x002A01FC,  
+	0x0F120001,	//REG_TC_IPRM_LedGpio                                      
+	0x002A01FE,  
+	0x0F120003,	//REG_TC_IPRM_CM_Init_AfModeType VCM IIC                   
+	0x0F120000,	//REG_TC_IPRM_CM_Init_PwmConfig1                           
+	0x002A0204,  
+	0x0F120061,	//REG_TC_IPRM_CM_Init_GpioConfig1 AF Enable GPIO 6      
+	0x002A020C,  
+	0x0F122F0C,	//REG_TC_IPRM_CM_Init_Mi2cBits                             
+	0x0F120190,	//REG_TC_IPRM_CM_Init_Mi2cRateKhz IIC Speed     
+	0x002A0294,  
+	0x0F120100,	//REG_TC_AF_FstWinStartX                                   
+	0x0F1200E3,	//REG_TC_AF_FstWinStartY                                   
+	0x0F120200,	//REG_TC_AF_FstWinSizeX                                    
+	0x0F120238,	//REG_TC_AF_FstWinSizeY                                    
+	0x0F1201C6,	//REG_TC_AF_ScndWinStartX                                  
+	0x0F120166,	//REG_TC_AF_ScndWinStartY                                  
+	0x0F120074,	//REG_TC_AF_ScndWinSizeX                                   
+	0x0F120132,	//REG_TC_AF_ScndWinSizeY                                   
+	0x0F120001,	//REG_TC_AF_WinSizesUpdated                                
+	0x002A070E,  
+	0x0F1200FF,	//C0         //skl_af_StatOvlpExpFactor
+	0x002A071E,  
+	0x0F120000,	//01 00      //skl_af_bAfStatOff
+	0x002A163C,  
+	0x0F120000,	//af_search_usAeStable                                     
+	0x002A1648,  
+	0x0F129002,	//af_search_usSingleAfFlags                                
+	0x002A1652,  
+	0x0F120002,	//af_search_usFinePeakCount                                
+	0x0F120000,	//af_search_usFineMaxScale                                 
+	0x002A15E0,  
+	0x0F120902,	//af_pos_usFineStepNumSize                                 
+	0x002A164C,  
+	0x0F120003,	//af_search_usMinPeakSamples                               
+	0x002A163E, 
+	0x0F1200E5,	//80 //8a //A0       //A0 af_search_usPeakThr Full search (E5 90%)
+	0x0F120098,	//80 //a0 //8a  //98 //98 af_search_usPeakThrLow
+	0x002A15D4,
+	0x0F120000,	//af_pos_usHomePos                                         
+	0x0F12D000,	//af_pos_usLowConfPos                                      
+	0x002A169A, 
+	0x0F12FF95,	//af_search_usConfCheckOrder_1_                            
+	0x002A166A,  
+	0x0F120280,	//af_search_usConfThr_4_                                   
+	0x002A1676,  
+	0x0F1203A0,	//af_search_usConfThr_10_                                  
+	0x0F120320,	//af_search_usConfThr_11_                                  
+	0x002A16BC,  
+	0x0F120030,	//af_stat_usMinStatVal                                     
+	0x002A16E0,
+	0x0F120060,	//af_scene_usSceneLowNormBrThr                             
+	0x002A16D4,  
+	0x0F120010,	//af_stat_usBpfThresh                                      
+	0x002A1656,  
+	0x0F120000,	//af_search_usCapturePolicy                                
+	0x002A15E6,  
+	0x0F12003C,	//af_pos_usCaptureFixedPos                                 
+	0x0F120018, 	//af_pos_usTableLastInd                                    
+	0x0F12002A,	//af_pos_usTable_0_                                        
+	0x0F120030,	//af_pos_usTable_1_                                        
+	0x0F120036,	//af_pos_usTable_2_                                        
+	0x0F12003C,	//af_pos_usTable_3_                                        
+	0x0F120042,	//af_pos_usTable_4_  
+	0x0F120048,	//af_pos_usTable_5_                                        
+	0x0F12004E,	//af_pos_usTable_6_                                        
+	0x0F120054,	//af_pos_usTable_7_                                        
+	0x0F12005A,	//af_pos_usTable_8_                                        
+	0x0F120060,	//af_pos_usTable_9_                                        
+	0x0F120066,	//af_pos_usTable_10 
+	0x0F12006C,	//af_pos_usTable_11_                                       
+	0x0F120072,	//af_pos_usTable_12_                                       
+	0x0F120078,	//af_pos_usTable_13_                                       
+	0x0F12007E,	//af_pos_usTable_14_                                       
+	0x0F120084,	//af_pos_usTable_15_ 
+	0x0F12008A,	//af_pos_usTable_16_                                       
+	0x0F120090,	//af_pos_usTable_17_                                       
+	0x0F120096,	//af_pos_usTable_18_                                       
+	0x0F12009C,	//af_pos_usTable_19_                                       
+	0x0F1200A2,	//af_pos_usTable_20_                                       
+	0x0F1200A8,	//af_pos_usTable_21_                                       
+	0x0F1200AE,	//af_pos_usTable_22_                                       
+	0x0F1200B4,	//af_pos_usTable_23_                                       
+	0x0F1200BA,	//af_pos_usTable_24_  
+	0x002A1722, 
+	0x0F128000,	//afd_usParam_0_                                           
+	0x0F120006,	//afd_usParam_1_                                           
+	0x0F123FF0,	//afd_usParam_2_                                           
+	0x0F1203E8,	//afd_usParam_3_                                           
+	0x0F120000,	//afd_usParam_4_                                           
+	0x0F120080,	//10 afd_usParam_5_
+	0x0F120010,	//10 afd_usParam_6_                                          
+	0x0F120010,	//08 afd_usParam_7_
+	0x0F120040,	//afd_usParam_8_                                           
+	0x0F120080,	//afd_usParam_9_                                           
+	0x0F1200C0,	//afd_usParam_10_                                          
+	0x0F1200E0,	//afd_usParam_11_                                          
+	0x002A028C, 
+	0x0F120003,	//REG_TC_AF_AfCmd         
+
+	/* 06.Gas_Anti Shading */
+	// Refer Mon_AWB_RotGain                
+	0x00287000,
+	0x002A08B4,
+	0x0F120001,	//wbt_bUseOutdoorASH    
+	0x002A08BC, 
+	0x0F1200C0,	//TVAR_ash_AwbAshCord_0_ 2300K  
+	0x0F1200DF,	//TVAR_ash_AwbAshCord_1_ 2750K  
+	0x0F120100,	//TVAR_ash_AwbAshCord_2_ 3300K  
+	0x0F120125,	//TVAR_ash_AwbAshCord_3_ 4150K  
+	0x0F12015F,	//TVAR_ash_AwbAshCord_4_ 5250K  
+	0x0F12017C,	//TVAR_ash_AwbAshCord_5_ 6400K  
+	0x0F120194,	//TVAR_ash_AwbAshCord_6_ 7500K  
+	0x002A08F6, 
+	0x0F124000,	//TVAR_ash_GASAlpha_0__0_ R  // 2300K           
+	0x0F124000,	//TVAR_ash_GASAlpha_0__1_ GR          
+	0x0F124000,	//TVAR_ash_GASAlpha_0__2_ GB          
+	0x0F124000,	//TVAR_ash_GASAlpha_0__3_ B    
+	0x0F124000,	//TVAR_ash_GASAlpha_1__0_ R  // 2750K 
+	0x0F124000,	//TVAR_ash_GASAlpha_1__1_ GR          
+	0x0F124000,	//TVAR_ash_GASAlpha_1__2_ GB  
+	0x0F124000,	//TVAR_ash_GASAlpha_1__3_ B   
+	0x0F124000,	//TVAR_ash_GASAlpha_2__0_ R  // 3300K 
+	0x0F124000,	//TVAR_ash_GASAlpha_2__1_ GR          
+	0x0F124000,	//TVAR_ash_GASAlpha_2__2_ GB          
+	0x0F124000,	//TVAR_ash_GASAlpha_2__3_ B   
+	0x0F124000,	//TVAR_ash_GASAlpha_3__0_ R  // 4150K 
+	0x0F124000,	//TVAR_ash_GASAlpha_3__1_ GR          
+	0x0F124000,	//TVAR_ash_GASAlpha_3__2_ GB          
+	0x0F124000,	//TVAR_ash_GASAlpha_3__3_ B    
+	0x0F124000,	//TVAR_ash_GASAlpha_4__0_ R  // 5250K 
+	0x0F124000,	//TVAR_ash_GASAlpha_4__1_ GR          
+	0x0F124000,	//TVAR_ash_GASAlpha_4__2_ GB          
+	0x0F124000,	//TVAR_ash_GASAlpha_4__3_ B      
+	0x0F124300,	//TVAR_ash_GASAlpha_5__0_ R  // 6400K 
+	0x0F124000,	//TVAR_ash_GASAlpha_5__1_ GR          
+	0x0F124000,	//TVAR_ash_GASAlpha_5__2_ GB          
+	0x0F124000,	//TVAR_ash_GASAlpha_5__3_ B        
+	0x0F124300,	//TVAR_ash_GASAlpha_6__0_ R  // 7500K 
+	0x0F124000,	//TVAR_ash_GASAlpha_6__1_ GR          
+	0x0F124000,	//TVAR_ash_GASAlpha_6__2_ GB          
+	0x0F124000,	//TVAR_ash_GASAlpha_6__3_ B        
+
+	//Outdoor GAS Alpha   
+	0x0F124500, 
+	0x0F124000, 
+	0x0F124000, 
+	0x0F124000,
+	0x002A08F4,
+	0x0F120001,	//ash_bUseGasAlpha
+
+	/* 13.AE Weight (Normal) */
+	0x002A1492, 
+	0x0F120100,	//ae_WeightTbl_16[0]
+	0x0F120101,	//ae_WeightTbl_16[1]
+	0x0F120101,	//ae_WeightTbl_16[2]
+	0x0F120001,	//ae_WeightTbl_16[3]
+	0x0F120101,	//ae_WeightTbl_16[4]
+	0x0F120201,	//ae_WeightTbl_16[5]
+	0x0F120102,	//ae_WeightTbl_16[6]
+	0x0F120101,	//ae_WeightTbl_16[7]
+	0x0F120101,	//ae_WeightTbl_16[8]
+	0x0F120202,	//ae_WeightTbl_16[9]
+	0x0F120202,	//ae_WeightTbl_16[10]
+	0x0F120101,	//ae_WeightTbl_16[11]
+	0x0F120201,	//ae_WeightTbl_16[12]
+	0x0F120302,	//ae_WeightTbl_16[13]
+	0x0F120203,	//ae_WeightTbl_16[14]
+	0x0F120102,	//ae_WeightTbl_16[15]
+	0x0F120201,	//ae_WeightTbl_16[16]
+	0x0F120302,	//ae_WeightTbl_16[17]
+	0x0F120203,	//ae_WeightTbl_16[18]
+	0x0F120102,	//ae_WeightTbl_16[19]
+	0x0F120201,	//ae_WeightTbl_16[20]
+	0x0F120202,	//ae_WeightTbl_16[21]
+	0x0F120202,	//ae_WeightTbl_16[22]
+	0x0F120102,	//ae_WeightTbl_16[23]
+	0x0F120101,	//ae_WeightTbl_16[24]
+	0x0F120202,	//ae_WeightTbl_16[25]
+	0x0F120202,	//ae_WeightTbl_16[26]
+	0x0F120101,	//ae_WeightTbl_16[27]
+	0x0F120101,	//ae_WeightTbl_16[28]
+	0x0F120101,	//ae_WeightTbl_16[29]
+	0x0F120101,	//ae_WeightTbl_16[30]
+	0x0F120101,	//ae_WeightTbl_16[31]
+
+/* 12.AE Setting */
+  
+	//AE Target     
+	0x002A1484,  
+	0x0F12003C,	//TVAR_ae_BrAve
+
+	//ae_StatMode bit[3] BLC has to be bypassed to prevent AE weight change especially backlight scene 
+	0x002A148A,  
+	0x0F12000F,	//ae_StatMode
+	0x002A0588,  
+	0x0F120002,	//lt_uInitPostToleranceCnt
+	  
+	//AE_state                      
+	0x002A0544,  
+	0x0F120111,	//lt_uLimitHigh
+	0x0F1200EF,	//lt_uLimitLow
+	  
+	//AE Concept    
+	0x002A0608,  
+	0x0F120001,	//lt_ExpGain_uSubsamplingmode
+	0x0F120001,	//lt_ExpGain_uNonSubsampling
+	  
+	//Exposure      
+	0x002a0610,	//lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_0
+	0x0F120001,  
+	0x0F120000,  
+	0x0F120A3C,  
+	0x0F120000,  
+	0x0F120D05,  
+	0x0F120000, 
+	0x0F124008, 
+	0x0F120000,  
+	0x0F127000,  
+	0x0F120000,  
+	0x0F129C00,  
+	0x0F120000,  
+	0x0F12AD00,  
+	0x0F120001,  
+	0x0F12F1D4,  
+	0x0F120002,  
+	0x0F12DC00,  
+	0x0F120005,  
+	0x0F12DC00,  
+	0x0F120005,  
+	0x002A0638,	//lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_0_
+	0x0F120001, 
+	0x0F120000, 
+	0x0F120A3C, 
+	0x0F120000, 
+	0x0F120D05, 
+	0x0F120000, 
+	0x0F123408, 
+	0x0F120000, 
+	0x0F123408, 
+	0x0F120000, 
+	0x0F126810, 
+	0x0F120000, 
+	0x0F128214, 
+	0x0F120000, 
+	0x0F12C350, 
+	0x0F120000,  
+	0x0F12C350,  
+	0x0F120000,  
+	0x0F12C350,  
+	0x0F120000,  
+	//Gain  
+	0x002A060C,  
+	0x0F120540,	//800 //lt_ExpGain_ExpCurveGainMaxStr
+	0x0F120100,	//lt_ExpGain_ExpCurveGainMaxStr_0__uMaxDigGain
+	0x002A05a2,  
+	0x0F121000,	//lt_uMaxTotGain
+
+	// Lei Control  
+	0x002A06B8,  
+	0x0F12452C,  
+	0x0F120005,	//lt_uMaxLei
+
+/* 09.AWB-BASIC setting */
+
+	// AWB init Start point
+	0x002A145E,  
+	0x0F1205C0,	//620 580 //awbb_GainsInit_0_
+	0x0F120428,	//awbb_GainsInit_1_
+	0x0F1206E0,	//6F0 780 //awbb_GainsInit_2_
+
+	// AWB Convergence Speed
+	0x002A1464,  
+	0x0F120008,	//awbb_WpFilterMinThr
+	0x0F120060,	//190 awbb_WpFilterMaxThr
+	0x0F120100,	//F0 awbb_WpFilterCoef
+	0x0F120004,	//awbb_WpFilterSize             
+	0x0F120002,	//awbb_GridEnable       
+	0x002A144E,  
+	0x0F120000,	//awbb_RGainOff                 
+	0x0F120000,	//awbb_BGainOff                 
+	0x0F120000,	//awbb_GGainOff                 
+	0x0F1200C2,	//awbb_Alpha_Comp_Mode          
+	0x0F120002,	//awbb_Rpl_InvalidOutDoor               
+	0x0F120001,	//awbb_UseGrThrCorr             
+	0x0F120074,	//awbb_Use_Filters              
+	0x0F120001,	//awbb_CorrectMinNumPatches             
+
+	// White Locus
+	0x002A11F0,  
+	0x0F12012C,	//awbb_IntcR
+	0x0F120121,	//awbb_IntcB
+	0x002A120E,  
+	0x0F120000,	//awbb_MovingScale10
+	0x0F1205FD,	//awbb_GamutWidthThr1
+	0x0F12036B,	//awbb_GamutHeightThr1
+	0x0F120020,	//awbb_GamutWidthThr2
+	0x0F12001A,	//awbb_GamutHeightThr2
+	0x002A1278,  
+	0x0F12FEF7,	//awbb_SCDetectionMap_SEC_StartR_B
+	0x0F120021,	//awbb_SCDetectionMap_SEC_StepR_B
+	0x0F120FA0,	//awbb_SCDetectionMap_SEC_SunnyNB
+	0x0F1207D0,	//awbb_SCDetectionMap_SEC_StepNB
+	0x0F1201C8,	//awbb_SCDetectionMap_SEC_LowTempR_B
+	0x0F120096,	//awbb_SCDetectionMap_SEC_SunnyNBZone
+	0x0F120004,	//awbb_SCDetectionMap_SEC_LowTempR_BZone
+	0x002A1224,  
+	0x0F120032,	//32 awbb_LowBr
+	0x0F12001E,	//awbb_LowBr_NBzone
+	0x0F1200E2,	//awbb_YThreshHigh
+	0x0F120010,	//awbb_YThreshLow_Norm
+	0x0F120002,	//awbb_YThreshLow_Low
+	0x002A2BA4,  
+	0x0F120004,	//Mon_AWB_ByPassMode
+	0x002A11FC,  
+	0x0F12000C,	//awbb_MinNumOfFinalPatches             
+	0x002A1208,  
+	0x0F120020,	//awbb_MinNumOfChromaclassifpatches
+
+	// Indoor Zone
+	0x002A101C,  
+	0x0F120360,	//0360 //0360        //awbb_IndoorGrZones_m_BGrid_0__m_left
+	0x0F12036C,	//036C //036C        //awbb_IndoorGrZones_m_BGrid_0__m_right
+	0x0F120320,	//0320 //0320        //awbb_IndoorGrZones_m_BGrid_1__m_left
+	0x0F12038A,	//038A //038A        //awbb_IndoorGrZones_m_BGrid_1__m_right
+	0x0F1202E8,	//02E8 //02E8        //awbb_IndoorGrZones_m_BGrid_2__m_left
+	0x0F12036C,	//036C //0380        //awbb_IndoorGrZones_m_BGrid_2__m_right
+	0x0F1202BE,	//02BE //02BE        //awbb_IndoorGrZones_m_BGrid_3__m_left
+	0x0F120342,	//0342 //035A        //awbb_IndoorGrZones_m_BGrid_3__m_right
+	0x0F120298,	//0298 //0298        //awbb_IndoorGrZones_m_BGrid_4__m_left
+	0x0F12031C,	//031C //0334        //awbb_IndoorGrZones_m_BGrid_4__m_right
+	0x0F120272,	//0272 //0272        //awbb_IndoorGrZones_m_BGrid_5__m_left
+	0x0F1202F6,	//02F6 //030E        //awbb_IndoorGrZones_m_BGrid_5__m_right
+	0x0F12024C,	//024C //024C        //awbb_IndoorGrZones_m_BGrid_6__m_left
+	0x0F1202D6,	//02D2 //02EA        //awbb_IndoorGrZones_m_BGrid_6__m_right
+	0x0F120230,	//0230 //0230        //awbb_IndoorGrZones_m_BGrid_7__m_left
+	0x0F1202BA,	//02B6 //02CC        //awbb_IndoorGrZones_m_BGrid_7__m_right
+	0x0F120214,	//0214 //0214        //awbb_IndoorGrZones_m_BGrid_8__m_left
+	0x0F1202A6,	//02A6 //02B0        //awbb_IndoorGrZones_m_BGrid_8__m_right
+	0x0F1201F8,	//01F8 //01F8        //awbb_IndoorGrZones_m_BGrid_9__m_left
+	0x0F120292,	//0292 //0294        //awbb_IndoorGrZones_m_BGrid_9__m_right
+	0x0F1201DC,	//01DC //01DC        //awbb_IndoorGrZones_m_BGrid_10__m_left
+	0x0F120278,	//0278 //0278        //awbb_IndoorGrZones_m_BGrid_10__m_right
+	0x0F1201C0,	//01C0 //01C0        //awbb_IndoorGrZones_m_BGrid_11__m_left
+	0x0F120264,	//0264 //0264        //awbb_IndoorGrZones_m_BGrid_11__m_right
+	0x0F1201AA,	//01AA //01AA        //awbb_IndoorGrZones_m_BGrid_12__m_left
+	0x0F120250,	//0250 //0250        //awbb_IndoorGrZones_m_BGrid_12__m_right
+	0x0F120196,	//0196 //0196        //awbb_IndoorGrZones_m_BGrid_13__m_left
+	0x0F12023C,	//023C //023C        //awbb_IndoorGrZones_m_BGrid_13__m_right
+	0x0F120180,	//0180 //0180        //awbb_IndoorGrZones_m_BGrid_14__m_left
+	0x0F120228,	//0228 //0228        //awbb_IndoorGrZones_m_BGrid_14__m_right
+	0x0F12016C,	//016C //016C        //awbb_IndoorGrZones_m_BGrid_15__m_left
+	0x0F120214,	//0214 //0214        //awbb_IndoorGrZones_m_BGrid_15__m_right
+	0x0F120168,	//0168 //0168        //awbb_IndoorGrZones_m_BGrid_16__m_left
+	0x0F120200,	//0200 //0200        //awbb_IndoorGrZones_m_BGrid_16__m_right
+	0x0F120172,	//0172 //0172        //awbb_IndoorGrZones_m_BGrid_17__m_left
+	0x0F1201EC,	//01EC //01EC        //awbb_IndoorGrZones_m_BGrid_17__m_right
+	0x0F12019A,	//019A //019A        //awbb_IndoorGrZones_m_BGrid_18__m_left
+	0x0F1201D8,	//01D8 //01D8        //awbb_IndoorGrZones_m_BGrid_18__m_right
+	0x0F120000,	//0000 //0000        //awbb_IndoorGrZones_m_BGrid_19__m_left
+	0x0F120000,	//0000 //0000        //awbb_IndoorGrZones_m_BGrid_19__m_right
+	0x0F120005,	//awbb_IndoorGrZones_m_GridStep
+	0x002A1070,  
+	0x0F120013,	//awbb_IndoorGrZones_ZInfo_m_GridSz
+	0x002A1074,  
+	0x0F1200EC,	//awbb_IndoorGrZones_m_Boffs
+
+	// Outdoor Zone
+	0x002A1078, 
+	0x0F120240,	//0240 //0232        //awbb_OutdoorGrZones_m_BGrid_0__m_left
+	0x0F12025A,	//025A //025A        //awbb_OutdoorGrZones_m_BGrid_0__m_right
+	0x0F120234,	//022C //021E        //awbb_OutdoorGrZones_m_BGrid_1__m_left
+	0x0F120274,	//0274 //0274        //awbb_OutdoorGrZones_m_BGrid_1__m_right
+	0x0F120228,	//021E //020E        //awbb_OutdoorGrZones_m_BGrid_2__m_left
+	0x0F12028E,	//028E //028E        //awbb_OutdoorGrZones_m_BGrid_2__m_right
+	0x0F120220,	//0210 //0200        //awbb_OutdoorGrZones_m_BGrid_3__m_left
+	0x0F120290,	//0290 //0290        //awbb_OutdoorGrZones_m_BGrid_3__m_right
+	0x0F120212,	//0204 //01F4        //awbb_OutdoorGrZones_m_BGrid_4__m_left
+	0x0F120286,	//0286 //0286        //awbb_OutdoorGrZones_m_BGrid_4__m_right
+	0x0F120202,	//01FA //01E8        //awbb_OutdoorGrZones_m_BGrid_5__m_left
+	0x0F12027E,	//027E //027E        //awbb_OutdoorGrZones_m_BGrid_5__m_right
+	0x0F1201F6,	//01F2 //01DE        //awbb_OutdoorGrZones_m_BGrid_6__m_left
+	0x0F120274,	//0274 //0274        //awbb_OutdoorGrZones_m_BGrid_6__m_right
+	0x0F1201EC,	//01EA //01D2        //awbb_OutdoorGrZones_m_BGrid_7__m_left
+	0x0F120268,	//0268 //0268        //awbb_OutdoorGrZones_m_BGrid_7__m_right
+	0x0F1201E6,	//01E6 //01D0        //awbb_OutdoorGrZones_m_BGrid_8__m_left
+	0x0F12025E,	//025E //025E        //awbb_OutdoorGrZones_m_BGrid_8__m_right
+	0x0F1201E4,	//01E4 //01D6        //awbb_OutdoorGrZones_m_BGrid_9__m_left
+	0x0F120252,	//0252 //0252        //awbb_OutdoorGrZones_m_BGrid_9__m_right
+	0x0F1201E6,	//01E6 //01E2        //awbb_OutdoorGrZones_m_BGrid_10__m_left
+	0x0F120248,	//0248 //0248        //awbb_OutdoorGrZones_m_BGrid_10__m_right
+	0x0F1201F4,	//01F4 //01F4        //awbb_OutdoorGrZones_m_BGrid_11__m_left
+	0x0F12021A,	//021A //021A        //awbb_OutdoorGrZones_m_BGrid_11__m_right
+	0x0F120004,	//awbb_OutdoorGrZones_m_GridStep
+	0x002A10AC,
+	0x0F12000C,	//awbb_OutdoorGrZones_ZInfo_m_GridSz
+	0x002A10B0, 
+	0x0F1201DA,	//awbb_OutdoorGrZones_m_Boffs
+
+	// Low Brightness Zone
+	0x002A10B4,  
+	0x0F120348,	//awbb_LowBrGrZones_m_BGrid_0__m_left
+	0x0F1203B6,	//awbb_LowBrGrZones_m_BGrid_0__m_right
+	0x0F1202B8,	//awbb_LowBrGrZones_m_BGrid_1__m_left
+	0x0F1203B6,	//awbb_LowBrGrZones_m_BGrid_1__m_right
+	0x0F120258,	//awbb_LowBrGrZones_m_BGrid_2__m_left
+	0x0F12038E,	//awbb_LowBrGrZones_m_BGrid_2__m_right
+	0x0F120212,	//awbb_LowBrGrZones_m_BGrid_3__m_left
+	0x0F120348,	//awbb_LowBrGrZones_m_BGrid_3__m_right
+	0x0F1201CC,	//awbb_LowBrGrZones_m_BGrid_4__m_left
+	0x0F12030C,	//awbb_LowBrGrZones_m_BGrid_4__m_right
+	0x0F1201A2,	//awbb_LowBrGrZones_m_BGrid_5__m_left
+	0x0F1202D2,	//awbb_LowBrGrZones_m_BGrid_5__m_right
+	0x0F120170,	//awbb_LowBrGrZones_m_BGrid_6__m_left
+	0x0F1202A6,	//awbb_LowBrGrZones_m_BGrid_6__m_right
+	0x0F12014C,	//awbb_LowBrGrZones_m_BGrid_7__m_left
+	0x0F120280,	//awbb_LowBrGrZones_m_BGrid_7__m_right
+	0x0F120128,	//awbb_LowBrGrZones_m_BGrid_8__m_left
+	0x0F12025C,	//awbb_LowBrGrZones_m_BGrid_8__m_right
+	0x0F120146,	//awbb_LowBrGrZones_m_BGrid_9__m_left
+	0x0F120236,	//awbb_LowBrGrZones_m_BGrid_9__m_right
+	0x0F120164,	//awbb_LowBrGrZones_m_BGrid_10__m_left
+	0x0F120212,	//awbb_LowBrGrZones_m_BGrid_10__m_right
+	0x0F120000,	//awbb_LowBrGrZones_m_BGrid_11__m_left
+	0x0F120000,	//awbb_LowBrGrZones_m_BGrid_11__m_right
+	0x0F120006,	//awbb_LowBrGrZones_m_GridStep
+	0x002A10E8,
+	0x0F12000B,	//awbb_LowBrGrZones_ZInfo_m_GridSz
+	0x002A10EC, 
+	0x0F1200D2,	//awbb_LowBrGrZones_m_Boffs
+
+	// Low Temp. Zone
+	0x002A10F0,  
+	0x0F12039A,  
+	0x0F120000,	//awbb_CrclLowT_R_c
+	0x0F1200FE,  
+	0x0F120000,	//awbb_CrclLowT_B_c
+	0x0F122284,  
+	0x0F120000,	//awbb_CrclLowT_Rad_c           
+
+	//AWB - GridCorrection                  
+	0x002A1434,  
+	0x0F1202C1,	//awbb_GridConst_1_0_
+	0x0F12033A,	//awbb_GridConst_1_1_
+	0x0F12038A,	//awbb_GridConst_1_2_
+	0x0F12101A,	//awbb_GridConst_2_0_
+	0x0F121075,	//awbb_GridConst_2_1_
+	0x0F12113D,	//awbb_GridConst_2_2_
+	0x0F12113F,	//awbb_GridConst_2_3_
+	0x0F1211AF,	//awbb_GridConst_2_4_
+	0x0F1211F0,	//awbb_GridConst_2_5_
+	0x0F1200B2,	//awbb_GridCoeff_R_1
+	0x0F1200B8,	//awbb_GridCoeff_B_1
+	0x0F1200CA,	//awbb_GridCoeff_R_2
+	0x0F12009D,	//awbb_GridCoeff_B_2
+
+	// Indoor Grid Offset                   
+	0x002A13A4,  
+	0x0F120000,	//D65 awbb_GridCorr_R_0__0_
+	0x0F12ffd0,	//D65 CW awbb_GridCorr_R_0__1_
+	0x0F12FFE0,	//CW awbb_GridCorr_R_0__2_
+	0x0F120000,	//FFF0 FFd0 A awbb_GridCorr_R_0__3_
+	0x0F120000,	//FFF0 FFd0 A awbb_GridCorr_R_0__4_
+	0x0F120000,	//FFF0 FFd0 H awbb_GridCorr_R_0__5_
+	0x0F120000,	//D65awbb_GridCorr_R_1__0_
+	0x0F12ffd0,	//D65 CW awbb_GridCorr_R_1__1_
+	0x0F12FFE0,	//CW awbb_GridCorr_R_1__2_
+	0x0F120000,	//A awbb_GridCorr_R_1__3_
+	0x0F120000,	//A awbb_GridCorr_R_1__4_
+	0x0F120000,	//H awbb_GridCorr_R_1__5_
+	0x0F120000,	//D65awbb_GridCorr_R_2__0_
+	0x0F12ffd0,	//D65 CW awbb_GridCorr_R_2__1_
+	0x0F12FFE0,	//CW awbb_GridCorr_R_2__2_
+	0x0F120000,	//A awbb_GridCorr_R_2__3_
+	0x0F120000, //A awbb_GridCorr_R_2__4_
+	0x0F120000,	//H awbb_GridCorr_R_2__5_
+	0x0F12FFD0,	//awbb_GridCorr_B_0__0_
+	0x0F12FFE0,	//awbb_GridCorr_B_0__1_
+	0x0F120020,	//awbb_GridCorr_B_0__2_
+	0x0F12FFE0,	//FFE0 0000 awbb_GridCorr_B_0__3_
+	0x0F12FFE0,	//FFE0 0000 awbb_GridCorr_B_0__4_
+	0x0F12FFE0,	//FFE0 0000 awbb_GridCorr_B_0__5_
+	0x0F12FFD0,	//awbb_GridCorr_B_1__0_
+	0x0F12FFE0,	//awbb_GridCorr_B_1__1_
+	0x0F120020,	//awbb_GridCorr_B_1__2_
+	0x0F12FFE0,	//awbb_GridCorr_B_1__3_
+	0x0F12FFE0,	//awbb_GridCorr_B_1__4_
+	0x0F12FFE0,	//awbb_GridCorr_B_1__5_
+	0x0F12FFD0,	//awbb_GridCorr_B_2__0_
+	0x0F12FFE0,	//awbb_GridCorr_B_2__1_
+	0x0F120020,	//awbb_GridCorr_B_2__2_
+	0x0F12FFE0,	//awbb_GridCorr_B_2__3_
+	0x0F12FFE0,	//awbb_GridCorr_B_2__4_
+	0x0F12FFE0,	//awbb_GridCorr_B_2__5_
+
+	// Outdoor Grid Offset
+	0x0F12FFB0,	//FFC0 awbb_GridCorr_R_Out_0__0_
+	0x0F12FFC0,	//FFD0 awbb_GridCorr_R_Out_0__1_
+	0x0F12FFC0,	//FFD0 awbb_GridCorr_R_Out_0__2_
+	0x0F12FFC0,	//FFD0 awbb_GridCorr_R_Out_0__3_
+	0x0F120000,	//0000 awbb_GridCorr_R_Out_0__4_
+	0x0F120000,	//0000 awbb_GridCorr_R_Out_0__5_
+	0x0F12FFB0,	//awbb_GridCorr_R_Out_1__0_
+	0x0F12FFC0,	//awbb_GridCorr_R_Out_1__1_
+	0x0F12FFC0,	//awbb_GridCorr_R_Out_1__2_
+	0x0F12FFC0,	//awbb_GridCorr_R_Out_1__3_
+	0x0F120000,	//awbb_GridCorr_R_Out_1__4_
+	0x0F120000,	//awbb_GridCorr_R_Out_1__5_
+	0x0F12FFB0,	//awbb_GridCorr_R_Out_2__0_
+	0x0F12FFC0,	//awbb_GridCorr_R_Out_2__1_
+	0x0F12FFC0,	//awbb_GridCorr_R_Out_2__2_
+	0x0F12FFC0,	//awbb_GridCorr_R_Out_2__3_
+	0x0F120000,	//awbb_GridCorr_R_Out_2__4_
+	0x0F120000,	//awbb_GridCorr_R_Out_2__5_
+	0x0F120080,	//awbb_GridCorr_B_Out_0__0_
+	0x0F12FFE0,	//awbb_GridCorr_B_Out_0__1_
+	0x0F12FFE0,	//awbb_GridCorr_B_Out_0__2_
+	0x0F12FFE0,	//awbb_GridCorr_B_Out_0__3_
+	0x0F120000,	//awbb_GridCorr_B_Out_0__4_
+	0x0F120000,	//awbb_GridCorr_B_Out_0__5_
+	0x0F120080,	//awbb_GridCorr_B_Out_1__0_
+	0x0F12FFE0,	//awbb_GridCorr_B_Out_1__1_
+	0x0F12FFE0,	//awbb_GridCorr_B_Out_1__2_
+	0x0F12FFE0,	//awbb_GridCorr_B_Out_1__3_
+	0x0F120000,	//awbb_GridCorr_B_Out_1__4_
+	0x0F120000,	//awbb_GridCorr_B_Out_1__5_
+	0x0F120080,	//awbb_GridCorr_B_Out_2__0_
+	0x0F12FFE0,	//awbb_GridCorr_B_Out_2__1_
+	0x0F12FFE0,	//awbb_GridCorr_B_Out_2__2_
+	0x0F12FFE0,	//awbb_GridCorr_B_Out_2__3_
+	0x0F120000,	//awbb_GridCorr_B_Out_2__4_
+	0x0F120000,	//awbb_GridCorr_B_Out_2__5_
+
+/* 10.Clock Setting */
+  
+	//Input Clock (Mclk)    
+	0x002A01F8,  
+	0x0F125DC0,	//REG_TC_IPRM_InClockLSBs , MCLK: 24Mhz
+	0x002A0212,  
+	0x0F120000,	//REG_TC_IPRM_UseNPviClocks          
+	0x0F120002,	//REG_TC_IPRM_UseNMipiClocks         
+	0x0F120002,	//REG_TC_IPRM_NumberOfMipiLanes
+
+	//System Clock & Output clock (Pclk)            
+	0x002A021A,  
+	0x0F1234BC,	//REG_TC_IPRM_OpClk4KHz_0, SCLK:54MHz 
+	0x0F124F1A-0x4000,	//REG_TC_IPRM_MinOutRate4KHz_0, PCLK Min : 81Mhz
+	0x0F124F1A,	//REG_TC_IPRM_MaxOutRate4KHz_0, PCLK Max : 81Mhz  
+
+	0x002A022C,  
+	0x0F120001,	//REG_TC_IPRM_InitParamsUpdated
+
+/* 18.JPEG Thumnail Setting */
+  
+	0x002A0478,     
+	0x0F12005F,     //REG_TC_BRC_usPrevQuality    
+	0x0F12005F,     //REG_TC_BRC_usCaptureQuality 
+	0x0F120001,     //REG_TC_THUMB_Thumb_bActive  
+	0x0F120140,     //REG_TC_THUMB_Thumb_uWidth   
+	0x0F1200F0,     //REG_TC_THUMB_Thumb_uHeight  
+	0x0F120005,     //REG_TC_THUMB_Thumb_Format   
+	  
+	0x002A17DC,     
+	0x0F120054,     //jpeg_ManualMBCV                
+	0x002A1AE4,                                      
+	0x0F12001C,     //senHal_bExtraAddLine           
+	0x002A0284,                                      
+	0x0F120001,     //REG_TC_GP_bBypassScalerJpg     
+	0x002A028A,                                      
+	0x0F120000,     //REG_TC_GP_bUse1FrameCaptureMode
+	  
+	0x002A1CC2,     //DRx_uDRxWeight for AutoCont function  
+	0x0F120100,                                           
+	0x0F120100,                                           
+	0x0F120100,                                           
+	0x0F120100,   
+
+/* 20.Preview & Capture Configration Setting */
+	
+	//Preview config[0] 640x480  7.5~15fps  
+	0x002A02A6, 
+	0x0F120500,	//280 REG_0TC_PCFG_usWidth : 1280
+	0x0F1203C0,	//1E0 REG_0TC_PCFG_usHeight :960
+	0x0F120005,	//REG_0TC_PCFG_Format 5 : YUV 7: Raw 9 : JPEG         
+	0x0F124F1A,	//REG_0TC_PCFG_usMaxOut4KHzRate         
+	0x0F124F1A,	//REG_0TC_PCFG_usMinOut4KHzRate         
+	0x0F120100,	//2B0 REG_0TC_PCFG_OutClkPerPix88               
+	0x0F120300,	//REG_0TC_PCFG_uBpp88                   
+	0x0F120002,	//02 2B4 REG_0TC_PCFG_PVIMask                   
+	0x0F120000,	//REG_0TC_PCFG_OIFMask                  
+	0x0F1201E0,	//REG_0TC_PCFG_usJpegPacketSize         
+	0x0F120000,	//REG_0TC_PCFG_usJpegTotalPackets       
+	0x0F120000,	//REG_0TC_PCFG_uClockInd                
+	0x0F120000,	//REG_0TC_PCFG_usFrTimeType             
+	0x0F120001,	//REG_0TC_PCFG_FrRateQualityType        
+	0x0F120535,	//REG_0TC_PCFG_usMaxFrTimeMsecMult10    
+	0x0F12014D,	//1F4  //14D 29A REG_0TC_PCFG_usMinFrTimeMsecMult10    
+	0x002A02D0,
+	0x0F12000F,	//REG_0TC_PCFG_uPrevMirror
+	0x0F12000F,	//REG_0TC_PCFG_uCaptureMirror
+
+	//Capture Config[0] 2560x1920   7.5~15fps                               
+	0x002A0396,
+	0x0F120000,	//00 REG_0TC_CCFG_uCaptureMode         
+
+//org
+0x0F120800,	//REG_0TC_CCFG_usWidth //800h=2048d
+0x0F120600,	//REG_0TC_CCFG_usHeight //600h=1536d
+
+
+//800 600
+//	0x0F120320,	//REG_0TC_CCFG_usWidth              
+//	0x0F120258,	//REG_0TC_CCFG_usHeight             
+//640 480
+//	0x0F120280,	//REG_0TC_CCFG_usWidth              
+//	0x0F1201e0,	//REG_0TC_CCFG_usHeight             
+	
+	0x0F120009,	//REG_0TC_CCFG_Format        9:jpeg       
+	0x0F124F1A,	//REG_0TC_CCFG_usMaxOut4KHzRate     
+	0x0F124F1A,	//REG_0TC_CCFG_usMinOut4KHzRate     
+	0x0F120100,	//REG_0TC_CCFG_OutClkPerPix88       
+	0x0F120300,	//REG_0TC_CCFG_uBpp88               
+	0x0F120002,	//02 REG_0TC_CCFG_PVIMask              
+	0x0F120000,	//REG_0TC_CCFG_OIFMask              
+	0x0F1201E0,	//REG_0TC_CCFG_usJpegPacketSize     
+	0x0F120000,	//REG_0TC_CCFG_usJpegTotalPackets   
+	0x0F120000,	//REG_0TC_CCFG_uClockInd            
+	0x0F120000,	//0 REG_0TC_CCFG_usFrTimeType         
+	0x0F120000,	//REG_0TC_CCFG_FrRateQualityType    
+	0x0F120535,	//REG_0TC_CCFG_usMaxFrTimeMsecMult10
+	0x0F120000,	//29A REG_0TC_CCFG_usMinFrTimeMsecMult10
+	
+/* 19.Input Size Setting */
+//Input Size    
+	0x002A0250, 
+	0x0F120A00,	//REG_TC_GP_PrevReqInputWidth
+	0x0F120780,	//REG_TC_GP_PrevReqInputHeight
+	0x0F120010,	//REG_TC_GP_PrevInputWidthOfs
+	0x0F12000c,	//REG_TC_GP_PrevInputHeightOfs
+	0x0F120A00,	//REG_TC_GP_CapReqInputWidth
+	0x0F120780,	//REG_TC_GP_CapReqInputHeight
+	0x0F120010,	//REG_TC_GP_CapInputWidthOfs
+	0x0F12000c,	//REG_TC_GP_CapInputHeightOfs
+	0x002A0494, 
+	0x0F120A00,	//REG_TC_PZOOM_ZoomInputWidth    
+	0x0F120780,	//REG_TC_PZOOM_ZoomInputHeight   
+	0x0F120000,	//REG_TC_PZOOM_ZoomInputWidthOfs 
+	0x0F120000,	//REG_TC_PZOOM_ZoomInputHeightOfs
+	0x0F120A00,	//REG_TC_CZOOM_ZoomInputWidth    
+	0x0F120780,	//REG_TC_CZOOM_ZoomInputHeight   
+	0x0F120000,	//REG_TC_CZOOM_ZoomInputWidthOfs 
+	0x0F120000,	//REG_TC_CZOOM_ZoomInputHeightOfs
+	0x002A0262,
+	0x0F120001,	//REG_TC_GP_bUseReqInputInPre  
+	0x0F120001,	//REG_TC_GP_bUseReqInputInCap 
+
+/* 17.AFIT */
+	0x002A0944,  
+	0x0F120050,	//afit_uNoiseIndInDoor
+	0x0F1200B0,	//afit_uNoiseIndInDoor
+	0x0F120196,	//afit_uNoiseIndInDoor
+	0x0F120245,	//afit_uNoiseIndInDoor
+	0x0F120300,	//afit_uNoiseIndInDoor
+	0x002A0938,  
+	0x0F120000,	// on/off AFIT by NB option
+	0x0F120014,	//SARR_uNormBrInDoor
+	0x0F1200D2,	//SARR_uNormBrInDoor
+	0x0F120384,	//SARR_uNormBrInDoor
+	0x0F1207D0,	//SARR_uNormBrInDoor
+	0x0F121388,	//SARR_uNormBrInDoor
+	0x002A0976, 
+	0x0F120070,	//afit_usGamutTh       
+	0x0F120005,	//afit_usNeargrayOffset
+	0x0F120000,	//afit_bUseSenBpr         
+	0x0F1201CC,	//afit_usBprThr_0_        
+	0x0F1201CC,	//afit_usBprThr_1_        
+	0x0F1201CC,	//afit_usBprThr_2_        
+	0x0F1201CC,	//afit_usBprThr_3_        
+	0x0F1201CC,	//afit_usBprThr_4_        
+	0x0F120180,	//afit_NIContrastAFITValue
+	0x0F120196,	//afit_NIContrastTh       
+	0x002A098C,  
+	0x0F120000,	//7000098C//AFIT16_BRIGHTNESS           
+	0x0F120000,	//7000098E//AFIT16_CONTRAST
+	0x0F120000,	//70000990//AFIT16_SATURATION 
+	0x0F120000,	//70000992//AFIT16_SHARP_BLUR
+	0x0F120000,	//70000994//AFIT16_GLAMOUR
+	0x0F1200C0,	//70000996//AFIT16_bnr_edge_high
+	0x0F120064,	//70000998//AFIT16_postdmsc_iLowBright
+	0x0F120384,	//7000099A//AFIT16_postdmsc_iHighBright
+	0x0F12005F,	//7000099C//AFIT16_postdmsc_iLowSat
+	0x0F1201F4,	//7000099E//AFIT16_postdmsc_iHighSat
+	0x0F120070,	//700009A0//AFIT16_postdmsc_iTune
+	0x0F120040,	//700009A2//AFIT16_yuvemix_mNegRanges_0
+	0x0F1200A0,	//700009A4//AFIT16_yuvemix_mNegRanges_1
+	0x0F120100,	//700009A6//AFIT16_yuvemix_mNegRanges_2
+	0x0F120010,	//700009A8//AFIT16_yuvemix_mPosRanges_0
+	0x0F120040,	//700009AA//AFIT16_yuvemix_mPosRanges_1
+	0x0F1200A0,	//700009AC//AFIT16_yuvemix_mPosRanges_2
+	0x0F121430,	//700009AE//AFIT8_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh
+	0x0F120201,	//700009B0//AFIT8_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh
+	0x0F120204,	//700009B2//AFIT8_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
+	0x0F123604,	//700009B4//AFIT8_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low                  
+	0x0F12032A,	//700009B6//AFIT8_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low
+	0x0F120403,	//700009B8//AFIT8_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
+	0x0F121B06,	//700009BA//AFIT8_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow                
+	0x0F126015,	//700009BC//AFIT8_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH           
+	0x0F1200C0,	//700009BE//AFIT8_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune            
+	0x0F126080,	//700009C0//AFIT8_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh          
+	0x0F124080,	//700009C2//AFIT8_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh    
+	0x0F120640,	//700009C4//AFIT8_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed     
+	0x0F120306,	//700009C6//AFIT8_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh       
+	0x0F122003,	//700009C8//AFIT8_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH              
+	0x0F12FF01,	//700009CA//AFIT8_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit         
+	0x0F120000,	//700009CC//AFIT8_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2              
+	0x0F120400,	//700009CE//AFIT8_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower                   
+	0x0F12365A,	//700009D0//AFIT8_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow                    
+	0x0F12102A,	//700009D2//AFIT8_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow                     
+	0x0F12000B,	//700009D4//AFIT8_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow                        
+	0x0F120600,	//700009D6//AFIT8_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower                        
+	0x0F125A0F,	//700009D8//AFIT8_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit                   
+	0x0F120505,	//700009DA//AFIT8_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope                
+	0x0F121802,	//700009DC//AFIT8_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR                        
+	0x0F120000,	//700009DE//AFIT8_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres                  
+	0x0F122006,	//700009E0//AFIT8_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR                  
+	0x0F123028,	//700009E2//AFIT8_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen                   
+	0x0F120418,	//700009E4//AFIT8_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh                         
+	0x0F120101,	//700009E6//AFIT8_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative                   
+	0x0F120800,	//700009E8//AFIT8_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle                  
+	0x0F121804,	//700009EA//AFIT8_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh               
+	0x0F124008,	//700009EC//AFIT8_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh                
+	0x0F120540,	//700009EE//AFIT8_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange                
+	0x0F128006,	//700009F0//AFIT8_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad                
+	0x0F120020,	//700009F2//AFIT8_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal                 
+	0x0F120000,	//700009F4//AFIT8_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh          
+	0x0F121800,	//700009F6//AFIT8_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat              
+	0x0F120000,	//700009F8//AFIT8_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit           
+	0x0F121E10,	//700009FA//AFIT8_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff                  
+	0x0F12000B,	//700009FC//AFIT8_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0            
+	0x0F120607,	//700009FE//AFIT8_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2          
+	0x0F120005,	//70000A00//AFIT8_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0          
+	0x0F120607,	//70000A02//AFIT8_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2          
+	0x0F120405,	//70000A04//AFIT8_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY           
+	0x0F120205,	//70000A06//AFIT8_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm            
+	0x0F120304,	//70000A08//AFIT8_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm            
+	0x0F120409,	//70000A0A//AFIT8_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift          
+	0x0F120306,	//70000A0C//AFIT8_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y       
+	0x0F120407,	//70000A0E//AFIT8_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y    
+	0x0F121C04,	//70000A10//AFIT8_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV   
+	0x0F120214,	//70000A12//AFIT8_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y    
+	0x0F121002,	//70000A14//AFIT8_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV     
+	0x0F120610,	//70000A16//AFIT8_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL     
+	0x0F121A02,	//70000A18//AFIT8_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL     
+	0x0F124A18,	//70000A1A//AFIT8_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower     
+	0x0F120080,	//70000A1C//AFIT8_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce         
+	0x0F120348,	//70000A1E//AFIT8_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset             
+	0x0F120180,	//70000A20//AFIT8_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H                 
+	0x0F120A0A,	//70000A22//AFIT8_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C                  
+	0x0F120101,	//70000A24//AFIT8_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C              
+	0x0F122A36,	//70000A26//AFIT8_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh               
+	0x0F126024,	//70000A28//AFIT8_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower               
+	0x0F122A36,	//70000A2A//AFIT8_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise                 
+	0x0F12FFFF,	//70000A2C//AFIT8_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp               
+	0x0F120808,	//70000A2E//AFIT8_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope          
+	0x0F120A01,	//70000A30//AFIT8_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin         
+	0x0F12010A,	//70000A32//AFIT8_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin        
+	0x0F123601,	//70000A34//AFIT8_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin       
+	0x0F12242A,	//70000A36//AFIT8_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin       
+	0x0F123660,	//70000A38//AFIT8_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin        
+	0x0F12FF2A,	//70000A3A//AFIT8_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin        
+	0x0F1208FF,	//70000A3C//AFIT8_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin   
+	0x0F120008,	//70000A3E//AFIT8_ee_iReduceEdgeSlope_Bin [7:0]
+	0x0F120001,	//70000A40//AFITB_bnr_nClustLevel_C      [0]  
+	0x0F120000,	//70000A42//AFIT16_BRIGHTNESS           
+	0x0F120000,	//70000A44//AFIT16_CONTRAST
+	0x0F120000,	//70000A46//AFIT16_SATURATION
+	0x0F120000,	//70000A48//AFIT16_SHARP_BLUR
+	0x0F120000,	//70000A4A//AFIT16_GLAMOUR
+	0x0F1200C0,	//70000A4C//AFIT16_bnr_edge_high
+	0x0F120064,	//70000A4E//AFIT16_postdmsc_iLowBright
+	0x0F120384,	//70000A50//AFIT16_postdmsc_iHighBright
+	0x0F120051,	//70000A52//AFIT16_postdmsc_iLowSat
+	0x0F1201F4,	//70000A54//AFIT16_postdmsc_iHighSat
+	0x0F120070,	//70000A56//AFIT16_postdmsc_iTune  
+	0x0F120040,	//70000A58//AFIT16_yuvemix_mNegRanges_0
+	0x0F1200A0,	//70000A5A//AFIT16_yuvemix_mNegRanges_1
+	0x0F120100,	//70000A5C//AFIT16_yuvemix_mNegRanges_2
+	0x0F120010,	//70000A5E//AFIT16_yuvemix_mPosRanges_0
+	0x0F120060,	//70000A60//AFIT16_yuvemix_mPosRanges_1
+	0x0F120100,	//70000A62//AFIT16_yuvemix_mPosRanges_2
+	0x0F121430,	//70000A64//AFIT8_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh
+	0x0F120201,	//70000A66//AFIT8_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh
+	0x0F120204,	//70000A68//AFIT8_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
+	0x0F122404,	//70000A6A//AFIT8_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low
+	0x0F12031B,	//70000A6C//AFIT8_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low
+	0x0F120103,	//70000A6E//AFIT8_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
+	0x0F121205,	//70000A70//AFIT8_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow 
+	0x0F12400D,	//70000A72//AFIT8_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH
+	0x0F120080,	//70000A74//AFIT8_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune            
+	0x0F122080,	//70000A76//AFIT8_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh
+	0x0F123040,	//70000A78//AFIT8_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh    
+	0x0F120630,	//70000A7A//AFIT8_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed     
+	0x0F120306,	//70000A7C//AFIT8_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh       
+	0x0F122003,	//70000A7E//AFIT8_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH              
+	0x0F12FF01,	//70000A80//AFIT8_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit         
+	0x0F120404,	//70000A82//AFIT8_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2              
+	0x0F120300,	//70000A84//AFIT8_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower                   
+	0x0F12245A,	//70000A86//AFIT8_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow                    
+	0x0F121018,	//70000A88//AFIT8_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow                     
+	0x0F12000B,	//70000A8A//AFIT8_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow                        
+	0x0F120B00,	//70000A8C//AFIT8_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower                        
+	0x0F125A0F,	//70000A8E//AFIT8_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit                   
+	0x0F120505,	//70000A90//AFIT8_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope                
+	0x0F121802,	//70000A92//AFIT8_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR                        
+	0x0F120000,	//70000A94//AFIT8_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres                  
+	0x0F122006,	//70000A96//AFIT8_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR                  
+	0x0F123428,	//70000A98//AFIT8_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen                   
+	0x0F12041C,	//70000A9A//AFIT8_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh                         
+	0x0F120101,	//70000A9C//AFIT8_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative
+	0x0F120800,	//70000A9E//AFIT8_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle
+	0x0F121004,	//70000AA0//AFIT8_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh
+	0x0F124008,	//70000AA2//AFIT8_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh
+	0x0F120540,	//70000AA4//AFIT8_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange
+	0x0F128006,	//70000AA6//AFIT8_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad
+	0x0F120020,	//70000AA8//AFIT8_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal
+	0x0F120000,	//70000AAA//AFIT8_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh
+	0x0F121800,	//70000AAC//AFIT8_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
+	0x0F120000,	//70000AAE//AFIT8_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit
+	0x0F121E10,	//70000AB0//AFIT8_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff
+	0x0F12000B,	//70000AB2//AFIT8_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0
+	0x0F120607,	//70000AB4//AFIT8_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2
+	0x0F120005,	//70000AB6//AFIT8_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0
+	0x0F120607,	//70000AB8//AFIT8_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2
+	0x0F120405,	//70000ABA//AFIT8_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY
+	0x0F120205,	//70000ABC//AFIT8_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm
+	0x0F120304,	//70000ABE//AFIT8_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm
+	0x0F120409,	//70000AC0//AFIT8_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift
+	0x0F120306,	//70000AC2//AFIT8_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y
+	0x0F120407,	//70000AC4//AFIT8_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y
+	0x0F121F04,	//70000AC6//AFIT8_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
+	0x0F120218,	//70000AC8//AFIT8_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y
+	0x0F121102,	//70000ACA//AFIT8_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV     
+	0x0F120611,	//70000ACC//AFIT8_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL
+	0x0F121A02,	//70000ACE//AFIT8_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL
+	0x0F128018,	//70000AD0//AFIT8_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower
+	0x0F120080,	//70000AD2//AFIT8_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce
+	0x0F120380,	//70000AD4//AFIT8_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset
+	0x0F120180,	//70000AD6//AFIT8_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H
+	0x0F120A0A,	//70000AD8//AFIT8_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C
+	0x0F120101,	//70000ADA//AFIT8_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
+	0x0F121B24,	//70000ADC//AFIT8_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh
+	0x0F126024,	//70000ADE//AFIT8_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower
+	0x0F121D22,	//70000AE0//AFIT8_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise
+	0x0F12FFFF,	//70000AE2//AFIT8_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp
+	0x0F120808,	//70000AE4//AFIT8_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope          
+	0x0F120A01,	//70000AE6//AFIT8_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin
+	0x0F12010A,	//70000AE8//AFIT8_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin
+	0x0F122401,	//70000AEA//AFIT8_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin
+	0x0F12241B,	//70000AEC//AFIT8_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin
+	0x0F121E60,	//70000AEE//AFIT8_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin        
+	0x0F12FF18,	//70000AF0//AFIT8_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin        
+	0x0F1208FF,	//70000AF2//AFIT8_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin   
+	0x0F120008,	//70000AF4//AFIT8_ee_iReduceEdgeSlope_Bin [7:0]
+	0x0F120001,	//70000AF6//AFITB_bnr_nClustLevel_C      [0]  
+	0x0F120000,	//70000AF8//AFIT16_BRIGHTNESS           
+	0x0F120000,	//70000AFA//AFIT16_CONTRAST
+	0x0F120000,	//70000AFC//AFIT16_SATURATION
+	0x0F120000,	//70000AFE//AFIT16_SHARP_BLUR
+	0x0F120000,	//70000B00//AFIT16_GLAMOUR
+	0x0F1200C0,	//70000B02//AFIT16_bnr_edge_high
+	0x0F120064,	//70000B04//AFIT16_postdmsc_iLowBright
+	0x0F120384,	//70000B06//AFIT16_postdmsc_iHighBright
+	0x0F120043,	//70000B08//AFIT16_postdmsc_iLowSat
+	0x0F1201F4,	//70000B0A//AFIT16_postdmsc_iHighSat
+	0x0F120070,	//70000B0C//AFIT16_postdmsc_iTune
+	0x0F120040,	//70000B0E//AFIT16_yuvemix_mNegRanges_0 
+	0x0F1200A0,	//70000B10//AFIT16_yuvemix_mNegRanges_1
+	0x0F120100,	//70000B12//AFIT16_yuvemix_mNegRanges_2
+	0x0F120010,	//70000B14//AFIT16_yuvemix_mPosRanges_0
+	0x0F120060,	//70000B16//AFIT16_yuvemix_mPosRanges_1
+	0x0F120100,	//70000B18//AFIT16_yuvemix_mPosRanges_2
+	0x0F121430,	//70000B1A//AFIT8_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh
+	0x0F120201,	//70000B1C//AFIT8_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh
+	0x0F120204,	//70000B1E//AFIT8_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
+	0x0F121B04,	//70000B20//AFIT8_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low   
+	0x0F120312,	//70000B22//AFIT8_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low
+	0x0F120003,	//70000B24//AFIT8_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
+	0x0F120C03,	//70000B26//AFIT8_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow 
+	0x0F122806,	//70000B28//AFIT8_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH
+	0x0F120060,	//70000B2A//AFIT8_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune
+	0x0F121580,	//70000B2C//AFIT8_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh
+	0x0F122020,	//70000B2E//AFIT8_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh
+	0x0F120620,	//70000B30//AFIT8_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed
+	0x0F120306,	//70000B32//AFIT8_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh 
+	0x0F122003,	//70000B34//AFIT8_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH 
+	0x0F12FF01,	//70000B36//AFIT8_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit 
+	0x0F120404,	//70000B38//AFIT8_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
+	0x0F120300,	//70000B3A//AFIT8_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower
+	0x0F12145A,	//70000B3C//AFIT8_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow
+	0x0F121010,	//70000B3E//AFIT8_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow
+	0x0F12000B,	//70000B40//AFIT8_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow
+	0x0F120E00,	//70000B42//AFIT8_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower
+	0x0F125A0F,	//70000B44//AFIT8_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit
+	0x0F120504,	//70000B46//AFIT8_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope
+	0x0F121802,	//70000B48//AFIT8_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR
+	0x0F120000,	//70000B4A//AFIT8_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres
+	0x0F122006,	//70000B4C//AFIT8_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR
+	0x0F123828,	//70000B4E//AFIT8_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen
+	0x0F120428,	//70000B50//AFIT8_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh
+	0x0F120101,	//70000B52//AFIT8_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative
+	0x0F128000,	//70000B54//AFIT8_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle
+	0x0F120A04,	//70000B56//AFIT8_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh
+	0x0F124008,	//70000B58//AFIT8_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh
+	0x0F120540,	//70000B5A//AFIT8_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange
+	0x0F128006,	//70000B5C//AFIT8_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad
+	0x0F120020,	//70000B5E//AFIT8_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal
+	0x0F120000,	//70000B60//AFIT8_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh
+	0x0F121800,	//70000B62//AFIT8_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
+	0x0F120000,	//70000B64//AFIT8_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit
+	0x0F121E10,	//70000B66//AFIT8_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff
+	0x0F12000B,	//70000B68//AFIT8_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0
+	0x0F120607,	//70000B6A//AFIT8_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2
+	0x0F120005,	//70000B6C//AFIT8_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0
+	0x0F120607,	//70000B6E//AFIT8_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2
+	0x0F120405,	//70000B70//AFIT8_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY
+	0x0F120207,	//70000B72//AFIT8_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm
+	0x0F120304,	//70000B74//AFIT8_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm
+	0x0F120409,	//70000B76//AFIT8_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift
+	0x0F120306,	//70000B78//AFIT8_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y
+	0x0F120407,	//70000B7A//AFIT8_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y
+	0x0F122404,	//70000B7C//AFIT8_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
+	0x0F120221,	//70000B7E//AFIT8_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y
+	0x0F121202,	//70000B80//AFIT8_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV
+	0x0F120613,	//70000B82//AFIT8_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL
+	0x0F121A02,	//70000B84//AFIT8_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL
+	0x0F128018,	//70000B86//AFIT8_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower
+	0x0F120080,	//70000B88//AFIT8_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce
+	0x0F120080,	//70000B8A//AFIT8_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset
+	0x0F120180,	//70000B8C//AFIT8_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H
+	0x0F120A0A,	//70000B8E//AFIT8_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C
+	0x0F120101,	//70000B90//AFIT8_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
+	0x0F12141D,	//70000B92//AFIT8_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh
+	0x0F126024,	//70000B94//AFIT8_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower
+	0x0F120C0C,	//70000B96//AFIT8_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise 
+	0x0F12FFFF,	//70000B98//AFIT8_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp
+	0x0F120808,	//70000B9A//AFIT8_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope          
+	0x0F120A01,	//70000B9C//AFIT8_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin         
+	0x0F12010A,	//70000B9E//AFIT8_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin        
+	0x0F121B01,	//70000BA0//AFIT8_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin       
+	0x0F122412,	//70000BA2//AFIT8_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin       
+	0x0F120C60,	//70000BA4//AFIT8_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin        
+	0x0F12FF0C,	//70000BA6//AFIT8_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin        
+	0x0F1208FF,	//70000BA8//AFIT8_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin   
+	0x0F120008,	//70000BAA//AFIT8_ee_iReduceEdgeSlope_Bin [7:0]                    
+	0x0F120001,	//70000BAC//AFITB_bnr_nClustLevel_C      [0]
+	0x0F120000,	//70000BAE//AFIT16_BRIGHTNESS          
+	0x0F120000,	//70000BB0//AFIT16_CONTRAST
+	0x0F120000,	//70000BB2//AFIT16_SATURATION
+	0x0F120000,	//70000BB4//AFIT16_SHARP_BLUR
+	0x0F120000,	//70000BB6//AFIT16_GLAMOUR  
+	0x0F1200C0,	//70000BB8//AFIT16_bnr_edge_high
+	0x0F120064,	//70000BBA//AFIT16_postdmsc_iLowBright
+	0x0F120384,	//70000BBC//AFIT16_postdmsc_iHighBright
+	0x0F120032,	//70000BBE//AFIT16_postdmsc_iLowSat   
+	0x0F1201F4,	//70000BC0//AFIT16_postdmsc_iHighSat 
+	0x0F120070,	//70000BC2//AFIT16_postdmsc_iTune
+	0x0F120040,	//70000BC4//AFIT16_yuvemix_mNegRanges_0
+	0x0F1200A0,	//70000BC6//AFIT16_yuvemix_mNegRanges_1
+	0x0F120100,	//70000BC8//AFIT16_yuvemix_mNegRanges_2
+	0x0F120010,	//70000BCA//AFIT16_yuvemix_mPosRanges_0
+	0x0F120060,	//70000BCC//AFIT16_yuvemix_mPosRanges_1
+	0x0F120100,	//70000BCE//AFIT16_yuvemix_mPosRanges_2
+	0x0F121430,	//70000BD0//AFIT8_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh
+	0x0F120201,	//70000BD2//AFIT8_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh
+	0x0F120204,	//70000BD4//AFIT8_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
+	0x0F121504,	//70000BD6//AFIT8_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low   
+	0x0F12030F,	//70000BD8//AFIT8_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low 
+	0x0F120003,	//70000BDA//AFIT8_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
+	0x0F120902,	//70000BDC//AFIT8_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow 
+	0x0F122004,	//70000BDE//AFIT8_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH           
+	0x0F120050,	//70000BE0//AFIT8_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune            
+	0x0F121140,	//70000BE2//AFIT8_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh          
+	0x0F12201C,	//70000BE4//AFIT8_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh    
+	0x0F120620,	//70000BE6//AFIT8_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed     
+	0x0F120306,	//70000BE8//AFIT8_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh       
+	0x0F122003,	//70000BEA//AFIT8_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH              
+	0x0F12FF01,	//70000BEC//AFIT8_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit         
+	0x0F120404,	//70000BEE//AFIT8_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2              
+	0x0F120300,	//70000BF0//AFIT8_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower   
+	0x0F12145A,	//70000BF2//AFIT8_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow   
+	0x0F121010,	//70000BF4//AFIT8_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow   
+	0x0F12000B,	//70000BF6//AFIT8_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow     
+	0x0F121000,	//70000BF8//AFIT8_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower
+	0x0F125A0F,	//70000BFA//AFIT8_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit
+	0x0F120503,	//70000BFC//AFIT8_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope
+	0x0F121802,	//70000BFE//AFIT8_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR
+	0x0F120000,	//70000C00//AFIT8_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres
+	0x0F122006,	//70000C02//AFIT8_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR 
+	0x0F123C28,	//70000C04//AFIT8_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen
+	0x0F12042C,	//70000C06//AFIT8_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh
+	0x0F120101,	//70000C08//AFIT8_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative
+	0x0F12FF00,	//70000C0A//AFIT8_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle
+	0x0F120904,	//70000C0C//AFIT8_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh
+	0x0F124008,	//70000C0E//AFIT8_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh
+	0x0F120540,	//70000C10//AFIT8_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange
+	0x0F128006,	//70000C12//AFIT8_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad
+	0x0F120020,	//70000C14//AFIT8_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal
+	0x0F120000,	//70000C16//AFIT8_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh
+	0x0F121800,	//70000C18//AFIT8_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
+	0x0F120000,	//70000C1A//AFIT8_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit
+	0x0F121E10,	//70000C1C//AFIT8_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff
+	0x0F12000B,	//70000C1E//AFIT8_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0
+	0x0F120607,	//70000C20//AFIT8_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2
+	0x0F120005,	//70000C22//AFIT8_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0
+	0x0F120607,	//70000C24//AFIT8_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2
+	0x0F120405,	//70000C26//AFIT8_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY
+	0x0F120206,	//70000C28//AFIT8_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm
+	0x0F120304,	//70000C2A//AFIT8_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm
+	0x0F120409,	//70000C2C//AFIT8_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift
+	0x0F120305,	//70000C2E//AFIT8_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y
+	0x0F120228,	//70000C34//AFIT8_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y    
+	0x0F121402,	//70000C36//AFIT8_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV     
+	0x0F120618,	//70000C38//AFIT8_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL     
+	0x0F121A02,	//70000C3A//AFIT8_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL     
+	0x0F128018,	//70000C3C//AFIT8_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower
+	0x0F120080,	//70000C3E//AFIT8_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce
+	0x0F120080,	//70000C40//AFIT8_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset
+	0x0F120180,	//70000C42//AFIT8_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H 
+	0x0F120A0A,	//70000C44//AFIT8_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C   
+	0x0F120101,	//70000C46//AFIT8_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
+	0x0F121117,	//70000C48//AFIT8_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh
+	0x0F126024,	//70000C4A//AFIT8_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower
+	0x0F120A0A,	//70000C4C//AFIT8_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise 
+	0x0F12FFFF,	//70000C4E//AFIT8_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp
+	0x0F120808,	//70000C50//AFIT8_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope 
+	0x0F120A01,	//70000C52//AFIT8_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin 
+	0x0F12010A,	//70000C54//AFIT8_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin        
+	0x0F121501,	//70000C56//AFIT8_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin       
+	0x0F12240F,	//70000C58//AFIT8_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin
+	0x0F120A60,	//70000C5A//AFIT8_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin
+	0x0F12FF0A,	//70000C5C//AFIT8_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin
+	0x0F1208FF,	//70000C5E//AFIT8_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
+	0x0F120008,	//70000C60//AFIT8_ee_iReduceEdgeSlope_Bin [7:0]
+	0x0F120001,	//70000C62//AFITB_bnr_nClustLevel_C      [0]
+	0x0F120000,	//70000C64//AFIT16_BRIGHTNESS         
+	0x0F120000,	//70000C66//AFIT16_CONTRAST                  
+	0x0F120000,	//70000C68//AFIT16_SATURATION                 
+	0x0F120000,	//70000C6A//AFIT16_SHARP_BLUR                  
+	0x0F120000,	//70000C6C//AFIT16_GLAMOUR                      
+	0x0F1200C0,	//70000C6E//AFIT16_bnr_edge_high                 
+	0x0F120064,	//70000C70//AFIT16_postdmsc_iLowBright            
+	0x0F120384,	//70000C72//AFIT16_postdmsc_iHighBright            
+	0x0F120032,	//70000C74//AFIT16_postdmsc_iLowSat                 
+	0x0F1201F4,	//70000C76//AFIT16_postdmsc_iHighSat                 
+	0x0F120070,	//70000C78//AFIT16_postdmsc_iTune                     
+	0x0F120040,	//70000C7A//AFIT16_yuvemix_mNegRanges_0                
+	0x0F1200A0,	//70000C7C//AFIT16_yuvemix_mNegRanges_1                 
+	0x0F120100,	//70000C7E//AFIT16_yuvemix_mNegRanges_2                  
+	0x0F120010,	//70000C80//AFIT16_yuvemix_mPosRanges_0                   
+	0x0F120060,	//70000C82//AFIT16_yuvemix_mPosRanges_1                    
+	0x0F120100,	//70000C84//AFIT16_yuvemix_mPosRanges_2                     
+	0x0F121430,	//70000C86//AFIT8_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh        
+	0x0F120201,	//70000C88//AFIT8_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh    
+	0x0F120204,	//70000C8A//AFIT8_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
+	0x0F120F04,	//70000C8C//AFIT8_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low
+	0x0F12030C,	//70000C8E//AFIT8_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low  
+	0x0F120003,	//70000C90//AFIT8_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
+	0x0F120602,	//70000C92//AFIT8_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow
+	0x0F121803,	//70000C94//AFIT8_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH
+	0x0F120040,	//70000C96//AFIT8_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune  
+	0x0F120E20,	//70000C98//AFIT8_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh     
+	0x0F122018,	//70000C9A//AFIT8_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh
+	0x0F120620,	//70000C9C//AFIT8_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed
+	0x0F120306,	//70000C9E//AFIT8_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh
+	0x0F122003,	//70000CA0//AFIT8_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
+	0x0F12FF01,	//70000CA2//AFIT8_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit
+	0x0F120404,	//70000CA4//AFIT8_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
+	0x0F120200,	//70000CA6//AFIT8_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower
+	0x0F12145A,	//70000CA8//AFIT8_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow
+	0x0F121010,	//70000CAA//AFIT8_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow  
+	0x0F12000B,	//70000CAC//AFIT8_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow      
+	0x0F121200,	//70000CAE//AFIT8_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower       
+	0x0F125A0F,	//70000CB0//AFIT8_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit   
+	0x0F120502,	//70000CB2//AFIT8_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope 
+	0x0F121802,	//70000CB4//AFIT8_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR
+	0x0F120000,	//70000CB6//AFIT8_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres
+	0x0F122006,	//70000CB8//AFIT8_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR
+	0x0F124028,	//70000CBA//AFIT8_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen
+	0x0F120430,	//70000CBC//AFIT8_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh     
+	0x0F120101,	//70000CBE//AFIT8_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative
+	0x0F12FF00,	//70000CC0//AFIT8_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle
+	0x0F120804,	//70000CC2//AFIT8_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh
+	0x0F124008,	//70000CC4//AFIT8_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh
+	0x0F120540,	//70000CC6//AFIT8_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange 
+	0x0F128006,	//70000CC8//AFIT8_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad 
+	0x0F120020,	//70000CCA//AFIT8_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal
+	0x0F120000,	//70000CCC//AFIT8_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh
+	0x0F121800,	//70000CCE//AFIT8_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
+	0x0F120000,	//70000CD0//AFIT8_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit
+	0x0F121E10,	//70000CD2//AFIT8_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff
+	0x0F12000B,	//70000CD4//AFIT8_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0
+	0x0F120607,	//70000CD6//AFIT8_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2          
+	0x0F120005,	//70000CD8//AFIT8_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0          
+	0x0F120607,	//70000CDA//AFIT8_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2          
+	0x0F120405,	//70000CDC//AFIT8_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY           
+	0x0F120205,	//70000CDE//AFIT8_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm
+	0x0F120304,	//70000CE0//AFIT8_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm            
+	0x0F120409,	//70000CE2//AFIT8_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift
+	0x0F120306,	//70000CE4//AFIT8_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y  
+	0x0F120407,	//70000CE6//AFIT8_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y
+	0x0F122C04,	//70000CE8//AFIT8_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
+	0x0F12022C,	//70000CEA//AFIT8_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y
+	0x0F121402,	//70000CEC//AFIT8_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV
+	0x0F120618,	//70000CEE//AFIT8_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL
+	0x0F121A02,	//70000CF0//AFIT8_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL     
+	0x0F128018,	//70000CF2//AFIT8_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower
+	0x0F120080,	//70000CF4//AFIT8_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce
+	0x0F120080,	//70000CF6//AFIT8_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset
+	0x0F120180,	//70000CF8//AFIT8_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H 
+	0x0F120A0A,	//70000CFA//AFIT8_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C   
+	0x0F120101,	//70000CFC//AFIT8_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
+	0x0F120C0F,	//70000CFE//AFIT8_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh
+	0x0F126024,	//70000D00//AFIT8_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower
+	0x0F120808,	//70000D02//AFIT8_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise
+	0x0F12FFFF,	//70000D04//AFIT8_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp
+	0x0F120808,	//70000D06//AFIT8_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope
+	0x0F120A01,	//70000D08//AFIT8_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin
+	0x0F12010A,	//70000D0A//AFIT8_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin
+	0x0F120F01,	//70000D0C//AFIT8_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin
+	0x0F12240C,	//70000D0E//AFIT8_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin
+	0x0F120860,	//70000D10//AFIT8_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin
+	0x0F12FF08,	//70000D12//AFIT8_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin
+	0x0F1208FF,	//70000D14//AFIT8_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
+	0x0F120008,	//70000D16//AFIT8_ee_iReduceEdgeSlope_Bin [7:0]
+	0x0F120001,	//70000D18//AFITB_bnr_nClustLevel_C      [0]
+	0x0F1223CE,	//70000D19//ConstAfitBaseVals
+	0x0F12FDC8,	//70000D1A//ConstAfitBaseVals
+	0x0F12112E,	//70000D1B//ConstAfitBaseVals
+	0x0F1293A5,	//70000D1C//ConstAfitBaseVals
+	0x0F12FE67,	//70000D1D//ConstAfitBaseVals
+	0x0F120000,	//70000D1E//ConstAfitBaseVals
+
+/* 11.Auto Flicker Detection */
+	0x002A0F30,  
+	0x0F120001,	//AFC_D_ConvAccelerPower 
+
+	// Auto Flicker (60Mhz start)   
+	0x002A0F2A,  
+	0x0F120001,	//AFC_Default BIT[0] 1:60Hz 0:50Hz
+	0x002A04E6,  
+	0x0F12077F,	//REG_TC_DBG 7F: 60Hz  5F:50Hz
+
+/* 15.CCM Setting */
+
+	0x002A08A6, 
+	0x0F1200C0,	//SARR_AwbCcmCord[0]
+	0x0F120100,	//SARR_AwbCcmCord[1]
+	0x0F120125,	//SARR_AwbCcmCord[2]
+	0x0F12015F,	//SARR_AwbCcmCord[3]
+	0x0F12017C,	//SARR_AwbCcmCord[4]
+	0x0F120194,	//SARR_AwbCcmCord[5]
+	0x002A0898,  
+	0x0F124800,	//TVAR_wbt_pBaseCcms
+	0x0F127000,  
+	0x002A08A0,  
+	0x0F1248D8,	//TVAR_wbt_pOutdoorCcm
+	0x0F127000,  
+	//Horizon       
+	0x002A4800,  
+	0x0F120210,	//H TVAR_wbt_pBaseCcms[0]  
+	0x0F12FFC0,	//TVAR_wbt_pBaseCcms[1]  
+	0x0F12FFCC,	//TVAR_wbt_pBaseCcms[2]  
+	0x0F12FF34,	//TVAR_wbt_pBaseCcms[3]  
+	0x0F1201EB,	//TVAR_wbt_pBaseCcms[4]  
+	0x0F12FF09,	//TVAR_wbt_pBaseCcms[5]  
+	0x0F12001C,	//TVAR_wbt_pBaseCcms[6]  
+	0x0F12FFE4,	//TVAR_wbt_pBaseCcms[7]  
+	0x0F1201CD,	//TVAR_wbt_pBaseCcms[8]  
+	0x0F1200D9,	//TVAR_wbt_pBaseCcms[9]  
+	0x0F1200D9,	//TVAR_wbt_pBaseCcms[10] 
+	0x0F12FE95,	//TVAR_wbt_pBaseCcms[11] 
+	0x0F120208,	//TVAR_wbt_pBaseCcms[12] 
+	0x0F12FF75,	//TVAR_wbt_pBaseCcms[13] 
+	0x0F120199,	//TVAR_wbt_pBaseCcms[14] 
+	0x0F12FF06,	//TVAR_wbt_pBaseCcms[15] 
+	0x0F1201BA,	//TVAR_wbt_pBaseCcms[16] 
+	0x0F120108,	//TVAR_wbt_pBaseCcms[17] 
+
+	// INCA A                                       
+	0x0F120210,	//A TVAR_wbt_pBaseCcms[18] 
+	0x0F12FFC0,	//TVAR_wbt_pBaseCcms[19] 
+	0x0F12FFCC,	//TVAR_wbt_pBaseCcms[20] 
+	0x0F12FF34,	//TVAR_wbt_pBaseCcms[21] 
+	0x0F1201EB,	//TVAR_wbt_pBaseCcms[22] 
+	0x0F12FF09,	//TVAR_wbt_pBaseCcms[23] 
+	0x0F12001C,	//TVAR_wbt_pBaseCcms[24] 
+	0x0F12FFE4,	//TVAR_wbt_pBaseCcms[25] 
+	0x0F1201CD,	//TVAR_wbt_pBaseCcms[26] 
+	0x0F1200D9,	//TVAR_wbt_pBaseCcms[27] 
+	0x0F1200D9,	//TVAR_wbt_pBaseCcms[28] 
+	0x0F12FE95,	//TVAR_wbt_pBaseCcms[29] 
+	0x0F120208,	//TVAR_wbt_pBaseCcms[30] 
+	0x0F12FF75,	//TVAR_wbt_pBaseCcms[31] 
+	0x0F120199,	//TVAR_wbt_pBaseCcms[32] 
+	0x0F12FF06,	//TVAR_wbt_pBaseCcms[33] 
+	0x0F1201BA,	//TVAR_wbt_pBaseCcms[34] 
+	0x0F120108,	//TVAR_wbt_pBaseCcms[35] 
+
+	//Warm White                            
+	0x0F120227,	//CW TVAR_wbt_pBaseCcms[36] 
+	0x0F12FF95,	//TVAR_wbt_pBaseCcms[37] 
+	0x0F12FFE0,	//TVAR_wbt_pBaseCcms[38] 
+	0x0F12FED2,	//TVAR_wbt_pBaseCcms[39] 
+	0x0F120174,	//TVAR_wbt_pBaseCcms[40] 
+	0x0F12FF1F,	//TVAR_wbt_pBaseCcms[41] 
+	0x0F12FFCB,	//TVAR_wbt_pBaseCcms[42] 
+	0x0F12FFCB,	//TVAR_wbt_pBaseCcms[43] 
+	0x0F1201D6,	//TVAR_wbt_pBaseCcms[44] 
+	0x0F1200F8,	//TVAR_wbt_pBaseCcms[45] 
+	0x0F1200D5,	//TVAR_wbt_pBaseCcms[46] 
+	0x0F12FF34,	//TVAR_wbt_pBaseCcms[47] 
+	0x0F120151,	//TVAR_wbt_pBaseCcms[48] 
+	0x0F12FF50,	//TVAR_wbt_pBaseCcms[49] 
+	0x0F120147,	//TVAR_wbt_pBaseCcms[50] 
+	0x0F12FF86,	//FF75       //TVAR_wbt_pBaseCcms[51] 
+	0x0F1201B4,	//0187       //TVAR_wbt_pBaseCcms[52] 
+	0x0F12017E,	//01BF       //TVAR_wbt_pBaseCcms[53] 
+
+	//Cool White
+	0x0F120227,	//CW TVAR_wbt_pBaseCcms[54] 
+	0x0F12FF95,	//TVAR_wbt_pBaseCcms[55] 
+	0x0F12FFE0,	//TVAR_wbt_pBaseCcms[56] 
+	0x0F12FED2,	//TVAR_wbt_pBaseCcms[57] 
+	0x0F120174,	//TVAR_wbt_pBaseCcms[58] 
+	0x0F12FF1F,	//TVAR_wbt_pBaseCcms[59] 
+	0x0F12FFCB,	//TVAR_wbt_pBaseCcms[60] 
+	0x0F12FFCB,	//TVAR_wbt_pBaseCcms[61] 
+	0x0F1201D6,	//TVAR_wbt_pBaseCcms[62] 
+	0x0F1200F8,	//TVAR_wbt_pBaseCcms[63] 
+	0x0F1200D5,	//TVAR_wbt_pBaseCcms[64] 
+	0x0F12FF34,	//TVAR_wbt_pBaseCcms[65] 
+	0x0F120151,	//TVAR_wbt_pBaseCcms[66] 
+	0x0F12FF50,	//TVAR_wbt_pBaseCcms[67] 
+	0x0F120147,	//TVAR_wbt_pBaseCcms[68] 
+	0x0F12FF86,	//FF75       //TVAR_wbt_pBaseCcms[69] 
+	0x0F1201B4,	//0187       //TVAR_wbt_pBaseCcms[70] 
+	0x0F12017E,	//01BF       //TVAR_wbt_pBaseCcms[71] 
+
+	//D50   
+	0x0F1201EC,	//TVAR_wbt_pBaseCcms[72]  
+	0x0F12FFB2,	//TVAR_wbt_pBaseCcms[73] 
+	0x0F120007,	//TVAR_wbt_pBaseCcms[74] 
+	0x0F12FEE1,	//TVAR_wbt_pBaseCcms[75] 
+	0x0F12013A,	//TVAR_wbt_pBaseCcms[76] 
+	0x0F12FF3C,	//TVAR_wbt_pBaseCcms[77] 
+	0x0F12FFDB,	//TVAR_wbt_pBaseCcms[78] 
+	0x0F12FFDB,	//TVAR_wbt_pBaseCcms[79] 
+	0x0F1201BE,	//TVAR_wbt_pBaseCcms[80] 
+	0x0F1200D3,	//TVAR_wbt_pBaseCcms[81] 
+	0x0F1200E4,	//TVAR_wbt_pBaseCcms[82] 
+	0x0F12FF4A,	//TVAR_wbt_pBaseCcms[83] 
+	0x0F120151,	//TVAR_wbt_pBaseCcms[84] 
+	0x0F12FF50,	//TVAR_wbt_pBaseCcms[85] 
+	0x0F120147,	//TVAR_wbt_pBaseCcms[86] 
+	0x0F12FF86,	//FF74 //FF75        //TVAR_wbt_pBaseCcms[87] 
+	0x0F1201B4,	//01A2 //0187        //TVAR_wbt_pBaseCcms[88] 
+	0x0F12017E,	//01A2 //01BF        //TVAR_wbt_pBaseCcms[89] 
+
+	//D65       
+	0x0F1201EC,	//d65 TVAR_wbt_pBaseCcms[90]  
+	0x0F12FFB2,	//TVAR_wbt_pBaseCcms[91] 
+	0x0F120007,	//TVAR_wbt_pBaseCcms[92] 
+	0x0F12FEE1,	//TVAR_wbt_pBaseCcms[93] 
+	0x0F12013A,	//TVAR_wbt_pBaseCcms[94] 
+	0x0F12FF3C,	//TVAR_wbt_pBaseCcms[95] 
+	0x0F12FFDB,	//TVAR_wbt_pBaseCcms[96] 
+	0x0F12FFDB,	//TVAR_wbt_pBaseCcms[97] 
+	0x0F1201BE,	//TVAR_wbt_pBaseCcms[98] 
+	0x0F1200D3,	//TVAR_wbt_pBaseCcms[99] 
+	0x0F1200E4,	//TVAR_wbt_pBaseCcms[100]
+	0x0F12FF4A,	//TVAR_wbt_pBaseCcms[101]
+	0x0F120151,	//TVAR_wbt_pBaseCcms[102]
+	0x0F12FF50,	//TVAR_wbt_pBaseCcms[103]
+	0x0F120147,	//TVAR_wbt_pBaseCcms[104]
+	0x0F12FF86,	//FF74 //FF75        //TVAR_wbt_pBaseCcms[105]
+	0x0F1201B4,	//01A2 //0187        //TVAR_wbt_pBaseCcms[106]
+	0x0F12017E,	//01A2 //01BF        //TVAR_wbt_pBaseCcms[107]
+
+	//Outdoor       
+	0x002A48d8,
+	0x0F1201D4,	//TVAR_wbt_pOutdoorCcm[0] 
+	0x0F12FF9D,	//TVAR_wbt_pOutdoorCcm[1] 
+	0x0F12FFE8,	//TVAR_wbt_pOutdoorCcm[2] 
+	0x0F12FEA9,	//TVAR_wbt_pOutdoorCcm[3] 
+	0x0F120143,	//TVAR_wbt_pOutdoorCcm[4] 
+	0x0F12FF01,	//TVAR_wbt_pOutdoorCcm[5] 
+	0x0F12FFB7,	//TVAR_wbt_pOutdoorCcm[6] 
+	0x0F12FFF5,	//TVAR_wbt_pOutdoorCcm[7] 
+	0x0F120237,	//TVAR_wbt_pOutdoorCcm[8] 
+	0x0F1200B9,	//TVAR_wbt_pOutdoorCcm[9] 
+	0x0F120126,	//TVAR_wbt_pOutdoorCcm[10]
+	0x0F12FF33,	//TVAR_wbt_pOutdoorCcm[11]
+	0x0F1201CE,	//TVAR_wbt_pOutdoorCcm[12]
+	0x0F12FF83,	//TVAR_wbt_pOutdoorCcm[13]
+	0x0F120195,	//TVAR_wbt_pOutdoorCcm[14]
+	0x0F12FEF3,	//TVAR_wbt_pOutdoorCcm[15]
+	0x0F12014F,	//TVAR_wbt_pOutdoorCcm[16]
+	0x0F120137,	//TVAR_wbt_pOutdoorCcm[17]
+
+	/* 16.GAMMA */
+	0x002A0734,  
+	0x0F120000,	//saRR_usDualGammaLutRGBIndoor[0][0] 
+	0x0F12000A,	//saRR_usDualGammaLutRGBIndoor[0][1] 
+	0x0F120016,	//saRR_usDualGammaLutRGBIndoor[0][2] 
+	0x0F120030,	//saRR_usDualGammaLutRGBIndoor[0][3] 
+	0x0F120066,	//saRR_usDualGammaLutRGBIndoor[0][4] 
+	0x0F1200D5,	//saRR_usDualGammaLutRGBIndoor[0][5] 
+	0x0F120138,	//saRR_usDualGammaLutRGBIndoor[0][6] 
+	0x0F120163,	//saRR_usDualGammaLutRGBIndoor[0][7] 
+	0x0F120189,	//saRR_usDualGammaLutRGBIndoor[0][8] 
+	0x0F1201C6,	//saRR_usDualGammaLutRGBIndoor[0][9] 
+	0x0F1201F8,	//saRR_usDualGammaLutRGBIndoor[0][10]
+	0x0F120222,	//saRR_usDualGammaLutRGBIndoor[0][11]
+	0x0F120247,	//saRR_usDualGammaLutRGBIndoor[0][12]
+	0x0F120282,	//saRR_usDualGammaLutRGBIndoor[0][13]
+	0x0F1202B5,	//saRR_usDualGammaLutRGBIndoor[0][14]
+	0x0F12030F,	//saRR_usDualGammaLutRGBIndoor[0][15]
+	0x0F12035F,	//saRR_usDualGammaLutRGBIndoor[0][16]
+	0x0F1203A2,	//saRR_usDualGammaLutRGBIndoor[0][17]
+	0x0F1203D8,	//saRR_usDualGammaLutRGBIndoor[0][18]
+	0x0F1203FF,	//saRR_usDualGammaLutRGBIndoor[0][19]
+	0x0F120000,	//saRR_usDualGammaLutRGBIndoor[1][0] 
+	0x0F12000A,	//saRR_usDualGammaLutRGBIndoor[1][1] 
+	0x0F120016,	//saRR_usDualGammaLutRGBIndoor[1][2] 
+	0x0F120030,	//saRR_usDualGammaLutRGBIndoor[1][3] 
+	0x0F120066,	//saRR_usDualGammaLutRGBIndoor[1][4] 
+	0x0F1200D5,	//saRR_usDualGammaLutRGBIndoor[1][5] 
+	0x0F120138,	//saRR_usDualGammaLutRGBIndoor[1][6] 
+	0x0F120163,	//saRR_usDualGammaLutRGBIndoor[1][7] 
+	0x0F120189,	//saRR_usDualGammaLutRGBIndoor[1][8] 
+	0x0F1201C6,	//saRR_usDualGammaLutRGBIndoor[1][9] 
+	0x0F1201F8,	//saRR_usDualGammaLutRGBIndoor[1][10]
+	0x0F120222,	//saRR_usDualGammaLutRGBIndoor[1][11]
+	0x0F120247,	//saRR_usDualGammaLutRGBIndoor[1][12]
+	0x0F120282,	//saRR_usDualGammaLutRGBIndoor[1][13]
+	0x0F1202B5,	//saRR_usDualGammaLutRGBIndoor[1][14]
+	0x0F12030F,	//saRR_usDualGammaLutRGBIndoor[1][15]
+	0x0F12035F,	//saRR_usDualGammaLutRGBIndoor[1][16]
+	0x0F1203A2,	//saRR_usDualGammaLutRGBIndoor[1][17]
+	0x0F1203D8,	//saRR_usDualGammaLutRGBIndoor[1][18]
+	0x0F1203FF,	//saRR_usDualGammaLutRGBIndoor[1][19]
+	0x0F120000,	//saRR_usDualGammaLutRGBIndoor[2][0] 
+	0x0F12000A,	//saRR_usDualGammaLutRGBIndoor[2][1] 
+	0x0F120016,	//saRR_usDualGammaLutRGBIndoor[2][2] 
+	0x0F120030,	//saRR_usDualGammaLutRGBIndoor[2][3] 
+	0x0F120066,	//saRR_usDualGammaLutRGBIndoor[2][4] 
+	0x0F1200D5,	//saRR_usDualGammaLutRGBIndoor[2][5] 
+	0x0F120138,	//saRR_usDualGammaLutRGBIndoor[2][6] 
+	0x0F120163,	//saRR_usDualGammaLutRGBIndoor[2][7] 
+	0x0F120189,	//saRR_usDualGammaLutRGBIndoor[2][8] 
+	0x0F1201C6,	//saRR_usDualGammaLutRGBIndoor[2][9] 
+	0x0F1201F8,	//saRR_usDualGammaLutRGBIndoor[2][10]
+	0x0F120222,	//saRR_usDualGammaLutRGBIndoor[2][11]
+	0x0F120247,	//saRR_usDualGammaLutRGBIndoor[2][12]
+	0x0F120282,	//saRR_usDualGammaLutRGBIndoor[2][13]
+	0x0F1202B5,	//saRR_usDualGammaLutRGBIndoor[2][14]
+	0x0F12030F,	//saRR_usDualGammaLutRGBIndoor[2][15]
+	0x0F12035F,	//saRR_usDualGammaLutRGBIndoor[2][16]
+	0x0F1203A2,	//saRR_usDualGammaLutRGBIndoor[2][17]
+	0x0F1203D8,	//saRR_usDualGammaLutRGBIndoor[2][18]
+	0x0F1203FF,	//saRR_usDualGammaLutRGBIndoor[2][19]
+	0x0F120000,	//0000 //0000 //0000 //saRR_usDualGammaLutRGBOutdoor[0][0] 
+	0x0F120004,	//000C //000B //000B //saRR_usDualGammaLutRGBOutdoor[0][1] 
+	0x0F120010,	//0020 //0019 //0019 //saRR_usDualGammaLutRGBOutdoor[0][2] 
+	0x0F120020,	//0050 //0048 //0036 //saRR_usDualGammaLutRGBOutdoor[0][3] 
+	0x0F120060,	//0098 //008C //006F //saRR_usDualGammaLutRGBOutdoor[0][4] 
+	0x0F1200D8,	//00FC //00F0 //00D8 //saRR_usDualGammaLutRGBOutdoor[0][5] 
+	0x0F120148,	//0148 //0140 //0135 //saRR_usDualGammaLutRGBOutdoor[0][6] 
+	0x0F120174,	//0168 //0164 //015F //saRR_usDualGammaLutRGBOutdoor[0][7] 
+	0x0F120198,	//0185 //0185 //0185 //saRR_usDualGammaLutRGBOutdoor[0][8] 
+	0x0F1201D4,	//01C1 //01C1 //01C1 //saRR_usDualGammaLutRGBOutdoor[0][9] 
+	0x0F120208,	//01F3 //01F3 //01F3 //saRR_usDualGammaLutRGBOutdoor[0][10]
+	0x0F120234,	//0220 //0220 //0220 //saRR_usDualGammaLutRGBOutdoor[0][11]
+	0x0F120260,	//024A //024A //024A //saRR_usDualGammaLutRGBOutdoor[0][12]
+	0x0F1202A8,	//0291 //0291 //0291 //saRR_usDualGammaLutRGBOutdoor[0][13]
+	0x0F1202E4,	//02D0 //02D0 //02D0 //saRR_usDualGammaLutRGBOutdoor[0][14]
+	0x0F120340,	//032A //032A //032A //saRR_usDualGammaLutRGBOutdoor[0][15]
+	0x0F120380,	//036A //036A //036A //saRR_usDualGammaLutRGBOutdoor[0][16]
+	0x0F1203B0,	//039F //039F //039F //saRR_usDualGammaLutRGBOutdoor[0][17]
+	0x0F1203D8,	//03CC //03CC //03CC //saRR_usDualGammaLutRGBOutdoor[0][18]
+	0x0F1203F9,	//03F9 //03F9 //03F9 //saRR_usDualGammaLutRGBOutdoor[0][19]
+	0x0F120000,	//0000 //0000 //0000 //saRR_usDualGammaLutRGBOutdoor[1][0] 
+	0x0F120004,	//000C //000B //000B //saRR_usDualGammaLutRGBOutdoor[1][1] 
+	0x0F120010,	//0020 //0019 //0019 //saRR_usDualGammaLutRGBOutdoor[1][2] 
+	0x0F120020,	//0050 //0048 //0036 //saRR_usDualGammaLutRGBOutdoor[1][3] 
+	0x0F120060,	//0098 //008C //006F //saRR_usDualGammaLutRGBOutdoor[1][4] 
+	0x0F1200D8,	//00FC //00F0 //00D8 //saRR_usDualGammaLutRGBOutdoor[1][5] 
+	0x0F120148,	//0148 //0140 //0135 //saRR_usDualGammaLutRGBOutdoor[1][6] 
+	0x0F120174,	//0168 //0164 //015F //saRR_usDualGammaLutRGBOutdoor[1][7] 
+	0x0F120198,	//0185 //0185 //0185 //saRR_usDualGammaLutRGBOutdoor[1][8] 
+	0x0F1201D4,	//01C1 //01C1 //01C1 //saRR_usDualGammaLutRGBOutdoor[1][9] 
+	0x0F120208,	//01F3 //01F3 //01F3 //saRR_usDualGammaLutRGBOutdoor[1][10]
+	0x0F120234,	//0220 //0220 //0220 //saRR_usDualGammaLutRGBOutdoor[1][11]
+	0x0F120260,	//024A //024A //024A //saRR_usDualGammaLutRGBOutdoor[1][12]
+	0x0F1202A8,	//0291 //0291 //0291 //saRR_usDualGammaLutRGBOutdoor[1][13]
+	0x0F1202E4,	//02D0 //02D0 //02D0 //saRR_usDualGammaLutRGBOutdoor[1][14]
+	0x0F120340,	//032A //032A //032A //saRR_usDualGammaLutRGBOutdoor[1][15]
+	0x0F120380,	//036A //036A //036A //saRR_usDualGammaLutRGBOutdoor[1][16]
+	0x0F1203B0,	//039F //039F //039F //saRR_usDualGammaLutRGBOutdoor[1][17]
+	0x0F1203D8,	//03CC //03CC //03CC //saRR_usDualGammaLutRGBOutdoor[1][18]
+	0x0F1203F9,	//03F9 //03F9 //03F9 //saRR_usDualGammaLutRGBOutdoor[1][19]
+	0x0F120000,	//0000 //0000 //0000 //saRR_usDualGammaLutRGBOutdoor[2][0] 
+	0x0F120004,	//000C //000B //000B //saRR_usDualGammaLutRGBOutdoor[2][1] 
+	0x0F120010,	//0020 //0019 //0019 //saRR_usDualGammaLutRGBOutdoor[2][2] 
+	0x0F120020,	//0050 //0048 //0036 //saRR_usDualGammaLutRGBOutdoor[2][3] 
+	0x0F120060,	//0098 //008C //006F //saRR_usDualGammaLutRGBOutdoor[2][4] 
+	0x0F1200D8,	//00FC //00F0 //00D8 //saRR_usDualGammaLutRGBOutdoor[2][5] 
+	0x0F120148,	//0148 //0140 //0135 //saRR_usDualGammaLutRGBOutdoor[2][6] 
+	0x0F120174,	//0168 //0164 //015F //saRR_usDualGammaLutRGBOutdoor[2][7] 
+	0x0F120198,	//0185 //0185 //0185 //saRR_usDualGammaLutRGBOutdoor[2][8] 
+	0x0F1201D4,	//01C1 //01C1 //01C1 //saRR_usDualGammaLutRGBOutdoor[2][9] 
+	0x0F120208,	//01F3 //01F3 //01F3 //saRR_usDualGammaLutRGBOutdoor[2][10]
+	0x0F120234,	//0220 //0220 //0220 //saRR_usDualGammaLutRGBOutdoor[2][11]
+	0x0F120260,	//024A //024A //024A //saRR_usDualGammaLutRGBOutdoor[2][12]
+	0x0F1202A8,	//0291 //0291 //0291 //saRR_usDualGammaLutRGBOutdoor[2][13]
+	0x0F1202E4,	//02D0 //02D0 //02D0 //saRR_usDualGammaLutRGBOutdoor[2][14]
+	0x0F120340,	//032A //032A //032A //saRR_usDualGammaLutRGBOutdoor[2][15]
+	0x0F120380,	//036A //036A //036A //saRR_usDualGammaLutRGBOutdoor[2][16]
+	0x0F1203B0,	//039F //039F //039F //saRR_usDualGammaLutRGBOutdoor[2][17]
+	0x0F1203D8,	//03CC //03CC //03CC //saRR_usDualGammaLutRGBOutdoor[2][18]
+	0x0F1203F9,	//03F9 //03F9 //03F9 //saRR_usDualGammaLutRGBOutdoor[2][19]
+
+	0xFFFF000A, //Delay 10ms
+
+/* 21.Select Cofigration Display */
+	//PREVIEW
+	0x00287000, 
+	0x002A0266, 
+	0x0f120000,	//REG_TC_GP_ActivePrevConfig                    
+	0x002A026A, 
+	0x0F120001,	//REG_TC_GP_PrevOpenAfterChange                 
+	0x002A024E,
+	0x0F120001,	//REG_TC_GP_NewConfigSync                       
+	0x002A0268, 
+	0x0F120001,	//REG_TC_GP_PrevConfigChanged                   
+	0x002A023E, 
+	0x0F120000,	//REG_TC_GP_EnablePreview               
+	0x0F120001,	//REG_TC_GP_EnablePreviewChanged        
+
+	0xFFFF000A, //Delay 10ms
+
+/* 22. EDS Check */
+	0x00287000,
+	0x002A01A6,	//ESD Check
+	0x0f120A0A, 
+
+};
+static const u32 s5k4ecgx_DTP_init[] = {
+	0x00287000,
+	0x0028D000,
+	0x002AB054,
+	0x0F120001,
+	0x00287000,
+};
+
+static const u32 s5k4ecgx_DTP_stop[] = {
+	0x00287000,
+	0x0028D000,
+	0x002AB054,
+	0x0F120000,
+	0x00287000,
+};
+
+static const u32 s5k4ecgx_FPS_Auto[] = {
+	0x00287000,
+	0x002A02B4,
+	0x0F120052,
+	0x002A02BE,
+	0x0F120000,
+	0x0F120001,
+	0x0F12029A,
+	0x0F12014A,
+	0x002A02D0,
+	0x0F120000,
+	0x0F120000,
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,
+	0x002A0268,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_FPS_5[] = {
+
+};
+
+static const u32 s5k4ecgx_FPS_7[] = {
+	0x00287000,
+	0x002A02B4,
+	0x0F120052,
+	0x002A02BE,
+	0x0F120000,
+	0x0F120001,
+	0x0F120535,
+	0x0F120535,
+	0x002A02D0,
+	0x0F120000,
+	0x0F120000,
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,
+	0x002A0268,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_FPS_10[] = {
+
+};
+
+static const u32 s5k4ecgx_FPS_15[] = {
+	0x00287000,
+	0x002A02B4,
+	0x0F120052,
+	0x002A02BE,
+	0x0F120000,
+	0x0F120001,
+	0x0F12029A,
+	0x0F12029A,
+	0x002A02D0,
+	0x0F120000,
+	0x0F120000,
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,
+	0x002A0268,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_FPS_25[] = {
+	0x00287000,
+	0x002A02B4,
+	0x0F120052,
+	0x002A02BE,
+	0x0F120000,
+	0x0F120001,
+	0x0F12014D,
+	0x0F12014D,
+	0x002A02D0,
+	0x0F120000,
+	0x0F120000,
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,
+	0x002A0268,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_FPS_30[] = {
+	0x00287000,
+	0x002A02B4,
+	0x0F120052,
+	0x002A02BE,
+	0x0F120000,
+	0x0F120001,
+	0x0F12014D,
+	0x0F12014D,
+	0x002A02D0,
+	0x0F120000,
+	0x0F120000,
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,
+	0x002A0268,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_FPS_60[] = {
+
+};
+
+static const u32 s5k4ecgx_FPS_120[] = {
+
+};
+
+static const u32 s5k4ecgx_Effect_Normal[] = {
+	0x00287000,
+	0x002A023C,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_Effect_Solarization[] = {
+	0x00287000,
+	0x002A023C,
+	0x0F120002,
+};
+
+static const u32 s5k4ecgx_Effect_Negative[] = {
+	0x00287000,
+	0x002A023C,
+	0x0F120003,
+};
+
+static const u32 s5k4ecgx_Effect_Sepia[] = {
+	0x00287000,
+	0x002A023C,
+	0x0F120004,
+};
+
+static const u32 s5k4ecgx_Effect_Black_White[] = {
+	0x00287000,
+	0x002A023C,
+	0x0F120001,
+};
+
+
+static const u32 s5k4ecgx_WB_Auto[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F12077F,
+};
+
+static const u32 s5k4ecgx_WB_Sunny[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F120777,
+	0x002A04BA,
+	0x0F1205E0,
+	0x0F120001,
+	0x0F120400,
+	0x0F120001,
+	0x0F120530,
+	0x0F120001,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_WB_Cloudy[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F120777,
+	0x002A04BA,
+	0x0F120710,
+	0x0F120001,
+	0x0F120400,
+	0x0F120001,
+	0x0F120420,
+	0x0F120001,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_WB_Tungsten[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F120777,
+	0x002A04BA,
+	0x0F120390,
+	0x0F120001,
+	0x0F120400,
+	0x0F120001,
+	0x0F120920,
+	0x0F120001,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_WB_Fluorescent[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F120777,
+	0x002A04BA,
+	0x0F120505,
+	0x0F120001,
+	0x0F120400,
+	0x0F120001,
+	0x0F120875,
+	0x0F120001,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_WDR_on[] = {
+	0x00287000,
+	0x002A1BEA,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_WDR_off[] = {
+	0x00287000,
+	0x002A1BEA,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_ISO_Auto[] = {
+	0x00287000,
+	0x002A0938,
+	0x0F120000,
+
+	0x002A0F2A,
+	0x0F120001,
+	0x002A04E6,
+	0x0F12077F,
+
+	0x002A04D0,
+	0x0F120000,
+	0x0F120000,
+	0x0F120001,
+	0x002A06C2,
+	0x0F120200,
+};
+
+static const u32 s5k4ecgx_ISO_100[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F12065F,
+	0x002A04D6,
+	0x0F120000,
+	0x0F120001,
+
+	0x002A04D0,
+	0x0F120001,
+	0x0F1201A0,
+	0x0F120001,
+	0x002A06C2,
+	0x0F120100,
+
+	0x002A0938,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_ISO_200[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F12065F,
+	0x002A04D6,
+	0x0F120000,
+	0x0F120001,
+
+	0x002A04D0,
+	0x0F120001,
+	0x0F120340,
+	0x0F120001,
+	0x002A06C2,
+	0x0F120100,
+
+	0x002A0938,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_ISO_400[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F12065F,
+	0x002A04D6,
+	0x0F120000,
+	0x0F120001,
+
+	0x002A04D0,
+	0x0F120001,
+	0x0F120680,
+	0x0F120001,
+	0x002A06C2,
+	0x0F120100,
+
+	0x002A0938,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Metering_Matrix[] = {
+	0x00287000,
+	0x002A1492,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+};
+
+static const u32 s5k4ecgx_Metering_Center[] = {
+	0x00287000,
+	0x002A1492,
+	0x0F120000,
+	0x0F120101,
+	0x0F120101,
+	0x0F120000,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120201,
+	0x0F120303,
+	0x0F120303,
+	0x0F120102,
+	0x0F120201,
+	0x0F120403,
+	0x0F120304,
+	0x0F120102,
+	0x0F120201,
+	0x0F120403,
+	0x0F120304,
+	0x0F120102,
+	0x0F120201,
+	0x0F120403,
+	0x0F120304,
+	0x0F120102,
+	0x0F120201,
+	0x0F120303,
+	0x0F120303,
+	0x0F120102,
+	0x0F120201,
+	0x0F120202,
+	0x0F120202,
+	0x0F120102,
+};
+
+static const u32 s5k4ecgx_Metering_Spot[] = {
+	0x00287000,
+	0x002A1492,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120101,
+	0x0F120101,
+	0x0F120000,
+	0x0F120000,
+	0x0F12010F,
+	0x0F120F01,
+	0x0F120000,
+	0x0F120000,
+	0x0F12010F,
+	0x0F120F01,
+	0x0F120000,
+	0x0F120000,
+	0x0F120101,
+	0x0F120101,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_EV_Minus_4[] = {
+	0x00287000,
+	0x002A0230,
+	0x0F12FF30,
+};
+
+static const u32 s5k4ecgx_EV_Minus_3[] = {
+	0x00287000,
+	0x002A0230,
+	0x0F12FFA0,
+};
+
+static const u32 s5k4ecgx_EV_Minus_2[] = {
+	0x00287000,
+	0x002A0230,
+	0x0F12FFC8,
+};
+
+static const u32 s5k4ecgx_EV_Minus_1[] = {
+	0x00287000,
+	0x002A0230,
+	0x0F12FFE0,
+};
+
+static const u32 s5k4ecgx_EV_Default[] = {
+	0x00287000,
+	0x002A0230,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_EV_Plus_1[] = {
+	0x00287000,
+	0x002A0230,
+	0x0F120020,
+};
+
+static const u32 s5k4ecgx_EV_Plus_2[] = {
+	0x00287000,
+	0x002A0230,
+	0x0F120038,
+};
+
+static const u32 s5k4ecgx_EV_Plus_3[] = {
+	0x00287000,
+	0x002A0230,
+	0x0F120060,
+};
+
+static const u32 s5k4ecgx_EV_Plus_4[] = {
+	0x00287000,
+	0x002A0230,
+	0x0F12007F,
+};
+
+static const u32 s5k4ecgx_Contrast_Minus_4[] = {
+	0x00287000,
+	0x002A0232,
+	0x0F12FF81,
+};
+
+static const u32 s5k4ecgx_Contrast_Minus_3[] = {
+	0x00287000,
+	0x002A0232,
+	0x0F12FFA0,
+};
+
+static const u32 s5k4ecgx_Contrast_Minus_2[] = {
+	0x00287000,
+	0x002A0232,
+	0x0F12FFC0,
+};
+
+static const u32 s5k4ecgx_Contrast_Minus_1[] = {
+	0x00287000,
+	0x002A0232,
+	0x0F12FFE0,
+};
+
+static const u32 s5k4ecgx_Contrast_Default[] = {
+	0x00287000,
+	0x002A0232,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_Contrast_Plus_1[] = {
+	0x00287000,
+	0x002A0232,
+	0x0F120020,
+};
+
+static const u32 s5k4ecgx_Contrast_Plus_2[] = {
+	0x00287000,
+	0x002A0232,
+	0x0F120040,
+};
+
+static const u32 s5k4ecgx_Contrast_Plus_3[] = {
+	0x00287000,
+	0x002A0232,
+	0x0F120060,
+};
+
+static const u32 s5k4ecgx_Contrast_Plus_4[] = {
+	0x00287000,
+	0x002A0232,
+	0x0F12007F,
+};
+
+static const u32 s5k4ecgx_Sharpness_Minus_3[] = {
+	0x00287000,
+	0x002A0A28,
+	0x0F120000,
+	0x002A0ADE,
+	0x0F120000,
+	0x002A0B94,
+	0x0F120000,
+	0x002A0C4A,
+	0x0F120000,
+	0x002A0D00,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_Sharpness_Minus_2[] = {
+	0x00287000,
+	0x002A0A28,
+	0x0F122010,
+	0x002A0ADE,
+	0x0F122010,
+	0x002A0B94,
+	0x0F122010,
+	0x002A0C4A,
+	0x0F122010,
+	0x002A0D00,
+	0x0F122010,
+};
+
+static const u32 s5k4ecgx_Sharpness_Minus_1[] = {
+	0x00287000,
+	0x002A0A28,
+	0x0F124020,
+	0x002A0ADE,
+	0x0F124020,
+	0x002A0B94,
+	0x0F124020,
+	0x002A0C4A,
+	0x0F124020,
+	0x002A0D00,
+	0x0F124020,
+};
+
+static const u32 s5k4ecgx_Sharpness_Default[] = {
+	0x00287000,
+	0x002A0A28,
+	0x0F126024,
+	0x002A0ADE,
+	0x0F126024,
+	0x002A0B94,
+	0x0F126024,
+	0x002A0C4A,
+	0x0F126024,
+	0x002A0D00,
+	0x0F126024,
+};
+
+static const u32 s5k4ecgx_Sharpness_Plus_1[] = {
+	0x00287000,
+	0x002A0A28,
+	0x0F128040,
+	0x002A0ADE,
+	0x0F128040,
+	0x002A0B94,
+	0x0F128040,
+	0x002A0C4A,
+	0x0F128040,
+	0x002A0D00,
+	0x0F128040,
+};
+
+static const u32 s5k4ecgx_Sharpness_Plus_2[] = {
+	0x00287000,
+	0x002A0A28,
+	0x0F12A060,
+	0x002A0ADE,
+	0x0F12A060,
+	0x002A0B94,
+	0x0F12A060,
+	0x002A0C4A,
+	0x0F12A060,
+	0x002A0D00,
+	0x0F12A060,
+};
+
+static const u32 s5k4ecgx_Sharpness_Plus_3[] = {
+	0x00287000,
+	0x002A0A28,
+	0x0F12C080,
+	0x002A0ADE,
+	0x0F12C080,
+	0x002A0B94,
+	0x0F12C080,
+	0x002A0C4A,
+	0x0F12C080,
+	0x002A0D00,
+	0x0F12C080,
+};
+
+static const u32 s5k4ecgx_Saturation_Minus_2[] = {
+	0x00287000,
+	0x002A0234,
+	0x0F12FF81,
+};
+
+static const u32 s5k4ecgx_Saturation_Minus_1[] = {
+	0x00287000,
+	0x002A0234,
+	0x0F12FFC0,
+};
+
+static const u32 s5k4ecgx_Saturation_Default[] = {
+	0x00287000,
+	0x002A0234,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_Saturation_Plus_1[] = {
+	0x00287000,
+	0x002A0234,
+	0x0F120040,
+};
+
+static const u32 s5k4ecgx_Saturation_Plus_2[] = {
+	0x00287000,
+	0x002A0234,
+	0x0F12007F,
+};
+
+static const u32 s5k4ecgx_Jpeg_Quality_High[] = {
+	0x00287000,
+	0x002A0478,
+	0x0F12005F,
+	0x0F12005F,
+};
+
+static const u32 s5k4ecgx_Jpeg_Quality_Normal[] = {
+	0x00287000,
+	0x002A0478,
+	0x0F12005A,
+	0x0F12005A,
+};
+
+static const u32 s5k4ecgx_Jpeg_Quality_Low[] = {
+	0x00287000,
+	0x002A0478,
+	0x0F120054,
+	0x0F120054,
+};
+
+static const u32 s5k4ecgx_Scene_Default[] = {
+	0x00287000,
+	0x002A1492,
+	0x0F120000,
+	0x0F120101,
+	0x0F120101,
+	0x0F120000,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120201,
+	0x0F120303,
+	0x0F120303,
+	0x0F120102,
+	0x0F120201,
+	0x0F120403,
+	0x0F120304,
+	0x0F120102,
+	0x0F120201,
+	0x0F120403,
+	0x0F120304,
+	0x0F120102,
+	0x0F120201,
+	0x0F120403,
+	0x0F120304,
+	0x0F120102,
+	0x0F120201,
+	0x0F120303,
+	0x0F120303,
+	0x0F120102,
+	0x0F120201,
+	0x0F120202,
+	0x0F120202,
+	0x0F120102,
+
+	0x002A0938,
+	0x0F120000,
+
+	0x002A06B8,
+	0x0F12452C,
+	0x0F12000C,
+
+	0x002A0F2A,
+	0x0F120001,
+	0x002A0F30,
+	0x0F120001,
+	0x002A04E6,
+	0x0F12077F,
+
+	0x002A04D0,
+	0x0F120000,
+	0x0F120000,
+	0x0F120001,
+	0x002A06C2,
+	0x0F120200,
+
+	0x002A2C66,
+	0x0F120001,
+
+	0x002A1484,
+	0x0F12003C,
+	0x002A148A,
+	0x0F12000F,
+	0x002A058C,
+	0x0F123520,
+	0x0F120000,
+	0x0F12C350,
+	0x0F120000,
+	0x0F123520,
+	0x0F120000,
+	0x0F12C350,
+	0x0F120000,
+	0x0F120470,
+	0x0F120C00,
+	0x0F120100,
+	0x0F121000,
+
+	0x002A0544,
+	0x0F120111,
+	0x0F1200EF,
+
+	0x002A0608,
+	0x0F120001,
+	0x0F120001,
+
+	0x002A0A28,
+	0x0F126024,
+	0x002A0ADE,
+	0x0F126024,
+	0x002A0B94,
+	0x0F126024,
+	0x002A0C4A,
+	0x0F126024,
+	0x002A0D00,
+	0x0F126024,
+
+	0x002A0234,
+	0x0F120000,
+
+	0x002A0638,
+	0x0F120001,
+	0x0F120000,
+	0x002A063C,
+	0x0F120A3C,
+	0x0F120000,
+	0x002A0640,
+	0x0F120D05,
+	0x0F120000,
+	0x002A0644,
+	0x0F123408,
+	0x0F120000,
+	0x002A0648,
+	0x0F123408,
+	0x0F120000,
+	0x002A064C,
+	0x0F126810,
+	0x0F120000,
+	0x002A0650,
+	0x0F128214,
+	0x0F120000,
+	0x002A0654,
+	0x0F12C350,
+	0x0F120000,
+	0x002A0658,
+	0x0F12C350,
+	0x0F120000,
+	0x002A065C,
+	0x0F12C350,
+	0x0F120000,
+
+	0x002A02C2,
+	0x0F12029A,	/*#REG_0TC_PCFG_usMaxFrTimeMsecMult10*/
+	0x0F12014A,	/*#REG_0TC_PCFG_usMinFrTimeMsecMult10*/
+
+	0x002A03B4,
+	0x0F120535,
+	0x0F12029A,
+
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,
+	0x002A0268,
+	0x0F120001,
+	0x002A0270,
+	0x0F120001,
+	0x002A023E,
+	0x0F120001,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Scene_Portrait[] = {
+	0x00287000,
+	0x002A0A28,
+	0x0F122010,
+	0x002A0ADE,
+	0x0F122010,
+	0x002A0B94,
+	0x0F122010,
+	0x002A0C4A,
+	0x0F122010,
+	0x002A0D00,
+	0x0F122010,
+};
+
+static const u32 s5k4ecgx_Scene_Nightshot[] = {
+	0x00287000,
+	0x002A06B8,
+	0x0F12FFFF,
+	0x0F1200FF,
+
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120900,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+
+	0x002A0658,
+	0x0F12D090,
+	0x0F120007,
+	0x0F12D090,
+	0x0F120007,
+
+	0x002A03B4,
+	0x0F121388,
+	0x0F121388,
+	0x002A02C2,
+	0x0F1209C4,
+	0x0F12014A,
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,
+	0x002A0268,
+	0x0F120001,
+	0x002A0270,
+	0x0F120001,
+	0x002A023E,
+	0x0F120001,
+	0x0F120001,
+
+	0x002A0A1E,
+	0x0F121580,
+};
+
+static const u32 s5k4ecgx_Scene_Backlight[] = {
+	0x00287000,
+	0x002A1492,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120101,
+	0x0F120101,
+	0x0F120000,
+	0x0F120000,
+	0x0F12010F,
+	0x0F120F01,
+	0x0F120000,
+	0x0F120000,
+	0x0F12010F,
+	0x0F120F01,
+	0x0F120000,
+	0x0F120000,
+	0x0F120101,
+	0x0F120101,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_Scene_Landscape[] = {
+	0x00287000,
+	0x002A1492,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x0F120101,
+	0x002A0A28,
+	0x0F12E082,
+	0x002A0ADE,
+	0x0F12E082,
+	0x002A0B94,
+	0x0F12E082,
+	0x002A0C4A,
+	0x0F12E082,
+	0x002A0D00,
+	0x0F12E082,
+	0x002A0234,
+	0x0F120030,
+};
+
+static const u32 s5k4ecgx_Scene_Sports[] = {
+	0x00287000,
+	0x002A0608,
+	0x0F120000,
+	0x0F120000,
+
+	0x002A058C,
+	0x0F123520,
+	0x0F120000,
+	0x0F123520,
+	0x0F120000,
+	0x0F123520,
+	0x0F120000,
+	0x0F123520,
+	0x0F120000,
+	0x0F120200,
+	0x0F120200,
+	0x0F120200,
+	0x0F120200,
+
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,
+	0x002A0268,
+	0x0F120001,
+	0x002A0270,
+	0x0F120001,
+	0x002A023E,
+	0x0F120001,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Scene_Party_Indoor[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F12065F,
+	0x002A04D6,
+	0x0F120000,
+	0x0F120001,
+
+	0x002A04D0,
+	0x0F120001,
+	0x0F120340,
+	0x0F120001,
+	0x002A06C2,
+	0x0F120100,
+
+	0x002A0938,
+	0x0F120001,
+
+	0x002A0234,
+	0x0F120030,
+};
+
+static const u32 s5k4ecgx_Scene_Beach_Snow[] = {
+	0x00287000,
+	0x002A1484,
+	0x0F120045,	/*#TVAR_ae_BrAve*/
+	0x002A04E6,
+	0x0F12065F,
+	0x002A04D6,
+	0x0F120000,
+	0x0F120001,
+	0x002A04D0,
+	0x0F120001,
+	0x0F1200D0,
+	0x0F120001,
+	0x002A06C2,
+	0x0F120100,
+
+	0x002A0938,
+	0x0F120001,
+
+	0x002A0234,
+	0x0F120030,
+};
+
+static const u32 s5k4ecgx_Scene_Sunset[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F120777,
+
+	0x002A04BA,
+	0x0F1205E0,
+	0x0F120001,
+	0x0F120400,
+	0x0F120001,
+	0x0F120530,
+	0x0F120001,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Scene_Duskdawn[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F120777,
+	0x002A04BA,
+	0x0F120505,
+	0x0F120001,
+	0x0F120400,
+	0x0F120001,
+	0x0F120875,
+	0x0F120001,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Scene_Fall_Color[] = {
+	0x00287000,
+	0x002A0234,
+	0x0F120060,
+};
+
+static const u32 s5k4ecgx_Scene_Fireworks[] = {
+	0x00287000,
+	0x002A0638,
+	0x0F120001,
+	0x0F120000,
+	0x002A063C,
+	0x0F121478,
+	0x0F120000,
+	0x002A0640,
+	0x0F121A0A,
+	0x0F120000,
+	0x002A0644,
+	0x0F126810,
+	0x0F120000,
+	0x002A0648,
+	0x0F126810,
+	0x0F120000,
+	0x002A064C,
+	0x0F12D020,
+	0x0F120000,
+	0x002A0650,
+	0x0F120428,
+	0x0F120001,
+	0x002A0654,
+	0x0F121A80,
+	0x0F120006,
+	0x002A0658,
+	0x0F121A80,
+	0x0F120006,
+	0x002A065C,
+	0x0F121A80,
+	0x0F120006,
+
+	0x002A03B4,
+	0x0F122710,
+	0x0F122710,
+
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,
+	0x002A0268,
+	0x0F120001,
+	0x002A0270,
+	0x0F120001,
+	0x002A023E,
+	0x0F120001,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Scene_Text[] = {
+	0x00287000,
+	0x002A0A28,
+	0x0F12A060,
+	0x002A0ADE,
+	0x0F12A060,
+	0x002A0B94,
+	0x0F12A060,
+	0x002A0C4A,
+	0x0F12A060,
+	0x002A0D00,
+	0x0F12A060,
+};
+
+static const u32 s5k4ecgx_Scene_Candle_Light[] = {
+	0x00287000,
+	0x002A04E6,
+	0x0F120777,
+	0x002A04BA,
+	0x0F1205E0,
+	0x0F120001,
+	0x0F120400,
+	0x0F120001,
+	0x0F120530,
+	0x0F120001,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Night_Capture[] = {
+	0x00287000,
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120900,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+};
+
+static const u32 s5k4ecgx_AF_Return_Macro_pos[] = {
+	0x00287000,
+	0x002A15E8,
+	0x0F120018,
+	0x0F12002A,
+	0x0F120030,
+	0x0F120036,
+	0x0F12003C,
+	0x0F120042,
+	0x0F120048,
+	0x0F12004E,
+	0x0F120054,
+	0x0F12005A,
+	0x0F120060,
+	0x0F120066,
+	0x0F12006C,
+	0x0F120072,
+	0x0F120078,
+	0x0F12007E,
+	0x0F120084,
+	0x0F12008A,
+	0x0F120090,
+	0x0F120096,
+	0x0F12009C,
+	0x0F1200A2,
+	0x0F1200A8,
+	0x0F1200AE,
+	0x0F1200B4,
+	0x0F1200BA,
+};
+
+static const u32 s5k4ecgx_AF_Normal_mode_1[] = {
+	0x00287000,
+	0x002A028E,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_AF_Normal_mode_2[] = {
+	0x00287000,
+	0x002A028C,
+	0x0F120004,
+};
+
+static const u32 s5k4ecgx_AF_Normal_mode_3[] = {
+	0x00287000,
+	0x002A1648,
+	0x0F129002,
+};
+
+static const u32 s5k4ecgx_AF_Macro_mode_1[] = {
+	0x00287000,
+	0x002A028E,
+	0x0F1200D0,
+};
+
+static const u32 s5k4ecgx_AF_Macro_mode_2[] = {
+	0x00287000,
+	0x002A028C,
+	0x0F120004,
+};
+
+static const u32 s5k4ecgx_AF_Macro_mode_3[] = {
+	0x00287000,
+	0x002A1648,
+	0x0F129042,
+	0x002A15DA,
+	0x0F121800,
+};
+
+static const u32 s5k4ecgx_AF_Low_Light_Mode_On[] = {
+	0x00287000,
+	0x002A15DA,
+	0x0F120C00,
+
+	0x002A15E8,
+	0x0F12000C,
+	0x0F12002A,
+	0x0F120033,
+	0x0F12003C,
+	0x0F120045,
+	0x0F12004E,
+	0x0F120057,
+	0x0F120063,
+	0x0F12006F,
+	0x0F12007B,
+	0x0F120087,
+	0x0F120093,
+	0x0F1200A2,
+	0x0F1200B1,
+};
+
+static const u32 s5k4ecgx_AF_Low_Light_Mode_Off[] = {
+	0x00287000,
+	0x002A15DA,
+	0x0F121800,
+
+	0x002A15E8,
+	0x0F120018,
+	0x0F12002A,
+	0x0F120030,
+	0x0F120036,
+	0x0F12003C,
+	0x0F120042,
+	0x0F120048,
+	0x0F12004E,
+	0x0F120054,
+	0x0F12005A,
+	0x0F120060,
+	0x0F120066,
+	0x0F12006C,
+	0x0F120072,
+	0x0F120078,
+	0x0F12007E,
+	0x0F120084,
+	0x0F12008A,
+	0x0F120090,
+	0x0F120096,
+	0x0F12009C,
+	0x0F1200A2,
+	0x0F1200A8,
+	0x0F1200AE,
+	0x0F1200B4,
+	0x0F1200BA,
+};
+
+static const u32 s5k4ecgx_Single_AF_Start[] = {
+	0x00287000,
+	0x002A028E,
+	0x0F120000,
+	0xFFFF0096,
+	0x002A028C,
+	0x0F120005,
+};
+
+static const u32 s5k4ecgx_Video_AF_Start[] = {
+	0x00287000,
+	0x002A028E,
+	0x0F120000,
+	0xFFFF0096,
+	0x002A028C,
+	0x0F120006,
+};
+
+static const u32 s5k4ecgx_Single_AF_Off_1[] = {
+	0x00287000,
+	0x002A028E,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_Single_AF_Off_2[] = {
+	0x00287000,
+	0x002A028C,
+	0x0F120004,
+};
+
+static const u32 s5k4ecgx_Single_AF_Off_3[] = {
+
+};
+
+static const u32 s5k4ecgx_Face_Detection_On[] = {
+	0x00287000,
+	0x002A0294,
+	0x0F120100,
+	0x0F1200E3,
+	0x0F120200,
+	0x0F120238,
+	0x0F1201C6,
+	0x0F120166,
+	0x0F120074,
+	0x0F120132,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Face_Detection_Off[] = {
+	0x00287000,
+	0x002A0294,
+	0x0F120100,
+	0x0F1200E3,
+	0x0F120200,
+	0x0F120238,
+	0x0F1201C6,
+	0x0F120166,
+	0x0F120074,
+	0x0F120132,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Low_Cap_On[] = {
+	0x00287000,
+	0x002A06B8,
+	0x0F12FFFF,
+	0x0F1200FF, /*#lt_uMaxLei*/
+
+	0x002A0A1A,
+	0x0F124A18, /*#Gamma linearity*/
+
+
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120850,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+
+	0x002A0938,
+	0x0F120001,
+	0x0F120012,	/*#SARR_uNormBrInDoor_0_*/
+	0x0F120022,	/*#SARR_uNormBrInDoor_1_*/
+	0x0F120384,	/*#SARR_uNormBrInDoor_2_*/
+	0x0F1207D0,	/*#SARR_uNormBrInDoor_3_*/
+	0x0F121388,	/*#SARR_uNormBrInDoor_4_*/
+};
+
+static const u32 s5k4ecgx_Low_Cap_Off[] = {
+	0x00287000,
+	0x002A06B8,
+	0x0F12452C,
+	0x0F12000C,	/*#lt_uMaxLei*/
+
+	0x002A0A1A,
+	0x0F128F18, /*#Gamma linearity*/
+
+
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120C00,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+
+	0x002A0938,
+	0x0F120000,
+	0x0F120014,	/*#SARR_uNormBrInDoor_0_*/
+	0x0F1200D2,	/*#SARR_uNormBrInDoor_1_*/
+	0x0F120384,	/*#SARR_uNormBrInDoor_2_*/
+	0x0F1207D0,	/*#SARR_uNormBrInDoor_3_*/
+	0x0F121388,	/*#SARR_uNormBrInDoor_4_*/
+};
+
+/* restores crop settings to full resolution */
+static const u32 s5k4ecgx_Reset_Crop[] = {
+	0x00287000,
+	0x002A0250,
+	0x0F120A00,
+	0x0F120780,
+	0x0F120010,
+	0x0F12000C,
+	0x0F120A00,
+	0x0F120780,
+	0x0F120010,
+	0x0F12000C,
+	0x002A0494,
+	0x0F120A00,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+	0x0F120A00,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+
+	0x002A0262,
+	0x0F120001,
+	0x0F120001,
+};
+
+/* Wide capture 2048x1104 for P2*/
+static const u32 s5k4ecgx_change_wide_cap[] = {
+//================================
+// 17.Input Size Setting
+//================================
+
+0x00287000,
+0x002A01F6,
+0x0F120800,	//REG_TC_GP_PrevReqInputWidth //800h=2048d
+0x0F120450,	//REG_TC_GP_PrevReqInputHeight //600h=1536d
+0x0F120000,	//REG_TC_GP_PrevInputWidthOfs
+0x0F1200D8,	//REG_TC_GP_PrevInputHeightOfs (600h-480h)/2
+0x0F120800,	//REG_TC_GP_CapReqInputWidth //800h=2048d
+0x0F120450,	//REG_TC_GP_CapReqInputHeight //600h=1536
+0x0F120000,	//REG_TC_GP_CapInputWidthOfs
+0x0F1200D8,	//REG_TC_GP_CapInputHeightOfs
+0x002A0216,
+0x0F120001,	//REG_TC_GP_bUseReqInputInPre
+0x0F120001,	//REG_TC_GP_bUseReqInputInCap
+0x002A043C,
+0x0F120800,	//REG_TC_PZOOM_ZoomInputWidth //800h=2048d
+0x0F120450,	//REG_TC_PZOOM_ZoomInputHeight //600h=1536
+0x0F120000,	//REG_TC_PZOOM_ZoomInputWidthOfs
+0x0F1200D8,	//REG_TC_PZOOM_ZoomInputHeightOfs
+
+//================================
+// 18.Preview & Capture Configration Setting
+//================================
+
+//Preview Config  10fps~30fps
+0x002A023E,
+0x0F120400,	//REG_0TC_PCFG_usWidth //280h=640d
+0x0F120228,	//REG_0TC_PCFG_usHeight //1E0h=480d
+
+
+//Capture Config 0  2048x1536 7.5~15fps
+0x002A032E,
+0x0F120000,	//REG_0TC_CCFG_uCaptureMode
+0x0F120800,	//REG_0TC_CCFG_usWidth //800h=2048d
+0x0F120600,	//REG_0TC_CCFG_usHeight //600h=1536d
+};
+static const u32 s5k4ecgx_restore_capture_reg[] = {
+	0x00287000,
+	//================================
+	// 17.Input Size Setting
+	//================================
+	
+	0x00287000,
+	0x002A01F6,
+	0x0F120800,	//REG_TC_GP_PrevReqInputWidth //800h=2048d
+	0x0F120600,	//REG_TC_GP_PrevReqInputHeight //600h=1536d
+	0x0F120000,	//REG_TC_GP_PrevInputWidthOfs
+	0x0F120000,	//REG_TC_GP_PrevInputHeightOfs
+	0x0F120800,	//REG_TC_GP_CapReqInputWidth //800h=2048d
+	0x0F120600,	//REG_TC_GP_CapReqInputHeight //600h=1536
+	0x0F120000,	//REG_TC_GP_CapInputWidthOfs
+	0x0F120000,	//REG_TC_GP_CapInputHeightOfs
+	0x002A0216,
+	0x0F120001,	//REG_TC_GP_bUseReqInputInPre
+	0x0F120001,	//REG_TC_GP_bUseReqInputInCap
+	0x002A043C,
+	0x0F120800,	//REG_TC_PZOOM_ZoomInputWidth //800h=2048d
+	0x0F120600,	//REG_TC_PZOOM_ZoomInputHeight //600h=1536
+	0x0F120000,	//REG_TC_PZOOM_ZoomInputWidthOfs
+	0x0F120000,	//REG_TC_PZOOM_ZoomInputHeightOfs
+	
+	//================================
+	// 18.Preview & Capture Configration Setting
+	//================================
+	
+	//Preview Config  10fps~30fps
+	0x002A023E,
+	0x0F120400,	//REG_0TC_PCFG_usWidth //280h=640d
+	0x0F120300,	//REG_0TC_PCFG_usHeight //1E0h=480d
+	
+	
+	//Capture Config 0  2048x1536 7.5~15fps
+	0x002A032E,
+	0x0F120000,	//REG_0TC_CCFG_uCaptureMode
+	0x0F120800,	//REG_0TC_CCFG_usWidth //800h=2048d
+	0x0F120600,	//REG_0TC_CCFG_usHeight //600h=1536d
+};
+
+static const u32 s5k4ecgx_Preview_Return[] = {
+	0x00287000,
+	0x002A0A1E,
+	0x0F120028,
+
+	0x002A0AD4,
+	0x0F12003C,
+
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120C00,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+
+	0x002A05D0,
+	0x0F120000,
+
+	0x002A0972,
+	0x0F120000,
+
+	0x002A0242,
+	0x0F120000,
+
+	0x002A024E,
+	0x0F120001,
+
+	0x002A0244,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Flash_init[] = {
+	0x00287000,
+	0x002A0484,
+	0x0F120002,	/* capture flash on */
+
+	0x002A183A,
+	0x0F120001,	/* one frame AE*/
+
+	0x002A17F6,
+	0x0F120258,	/* AWB R point */
+	0x0F120248,	/* AWB B point */
+
+	0x002A1840,
+	0x0F120001,	/* Fls AE tune start */
+
+	0x0F120100,	/* fls_afl_FlsAFIn  Rin */
+	0x0F120120,
+	0x0F120180,
+	0x0F120200,
+	0x0F120400,
+	0x0F120800,
+	0x0F120A00,
+	0x0F121000,
+
+	0x0F120100,	/* fls_afl_FlsAFOut  Rout */
+	0x0F1200A0,
+	0x0F120090,
+	0x0F120080,
+	0x0F120070,
+	0x0F120045,
+	0x0F120030,
+	0x0F120010,
+
+	0x002A1884,
+	0x0F120100,	/* fls_afl_FlsNBOut  flash NB default */
+	0x0F120100,
+	0x0F120100,
+	0x0F120100,
+	0x0F120100,
+	0x0F120100,
+	0x0F120100,
+	0x0F120100,
+
+	0x002A1826,
+
+	0x0F120100,	/* fls_afl_FlashWP_Weight  flash NB default */
+	0x0F1200C0,
+	0x0F120080,
+	0x0F12000A,
+	0x0F120000,
+
+	0x0F120030,	/* fls_afl_FlashWP_Weight  flash NB default */
+	0x0F120040,
+	0x0F120048,
+	0x0F120050,
+	0x0F120060,
+
+	0x002A4784,
+	0x0F1200A0,	/* TNP_Regs_FlsWeightRIn  weight tune start in*/
+	0x0F1200C0,
+	0x0F1200D0,
+	0x0F120100,
+	0x0F120200,
+	0x0F120300,
+
+	0x0F120088,	/* TNP_Regs_FlsWeightROut  weight tune start out*/
+	0x0F1200B0,
+	0x0F1200C0,
+	0x0F120100,
+	0x0F120200,
+	0x0F120300,
+
+	0x002A479C,
+
+	0x0F120120,	/*Fls  BRIn  */
+	0x0F120150,
+	0x0F120200,
+
+	0x0F12003C,	/* Fls  BROut*/
+	0x0F12003B,
+	0x0F120030,
+
+};
+
+static const u32 s5k4ecgx_Pre_Flash_Start[] = {
+	0x00287000,
+	0x002A0588, /* set AE speed to fast */
+	0x0F120000,
+
+	0x002A17FC, /* fls_afl_FlashWP_Weight_0_  Pre_Flash_Start */
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Pre_Flash_End[] = {
+	0x00287000,
+	0x002A0588, /* set AE speed to normal */
+	0x0F120002,
+
+	0x002A1800, /* fls_afl_FlashWP_Weight_0_  Pre_Flash_end */
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Flash_Start[] = {
+	0x00287000,
+	0x002A17E8,	/* fls_afl_FlashMode : Flash alg start */
+	0x0F120001,
+
+	0x002A180C,	/* fls_afl_FlashWP_Weight_4_  flash br avg */
+	0x0F120027,
+};
+
+static const u32 s5k4ecgx_Flash_End[] = {
+	0x00287000,
+	0x002A17E8,	/* fls_afl_FlashMode  Flash alg end */
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_Flash_AE_Set[] = {
+};
+
+static const u32 s5k4ecgx_Flash_AE_Clear[] = {
+};
+
+/* 2560 x 1920 */
+static const u32 s5k4ecgx_5M_Capture[] = {
+	0x00287000,
+	0x002A0398,
+	0x0F120A00,	/* #REG_0TC_CCFG_usWidth */
+	0x0F120780,	/* #REG_0TC_CCFG_usHeight */
+	0x0F120009,
+
+	0x002A03B2,
+	0x0F120002,
+	0x002A03B0,
+	0x0F120002,
+	0x002A0270,
+	0x0F120001,
+
+	0xFFFF0003,
+
+	0x002A0A1E,
+	0x0F120050,
+
+	0x002A0AD4,
+	0x0F120074,
+
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120850,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+
+	0x002A0242,
+	0x0F120001,
+
+	0x002A024E,
+	0x0F120001,
+
+	0x002A0244,
+	0x0F120001,
+	
+};
+/* 2048 x 1536 */
+static const u32 s5k4ecgx_3M_Capture[] = {
+	0x00287000,
+	0x002A0398,
+	0x0F120800,  /* REG_0TC_CCFG_usWidth */
+	0x0F120600,  /* REG_0TC_CCFG_usWidth */
+	0x0F120009,  /* REG_0TC_CCFG_Format */
+
+	0x002A03B2,
+	0x0F120002,  /* REG_0TC_CCFG_FrRateQualityType */
+	0x002A03B0,
+	0x0F120002,  /* REG_0TC_CCFG_usFrTimeType */
+	0x002A024E,
+	0x0F120001,  /* REG_TC_GP_NewConfigSync */
+	0x002A0270,
+	0x0F120001,  /* REG_TC_GP_CapConfigChanged */
+
+	0xFFFF0003,
+
+	0x002A0A1E,
+	0x0F120050,
+
+	0x002A0AD4,
+	0x0F120074,
+
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120850,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+
+	0x002A0242,
+	0x0F120001,
+
+	0x002A024E,
+	0x0F120001,
+
+	0x002A0244,
+	0x0F120001,
+};
+/* 1600 x 1200 */
+static const u32 s5k4ecgx_2M_Capture[] = {
+	0x00287000,
+	0x002A0398,
+	0x0F120640,	/* #REG_0TC_CCFG_usWidth */
+	0x0F1204B0,	/* #REG_0TC_CCFG_usHeight */
+	0x0F120009,
+	0x002A03B2,
+	0x0F120002,
+	0x002A03B0,
+	0x0F120002,
+	0x002A024E,
+	0x0F120001,
+	0x002A0270,
+	0x0F120001,
+
+	0xFFFF0003,
+
+	0x002A0A1E,
+	0x0F120050,
+
+	0x002A0AD4,
+	0x0F120074,
+
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120850,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+
+	0x002A0242,
+	0x0F120001,
+
+	0x002A024E,
+	0x0F120001,
+
+	0x002A0244,
+	0x0F120001,
+};
+/* 1280 x 960 */
+static const u32 s5k4ecgx_1M_Capture[] = {
+	0x00287000,
+	0x002A0398,
+	0x0F120500,	/* #REG_0TC_CCFG_usWidth */
+	0x0F1203C0,	/* #REG_0TC_CCFG_usHeight */
+	0x0F120009,
+	0x002A03B2,
+	0x0F120002,
+	0x002A03B0,
+	0x0F120002,
+	0x002A024E,
+	0x0F120001,
+	0x002A0270,
+	0x0F120001,
+
+	0xFFFF0003,
+
+	0x002A0A1E,
+	0x0F120050,
+
+	0x002A0AD4,
+	0x0F120074,
+
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120850,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+
+	0x002A0242,
+	0x0F120001,
+
+	0x002A024E,
+	0x0F120001,
+
+	0x002A0244,
+	0x0F120001,
+};
+/* 640 x 480 */
+static const u32 s5k4ecgx_VGA_Capture[] = {
+	0x00287000,
+	0x002A0398,
+	0x0F120280,	/* #REG_0TC_CCFG_usWidth */
+	0x0F1201E0,	/* #REG_0TC_CCFG_usHeight */
+	0x0F120009,
+	0x002A03B2,
+	0x0F120002,
+	0x002A03B0,
+	0x0F120002,
+	0x002A024E,
+	0x0F120001,
+	0x002A0270,
+	0x0F120001,
+
+	0xFFFF0003,
+
+	0x002A0A1E,
+	0x0F120050,
+
+	0x002A0AD4,
+	0x0F120074,
+
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120850,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+
+	0x002A0242,
+	0x0F120001,
+
+	0x002A024E,
+	0x0F120001,
+
+	0x002A0244,
+	0x0F120001,
+};
+
+/* 1280 x 720 */
+static const u32 s5k4ecgx_1280_Preview[] = {
+	0x00287000,
+	0x002A01F6, //REG_TC_GP_PrevREqInputWidth
+	0x0F120A00,
+	0x0F120780,
+	0x0F120010,
+	0x0F12000C,
+	0x0F120A00,
+	0x0F120780,
+	0x0F120010,
+	0x0F12000C,
+	0x002A0494, //REG_TC_PZOOM_Prev ZoomReqInputWidth
+	0x0F120A00,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+	0x0F120A00,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+	0x002A0262,
+	0x0F120001,	/* #REG_TC_GP_bUseReqInputInPre	*/
+	0x002A0A1E,
+	0x0F120028,
+	0x002A0AD4,
+	0x0F12003C,
+
+	0x002A02A6,
+	0x0F120500, //REG_0TC_PCFG_usWidth 
+	0x0F1202D0, //REG_0TC_PCFG_usHeight
+	0x0F120005, //REG_0TC_PCFG_Format 
+	
+	0x002A02B4,
+	0x0F120052,	//REG_0TC_PCFG_PVIMask
+	0x002A02BE,
+	0x0F120000, //REG_0TC_PCFG_FrRateQualityType 
+	0x0F120001, //REG_0TC_PCFG_usFrTimeType 
+	0x0F12029A, //REG_0TC_PCFG_usMaxFrTimeMsecMult10 
+	0x0F12014A, //REG_0TC_PCFG_usMinFrTimeMsecMult10 
+	
+	0x002A02D0,
+	0x0F120000,	//REG_0TC_PCFG_uPrevMirror 
+	0x0F120000,	//REG_0TC_PCFG_uCaptureMirror 
+	0x002A0266,
+	0x0F120000,	//REG_TC_GP_ActivePrevConfig 
+	0x002A026A,
+	0x0F120001,	//REG_TC_GP_PrevOpenAfterChange 
+	0x002A024E,
+	0x0F120001, //REG_TC_GP_NewConfigSync
+	0x002A0268,
+	0x0F120001,	/* #REG_TC_GP_CapConfigChanged */
+};
+
+/* 960 x 640 */
+static const u32 s5k4ecgx_960_Preview[] = {
+	0x00287000,
+	0x002A01F6, //REG_TC_GP_PrevREqInputWidth
+	0x0F120A00,
+	0x0F120780,
+	0x0F120010,
+	0x0F12000C,
+	0x0F120A00,
+	0x0F120780,
+	0x0F120010,
+	0x0F12000C,
+	0x002A0494, //REG_TC_PZOOM_Prev ZoomReqInputWidth
+	0x0F120A00,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+	0x0F120A00,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+	0x002A0262,
+	0x0F120001,	/* #REG_TC_GP_bUseReqInputInPre	*/
+	0x002A0A1E,
+	0x0F120028,
+	0x002A0AD4,
+	0x0F12003C,
+
+	0x002A02A6,
+	0x0F1203C0, //REG_0TC_PCFG_usWidth 
+	0x0F120280, //REG_0TC_PCFG_usHeight
+	0x0F120005, //REG_0TC_PCFG_Format 
+	
+	0x002A02B4,
+	0x0F120052,	//REG_0TC_PCFG_PVIMask
+	0x002A02BE,
+	0x0F120000, //REG_0TC_PCFG_FrRateQualityType 
+	0x0F120001, //REG_0TC_PCFG_usFrTimeType 
+	0x0F12029A, //REG_0TC_PCFG_usMaxFrTimeMsecMult10 
+	0x0F12014A, //REG_0TC_PCFG_usMinFrTimeMsecMult10 
+	
+	0x002A02D0,
+	0x0F120000,	//REG_0TC_PCFG_uPrevMirror 
+	0x0F120000,	//REG_0TC_PCFG_uCaptureMirror 
+	0x002A0266,
+	0x0F120000,	//REG_TC_GP_ActivePrevConfig 
+	0x002A026A,
+	0x0F120001,	//REG_TC_GP_PrevOpenAfterChange 
+	0x002A024E,
+	0x0F120001, //REG_TC_GP_NewConfigSync
+	0x002A0268,
+	0x0F120001,	/* #REG_TC_GP_CapConfigChanged */
+};
+
+/* 720 x 480 */
+static const u32 s5k4ecgx_720_Preview[] = {
+	0x00287000,
+	0x002A0250,
+	0x0F120A00,
+	0x0F1206A8,
+	0x0F120010,
+	0x0F120078,
+	0x0F120A00,
+	0x0F1206A8,
+	0x0F120010,
+	0x0F120078,
+	0x002A0494,
+	0x0F120A00,
+	0x0F1206A8,
+	0x0F120000,
+	0x0F120000,
+	0x0F120A00,
+	0x0F1206A8,
+	0x0F120000,
+	0x0F120000,
+
+	0x002A0262,
+	0x0F120001,	/* #REG_TC_GP_bUseReqInputInPre	*/
+	0x002A0A1E,
+	0x0F120028,
+	0x002A0AD4,
+	0x0F12003C,
+
+	0x002A02A6,
+	0x0F1202D0,
+	0x0F1201E0,
+	0x0F120005,
+	0x002A02B4,
+	0x0F120052,
+	0x002A02BE,
+	0x0F120000,
+	0x0F120001,
+	0x0F12029A,
+	0x0F12014D,
+	0x002A02D0,
+	0x0F120000,
+	0x0F120000,
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,	/* #REG_TC_GP_NewConfigSync */
+	0x002A0268,
+	0x0F120001,	/* #REG_TC_GP_CapConfigChanged */
+};
+/* 640 x 480 */
+static const u32 s5k4ecgx_640_Preview[] = {
+	0x00287000,
+	0x002A01F6, //REG_TC_GP_PrevREqInputWidth
+	0x0F120A00,
+	0x0F120780,
+	0x0F120010,
+	0x0F12000C,
+	0x0F120A00,
+	0x0F120780,
+	0x0F120010,
+	0x0F12000C,
+	0x002A0494, //REG_TC_PZOOM_Prev ZoomReqInputWidth
+	0x0F120A00,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+	0x0F120A00,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+	0x002A0262,
+	0x0F120001,	/* #REG_TC_GP_bUseReqInputInPre	*/
+	0x002A0A1E,
+	0x0F120028,
+	0x002A0AD4,
+	0x0F12003C,
+
+	0x002A02A6,
+	0x0F120280, //REG_0TC_PCFG_usWidth 
+	0x0F1201E0, //REG_0TC_PCFG_usHeight
+	0x0F120005, //REG_0TC_PCFG_Format 
+	
+	0x002A02B4,
+	0x0F120052,	//REG_0TC_PCFG_PVIMask
+	0x002A02BE,
+	0x0F120000, //REG_0TC_PCFG_FrRateQualityType 
+	0x0F120001, //REG_0TC_PCFG_usFrTimeType 
+	0x0F12029A, //REG_0TC_PCFG_usMaxFrTimeMsecMult10 
+	0x0F12014A, //REG_0TC_PCFG_usMinFrTimeMsecMult10 
+	
+	0x002A02D0,
+	0x0F120000,	//REG_0TC_PCFG_uPrevMirror 
+	0x0F120000,	//REG_0TC_PCFG_uCaptureMirror 
+	0x002A0266,
+	0x0F120000,	//REG_TC_GP_ActivePrevConfig 
+	0x002A026A,
+	0x0F120001,	//REG_TC_GP_PrevOpenAfterChange 
+	0x002A024E,
+	0x0F120001, //REG_TC_GP_NewConfigSync
+	0x002A0268,
+	0x0F120001,	/* #REG_TC_GP_CapConfigChanged */
+};
+/* 352 x 288 */
+static const u32 s5k4ecgx_352_Preview[] = {
+	0x00287000,
+	0x002A0250,
+	0x0F120928,
+	0x0F120780,
+	0x0F12007C,
+	0x0F12000C,
+	0x0F120928,
+	0x0F120780,
+	0x0F12007C,
+	0x0F12000C,
+	0x002A0494,
+	0x0F120928,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+	0x0F120928,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+
+	0x002A0262,
+	0x0F120001,	/* #REG_TC_GP_bUseReqInputInPre	*/
+	0x002A0A1E,
+	0x0F120028,
+	0x002A0AD4,
+	0x0F12003C,
+
+	0x002A02A6,
+	0x0F120160,
+	0x0F120120,
+	0x0F120005,
+	0x002A02B4,
+	0x0F120052,
+	0x002A02BE,
+	0x0F120000,
+	0x0F120001,
+	0x0F12029A,
+	0x0F12014D,
+	0x002A02D0,
+	0x0F120000,
+	0x0F120000,
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,	/* #REG_TC_GP_NewConfigSync */
+	0x002A0268,
+	0x0F120001,	/* #REG_TC_GP_CapConfigChanged */
+};
+/* 176 x 144 */
+static const u32 s5k4ecgx_176_Preview[] = {
+	0x00287000,
+	0x002A0250,
+	0x0F120928,
+	0x0F120780,
+	0x0F12007C,
+	0x0F12000C,
+	0x0F120928,
+	0x0F120780,
+	0x0F12007C,
+	0x0F12000C,
+	0x002A0494,
+	0x0F120928,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+	0x0F120928,
+	0x0F120780,
+	0x0F120000,
+	0x0F120000,
+
+	0x002A0262,
+	0x0F120001,	/* #REG_TC_GP_bUseReqInputInPre	*/
+	0x002A0A1E,
+	0x0F120028,
+	0x002A0AD4,
+	0x0F12003C,
+
+	0x002A02A6,
+	0x0F1200B0,
+	0x0F120090,
+	0x0F120005,
+	0x002A02B4,
+	0x0F120052,
+	0x002A02BE,
+	0x0F120000,
+	0x0F120001,
+	0x0F12029A,
+	0x0F12014D,
+	0x002A02D0,
+	0x0F120000,
+	0x0F120000,
+	0x002A0266,
+	0x0F120000,
+	0x002A026A,
+	0x0F120001,
+	0x002A024E,
+	0x0F120001,	/* #REG_TC_GP_NewConfigSync */
+	0x002A0268,
+	0x0F120001,	/* #REG_TC_GP_CapConfigChanged */
+};
+
+static const u32 s5k4ecgx_AE_AWB_Lock_On[] = {
+	0x002A2C5E,
+	0x0F120000,
+};
+
+static const u32 s5k4ecgx_AE_AWB_Lock_Off[] = {
+	0x002A2C5E,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_Get_AE_Stable_Status[] = {
+	0x002E2C74,
+};
+
+static const u32 s5k4ecgx_Get_Light_Level[] = {
+	0x002C7000,
+	0x002E2C18,
+};
+
+static const u32 s5k4ecgx_get_1st_af_search_status[] = {
+	0x002E2EEE,
+};
+
+static const u32 s5k4ecgx_get_2nd_af_search_status[] = {
+	0x002E2207,
+};
+
+static const u32 s5k4ecgx_get_capture_status[] = {
+	0x002E0530,
+};
+
+static const u32 s5k4ecgx_get_esd_status[] = {
+	0xFCFCD000,
+	0x002CD000,
+	0x002E0060,
+};
+
+static const u32 s5k4ecgx_get_iso_reg[] = {
+	0x002C7000,
+	0x002E2BC4,
+};
+
+static const u32 s5k4ecgx_get_shutterspeed_reg[] = {
+	0x002C7000,
+	0x002E2BC0,
+};
+
+static const u32 s5k4ecgx_get_ev_reg[] = {
+	0x002C7000,
+	0x002E0230,
+};
+
+static const u32 s5k4ecgx_stream_stop_reg[] = {
+	0x00287000,
+	0x002A01E4,
+	0x0F120000,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_update_preview_reg[] = {
+	0x00287000,
+	0x002A0A1E,
+	0x0F120028,
+
+	0x002A0AD4,
+	0x0F12003C,
+
+	0x002A0608,
+	0x0F120001,	/*#lt_ExpGain_uSubsamplingmode*/
+	0x0F120001,	/*#lt_ExpGain_uNonSubsampling*/
+	0x0F120C00,	/*#lt_ExpGain_ExpCurveGainMaxStr*/
+
+	0x002A05D0,
+	0x0F120000,
+
+	0x002A0972,
+	0x0F120000,
+
+	0x002A0242,
+	0x0F120000,
+
+	0x002A024E,
+	0x0F120001,
+
+	0x002A0244,
+	0x0F120001,
+};
+
+static const u32 s5k4ecgx_update_hd_preview_reg[] = {
+	/* PREVIEW */
+	0x00287000,
+	0x002A0266,
+	0x0F120000, /* REG_TC_GP_ActivePrevConfig */
+	0x002A026E,
+	0x0F120000, /* REG_TC_GP_ActiveCapConfig */
+	0x002A026A,
+	0x0F120001, /* REG_TC_GP_PrevOpenAfterChange */
+	0x002A024E,
+	0x0F120001, /* REG_TC_GP_NewConfigSync */
+	0x002A0268,
+	0x0F120001, /* REG_TC_GP_PrevConfigChanged */
+	0x002A0270,
+	0x0F120001, /* REG_TC_GP_CapConfigChanged */
+	0x002A0242,
+	0x0F120000, /* REG_TC_GP_EnableCapture */
+	0x0F120001, /* REG_TC_GP_EnableCaptureChanged */
+	0xFFFF0064, /* Delay 100ms */
+};
+
+#endif /* __S5K4ECGX_REGS_ODROID_H__ */
diff -Naur org/include/media/dohofpga_platform.h ths/include/media/dohofpga_platform.h
--- org/include/media/dohofpga_platform.h	1970-01-01 01:00:00.000000000 +0100
+++ ths/include/media/dohofpga_platform.h	2013-07-10 18:13:41.000000000 +0200
@@ -0,0 +1,22 @@
+
+#include <linux/device.h>
+#include <media/v4l2-mediabus.h>
+
+struct dohofpga_platform_data {
+	unsigned int default_width;
+	unsigned int default_height;
+	unsigned int pixelformat;
+	int freq;	/* MCLK in KHz */
+
+	/* This SoC supports Parallel & CSI-2 */
+	int is_mipi;
+};
+	
+struct dohofpga_mbus_platform_data {
+	int id;
+	struct v4l2_mbus_framefmt fmt;
+	unsigned long clk_rate; /* master clock frequency in Hz */
+	int (*set_power)(int on);
+	int (*set_clock)(struct device *dev, int on);
+};
+
